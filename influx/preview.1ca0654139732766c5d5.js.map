{"version":3,"file":"preview.1ca0654139732766c5d5.js","mappings":"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CA;AACA,oCAAoC;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,IAAI,qEAAqE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,QAAQ;AACpB,YAAY,kBAAkB;AAC9B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA,iCAAiC,mDAAmD;AACpF;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA,iBAAiB,QAAQ,wBAAwB,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,YAAY;AACvB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,eAAe;AAC1B;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,mEAAmE;AACnE,2BAA2B,0IAAkH;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4BAA4B;AACjE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,6CAA6C,mCAAmC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4BAA4B;AACjE;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C,gDAAgD;AAChD,gDAAgD;AAChD,iWAAiW;AACjW,mDAAmD;AACnD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8BAA8B;AAC9B,kDAAkD;AAClD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,2BAA2B,oBAAoB;AAC/C,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB,OAAO;AAClD,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,yDAAyD;AACzD,6IAA6I;AAC7I,YAAY;AACZ;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA,sBAAsB,kBAAkB;AACxC,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG;AACA;AACA,sDAAsD;AACtD,QAAQ;AACR,4CAA4C,qBAAqB,OAAO;AACxE;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,qCAAqC;AACrC,QAAQ;AACR;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,8BAA8B,EAAE,gBAAgB,EAAE,WAAW,EAAE,WAAW,EAAE,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E,oDAAoD;AACpD;AACA,qDAAqD,+BAA+B;AACpF,qDAAqD;AACrD;AACA,qDAAqD,+BAA+B;AACpF,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,8CAA8C,aAAa;AAC3D,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4CAA4C,aAAa;AACzD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,gBAAgB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA,kHAAkH;AAClH;AACA;AACA;AACA,uDAAuD;AACvD,sBAAsB,kBAAkB;AACxC;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,mDAAmD,IAAI;AACvD;AACA,OAAO;AACP;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE,QAAQ;AACR;AACA,0BAA0B;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA,YAAY;AACZ,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,0BAA0B;AAC1B;AACA,OAAO,aAAa;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ,gDAAgD;AAChD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,sFAAsF;AACtF;AACA,OAAO;AACP;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA,qDAAqD;AACrD,+FAA+F;AAC/F,OAAO;AACP;AACA;AACA,gCAAgC;AAChC;AACA,UAAU;AACV;AACA,mDAAmD;AACnD;AACA,2FAA2F;AAC3F;AACA;AACA;AACA,OAAO,WAAW;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,YAAY;AACZ,4BAA4B,UAAU;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,cAAc,mDAAmD;AACjE;AACA;AACA;AACA,cAAc,gDAAgD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,4BAA4B,YAAY;AACxC,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,YAAY,8BAA8B,gIAAgI,8DAA8D;AACxO;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,uCAAuC;AAChG;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO,YAAY,iDAAiD;AACpE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,OAAO;AACP,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,mCAAmC;AACnC,aAAa;AACb;AACA,gCAAgC;AAChC,aAAa;AACb;AACA,gCAAgC;AAChC,aAAa;AACb;AACA,gCAAgC;AAChC,aAAa;AACb;AACA,gCAAgC,2BAA2B;AAC3D,mCAAmC,0BAA0B;AAC7D,aAAa;AACb;AACA,+BAA+B,8BAA8B;AAC7D,mCAAmC,6BAA6B;AAChE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO,oBAAoB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,UAAU;AACV,4BAA4B;AAC5B,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,mDAAmD,qBAAqB;AACxE;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,0BAA0B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,OAAO,iCAAiC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C,8BAA8B,6BAA6B;AAC3D;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC,QAAQ;AAC1C;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA,yCAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,4BAA4B,YAAY;AACxC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,6BAA6B;AAC7B,UAAU;AACV,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,gBAAgB;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,4BAA4B,UAAU;AACtC;AACA;AACA,YAAY;AACZ,4BAA4B,UAAU,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP,oCAAoC;AACpC,sCAAsC;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,2CAA2C,MAAM;AACjD,yCAAyC,QAAQ;AACjD,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP,oCAAoC;AACpC,sCAAsC;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD,WAAW;AACX;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,UAAU;AACV;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,mFAAmF;AACnF;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gNAAgN;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,KAAK;AACL,mBAAmB,QAAQ;AAC3B;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,QAAQ;AAC3B;AACA,KAAK;AACL,mBAAmB,QAAQ;AAC3B;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iEAAe,MAAM;;;;;;;;;;;;;;ACl1MrB;AACA;AACA,mBAAmB,kFAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,oCAAoC;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,IAAI,qEAAqE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,QAAQ;AACpB,YAAY,kBAAkB;AAC9B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA,iCAAiC,mDAAmD;AACpF;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA,iBAAiB,QAAQ,wBAAwB,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,YAAY;AACvB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,eAAe;AAC1B;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,mEAAmE;AACnE,2BAA2B,0IAAkH;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4BAA4B;AACjE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,6CAA6C,mCAAmC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4BAA4B;AACjE;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C,gDAAgD;AAChD,gDAAgD;AAChD,iWAAiW;AACjW,mDAAmD;AACnD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8BAA8B;AAC9B,kDAAkD;AAClD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,2BAA2B,oBAAoB;AAC/C,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB,OAAO;AAClD,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,yDAAyD;AACzD,6IAA6I;AAC7I,YAAY;AACZ;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA,sBAAsB,kBAAkB;AACxC,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG;AACA;AACA,sDAAsD;AACtD,QAAQ;AACR,4CAA4C,qBAAqB,OAAO;AACxE;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,qCAAqC;AACrC,QAAQ;AACR;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,8BAA8B,EAAE,gBAAgB,EAAE,WAAW,EAAE,WAAW,EAAE,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E,oDAAoD;AACpD;AACA,qDAAqD,+BAA+B;AACpF,qDAAqD;AACrD;AACA,qDAAqD,+BAA+B;AACpF,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,8CAA8C,aAAa;AAC3D,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4CAA4C,aAAa;AACzD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,gBAAgB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA,kHAAkH;AAClH;AACA;AACA;AACA,uDAAuD;AACvD,sBAAsB,kBAAkB;AACxC;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,mDAAmD,IAAI;AACvD;AACA,OAAO;AACP;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE,QAAQ;AACR;AACA,0BAA0B;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA,YAAY;AACZ,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,0BAA0B;AAC1B;AACA,OAAO,aAAa;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ,gDAAgD;AAChD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,sFAAsF;AACtF;AACA,OAAO;AACP;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA,qDAAqD;AACrD,+FAA+F;AAC/F,OAAO;AACP;AACA;AACA,gCAAgC;AAChC;AACA,UAAU;AACV;AACA,mDAAmD;AACnD;AACA,2FAA2F;AAC3F;AACA;AACA;AACA,OAAO,WAAW;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,YAAY;AACZ,4BAA4B,UAAU;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,cAAc,mDAAmD;AACjE;AACA;AACA;AACA,cAAc,gDAAgD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,4BAA4B,YAAY;AACxC,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,YAAY,8BAA8B,gIAAgI,8DAA8D;AACxO;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,uCAAuC;AAChG;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO,YAAY,iDAAiD;AACpE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,OAAO;AACP,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,mCAAmC;AACnC,aAAa;AACb;AACA,gCAAgC;AAChC,aAAa;AACb;AACA,gCAAgC;AAChC,aAAa;AACb;AACA,gCAAgC;AAChC,aAAa;AACb;AACA,gCAAgC,2BAA2B;AAC3D,mCAAmC,0BAA0B;AAC7D,aAAa;AACb;AACA,+BAA+B,8BAA8B;AAC7D,mCAAmC,6BAA6B;AAChE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO,oBAAoB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,UAAU;AACV,4BAA4B;AAC5B,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,mDAAmD,qBAAqB;AACxE;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,0BAA0B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,OAAO,iCAAiC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C,8BAA8B,6BAA6B;AAC3D;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC,QAAQ;AAC1C;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA,yCAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,4BAA4B,YAAY;AACxC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,6BAA6B;AAC7B,UAAU;AACV,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,gBAAgB;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,4BAA4B,UAAU;AACtC;AACA;AACA,YAAY;AACZ,4BAA4B,UAAU,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP,oCAAoC;AACpC,sCAAsC;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,2CAA2C,MAAM;AACjD,yCAAyC,QAAQ;AACjD,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP,oCAAoC;AACpC,sCAAsC;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD,WAAW;AACX;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,UAAU;AACV;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,mFAAmF;AACnF;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gNAAgN;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,KAAK;AACL,mBAAmB,QAAQ;AAC3B;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,QAAQ;AAC3B;AACA,KAAK;AACL,mBAAmB,QAAQ;AAC3B;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iEAAe,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC70MrB;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA","sources":["webpack://influx/./src/sandbox/styles/custom/dat-gui.css","webpack://influx/./src/sandbox/containers/playground/shaders/fx/default_mat_frag.glsl","webpack://influx/./src/sandbox/containers/playground/shaders/fx/default_mat_vert.glsl","webpack://influx/./src/sandbox/containers/playground/shaders/fx/lwi_colored_mat_frag.glsl","webpack://influx/./src/sandbox/containers/playground/shaders/fx/lwi_colored_mat_vert.glsl","webpack://influx/./src/sandbox/containers/playground/shaders/fx/lwi_mat_frag.glsl","webpack://influx/./src/sandbox/containers/playground/shaders/fx/lwi_mat_vert.glsl","webpack://influx/./src/lib/fx/HLSL.js","webpack://influx/./src/sandbox/containers/playground/shaders/fx/index.js","webpack://influx/./src/sandbox/styles/custom/dat-gui.css?cf03","webpack://influx/./src/lib/bf/bf.ts","webpack://influx/./src/lib/bf/index.ts","webpack://influx/./src/lib/common.ts","webpack://influx/./src/lib/fx/AnalyzerDiagnostics.ts","webpack://influx/./src/lib/fx/FXSLDocument.ts","webpack://influx/./src/lib/fx/SLASTDocument.ts","webpack://influx/./src/lib/fx/SLDocument.ts","webpack://influx/./src/lib/fx/SLParser.ts","webpack://influx/./src/lib/fx/TextDocument.ts","webpack://influx/./src/lib/fx/UniformHelper.ts","webpack://influx/./src/lib/fx/Visitors.ts","webpack://influx/./src/lib/fx/analisys/Analyzer.ts","webpack://influx/./src/lib/fx/analisys/FxAnalyzer.ts","webpack://influx/./src/lib/fx/analisys/ProgramScope.ts","webpack://influx/./src/lib/fx/analisys/SystemScope.ts","webpack://influx/./src/lib/fx/analisys/helpers/expression.ts","webpack://influx/./src/lib/fx/analisys/helpers/fn.ts","webpack://influx/./src/lib/fx/analisys/helpers/index.ts","webpack://influx/./src/lib/fx/analisys/helpers/instruction.ts","webpack://influx/./src/lib/fx/analisys/helpers/types.ts","webpack://influx/./src/lib/fx/analisys/helpers/variable.ts","webpack://influx/./src/lib/fx/analisys/instructions/AnnotationInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ArithmeticExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/AssignmentExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/AttributeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/BitwiseExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/BoolInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/BreakStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/CastExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/CbufferInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/CompileExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/CompileShader11Instruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ComplexExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ComplexTypeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ConditionalExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ConstructorCallInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/DeclInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/DeclStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ExprStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/FloatInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ForStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/FunctionCallInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/FunctionDeclInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/FunctionDefInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/IdExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/IdInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/IfStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/InitExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/Instruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/InstructionCollector.ts","webpack://influx/./src/lib/fx/analisys/instructions/IntInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/LogicalExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/NullInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/PassInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/PostfixArithmeticInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/PostfixIndexInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/PostfixPointInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/Preset.ts","webpack://influx/./src/lib/fx/analisys/instructions/PresetProperty.ts","webpack://influx/./src/lib/fx/analisys/instructions/ProvideInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ProxyTypeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/RelationalExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ReturnStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/SemicolonStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/StateBlockInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/StmtBlockInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/StmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/StringInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/SystemFunctionInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/SystemTypeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/Technique11Instruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/TechniqueInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/TypeDeclInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/TypedInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/TypedefInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/UnaryExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/VariableDeclInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/VariableTypeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/WhileStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/part/DrawInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/part/PartFxInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/part/PartFxPassInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/part/SpawnInstruction.ts","webpack://influx/./src/lib/fx/analisys/system/AppendStructuredBufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/BufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/RWBufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/RWStructuredBufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/RWTexture1DTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/RWTexture2DTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/StructuredBufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/Texture2DArrayTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/Texture2DTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/Texture3DTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/TextureCubeArrayTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/TextureCubeTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/TriMeshTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/TypeTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/api.ts","webpack://influx/./src/lib/fx/analisys/system/builtin.ts","webpack://influx/./src/lib/fx/analisys/system/matrix.ts","webpack://influx/./src/lib/fx/analisys/system/scalar.ts","webpack://influx/./src/lib/fx/analisys/system/utils.ts","webpack://influx/./src/lib/fx/analisys/system/vector.ts","webpack://influx/./src/lib/fx/bundles/Bundle.ts","webpack://influx/./src/lib/fx/bundles/Bundle11.ts","webpack://influx/./src/lib/fx/bundles/utils.ts","webpack://influx/./src/lib/fx/bytecode/Bytecode.ts","webpack://influx/./src/lib/fx/bytecode/ConstantPool.ts","webpack://influx/./src/lib/fx/bytecode/Context.ts","webpack://influx/./src/lib/fx/bytecode/DebugLayout.ts","webpack://influx/./src/lib/fx/bytecode/Externs.ts","webpack://influx/./src/lib/fx/bytecode/InstructionList.ts","webpack://influx/./src/lib/fx/bytecode/PipelineStates.ts","webpack://influx/./src/lib/fx/bytecode/PromisedAddress.ts","webpack://influx/./src/lib/fx/bytecode/SRVPool.ts","webpack://influx/./src/lib/fx/bytecode/SymbolTable.ts","webpack://influx/./src/lib/fx/bytecode/UAVPool.ts","webpack://influx/./src/lib/fx/bytecode/VM/cpp/bridge.ts","webpack://influx/./src/lib/fx/bytecode/VM/index.ts","webpack://influx/./src/lib/fx/bytecode/VM/native.ts","webpack://influx/./src/lib/fx/bytecode/VM/ts/bridge.ts","webpack://influx/./src/lib/fx/bytecode/VM/ts/bundle.ts","webpack://influx/./src/lib/fx/bytecode/common.ts","webpack://influx/./src/lib/fx/bytecode/index.ts","webpack://influx/./src/lib/fx/bytecode/sizeof.ts","webpack://influx/./src/lib/fx/techniques/cpp/bridge.ts","webpack://influx/./src/lib/fx/techniques/index.ts","webpack://influx/./src/lib/fx/techniques/ts/bridge.ts","webpack://influx/./src/lib/fx/techniques/ts/emitter.ts","webpack://influx/./src/lib/fx/techniques/ts/mat.ts","webpack://influx/./src/lib/fx/techniques/ts/technique11.ts","webpack://influx/./src/lib/fx/timeline.ts","webpack://influx/./src/lib/fx/translators/BaseEmitter.ts","webpack://influx/./src/lib/fx/translators/CodeConvolutionEmitter.ts","webpack://influx/./src/lib/fx/translators/CodeEmitter.ts","webpack://influx/./src/lib/fx/translators/FxEmitter.ts","webpack://influx/./src/lib/fx/translators/FxTranslator.ts","webpack://influx/./src/lib/fx/translators/GlslEmitter.ts","webpack://influx/./src/lib/fx/translators/Output.ts","webpack://influx/./src/lib/idl/EAnalyzerErrors.ts","webpack://influx/./src/lib/idl/EAnalyzerWarnings.ts","webpack://influx/./src/lib/idl/ERenderStateValues.ts","webpack://influx/./src/lib/idl/ERenderStates.ts","webpack://influx/./src/lib/idl/IDiagnostics.ts","webpack://influx/./src/lib/idl/IInstruction.ts","webpack://influx/./src/lib/idl/ITechnique9.ts","webpack://influx/./src/lib/idl/bundles/auto/cbbundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/buffer-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/bundle-content.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/bundle-meta.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/bundle-signature.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/color-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/control-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/emat-render-routines.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/epart-render-routines.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/epart-sim-routines.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/float-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/float2value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/float3value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/float4value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/glslattribute.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/int-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/mat-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/mat-render-pass.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/mesh-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/part-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/part-render-pass.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/pixel-shader.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/preset-entry.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/preset.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/property-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/render-state.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/routine-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/routine-bytecode-bundle-resources.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/routine-bytecode-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/routine-glslsource-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/routine-hlslsource-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/routine-shader-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/routine-source-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/shader.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/string-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/technique11bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/technique11render-pass.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/texture-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/texture-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/trimesh-bundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/uavbundle.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/uicontrol.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/uint-value.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/vertex-shader.ts","webpack://influx/./src/lib/idl/bundles/auto/fx/view-type-property.ts","webpack://influx/./src/lib/idl/bundles/auto/type-field.ts","webpack://influx/./src/lib/idl/bundles/auto/type-layout.ts","webpack://influx/./src/lib/idl/bytecode/EOperations.ts","webpack://influx/./src/lib/idl/bytecode/IDepthStencilState.ts","webpack://influx/./src/lib/idl/bytecode/index.ts","webpack://influx/./src/lib/idl/parser/IParser.ts","webpack://influx/./src/lib/idl/part/IPartFx.ts","webpack://influx/./src/lib/parser/ASTDocument.ts","webpack://influx/./src/lib/parser/AbstractParser.ts","webpack://influx/./src/lib/parser/CachingLexer.ts","webpack://influx/./src/lib/parser/Item.ts","webpack://influx/./src/lib/parser/Lexer.ts","webpack://influx/./src/lib/parser/Macros.ts","webpack://influx/./src/lib/parser/ParseTree.ts","webpack://influx/./src/lib/parser/Preprocessor.ts","webpack://influx/./src/lib/parser/State.ts","webpack://influx/./src/lib/parser/helpers.ts","webpack://influx/./src/lib/parser/symbols.ts","webpack://influx/./src/lib/parser/util.ts","webpack://influx/./src/lib/path/path.ts","webpack://influx/./src/lib/uri/uri.ts","webpack://influx/./src/lib/util/Diagnostics.ts","webpack://influx/./src/lib/util/DistinctColor.ts","webpack://influx/./src/lib/util/StringRef.ts","webpack://influx/./src/lib/util/p4/p4.tsx","webpack://influx/./src/lib/util/s3d/prjenv.ts","webpack://influx/./src/lib/util/s3d/type.ts","webpack://influx/./src/sandbox/actions/ActionTypeKeys.ts","webpack://influx/./src/sandbox/actions/index.ts","webpack://influx/./src/sandbox/components/graphEx/BasicType.ts","webpack://influx/./src/sandbox/components/graphEx/Decomposer.ts","webpack://influx/./src/sandbox/components/graphEx/Float.ts","webpack://influx/./src/sandbox/components/graphEx/FuncNodes.ts","webpack://influx/./src/sandbox/components/graphEx/GraphNode.ts","webpack://influx/./src/sandbox/components/graphEx/IfStmt.ts","webpack://influx/./src/sandbox/components/graphEx/Int.ts","webpack://influx/./src/sandbox/components/graphEx/Operators.ts","webpack://influx/./src/sandbox/components/graphEx/StmtList.ts","webpack://influx/./src/sandbox/components/graphEx/Uniforms.ts","webpack://influx/./src/sandbox/components/graphEx/common.ts","webpack://influx/./src/sandbox/components/graphEx/fx/DefaultMaterial.ts","webpack://influx/./src/sandbox/components/graphEx/fx/Kill.ts","webpack://influx/./src/sandbox/components/graphEx/fx/KillBy.ts","webpack://influx/./src/sandbox/components/graphEx/fx/LwiMaterial.ts","webpack://influx/./src/sandbox/components/graphEx/fx/Param.ts","webpack://influx/./src/sandbox/components/graphEx/fx/Part.ts","webpack://influx/./src/sandbox/components/graphEx/fx/PartId.ts","webpack://influx/./src/sandbox/components/graphEx/fx/PartInit.ts","webpack://influx/./src/sandbox/components/graphEx/fx/PartPrevious.ts","webpack://influx/./src/sandbox/components/graphEx/fx/PartSpawn.ts","webpack://influx/./src/sandbox/components/graphEx/fx/PartUpdate.ts","webpack://influx/./src/sandbox/components/graphEx/fx/SpawnOp.ts","webpack://influx/./src/sandbox/components/graphEx/fx/UserConst.ts","webpack://influx/./src/sandbox/components/graphEx/utils/LibLoader.ts","webpack://influx/./src/sandbox/components/graphEx/utils/docs.ts","webpack://influx/./src/sandbox/containers/Preview.tsx","webpack://influx/./src/sandbox/containers/playground/FxScene.tsx","webpack://influx/./src/sandbox/containers/playground/HDRScene.tsx","webpack://influx/./src/sandbox/containers/playground/Technique9Scene.tsx","webpack://influx/./src/sandbox/containers/playground/ThreeScene.tsx","webpack://influx/./src/sandbox/containers/playground/utils/GroupedUniforms.ts","webpack://influx/./src/sandbox/containers/playground/utils/SingleUniforms.ts","webpack://influx/./src/sandbox/containers/playground/utils/adjacency.ts","webpack://influx/./src/sandbox/containers/playground/utils/controls.ts","webpack://influx/./src/sandbox/containers/playground/utils/deps.ts","webpack://influx/./src/sandbox/containers/playground/utils/gui.ts","webpack://influx/./src/sandbox/ipc.ts","webpack://influx/./src/sandbox/logic/common.ts","webpack://influx/./src/sandbox/logic/depot.ts","webpack://influx/./src/sandbox/logic/fxRuntime.ts","webpack://influx/./src/sandbox/logic/nodesEx.ts","webpack://influx/./src/sandbox/logic/parsing.ts","webpack://influx/./src/sandbox/logic/s3d.ts","webpack://influx/./src/sandbox/preview.tsx","webpack://influx/./src/sandbox/reducers/depot.ts","webpack://influx/./src/sandbox/reducers/handleActions.ts","webpack://influx/./src/sandbox/reducers/nodes.ts","webpack://influx/./src/sandbox/reducers/parserParams.ts","webpack://influx/./src/sandbox/reducers/playground.ts","webpack://influx/./src/sandbox/reducers/router.ts","webpack://influx/./src/sandbox/reducers/s3d.ts","webpack://influx/./src/sandbox/reducers/sourceFile.ts","webpack://influx/./src/sandbox/reducers/translatorParams.ts","webpack://influx/./src/sandbox/store/index.ts","webpack://influx/./src/lib/fx/bytecode/VM/cpp/module.cpp","webpack://influx/./src/lib/fx/techniques/cpp/module.cpp","webpack://influx/external node-commonjs \"child_process\"","webpack://influx/external node-commonjs \"electron\"","webpack://influx/external node-commonjs \"fs\"","webpack://influx/external node-commonjs \"os\"","webpack://influx/external node-commonjs \"path\"","webpack://influx/external node-commonjs \"util\""],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/getUrl.js\";\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(\"data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==\", import.meta.url);\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".dg.main.taller-than-window .close-button {\\r\\n    border-top: 1px solid #ddd;\\r\\n}\\r\\n\\r\\n.dg.main .close-button {\\r\\n    background-color: #ccc;\\r\\n}\\r\\n \\r\\n.dg.main .close-button:hover {\\r\\n    background-color: #ddd;\\r\\n}\\r\\n\\r\\n.dg {\\r\\n    color: #555;\\r\\n    text-shadow: none !important;\\r\\n}\\r\\n\\r\\n.dg.main::-webkit-scrollbar {\\r\\n    background: #fafafa;\\r\\n}\\r\\n\\r\\n.dg.main::-webkit-scrollbar-thumb {\\r\\n    background: #bbb;\\r\\n}\\r\\n \\r\\n.dg li:not(.folder) {\\r\\n    background: #fafafa;\\r\\n    border-bottom: 1px solid #ddd;\\r\\n}\\r\\n \\r\\n.dg li.save-row .button {\\r\\n    text-shadow: none !important;\\r\\n}\\r\\n\\r\\n.dg li.title {\\r\\n    background: #e8e8e8 url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \") 6px 10px no-repeat;\\r\\n}\\r\\n\\r\\n.dg .cr.function:hover,.dg .cr.boolean:hover {\\r\\n    background: #fff;\\r\\n}\\r\\n \\r\\n.dg .c input[type=text] {\\r\\n    background: #e9e9e9;\\r\\n}\\r\\n \\r\\n.dg .c input[type=text]:hover {\\r\\n    background: #eee;\\r\\n}\\r\\n \\r\\n.dg .c input[type=text]:focus {\\r\\n    background: #eee;\\r\\n    color: #555;\\r\\n}\\r\\n \\r\\n.dg .c .slider {\\r\\n    background: #e9e9e9;\\r\\n}\\r\\n\\r\\n.dg .c .slider:hover {\\r\\n    background: #eee;\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/sandbox/styles/custom/dat-gui.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,0BAA0B;AAC9B;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,WAAW;IACX,4BAA4B;AAChC;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,mBAAmB;IACnB,6BAA6B;AACjC;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,8EAA8I;AAClJ;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,gBAAgB;IAChB,WAAW;AACf;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;AACpB\",\"sourcesContent\":[\".dg.main.taller-than-window .close-button {\\r\\n    border-top: 1px solid #ddd;\\r\\n}\\r\\n\\r\\n.dg.main .close-button {\\r\\n    background-color: #ccc;\\r\\n}\\r\\n \\r\\n.dg.main .close-button:hover {\\r\\n    background-color: #ddd;\\r\\n}\\r\\n\\r\\n.dg {\\r\\n    color: #555;\\r\\n    text-shadow: none !important;\\r\\n}\\r\\n\\r\\n.dg.main::-webkit-scrollbar {\\r\\n    background: #fafafa;\\r\\n}\\r\\n\\r\\n.dg.main::-webkit-scrollbar-thumb {\\r\\n    background: #bbb;\\r\\n}\\r\\n \\r\\n.dg li:not(.folder) {\\r\\n    background: #fafafa;\\r\\n    border-bottom: 1px solid #ddd;\\r\\n}\\r\\n \\r\\n.dg li.save-row .button {\\r\\n    text-shadow: none !important;\\r\\n}\\r\\n\\r\\n.dg li.title {\\r\\n    background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\\r\\n}\\r\\n\\r\\n.dg .cr.function:hover,.dg .cr.boolean:hover {\\r\\n    background: #fff;\\r\\n}\\r\\n \\r\\n.dg .c input[type=text] {\\r\\n    background: #e9e9e9;\\r\\n}\\r\\n \\r\\n.dg .c input[type=text]:hover {\\r\\n    background: #eee;\\r\\n}\\r\\n \\r\\n.dg .c input[type=text]:focus {\\r\\n    background: #eee;\\r\\n    color: #555;\\r\\n}\\r\\n \\r\\n.dg .c .slider {\\r\\n    background: #e9e9e9;\\r\\n}\\r\\n\\r\\n.dg .c .slider:hover {\\r\\n    background: #eee;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","export default \"precision highp float;\\r\\n\\r\\nvarying vec4 vColor;\\r\\n\\r\\nvoid main() {\\r\\n    gl_FragColor = vColor;\\r\\n}\\r\\n\";","export default \"precision highp float;\\r\\nuniform mat4 modelViewMatrix;\\r\\nuniform mat4 projectionMatrix;\\r\\n\\r\\nattribute vec3 position;\\r\\nattribute vec4 color;\\r\\nattribute float size;\\r\\nattribute vec3 offset;\\r\\n\\r\\nvarying vec4 vColor;\\r\\n\\r\\nvoid main() {\\r\\n    vColor = color;\\r\\n    vec4 viewPos = modelViewMatrix * vec4(offset, 1.0) + vec4(position * size, 0.0);\\r\\n    gl_Position = projectionMatrix * viewPos;\\r\\n}\\r\\n\";","export default \"precision highp float;\\r\\n\\r\\nvarying vec4 vColor;\\r\\n\\r\\nvoid main() \\r\\n{\\r\\n    gl_FragColor = vColor;\\r\\n}\\r\\n\";","export default \"precision highp float;\\r\\n\\r\\nuniform mat4 modelMatrix;\\r\\nuniform mat4 viewMatrix;\\r\\nuniform mat4 projectionMatrix;\\r\\nuniform mat4 modelViewMatrix;\\r\\n\\r\\nattribute vec3 position;\\r\\nattribute vec3 normal;\\r\\nattribute vec2 uv;\\r\\n\\r\\n/*\\r\\n\\r\\nstruct LwiInstance {\\r\\n    float4 dynData[2]: META;\\r\\n    float3x4 worldMatr: TRANSFORM0;\\r\\n    float3x4 worldMatrPrev: TRANSFORM1;\\r\\n};\\r\\n\\r\\nwebgl doesn't support non-squared matrices or arrays in attributes (!)\\r\\n\\r\\n*/\\r\\n\\r\\nattribute vec4 a_dynData_0;\\r\\nattribute vec4 a_dynData_1;\\r\\n\\r\\nattribute vec4 a_worldMat_0;\\r\\nattribute vec4 a_worldMat_1;\\r\\nattribute vec4 a_worldMat_2;\\r\\n\\r\\nattribute vec4 a_worldMatPrev_0;\\r\\nattribute vec4 a_worldMatPrev_1;\\r\\nattribute vec4 a_worldMatPrev_2;\\r\\n\\r\\nvarying vec4 vColor;\\r\\n\\r\\nvoid main() \\r\\n{\\r\\n    vec4 zero = vec4(position, 1.0);\\r\\n    \\r\\n    vec4 pos;\\r\\n    pos.x = dot(a_worldMat_0, zero);\\r\\n    pos.y = dot(a_worldMat_1, zero);\\r\\n    pos.z = dot(a_worldMat_2, zero);\\r\\n    pos.w = 1.0;\\r\\n\\r\\n    vec4 viewPos = viewMatrix * pos;\\r\\n    gl_Position = projectionMatrix * viewPos;\\r\\n\\r\\n    vec3 lightDir;\\r\\n    lightDir = normalize(vec3(1.0, 4.0, 1.0));\\r\\n\\r\\n    float NdL;\\r\\n    NdL = max(0.0, dot(normal, lightDir) * 0.75);\\r\\n    vColor = vec4(vec3(NdL), 0.0) + vec4(0.25, 0.25, 0.25, 1.0) * a_dynData_0;\\r\\n}\\r\\n\";","export default \"precision highp float;\\r\\n\\r\\nvarying vec4 vColor;\\r\\n\\r\\nvoid main() \\r\\n{\\r\\n    gl_FragColor = vColor;\\r\\n}\\r\\n\";","export default \"precision highp float;\\r\\n\\r\\nuniform mat4 modelMatrix;\\r\\nuniform mat4 viewMatrix;\\r\\nuniform mat4 projectionMatrix;\\r\\nuniform mat4 modelViewMatrix;\\r\\n\\r\\nattribute vec3 position;\\r\\nattribute vec3 normal;\\r\\nattribute vec2 uv;\\r\\n\\r\\n/*\\r\\n\\r\\nstruct LwiInstance {\\r\\n    float4 dynData[2]: META;\\r\\n    float3x4 worldMatr: TRANSFORM0;\\r\\n    float3x4 worldMatrPrev: TRANSFORM1;\\r\\n};\\r\\n\\r\\nwebgl doesn't support non-squared matrices or arrays in attributes (!)\\r\\n\\r\\n*/\\r\\n\\r\\nattribute vec4 a_dynData_0;\\r\\nattribute vec4 a_dynData_1;\\r\\n\\r\\nattribute vec4 a_worldMat_0;\\r\\nattribute vec4 a_worldMat_1;\\r\\nattribute vec4 a_worldMat_2;\\r\\n\\r\\nattribute vec4 a_worldMatPrev_0;\\r\\nattribute vec4 a_worldMatPrev_1;\\r\\nattribute vec4 a_worldMatPrev_2;\\r\\n\\r\\nvarying vec4 vColor;\\r\\n\\r\\nvoid main() \\r\\n{\\r\\n    vec4 zero = vec4(position, 1.0);\\r\\n    \\r\\n    vec4 pos;\\r\\n    pos.x = dot(a_worldMat_0, zero);\\r\\n    pos.y = dot(a_worldMat_1, zero);\\r\\n    pos.z = dot(a_worldMat_2, zero);\\r\\n    pos.w = 1.0;\\r\\n\\r\\n    vec4 viewPos = viewMatrix * pos;\\r\\n    gl_Position = projectionMatrix * viewPos;\\r\\n\\r\\n    vec3 lightDir;\\r\\n    lightDir = normalize(vec3(1.0, -4.0, 0.0));\\r\\n\\r\\n    float NdL;\\r\\n    NdL = max(0.0, dot(normal, lightDir) * 0.5);\\r\\n    vColor = vec4(vec3(NdL), 0.0) + vec4(0.5, 0.5, 0.5, 1.0);\\r\\n}\\r\\n\";","export { default as HLSL } from './HLSL.gr';\r\n\r\n","export { default as defMatVS } from './default_mat_vert.glsl';\r\nexport { default as defMatFS } from './default_mat_frag.glsl';\r\nexport { default as lwiMatVS } from './lwi_mat_vert.glsl';\r\nexport { default as lwiMatFS } from './lwi_mat_frag.glsl';\r\nexport { default as lwiColoredMatVS } from './lwi_colored_mat_vert.glsl';\r\nexport { default as lwiColoredMatFS } from './lwi_colored_mat_frag.glsl';","\n      import API from \"!../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../../../../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../../../../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../../../../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../../../../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../../../../node_modules/css-loader/dist/cjs.js!./dat-gui.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../../../../node_modules/css-loader/dist/cjs.js!./dat-gui.css\";\n       export default content && content.locals ? content.locals : undefined;\n","/**\r\n *    @a x  .\r\n */\r\nexport var flag = (x: number) => (1 << (x));\r\n/**\r\n *     @a value    @a bit  .\r\n */\r\nexport var testBit = (value: number, bit: number) => ((value & flag(bit)) != 0);\r\n/**\r\n *     @a value    ,\r\n *     @a set.\r\n */\r\nexport var testAll = (value: number, set: number) => (((value) & (set)) == (set));\r\n/**\r\n *     @a value        ,\r\n *     @a set.\r\n */\r\nexport var testAny = (value: number, set: number) => (((value) & (set)) != 0);\r\n/**\r\n *     @a bit   @a value  \r\n */\r\nexport var setBit = (value: number, bit: number, setting: boolean = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));\r\n/**\r\n *\r\n */\r\nexport var clearBit = (value: number, bit: number) => ((value) &= ~flag((bit)));\r\n/**\r\n *     @a bit   @a value  \r\n */\r\nexport var setAll = (value: number, set: number, setting: boolean = true) => (setting ? ((value) |= (set)) : ((value) &= ~(set)));\r\n/**\r\n *      @a value  ,\r\n *      @a set\r\n */\r\nexport var clearAll = (value: number, set: number) => ((value) &= ~(set));\r\n/**\r\n *      @a value  ,\r\n *      @a set\r\n */\r\nexport var equal = (value: number, src: number) => { value = src; };\r\n/**\r\n *   @a value  @a src\r\n */\r\nexport var isEqual = (value: number, src: number) => value == src;\r\n/**\r\n *   @a value   @a src  true\r\n */\r\nexport var isNotEqaul = (value: number, src: number) => value != src;\r\n/**\r\n *   @a value  @a src\r\n */\r\nexport var set = (value: number, src: number) => { value = src; };\r\n/**\r\n *   @a value\r\n */\r\nexport var clear = (value: number) => { value = 0; };\r\n/**\r\n *      @a value  ,\r\n *      @a src\r\n */\r\nexport var setFlags = (value: number, src: number) => (value |= src);\r\n/**\r\n *      @a value  ,\r\n *      @a src\r\n */\r\nexport var clearFlags = (value: number, src: number) => value &= ~src;\r\n/**\r\n *     @a value .    true.\r\n *     false.\r\n */\r\nexport var isEmpty = (value: number) => (value == 0);\r\n/**\r\n *      @a value.\r\n *      32.\r\n */\r\nexport var totalBits = (value: number) => 32;\r\n\r\n\r\n/**\r\n *       @a value.\r\n */\r\nexport var totalSet = (value: number): number => {\r\n    var count: number = 0;\r\n    var total: number = totalBits(value);\r\n\r\n    for (var i: number = total; i; --i) {\r\n        count += (value & 1);\r\n        value >>= 1;\r\n    }\r\n\r\n    return (count);\r\n}\r\n","import * as bf from './bf';\r\nexport default bf;\r\n","import { isEqual } from \"./bf/bf\";\r\nimport { IMap } from \"./idl/IMap\";\r\n\r\nexport let typeOf: (x: any) => string = (x: any): string => {\r\n    const s: string = typeof x;\r\n\r\n    if (s === 'object') {\r\n        if (x) {\r\n            if (x instanceof Array) {\r\n                return 'array';\r\n            } else if (x instanceof Object) {\r\n                return s;\r\n            }\r\n\r\n            const sClassName: string = Object.prototype.toString.call(x);\r\n\r\n            if (sClassName === '[object Window]') {\r\n                return 'object';\r\n            }\r\n\r\n            if ((sClassName === '[object Array]' ||\r\n                (typeof x.length) === 'number' &&\r\n                (typeof x.splice) !== 'undefined' &&\r\n                (typeof x.propertyIsEnumerable) !== 'undefined' &&\r\n                !x.propertyIsEnumerable('splice')\r\n\r\n            )) {\r\n                return 'array';\r\n            }\r\n\r\n            if ((sClassName === '[object Function]' ||\r\n                (typeof x.call) !== 'undefined' &&\r\n                (typeof x.propertyIsEnumerable) !== 'undefined' &&\r\n                !x.propertyIsEnumerable('call'))) {\r\n                return 'function';\r\n            }\r\n        } else {\r\n            return 'null';\r\n        }\r\n    } else if (s === 'function' && (typeof x.call) === 'undefined') {\r\n        return 'object';\r\n    }\r\n\r\n    return s;\r\n};\r\n\r\nexport let isDef = (x: any): boolean => x !== undefined;\r\nexport let isDefAndNotNull = (x: any): boolean => x != null;\r\nexport let isEmpty = (x: any): boolean => x.length === 0;\r\nexport let isNull = (x: any): boolean => x === null;\r\nexport let isBoolean = (x: any): boolean => typeof x === 'boolean';\r\nexport let isString = (x: any): boolean => typeof x === 'string';\r\nexport let isNumber = (x: any): boolean => typeof x === 'number';\r\nexport let isFloat = isNumber;\r\nexport let isInt = (x: any): boolean => isNumber(x) && (~~x === x);\r\nexport let isUint = (x: any): boolean => isInt(x) && x > 0;\r\nexport let isFunction = (x: any): boolean => typeOf(x) === 'function';\r\nexport let isObject = (x: any): boolean => {\r\n    const T: string = typeOf(x);\r\n    return T === 'object' || T === 'array' || T === 'function';\r\n};\r\nexport let isArrayBuffer = (x: any): boolean => x instanceof ArrayBuffer;\r\nexport let isTypedArray = (x: any): boolean => x !== null && typeof x === 'object' && typeof x.byteOffset === 'number';\r\nexport let isBlob = (x: any): boolean => x instanceof Blob;\r\nexport let isArray = (x: any): boolean => typeOf(x) === 'array';\r\n// export let assignIfDef = (val: any, def: any) => (isDef(val) ? val : def);\r\nexport let deepEqual = (a: Object, b: Object) => JSON.stringify(a) === JSON.stringify(b);\r\n\r\n\r\nexport type Nullable<T> = {[P in keyof T]: T[P] | null } | null;\r\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] };\r\nexport type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\r\nexport type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\r\nexport type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\r\nexport type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\r\n/** For ex: retrieve the properties of the child that the parent does not have. */\r\nexport type Diff<T1, T2> = Pick<T1, Exclude<keyof T1, keyof T2>>;\r\nexport type NonFunctionDiff<T1, T2> = NonFunctionProperties<Diff<T1, T2>>;\r\nexport type PropertiesDiff<T1, T2> = Writeable<NonFunctionDiff<T1, T2>>;\r\nexport type MakeOptional<T> = { [P in keyof T]?: T[P]; };\r\n\r\nexport const assert = console.assert.bind(console);\r\nexport const verbose = console.log.bind(console);\r\n\r\n/** 'ForEach' for maps. */\r\nexport function mwalk<T>(map: IMap<T>, cb: (element: T, key?: string, i?: number) => boolean | void) {\r\n    let i = 0;\r\n    for (const key in map) {\r\n        if (cb(map[key], key, i++) === false) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n","import { isDefAndNotNull } from \"@lib/common\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { EDiagnosticCategory } from \"@lib/idl/IDiagnostics\";\r\nimport { IFile, IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\ninterface IDiagDesc {\r\n    file: IFile;\r\n    loc: IRange;\r\n    info: any; // TODO: fixme\r\n}\r\n\r\n\r\nexport class AnalyzerDiagnostics extends Diagnostics<IDiagDesc> {\r\n    constructor() {\r\n        super(\"Analyzer Diagnostics\", 'A');\r\n    }\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IDiagDesc): string {\r\n        return desc.file.toString();\r\n    }\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IDiagDesc): IRange {\r\n        return desc.loc;\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        // TODO: fill all errors.\r\n        // TODO: add support for warnings\r\n        return {\r\n            [EErrors.InvalidReturnStmtEmpty]: 'Invalid return statement. Expression with \\'*type*\\' type expected.', // TODO: specify type\r\n            [EErrors.InvalidReturnStmtVoid]: 'Invalid return statement. Expression with \\'void\\' type expected.',\r\n            [EErrors.FunctionRedefinition]: 'Function redefinition. Function with name \\'{info.funcName}\\' already declared.', // TODO: add location where function declared before\r\n            [EErrors.InvalidFuncDefenitionReturnType]: 'Invalid function defenition return type. Function with the same name \\'{info.funcName}\\' but another type already declared.', // TODO: specify prev type and location\r\n            [EErrors.InvalidFunctionReturnStmtNotFound]: 'Return statement expected.', // TODO: specify func name and return type details.\r\n            [EErrors.InvalidVariableInitializing]: 'Invalid variable initializing.',\r\n            [EErrors.InvalidComplexNotFunction]: ({ info }: IDiagDesc) => \r\n                `Function definition for \"${info.funcName}(${info.args.join(', ')})\" has not been found.`\r\n        };\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: IDiagDesc): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { file, loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n","import { isNumber, isString } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ISLASTDocument } from \"@lib/idl/ISLASTDocument\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IncludeResolver } from \"@lib/idl/parser/IParser\";\r\nimport { IKnownDefine } from \"@lib/parser/Preprocessor\";\r\nimport { IExprSubstCallback } from \"./analisys/Analyzer\";\r\n\r\nimport { FxAnalyzer } from \"./analisys/FxAnalyzer\";\r\nimport { createSLASTDocument } from \"./SLASTDocument\";\r\n\r\ntype Opts = { flags?: number, includeResolver?: IncludeResolver };\r\n\r\nexport interface IFXSLOptions {\r\n    flags?: number;\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n};\r\n\r\nexport async function createFXSLDocument(document: ISLASTDocument | ITextDocument, \r\n    opts : IFXSLOptions = {}, parent: ISLDocument = null): Promise<ISLDocument> {\r\n    let textDocument: ITextDocument;\r\n    let slastDocument: ISLASTDocument;\r\n\r\n    if (isString((document as ITextDocument).source)) {    \r\n        textDocument = <ITextDocument>document;\r\n        slastDocument = await createSLASTDocument(textDocument, opts);\r\n    } else {\r\n        slastDocument = <ISLASTDocument>document;\r\n    }\r\n\r\n    const timeLabel = `createFXSLDocument(${slastDocument.uri})`;\r\n    console.time(timeLabel);\r\n\r\n    const analyzer = new FxAnalyzer;\r\n    const slDocument = await analyzer.parse(slastDocument, parent);\r\n    \r\n    console.timeEnd(timeLabel);\r\n\r\n    return slDocument;\r\n}\r\n\r\nexport async function extendFXSLDocument(textAddition: ITextDocument, base: ISLDocument, expressions?: IMap<IExprSubstCallback>, \r\n    opts: IFXSLOptions = {}): Promise<ISLDocument> {\r\n    let addition = null;\r\n    if (textAddition)\r\n    {\r\n        const knownTypes = Object.keys(base.root.scope.types);\r\n        const { flags, includeResolver } = opts;\r\n        addition = await createSLASTDocument(textAddition, { flags, knownTypes, includeResolver });\r\n    }\r\n    const analyzer = new FxAnalyzer;\r\n    const slDocument = analyzer.extend(addition, base, expressions);\r\n    return slDocument;\r\n}\r\n\r\n","import { IDiagnosticReport } from '@lib/idl/IDiagnostics';\r\nimport { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { IMacro } from '@lib/idl/parser/IMacro';\r\nimport { EOperationType, IASTConfig, IFile, IncludeResolver, IRange, IToken } from '@lib/idl/parser/IParser';\r\nimport { ASTDocument } from \"@lib/parser/ASTDocument\";\r\nimport { IKnownDefine, Preprocessor } from '@lib/parser/Preprocessor';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\n\r\nimport { defaultSLParser } from './SLParser';\r\n\r\n// const readFile = fname => fetch(fname).then(resp => resp.text(), reason => console.warn('!!!', reason));\r\n\r\nconst PREDEFINED_TYPES = [\r\n    'half2', 'half3', 'half4',\r\n    'float2', 'float3', 'float4',\r\n    'float2x2', 'float2x3', 'float2x4', \r\n    'float3x2', 'float3x3', 'float3x4', \r\n    'float4x2', 'float4x3', 'float4x4',\r\n    'int2', 'int3', 'int4',\r\n    'uint2', 'uint3', 'uint4',\r\n    'bool2', 'bool3', 'bool4',\r\n    'auto'\r\n];\r\n\r\n\r\nexport class SLASTDocument extends ASTDocument implements ISLASTDocument {\r\n    protected preprocessor: Preprocessor;\r\n\r\n    constructor({ parser = defaultSLParser(), knownTypes = new Set(), ...settings }: IASTConfig = {}) {\r\n        super({ parser, knownTypes: new Set([...PREDEFINED_TYPES, ...knownTypes]), ...settings });\r\n    }\r\n\r\n\r\n    get includes(): Map<string, IRange> {\r\n        return this.preprocessor.includeMap;\r\n    }\r\n\r\n\r\n    get unreachableCode(): IRange[] {\r\n        return this.preprocessor.unreachableCodeList;\r\n    }\r\n\r\n\r\n    get macros(): IMacro[] {\r\n        return [ ...this.preprocessor.macros ];\r\n    }\r\n\r\n\r\n    get unresolvedMacros(): IMacro[] {\r\n        return this.preprocessor.unresolvedMacros;\r\n    }\r\n\r\n\r\n    get uri(): IFile {\r\n        return this.preprocessor.uri;\r\n    }\r\n\r\n\r\n    get diagnosticReport(): IDiagnosticReport {\r\n        let preprocessorReport = this.preprocessor.getDiagnosticReport();\r\n        let parserReport = this.diag.resolve();\r\n        return Diagnostics.mergeReports([preprocessorReport, parserReport]);\r\n    }\r\n\r\n\r\n    protected init(config: IASTConfig) {\r\n        super.init(config);\r\n        const { knownTypes } = this;\r\n        const { includeResolver, defines } = config;\r\n        this.preprocessor = new Preprocessor(this.parser.lexerEngine, { knownTypes, includeResolver, defines });\r\n\r\n        this.ruleFunctions.set('addType', this._addType.bind(this));\r\n        this.ruleFunctions.set('addTypeDef', this._addTypeDef.bind(this));\r\n        this.ruleFunctions.set('print', this._print.bind(this));\r\n    }\r\n\r\n\r\n    private _addType(): EOperationType {\r\n        const tree = this.tree;\r\n        const node = tree.lastNode;\r\n        const typeId = node.value;\r\n        this.knownTypes.add(typeId);\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private _addTypeDef(): EOperationType {\r\n        const tree = this.tree;\r\n        const node = tree.lastNode;\r\n        const typeId = node.children[0].value;\r\n        this.knownTypes.add(typeId);\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private _print(): EOperationType {\r\n        const tree = this.tree;\r\n        const node = tree.lastNode;\r\n        console.log(node);\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    protected setTextDocument(textDocument: ITextDocument): void {\r\n        this.preprocessor.setTextDocument(textDocument);\r\n    }\r\n\r\n\r\n    protected async readToken(): Promise<IToken> {\r\n        const token = await this.preprocessor.readToken();\r\n        \r\n        // replacement of the original token location with the macro location\r\n        const macroLoc = this.preprocessor.macroLocation();\r\n        if (macroLoc) { \r\n            token.loc = macroLoc; \r\n        }\r\n\r\n        return token;\r\n    }\r\n}\r\n\r\n\r\nexport interface ISLASTOptions {\r\n    flags?: number;\r\n    knownTypes?: string[];\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n};\r\n\r\nexport async function createSLASTDocument(textDocument: ITextDocument, opts : ISLASTOptions = {}): Promise<ISLASTDocument> {\r\n    const { flags, knownTypes, includeResolver, defines } = opts;\r\n    const document = new SLASTDocument({ knownTypes: new Set([...(knownTypes || [])]), includeResolver, defines });\r\n    // const timeLabel = `createSLASTDocument(${textDocument.uri})`;\r\n    // console.time(timeLabel);\r\n    await document.parse(textDocument, flags);\r\n    // console.timeEnd(timeLabel);\r\n    return document;\r\n}\r\n","import { isString } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ISLASTDocument } from \"@lib/idl/ISLASTDocument\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IncludeResolver } from \"@lib/idl/parser/IParser\";\r\nimport { IKnownDefine } from \"@lib/parser/Preprocessor\";\r\n\r\nimport { Analyzer, IExprSubstCallback } from \"./analisys/Analyzer\";\r\nimport { createSLASTDocument } from \"./SLASTDocument\";\r\n\r\nexport interface ISLOptions {\r\n    flags?: number;\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n}\r\n\r\nexport async function createSLDocument(document: ISLASTDocument | ITextDocument, opts : ISLOptions = {}): Promise<ISLDocument> {\r\n    let textDocument = <ITextDocument>document;\r\n    let slastDocument = <ISLASTDocument>document;\r\n\r\n    if (isString(textDocument.source)) {    \r\n        let { flags, includeResolver } = opts;\r\n        slastDocument = await createSLASTDocument(textDocument, { flags, includeResolver });\r\n    }\r\n    \r\n    const timeLabel = `createSLDocument(${slastDocument.uri})`;\r\n    console.time(timeLabel);\r\n\r\n    const analyzer = new Analyzer;\r\n    const slDocument = await analyzer.parse(slastDocument);\r\n\r\n    console.timeEnd(timeLabel);\r\n\r\n    return slDocument;\r\n}\r\n\r\n\r\n// export async function extendSLDocument2(addition: ISLASTDocument, base: ISLDocument, expressions?: IMap<IExprSubstCallback>): Promise<ISLDocument> {\r\n//     const analyzer = new Analyzer;\r\n//     const slDocument = analyzer.extend(addition, base, expressions);\r\n//     return slDocument;\r\n// }\r\n\r\n\r\nexport async function extendSLDocument(textAddition: ITextDocument, base: ISLDocument, expressions?: IMap<IExprSubstCallback>, \r\n    opts: ISLOptions = {}): Promise<ISLDocument> {\r\n    let addition = null;\r\n    if (textAddition)\r\n    {\r\n        let knownTypes = Object.keys(base.root.scope.types);\r\n        let { flags, includeResolver } = opts;\r\n        addition = await createSLASTDocument(textAddition, { flags, knownTypes, includeResolver });\r\n    }\r\n    const analyzer = new Analyzer;\r\n    const slDocument = analyzer.extend(addition, base, expressions);\r\n    return slDocument;\r\n}\r\n\r\n","import { deepEqual } from \"@lib/common\";\r\nimport { EParserFlags, EParserType, IParserParams } from \"@lib/idl/parser/IParser\";\r\nimport { IParser } from \"@lib/idl/parser/IParser\"\r\nimport { AbstractParser } from \"@lib/parser/AbstractParser\";\r\n\r\n// import slGrammar from 'raw-loader!./HLSL.gr';\r\nimport { HLSL as slGrammar } from './HLSL';\r\n\r\nexport class SLParser extends AbstractParser {\r\n    protected init({ grammar = slGrammar, type = EParserType.k_LALR, flags = EParserFlags.k_Default }: IParserParams) {\r\n        super.init({ grammar, type, flags });\r\n    }\r\n}\r\n\r\nlet paramsDefault: IParserParams = null;\r\nlet parserDefault: IParser = null;\r\n\r\nexport function defaultSLGrammar(): string {\r\n    return slGrammar;\r\n}\r\n\r\nexport function defaultSLParser(): IParser {\r\n    if (!parserDefault) {\r\n        createDefaultSLParser();\r\n    }\r\n    return parserDefault;\r\n}\r\n\r\n/**\r\n * Internal debugging functionality, no need to use without necessary.\r\n */\r\nexport function createDefaultSLParser(params: IParserParams = { grammar: slGrammar }) {\r\n    if (deepEqual(paramsDefault, params)) {\r\n        return;\r\n    }\r\n    paramsDefault = params;\r\n    parserDefault = new SLParser(params);\r\n}\r\n","import { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IPosition } from \"@lib/idl/parser/IParser\";\r\nimport { StringRef } from \"@lib/util/StringRef\";\r\n\r\nexport async function createTextDocument(uri: string | StringRef, source: string, offset: IPosition = null): Promise<ITextDocument> {\r\n    uri = StringRef.make(uri);\r\n    return { uri, source, offset };\r\n}\r\n","import { Uniforms } from \"@lib/idl/Uniforms\";\r\n\r\nexport interface IUniformHelperActions {\r\n    raw(data: Uint8Array) : IUniformHelper;\r\n    int(x: number) : IUniformHelper;\r\n    float(x: number) : IUniformHelper;\r\n    float2(x: number, y: number) : IUniformHelper;\r\n    float3(x: number, y: number, z: number) : IUniformHelper;\r\n    float4(x: number, y: number, z: number, w: number) : IUniformHelper;\r\n}\r\n\r\nexport interface IUniformHelper {\r\n    set(name: string) : IUniformHelperActions;\r\n    finish() : Uniforms;\r\n}\r\n\r\nfunction UniformHelper (storage: Uint8Array = new Uint8Array(256)) : IUniformHelper\r\n{\r\n    let offset = 0;\r\n    let mapping = [];\r\n    let self = { set, finish };\r\n\r\n    function finish() : Uniforms\r\n    {\r\n        let uniforms = <Uniforms>{};\r\n        mapping.forEach((entry, i, arr) => {\r\n            let length = (i < (arr.length - 1) ? arr[i + 1].offset : offset) - entry.offset;\r\n            let data = new Uint8Array(storage.buffer, storage.byteOffset + entry.offset, length);\r\n            uniforms[entry.name] = data;\r\n        });\r\n        return uniforms;\r\n    }\r\n\r\n    function set(name: string) : IUniformHelperActions\r\n    {\r\n        mapping.push({ name, offset });\r\n        \r\n        function float2(x: number, y: number) : IUniformHelper\r\n        {\r\n            float(x);\r\n            float(y);\r\n            return self;\r\n        }\r\n\r\n        function float3(x: number, y: number, z: number) : IUniformHelper\r\n        {\r\n            float(x);\r\n            float(y);\r\n            float(z);\r\n            return self;\r\n        }\r\n\r\n        function float4(x: number, y: number, z: number, w: number) : IUniformHelper\r\n        {\r\n            float3(x, y, z);\r\n            float(w);\r\n            return self;\r\n        }\r\n    \r\n        function float(x: number) : IUniformHelper\r\n        {\r\n            (new DataView(storage.buffer, storage.byteOffset)).setFloat32(offset, x, true);\r\n            offset += 4;\r\n            console.assert(offset < storage.byteLength);\r\n            return self;\r\n        }\r\n\r\n        function int(x: number) : IUniformHelper\r\n        {\r\n            (new DataView(storage.buffer, storage.byteOffset)).setInt32(offset, x, true);\r\n            offset += 4;\r\n            console.assert(offset < storage.byteLength);\r\n            return self;\r\n        }\r\n\r\n        function raw(data: Uint8Array) : IUniformHelper {\r\n            for (let u8 of data) {\r\n                storage[offset] = u8;\r\n                offset++;\r\n            }\r\n            console.assert(offset < storage.byteLength);\r\n            return self;\r\n        }\r\n    \r\n        return { float4, float3, float2, float, int, raw };\r\n    }\r\n\r\n    return self;\r\n}\r\n\r\nexport default UniformHelper;\r\n\r\n// let u8 = new Uint8Array(256);\r\n// let helper = UniformHelper(u8);\r\n// helper.set('elapsedTime').float(0);","import { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, ICompileExprInstruction, IComplexExprInstruction, IConditionalExprInstruction, IConstructorCallInstruction, IDeclStmtInstruction, IExprStmtInstruction, IForStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIfStmtInstruction, IInitExprInstruction, IInstruction, ILogicalExprInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IRelationalExprInstruction, IReturnStmtInstruction, ISamplerStateBlockInstruction, IStmtBlockInstruction, ITypeInstruction, IUnaryExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IWhileStmtInstruction, IBitwiseExprInstruction, ICompileShader11Instruction } from \"@lib/idl/IInstruction\";\r\n\r\n// TODO: move it to helpers\r\nexport function visitor(owner: IInstruction, cb: (instr: IInstruction, owner?: IInstruction) => void) {\r\n    if (!owner) {\r\n        return;\r\n    }\r\n\r\n    const visit = (instr: IInstruction) => { \r\n        if (instr) {\r\n            cb(instr, owner); \r\n            visitor(instr, cb) \r\n        }\r\n    };\r\n\r\n    switch (owner.instructionType) {\r\n\r\n        //\r\n        // Stmt\r\n        //\r\n\r\n        case EInstructionTypes.k_ReturnStmt:\r\n            visit((owner as IReturnStmtInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_DeclStmt:\r\n            (owner as IDeclStmtInstruction).declList.forEach(decl => visit(decl));\r\n            break;\r\n        case EInstructionTypes.k_ExprStmt:\r\n            visit((owner as IExprStmtInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_IfStmt:\r\n            visit((owner as IIfStmtInstruction).cond);\r\n            visit((owner as IIfStmtInstruction).conseq);\r\n            visit((owner as IIfStmtInstruction).contrary);\r\n            break;\r\n        case EInstructionTypes.k_StmtBlock:\r\n            (owner as IStmtBlockInstruction).stmtList.forEach(stmt => visit(stmt));\r\n            break;\r\n        case EInstructionTypes.k_ForStmt:\r\n            visit((owner as IForStmtInstruction).init);\r\n            visit((owner as IForStmtInstruction).cond);\r\n            visit((owner as IForStmtInstruction).body);\r\n            visit((owner as IForStmtInstruction).step);\r\n            break;\r\n        case EInstructionTypes.k_WhileStmt:\r\n            visit((owner as IWhileStmtInstruction).cond);\r\n            visit((owner as IWhileStmtInstruction).body);\r\n            break;\r\n\r\n        //\r\n        // Expr\r\n        //\r\n\r\n        case EInstructionTypes.k_ArithmeticExpr:\r\n            visit((owner as IArithmeticExprInstruction).left);\r\n            visit((owner as IArithmeticExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_AssignmentExpr:\r\n            visit((owner as IAssignmentExprInstruction).left);\r\n            visit((owner as IAssignmentExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_BitwiseExpr:\r\n            visit((owner as IBitwiseExprInstruction).left);\r\n            visit((owner as IBitwiseExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_CastExpr:\r\n            visit((owner as ICastExprInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_CompileExpr:\r\n            (owner as ICompileExprInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as ICompileExprInstruction).function);\r\n            break;\r\n        case EInstructionTypes.k_CompileShader11Expr:\r\n            visit((owner as ICompileShader11Instruction).func);\r\n            (owner as ICompileShader11Instruction).args.forEach(arg => visit(arg));\r\n            break;\r\n        case EInstructionTypes.k_ComplexExpr:\r\n            visit((owner as IComplexExprInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_ConditionalExpr:\r\n            visit((owner as IConditionalExprInstruction).left);\r\n            visit((owner as IConditionalExprInstruction).right);\r\n            visit((owner as IConditionalExprInstruction).condition);\r\n            break;\r\n        case EInstructionTypes.k_ConstructorCallExpr:\r\n            (owner as IConstructorCallInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as IConstructorCallInstruction).ctor);\r\n            break;\r\n        case EInstructionTypes.k_FunctionCallExpr:\r\n            (owner as IFunctionCallInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as IFunctionCallInstruction).decl);\r\n            break;\r\n        case EInstructionTypes.k_IdExpr:\r\n            visit((owner as IIdExprInstruction).id);\r\n            break;\r\n        case EInstructionTypes.k_InitExpr:\r\n            (owner as IInitExprInstruction).args.forEach(arg => visit(arg));\r\n            break;\r\n        case EInstructionTypes.k_StateBlockExpr:\r\n            console.assert(false, 'not implemented');\r\n            break;\r\n        case EInstructionTypes.k_IntExpr:\r\n        case EInstructionTypes.k_FloatExpr:\r\n        case EInstructionTypes.k_BoolExpr:\r\n        case EInstructionTypes.k_StringExpr:\r\n        case EInstructionTypes.k_NullExpr:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_LogicalExpr:\r\n            visit((owner as ILogicalExprInstruction).left);\r\n            visit((owner as ILogicalExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_PostfixArithmeticExpr:\r\n            visit((owner as IPostfixArithmeticInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_PostfixIndexExpr:\r\n            visit((owner as IPostfixIndexInstruction).element);\r\n            visit((owner as IPostfixIndexInstruction).index);\r\n            break;\r\n        case EInstructionTypes.k_PostfixPointExpr:\r\n            visit((owner as IPostfixPointInstruction).element);\r\n            visit((owner as IPostfixPointInstruction).postfix);\r\n            break;\r\n        case EInstructionTypes.k_RelationalExpr:\r\n            visit((owner as IRelationalExprInstruction).left);\r\n            visit((owner as IRelationalExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_SamplerStateBlockExpr:\r\n            (owner as ISamplerStateBlockInstruction).params.forEach(param => visit(param));\r\n            visit((owner as ISamplerStateBlockInstruction).texture);\r\n            break;\r\n        case EInstructionTypes.k_UnaryExpr:\r\n            visit((owner as IUnaryExprInstruction).expr);\r\n            break;\r\n\r\n        //\r\n        // Others\r\n        //\r\n        case EInstructionTypes.k_ComplexType:\r\n            (owner as ITypeInstruction).fields.forEach(field => visit(field));\r\n            break;\r\n        case EInstructionTypes.k_FunctionDef:\r\n            visit((owner as IFunctionDefInstruction).returnType);\r\n            visit((owner as IFunctionDefInstruction).id);\r\n            (owner as IFunctionDefInstruction).params.forEach(param => visit(param));\r\n            break;\r\n        case EInstructionTypes.k_FunctionDecl:\r\n            visit((owner as IFunctionDeclInstruction).def);\r\n            visit((owner as IFunctionDeclInstruction).impl);\r\n            break;\r\n        case EInstructionTypes.k_VariableDecl:\r\n            visit((owner as IVariableDeclInstruction).type);\r\n            visit((owner as IVariableDeclInstruction).initExpr);\r\n            visit((owner as IVariableDeclInstruction).id);\r\n            break;\r\n        case EInstructionTypes.k_VariableType:\r\n            visit((owner as IVariableTypeInstruction).subType);\r\n            break;\r\n        case EInstructionTypes.k_Id:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_SystemFunctionDecl:\r\n        case EInstructionTypes.k_SystemType:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_BreakStmt:\r\n            break;\r\n\r\n        case EInstructionTypes.k_SpawnStmt:\r\n            // nothing todo?\r\n            break;\r\n\r\n        default:\r\n            console.error('unsupported instruction type found');\r\n    }\r\n}\r\n\r\nexport const Visitor = {\r\n    each: visitor\r\n};\r\n\r\n","import { assert, isDef, isDefAndNotNull, isNull, mwalk } from '@lib/common';\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { ERenderStates } from '@lib/idl/ERenderStates';\r\nimport { ERenderStateValues } from '@lib/idl/ERenderStateValues';\r\nimport {\r\n    EInstructionTypes, EScopeType, ETechniqueType,\r\n    IAnnotationInstruction, IArithmeticOperator, IAttributeInstruction, IBitwiseOperator, ICbufferInstruction,\r\n    ICompileShader11Instruction, IConstructorCallInstruction, IDeclInstruction, IDoWhileOperator, IExprInstruction,\r\n    IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIdInstruction,\r\n    IInstruction, IInstructionCollector, ILiteralInstruction, ILogicalOperator, IPass11Instruction, IPassInstruction,\r\n    IPresetInstruction, IPresetPropertyInstruction, IProvideInstruction, IScope, IStateBlockInstruction, IStmtBlockInstruction,\r\n    IStmtInstruction, ITechnique11Instruction, ITechniqueInstruction, ITypeDeclInstruction, ITypedefInstruction,\r\n    ITypedInstruction, ITypeInstruction, IUnaryOperator, IVariableDeclInstruction, IVariableTypeInstruction, IVariableUsage\r\n} from '@lib/idl/IInstruction';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IFile, IParseNode, IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\nimport { isNumber } from '@lib/util/s3d/type';\r\nimport { AnalyzerDiagnostics } from '@lib/fx/AnalyzerDiagnostics';\r\nimport { visitor } from '@lib/fx/Visitors';\r\nimport { expression, instruction, types } from './helpers';\r\nimport { AnnotationInstruction } from './instructions/AnnotationInstruction';\r\nimport { ArithmeticExprInstruction } from './instructions/ArithmeticExprInstruction';\r\nimport { AssigmentOperator, AssignmentExprInstruction } from \"./instructions/AssignmentExprInstruction\";\r\nimport { AttributeInstruction } from './instructions/AttributeInstruction';\r\nimport { BitwiseExprInstruction } from './instructions/BitwiseExprInstruction';\r\nimport { BoolInstruction } from './instructions/BoolInstruction';\r\nimport { BreakOperator, BreakStmtInstruction } from './instructions/BreakStmtInstruction';\r\nimport { CastExprInstruction } from './instructions/CastExprInstruction';\r\nimport { CbufferInstruction } from './instructions/CbufferInstruction';\r\nimport { CompileExprInstruction } from './instructions/CompileExprInstruction';\r\nimport { CompileShader11Instruction } from './instructions/CompileShader11Instruction';\r\nimport { ComplexExprInstruction } from './instructions/ComplexExprInstruction';\r\nimport { ComplexTypeInstruction } from './instructions/ComplexTypeInstruction';\r\nimport { ConditionalExprInstruction } from './instructions/ConditionalExprInstruction';\r\nimport { ConstructorCallInstruction } from './instructions/ConstructorCallInstruction';\r\nimport { DeclStmtInstruction } from './instructions/DeclStmtInstruction';\r\nimport { ExprStmtInstruction } from './instructions/ExprStmtInstruction';\r\nimport { FloatInstruction } from './instructions/FloatInstruction';\r\nimport { ForStmtInstruction } from './instructions/ForStmtInstruction';\r\nimport { FunctionCallInstruction } from './instructions/FunctionCallInstruction';\r\nimport { FunctionDeclInstruction } from './instructions/FunctionDeclInstruction';\r\nimport { FunctionDefInstruction } from './instructions/FunctionDefInstruction';\r\nimport { IdExprInstruction } from './instructions/IdExprInstruction';\r\nimport { IdInstruction } from './instructions/IdInstruction';\r\nimport { IfStmtInstruction } from './instructions/IfStmtInstruction';\r\nimport { InitExprInstruction } from './instructions/InitExprInstruction';\r\nimport { Instruction } from './instructions/Instruction';\r\nimport { InstructionCollector } from './instructions/InstructionCollector';\r\nimport { IntInstruction } from './instructions/IntInstruction';\r\nimport { LogicalExprInstruction } from './instructions/LogicalExprInstruction';\r\nimport { NullInstruction } from './instructions/NullInstruction';\r\nimport { PassInstruction } from './instructions/PassInstruction';\r\nimport { PostfixArithmeticInstruction, PostfixOperator } from './instructions/PostfixArithmeticInstruction';\r\nimport { PostfixIndexInstruction } from './instructions/PostfixIndexInstruction';\r\nimport { PostfixPointInstruction } from './instructions/PostfixPointInstruction';\r\nimport { PresetInstruction } from './instructions/Preset';\r\nimport { PresetProperty } from './instructions/PresetProperty';\r\nimport { ProvideInstruction } from \"./instructions/ProvideInstruction\";\r\nimport { ProxyTypeInstruction } from './instructions/ProxyTypeInstruction';\r\nimport { RelationalExprInstruction, RelationOperator } from './instructions/RelationalExprInstruction';\r\nimport { ReturnStmtInstruction } from './instructions/ReturnStmtInstruction';\r\nimport { SemicolonStmtInstruction } from './instructions/SemicolonStmtInstruction';\r\nimport { StateBlockInstruction } from './instructions/StateBlockInstruction';\r\nimport { StmtBlockInstruction } from './instructions/StmtBlockInstruction';\r\nimport { StringInstruction } from './instructions/StringInstruction';\r\nimport { SystemTypeInstruction } from './instructions/SystemTypeInstruction';\r\nimport { Technique11Instruction } from './instructions/Technique11Instruction';\r\nimport { TechniqueInstruction } from './instructions/TechniqueInstruction';\r\nimport { TypeDeclInstruction } from './instructions/TypeDeclInstruction';\r\nimport { TypedefInstruction } from './instructions/TypedefInstruction';\r\nimport { UnaryExprInstruction } from './instructions/UnaryExprInstruction';\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from './instructions/VariableDeclInstruction';\r\nimport { VariableTypeInstruction } from './instructions/VariableTypeInstruction';\r\nimport { WhileStmtInstruction } from './instructions/WhileStmtInstruction';\r\nimport { ProgramScope, ProgramScopeEx } from './ProgramScope';\r\nimport { parseUintLiteral } from './system/utils';\r\nimport * as SystemScope from './SystemScope';\r\nimport {\r\n    T_BOOL, T_BOOL2, T_BOOL3, T_BOOL4, T_COMPUTE_SHADER, T_FLOAT4, T_GEOMETRY_SHADER, T_INT, T_PIXEL_SHADER, T_UINT, T_VERTEX_SHADER, T_VOID\r\n} from './SystemScope';\r\n\r\n\r\ntype IErrorInfo = IMap<any>;\r\ntype IWarningInfo = IMap<any>;\r\n\r\nexport type IExprSubstCallback = (context: Context, program: ProgramScope, sourceNode: IParseNode) => IExprInstruction;\r\n\r\n// TODO: refactor it\r\nfunction findConstructor(type: ITypeInstruction, args: IExprInstruction[]): IVariableTypeInstruction {\r\n    return new VariableTypeInstruction({ type, scope: null });\r\n}\r\n\r\n\r\nconst asType = (instr: ITypedInstruction): ITypeInstruction => instr ? instr.type : null;\r\n\r\n\r\n// FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n// relax only uint => int\r\nconst asRelaxedType = (instr: ITypedInstruction | ITypeInstruction): ITypeInstruction | RegExp => {\r\n    if (!instr) {\r\n        return null;\r\n    }\r\n\r\n    const type = ((instr as any).getField) ? <ITypeInstruction>instr : (<ITypedInstruction> instr).type;\r\n    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    //          hacky way to check if \"type\" instruction (not \"typed\")\r\n\r\n    // hack to NULL expression to any type\r\n    if (types.equals(type, SystemScope.T_NULL)) {\r\n        return /^.*$/;\r\n    }\r\n\r\n    // allow \"int\" => \"float\" substitution\r\n    if (SystemScope.isIntBasedType(type) || SystemScope.isUintBasedType(type) || SystemScope.isBoolBasedType(type)) {\r\n        // temp workaround in order to match int to uint and etc. \r\n        const n = `${type.length > 1 ? type.length : ''}`;\r\n        return new RegExp(`^int${n}$|^uint${n}$|^bool${n}$|^float${n}$`, \"g\")\r\n    }\r\n\r\n    return type;\r\n};\r\n\r\n// TODO: rework 'auto' api\r\nfunction tryResolveProxyType(type: IVariableTypeInstruction, host: ITypeInstruction) {\r\n    if (type.subType && type.subType.instructionType === EInstructionTypes.k_ProxyType) {\r\n        const proxy = <ProxyTypeInstruction>type.subType;\r\n        if (!proxy.isResolved()) {\r\n            proxy.resolve(host);\r\n        }\r\n    }\r\n}\r\n\r\n/** @deprecated */\r\nfunction getRenderStateValue(state: ERenderStates, value: string): ERenderStateValues {\r\n    let eValue: ERenderStateValues = ERenderStateValues.UNDEF;\r\n\r\n    switch (state) {\r\n        case ERenderStates.ALPHABLENDENABLE:\r\n        case ERenderStates.ALPHATESTENABLE:\r\n            console.warn('ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.');\r\n            return ERenderStateValues.UNDEF;\r\n\r\n        case ERenderStates.BLENDENABLE:\r\n        case ERenderStates.CULLFACEENABLE:\r\n        case ERenderStates.ZENABLE:\r\n        case ERenderStates.ZWRITEENABLE:\r\n        case ERenderStates.DITHERENABLE:\r\n        case ERenderStates.SCISSORTESTENABLE:\r\n        case ERenderStates.STENCILTESTENABLE:\r\n        case ERenderStates.POLYGONOFFSETFILLENABLE:\r\n            switch (value) {\r\n                case 'TRUE':\r\n                    eValue = ERenderStateValues.TRUE;\r\n                    break;\r\n                case 'FALSE':\r\n                    eValue = ERenderStateValues.FALSE;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: '\r\n                        + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.CULLFACE:\r\n            switch (value) {\r\n                case 'FRONT':\r\n                    eValue = ERenderStateValues.FRONT;\r\n                    break;\r\n                case 'BACK':\r\n                    eValue = ERenderStateValues.BACK;\r\n                    break\r\n                case 'FRONT_AND_BACK':\r\n                    eValue = ERenderStateValues.FRONT_AND_BACK;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state CULLFACE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.FRONTFACE:\r\n            switch (value) {\r\n                case 'CW':\r\n                    eValue = ERenderStateValues.CW;\r\n                    break;\r\n                case 'CCW':\r\n                    eValue = ERenderStateValues.CCW;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state FRONTFACE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.SRCBLEND:\r\n        case ERenderStates.DESTBLEND:\r\n        case ERenderStates.SRCBLENDALPHA:\r\n        case ERenderStates.DESTBLENDALPHA:\r\n        case ERenderStates.SRCBLENDCOLOR:\r\n        case ERenderStates.DESTBLENDCOLOR:\r\n        case ERenderStates.BLENDFUNC:\r\n        case ERenderStates.BLENDFUNCSEPARATE:\r\n            switch (value) {\r\n                case 'ZERO':\r\n                    eValue = ERenderStateValues.ZERO;\r\n                    break;\r\n                case 'ONE':\r\n                    eValue = ERenderStateValues.ONE;\r\n                    break;\r\n                case 'SRCCOLOR':\r\n                    eValue = ERenderStateValues.SRCCOLOR;\r\n                    break;\r\n                case 'INVSRCCOLOR':\r\n                    eValue = ERenderStateValues.INVSRCCOLOR;\r\n                    break;\r\n                case 'SRCALPHA':\r\n                    eValue = ERenderStateValues.SRCALPHA;\r\n                    break;\r\n                case 'INVSRCALPHA':\r\n                    eValue = ERenderStateValues.INVSRCALPHA;\r\n                    break;\r\n                case 'DESTALPHA':\r\n                    eValue = ERenderStateValues.DESTALPHA;\r\n                    break;\r\n                case 'INVDESTALPHA':\r\n                    eValue = ERenderStateValues.INVDESTALPHA;\r\n                    break;\r\n                case 'DESTCOLOR':\r\n                    eValue = ERenderStateValues.DESTCOLOR;\r\n                    break;\r\n                case 'INVDESTCOLOR':\r\n                    eValue = ERenderStateValues.INVDESTCOLOR;\r\n                    break;\r\n                case 'SRCALPHASAT':\r\n                    eValue = ERenderStateValues.SRCALPHASAT;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state SRCBLEND/DESTBLEND value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.BLENDEQUATION:\r\n        case ERenderStates.BLENDEQUATIONSEPARATE:\r\n        case ERenderStates.BLENDEQUATIONCOLOR:\r\n        case ERenderStates.BLENDEQUATIONALPHA:\r\n            switch (value) {\r\n                case 'FUNCADD':\r\n                case 'ADD':\r\n                    eValue = ERenderStateValues.FUNCADD;\r\n                    break;\r\n                case 'FUNCSUBTRACT':\r\n                case 'SUBTRACT':\r\n                    eValue = ERenderStateValues.FUNCSUBTRACT;\r\n                    break;\r\n                case 'FUNCREVERSESUBTRACT':\r\n                case 'REVERSESUBTRACT':\r\n                    eValue = ERenderStateValues.FUNCREVERSESUBTRACT;\r\n                    break;\r\n                default:\r\n                    console.warn('Unsupported render state BLENDEQUATION/BLENDEQUATIONSEPARATE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.ZFUNC:\r\n            switch (value) {\r\n                case 'NEVER':\r\n                    eValue = ERenderStateValues.NEVER;\r\n                    break;\r\n                case 'LESS':\r\n                    eValue = ERenderStateValues.LESS;\r\n                    break;\r\n                case 'EQUAL':\r\n                    eValue = ERenderStateValues.EQUAL;\r\n                    break;\r\n                case 'LESSEQUAL':\r\n                    eValue = ERenderStateValues.LESSEQUAL;\r\n                    break;\r\n                case 'GREATER':\r\n                    eValue = ERenderStateValues.GREATER;\r\n                    break;\r\n                case 'NOTEQUAL':\r\n                    eValue = ERenderStateValues.NOTEQUAL;\r\n                    break;\r\n                case 'GREATEREQUAL':\r\n                    eValue = ERenderStateValues.GREATEREQUAL;\r\n                    break;\r\n                case 'ALWAYS':\r\n                    eValue = ERenderStateValues.ALWAYS;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state ZFUNC value used: ' +\r\n                        value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n        case ERenderStates.PRIMITIVETOPOLOGY:\r\n            switch (value) {\r\n                case 'TRIANGLELIST':\r\n                    eValue = ERenderStateValues.TRIANGLELIST;\r\n                    break;\r\n                case 'LINELIST':\r\n                    eValue = ERenderStateValues.LINELIST;\r\n                    break;\r\n                default:\r\n                    console.warn('Unsupported render state ZFUNC value used: ' +\r\n                        value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n    }\r\n\r\n    return eValue;\r\n}\r\n\r\n\r\n\r\n\r\nfunction addTypeDecl(context: Context, scope: IScope, typeDecl: ITypeDeclInstruction): void {\r\n    if (SystemScope.findType(typeDecl.name)) {\r\n        context.error(typeDecl.sourceNode, EErrors.SystemTypeRedefinition, { typeName: typeDecl.name });\r\n    }\r\n\r\n    let isAdded = scope.addType(typeDecl.type);\r\n    if (!isAdded) {\r\n        context.error(typeDecl.sourceNode, EErrors.TypeRedefinition, { typeName: typeDecl.name });\r\n    }\r\n}\r\n\r\n// TODO: rework to support complex typ defenitions like \r\n//  typedef const float4 TYPE_T;\r\n//          ^^^^^^\r\n// IP: at the moment type defenitions are not supported\r\nfunction addTypeAlias(context: Context, scope: IScope, typedef: ITypedefInstruction): void {\r\n    if (SystemScope.findType(typedef.alias)) {\r\n        context.error(typedef.sourceNode, EErrors.SystemTypeRedefinition, { typeName: typedef.name });\r\n    }\r\n\r\n    let isAdded = scope.addTypeAlias(typedef.type, typedef.alias);\r\n    if (!isAdded) {\r\n        context.error(typedef.sourceNode, EErrors.TypeRedefinition, { typeName: typedef.alias });\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction checkFunctionForRecursion(context: Context, func: IFunctionDeclInstruction, stack: number[]): boolean {\r\n    if (stack.indexOf(func.instructionID) !== -1) {\r\n        context.error(func.sourceNode,\r\n            EErrors.InvalidFunctionRecursionNotAllowed,\r\n            { funcName: func.name });\r\n        return false;\r\n    }\r\n\r\n    let recursionFound = false;\r\n\r\n    stack = [...stack, func.instructionID];\r\n    const recursionChecker = (instr: IInstruction) => {\r\n        if (instr.instructionType === EInstructionTypes.k_FunctionCallExpr) {\r\n            let fcall = (instr as IFunctionCallInstruction);\r\n            let fdecl = fcall.decl;\r\n            if (fdecl.instructionType === EInstructionTypes.k_SystemFunctionDecl) {\r\n                return;\r\n            }\r\n\r\n            // NOTE: it is possible that the declaration was not complete \r\n            //       at the time of the call, so you need to look for a \r\n            //       version with implementation\r\n            fdecl = fdecl.scope.findFunctionInScope(fdecl);\r\n            if (isNull(fdecl.impl)) {\r\n                if (fdecl.attrs.find(attr => attr.name === 'extern')) {\r\n                    // todo: use context info\r\n                    context.warn(instr.sourceNode, EWarnings.ExternCall);\r\n                } else {\r\n                    context.error(instr.sourceNode,\r\n                        EErrors.InvalidFunctionImplementationNotFound,\r\n                        { funcName: fdecl.name });\r\n                }\r\n                return;\r\n            }\r\n\r\n            // visitor(fdecl.impl, recursionChecker);\r\n            recursionFound = recursionFound ||\r\n                checkFunctionForRecursion(context, fdecl, stack);\r\n        }\r\n    };\r\n\r\n    visitor(func.impl, recursionChecker);\r\n\r\n    return !recursionFound;\r\n}\r\n\r\nfunction checkFunctionsForRecursion(context: Context, program: ProgramScope) {\r\n    const gs = program.globalScope;\r\n\r\n    let recusrionFound = false;\r\n    mwalk(gs.functions, funcOverloads => {\r\n        funcOverloads.forEach(func => {\r\n            recusrionFound = recusrionFound ||\r\n                !checkFunctionForRecursion(context, func, []);\r\n        })\r\n    });\r\n\r\n    return !recusrionFound;\r\n}\r\n\r\n\r\n\r\nfunction checkForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    if (!checkReturnTypeForVertexUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    if (!checkArgumentsForVertexUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    if (!checkReturnTypeForPixelUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    if (!checkArgumentsForPixelUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\nfunction checkReturnTypeForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    const returnType = <IVariableTypeInstruction>funcDef.returnType;\r\n\r\n    if (types.equals(returnType, T_VOID)) {\r\n        return true;\r\n    }\r\n\r\n    if (returnType.isComplex()) {\r\n        if (returnType.hasFieldWithoutSemantics()) {\r\n            // todo: emit warning\r\n            // return false;\r\n        }\r\n\r\n        if (!returnType.hasAllUniqueSemantics()) {\r\n            return false;\r\n        }\r\n\r\n        // Forbid fileds with user-defined types\r\n        // or any other complex types?\r\n        // if (returnType.isContainComplexType()) \r\n        {\r\n            //return false;\r\n        }\r\n    } else {\r\n        if (!types.equals(returnType, T_FLOAT4)) {\r\n            return false;\r\n        }\r\n\r\n        if (funcDef.semantic !== \"POSITION\") {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// todo: add support for dual source blending\r\n// todo: add support for MRT\r\nfunction checkReturnTypeForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let returnType = <IVariableTypeInstruction>funcDef.returnType;\r\n\r\n    if (types.equals(returnType, T_VOID)) {\r\n        return true;\r\n    }\r\n\r\n    // TODO: add MRT support\r\n    if (!SystemScope.isBase(returnType)) {\r\n        return false;\r\n    }\r\n\r\n    if (!types.equals(returnType, T_FLOAT4)) {\r\n        return false;\r\n    }\r\n\r\n    if (funcDef.semantic !== \"COLOR\") {\r\n        // todo: emit warning\r\n        // return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkArgumentsForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let params = funcDef.params;\r\n    let isAttributeByStruct = false;\r\n    let isAttributeByParams = false;\r\n    let isStartAnalyze = false;\r\n\r\n    for (let i: number = 0; i < params.length; i++) {\r\n        let param = params[i];\r\n\r\n        if (param.type.isUniform()) {\r\n            continue;\r\n        }\r\n\r\n        if (!isStartAnalyze) {\r\n            if (isNull(param.semantic)) {\r\n                if (SystemScope.isBase(param.type) ||\r\n                    param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics()) {\r\n                    return false;\r\n                }\r\n\r\n                isAttributeByStruct = true;\r\n            } else if (!isNull(param.semantic)) {\r\n                if (param.type.isComplex() &&\r\n                    (param.type.hasFieldWithoutSemantics() ||\r\n                        !param.type.hasAllUniqueSemantics())) {\r\n                    return false;\r\n                }\r\n\r\n                isAttributeByParams = true;\r\n            }\r\n\r\n            isStartAnalyze = true;\r\n        } else if (isAttributeByStruct) {\r\n            return false;\r\n        } else if (isAttributeByParams) {\r\n            if (isNull(param.semantic)) {\r\n                return false;\r\n            }\r\n\r\n            if (param.type.isComplex() &&\r\n                (param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkArgumentsForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let params = funcDef.params;\r\n    let isVaryingsByStruct = false;\r\n    let isVaryingsByParams = false;\r\n    let isStartAnalyze = false;\r\n\r\n    for (let i: number = 0; i < params.length; i++) {\r\n        let param: IVariableDeclInstruction = params[i];\r\n\r\n        if (param.type.isUniform()) {\r\n            continue;\r\n        }\r\n\r\n        if (!isStartAnalyze) {\r\n            if (param.semantic === \"\") {\r\n                if (SystemScope.isBase(param.type) ||\r\n                    param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics()) {\r\n                    // todo: check that there are no samplers in properties\r\n                    return false;\r\n                }\r\n\r\n                isVaryingsByStruct = true;\r\n            } else if (param.semantic !== \"\") {\r\n                // todo: check that there are no samplers in properties\r\n                if (param.type.isComplex() &&\r\n                    (param.type.hasFieldWithoutSemantics() ||\r\n                        !param.type.hasAllUniqueSemantics())) {\r\n                    return false;\r\n                }\r\n\r\n                isVaryingsByParams = true;\r\n            }\r\n\r\n            isStartAnalyze = true;\r\n        }\r\n        else if (isVaryingsByStruct) {\r\n            return false;\r\n        }\r\n        else if (isVaryingsByParams) {\r\n            if (param.semantic === \"\") {\r\n                // todo: emit warning\r\n                // return false;\r\n            }\r\n\r\n            // todo: check that there are no samplers in properties\r\n\r\n            if (param.type.isComplex() &&\r\n                (param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\nexport interface ICompileValidator {\r\n    // validate with custom arguments ignoring statements inside compile expression.\r\n    args?: (RegExp | ITypeInstruction)[];\r\n    ret?: ITypeInstruction;\r\n}\r\n\r\n\r\n\r\nexport class Context {\r\n    readonly uri: IFile;\r\n    readonly diagnostics: AnalyzerDiagnostics;\r\n\r\n    /** driven from provide declaration */\r\n    moduleName: string | null;\r\n\r\n    // funct states\r\n    func: boolean;                              // Are we inside a function analysis?\r\n    funcDef: IFunctionDefInstruction | null;    // Current function definition.\r\n    haveCurrentFunctionReturnOccur: boolean;    // TODO: replace with array of return statements.\r\n\r\n    cbuffer: boolean;\r\n\r\n    renderStates: IMap<ERenderStateValues>;\r\n\r\n    // graph needs extensions\r\n    expressions: IMap<IExprSubstCallback>;\r\n\r\n    constructor(uri: IFile, expressions?: IMap<IExprSubstCallback>) {\r\n        this.diagnostics = new AnalyzerDiagnostics;\r\n        this.uri = uri;\r\n        this.moduleName = null;\r\n        this.haveCurrentFunctionReturnOccur = false;\r\n        this.expressions = expressions || {};\r\n    }\r\n\r\n    beginCbuffer(): void { this.cbuffer = true; }\r\n    endCbuffer(): void { this.cbuffer = false; }\r\n\r\n    beginFunc(): void {\r\n        this.func = true;\r\n        this.haveCurrentFunctionReturnOccur = false;\r\n        this.funcDef = null; // << will be set inside analyzeFunctionDecl();\r\n    }\r\n\r\n    endFunc(): void {\r\n        this.func = false\r\n    }\r\n\r\n\r\n    beginPass(): void {\r\n        this.renderStates = null;\r\n    }\r\n\r\n    endPass(): void {\r\n        this.renderStates = null;\r\n    }\r\n\r\n\r\n    error(sourceNode: IParseNode, code: number, info: IErrorInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.error(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    critical(sourceNode: IParseNode, code: number, info: IErrorInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.critical(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    warn(sourceNode: IParseNode, code: number, info: IWarningInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.warning(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    private resolveNodeSourceLocation(sourceNode: IParseNode): IRange {\r\n        if (!isDefAndNotNull(sourceNode)) {\r\n            return null;\r\n        }\r\n\r\n        if (isDef(sourceNode.loc)) {\r\n            return sourceNode.loc;\r\n        }\r\n\r\n        return this.resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Analyzer {\r\n\r\n\r\n    protected analyzeUseDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): void {\r\n        program.currentScope.strictMode = true;\r\n    }\r\n\r\n\r\n    protected analyzeComplexName(sourceNode: IParseNode): string {\r\n        const children = sourceNode.children;\r\n        let name: string = '';\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            name += children[i].value;\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ProvideDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + ComplexNameOpt \r\n     *         T_KW_PROVIDE = 'provide'\r\n     */\r\n    protected analyzeProvideDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IProvideInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (children.length === 3) {\r\n            let moduleName = this.analyzeComplexName(children[1]);;\r\n            if (!isNull(context.moduleName)) {\r\n                console.warn(`Context module overriding detected '${context.moduleName}' => '${module}'`);\r\n            }\r\n            context.moduleName = moduleName;\r\n            assert(children[2].name === 'T_KW_PROVIDE');\r\n            return new ProvideInstruction({ sourceNode, moduleName, scope });\r\n        }\r\n\r\n        context.error(sourceNode, EErrors.UnsupportedProvideAs);\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    InitExpr\r\n     *         T_UINT = '0'\r\n     *    InitExpr\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeInitExprChildren(context: Context, program: ProgramScope, sourceNode: IParseNode, children: IParseNode[], expectedType: ITypeInstruction, exprSourceNode: IParseNode = null): IExprInstruction {\r\n        const scope = program.currentScope;\r\n\r\n\r\n        // raw value like \"int a = 1\"\r\n        if (children.length === 1) {\r\n            const initExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n            if (!initExpr) {\r\n                return null;\r\n            }\r\n\r\n            // NOTE: exprSourceNode => source node of the whole expression like \"const float name = value\" for better error highlighting.\r\n            //                                                                               ^^^^^^^^^^^^\r\n            //       sourceNode => source node of the init expr: const float3 name = { 1, 2, 3 };\r\n            //                                                                    ^^^^^^^^^^^^^\r\n            //       sourceNode => source node of the init expr: const float3[1] name = { { 1, 2, 3 } };\r\n            //                                                                            ^^^^^^^^^^^\r\n\r\n            const resType = Analyzer.checkTwoOperandExprTypes(context, '=', expectedType, initExpr.type,\r\n                sourceNode/* Use correct source node! */, initExpr.sourceNode, exprSourceNode || sourceNode, { isInitializing: true });\r\n\r\n            if (!resType) {\r\n                // omit error, all errors must be already fired above (inside checkTwoOperandExprTypes)\r\n                return null;\r\n            }\r\n\r\n            ////////////////////////////////////////////////\r\n            // IP: quick hack to avoid future conversions\r\n            ////////////////////////////////////////////////\r\n\r\n            // cast uint <=> int constant if possible\r\n            // if (initExpr.instructionType === EInstructionTypes.k_IntExpr && !types.equals(initExpr.type, expectedType)) {\r\n            //     let { scope, sourceNode, base, exp, signed, heximal } = <IntInstruction>initExpr;\r\n            //     signed = expectedType.name === 'int';\r\n            //     return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n            // }\r\n\r\n            // if (!types.equals(initExpr.type, expectedType)) {\r\n            //     return new CastExprInstruction({scope, sourceNode, sourceExpr: initExpr, type: expectedType});\r\n            // }\r\n\r\n            ////////////////////////////////////////////////\r\n            ////////////////////////////////////////////////\r\n\r\n            return initExpr;\r\n        }\r\n        // It's a global user defined array or just not unit array;\r\n        // Trying to exclude types like float1.\r\n        else if ((expectedType.isNotBaseArray() && expectedType.scope.type <= EScopeType.k_Global) ||\r\n            expectedType.isArray()) {\r\n            const args = <IExprInstruction[]>[];\r\n            const numArgs = (children.length - 1) / 2;\r\n\r\n            if (expectedType.length === instruction.UNDEFINE_LENGTH ||\r\n                (expectedType.isNotBaseArray() && numArgs !== expectedType.length) ||\r\n                (!expectedType.isNotBaseArray() && numArgs !== expectedType.baseType.length)) {\r\n                context.error(sourceNode, EErrors.InvalidVariableInitializingEx, {\r\n                    tooltip: `attemp to init an array with invalid number of arguments. expected: ${expectedType.length}, given: ${numArgs}`\r\n                });\r\n                return null;\r\n            }\r\n\r\n            const arrayElementType = <IVariableTypeInstruction>expectedType.arrayElementType;\r\n            /**\r\n             * AST example:\r\n             *    InitExpr\r\n             *         T_PUNCTUATOR_125 = '}'\r\n             *       + InitExpr \r\n             *         T_PUNCTUATOR_44 = ','\r\n             *       + InitExpr \r\n             *         T_PUNCTUATOR_123 = '{'\r\n             */\r\n            for (let i = children.length - 2; i >= 1; i--) {\r\n                if (children[i].name === 'InitExpr') {\r\n                    const initExpr = this.analyzeInitExpr(context, program, children[i], arrayElementType);\r\n\r\n                    if (isNull(initExpr)) {\r\n                        // omit error because it was already produced by the call above\r\n                        return null;\r\n                    }\r\n\r\n                    args.push(initExpr);\r\n                }\r\n            }\r\n\r\n            assert(expectedType.instructionType === EInstructionTypes.k_VariableType);\r\n            return new InitExprInstruction({ scope, sourceNode, args, type: <IVariableTypeInstruction>expectedType });\r\n        } else if (expectedType.isComplex()) {\r\n            const numArgs = (children.length - 1) / 2;\r\n            const fieldNameList = expectedType.fields.map(f => f.name);\r\n            const args = <IExprInstruction[]>[];\r\n\r\n            if (numArgs !== fieldNameList.length) {\r\n                // TODO: emit error (invalid number of arguments)\r\n                return null;\r\n            }\r\n\r\n            /**\r\n             * AST example:\r\n             *    InitExpr\r\n             *         T_PUNCTUATOR_125 = '}'\r\n             *       + InitExpr \r\n             *         T_PUNCTUATOR_44 = ','\r\n             *       + InitExpr \r\n             *         T_PUNCTUATOR_123 = '{'\r\n             */\r\n            for (let i = children.length - 2; i >= 1; i--) {\r\n                if (children[i].name === 'InitExpr') {\r\n                    const fieldType = expectedType.getField(fieldNameList[i]).type;\r\n                    const initExpr = this.analyzeInitExpr(context, program, children[i], fieldType);\r\n\r\n                    if (isNull(initExpr)) {\r\n                        // omit error because it was already produced by the call above\r\n                        return null;\r\n                    }\r\n\r\n                    args.push(initExpr);\r\n                }\r\n            }\r\n            assert(expectedType.instructionType === EInstructionTypes.k_VariableType);\r\n            return new InitExprInstruction({ scope, sourceNode, args, type: <IVariableTypeInstruction>expectedType });\r\n        } else {\r\n            const numArgs = (children.length - 1) / 2;\r\n\r\n            // handle cases like: int a = { 1 };\r\n            if (numArgs !== 1) {\r\n                // TODO: emit error (invalid number of arguments)\r\n                return null;\r\n            }\r\n\r\n            const exprNode = children[children.length - 2];\r\n\r\n            let initExpr = null;\r\n            if (exprNode.name === 'InitExpr')\r\n                initExpr = this.analyzeInitExpr(context, program, exprNode, expectedType);\r\n            else\r\n                initExpr = this.analyzeExpr(context, program, children[children.length - 2]);\r\n            \r\n\r\n            // TODO: use checkTwoOperandTypes() function instead\r\n            if (!types.equals(expectedType, initExpr.type)) {\r\n                // TODO: emit error\r\n                return null;\r\n            }\r\n\r\n            return initExpr;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    InitExpr\r\n     *         T_UINT = '0'\r\n     *    InitExpr\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeInitExpr(context: Context, program: ProgramScope, sourceNode: IParseNode, expectedType: ITypeInstruction): IExprInstruction {\r\n        return this.analyzeInitExprChildren(context, program, sourceNode, sourceNode.children, expectedType);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    SamplerStateDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + StateBlock \r\n     *         T_NON_TYPE_ID = 'MeshTextureSampler'\r\n     *         T_KW_SAMPLER_STATE = 'SamplerState'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzeSamplerStateDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction {\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeVariableDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const generalType = this.analyzeUsageType(context, program, children[children.length - 1]);\r\n        const vars: IVariableDeclInstruction[] = [];\r\n\r\n        if (isNull(generalType)) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'Variable') {\r\n                vars.push(this.analyzeVariable(context, program, children[i], generalType));\r\n            }\r\n        }\r\n\r\n        return vars;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    UsageType\r\n     *       + Type \r\n     *       + Usage \r\n     */\r\n    protected analyzeUsageType(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n        let usagesRaw: IVariableUsage[] = [];\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'Type') {\r\n                // basically, just get type from scope\r\n                type = this.analyzeType(context, program, children[i]);\r\n                if (isNull(type)) {\r\n                    return null\r\n                }\r\n            }\r\n            else if (children[i].name === 'Usage') {\r\n                usagesRaw.push(this.analyzeUsage(children[i]));\r\n            }\r\n        }\r\n\r\n        const usageIn = usagesRaw.includes('in');\r\n        const usageOut = usagesRaw.includes('out');\r\n        const usageInout = usagesRaw.includes('inout');\r\n        const usageConst = usagesRaw.includes('const');\r\n        const usageUniform = usagesRaw.includes('uniform');\r\n        const usageUnsigned = usagesRaw.includes('unsigned');\r\n        const usageStatic = usagesRaw.includes('static');\r\n\r\n        // TODO: emit errors in case of inconsistent usages\r\n        // TODO: remplace with bitflags\r\n        let usages: IVariableUsage[] = [];\r\n        if (usageInout) {\r\n            usages.push('inout');\r\n            // emit error in case of uniform\r\n            // emit error in case of const\r\n        } else {\r\n            if (usageIn && usageOut) {\r\n                usages.push('inout');\r\n                // emit error in case of uniform\r\n                // emit error in case of const\r\n            } else {\r\n                if (usageIn) {\r\n                    usages.push('in');\r\n                }\r\n                if (usageOut) {\r\n                    usages.push('out');\r\n                    // emit error in case of const\r\n                    // emit error in case of uniform\r\n                } else {\r\n                    if (usageConst) usages.push('const');\r\n                    if (usageUniform) usages.push('uniform');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (usageStatic) {\r\n            usages.push('static');\r\n        }\r\n\r\n        if (usageUnsigned && !SystemScope.isIntBasedType(type)) {\r\n            console.error('invalid unsigned usage');\r\n        }\r\n\r\n        // wrap type with usages\r\n        return new VariableTypeInstruction({ scope, sourceNode, type, usages })\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Type\r\n     *         T_TYPE_ID = 'float3'\r\n     */\r\n    protected analyzeType(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n\r\n        switch (sourceNode.name) {\r\n            case 'T_TYPE_ID':\r\n                if (sourceNode.value === 'auto') {\r\n                    type = new ProxyTypeInstruction({ scope });\r\n                    break;\r\n                }\r\n\r\n                type = scope.findType(sourceNode.value);\r\n\r\n                if (isNull(type)) {\r\n                    context.error(sourceNode, EErrors.InvalidTypeNameNotType, { typeName: sourceNode.value });\r\n                }\r\n                break;\r\n            case 'Struct':\r\n                type = this.analyzeStruct(context, program, sourceNode);\r\n                break;\r\n\r\n            case 'T_KW_VOID':\r\n                type = T_VOID;\r\n                break;\r\n\r\n            case 'ScalarType':\r\n            case 'ObjectType':\r\n                {\r\n                    let typeName = children[children.length - 1].value;\r\n\r\n                    if (children.length !== 1) {\r\n                        assert(children[children.length - 2].value === '<' && children[0].value === '>');\r\n                        const tplName = typeName;\r\n                        const args = children\r\n                            .slice(1, -2)\r\n                            .reverse()\r\n                            .filter((v, i) => i % 2 == 0)\r\n                            .map(sourceNode => this.analyzeType(context, program, sourceNode));\r\n\r\n                        const template = scope.findTypeTemplate(typeName);\r\n\r\n                        if (isNull(template)) {\r\n                            context.error(sourceNode, EErrors.InvalidTypeNameTemplateNotFound,\r\n                                { tplName, args: args.map(arg => arg.toCode()) });\r\n                            return null;\r\n                        }\r\n\r\n                        // TODO: validate register\r\n                        // TODO: use ESystemTypes enumeration\r\n                        const SYSTEM_TYPES = [\r\n                            'Buffer',\r\n                            'RWBuffer',\r\n                            'RWStructuredBuffer',\r\n                            'AppendStructuredBuffer',\r\n                            'RWTexture1D',\r\n                            'RWTexture2D',\r\n                            'RWTexture3D',\r\n                            'Texture1D',\r\n                            'Texture2D',\r\n                            'Texture3D',\r\n                            'Texture2DArray',\r\n                            'TextureCubeArray',\r\n                        ];\r\n                        if (SYSTEM_TYPES.indexOf(template.name) !== -1) {\r\n                            if (scope.type != EScopeType.k_Global) {\r\n                                context.error(sourceNode, EErrors.InvalidTypeScope,\r\n                                    { typeName: template.name, tooltip: 'only global scope allowed' });\r\n                                return null;\r\n                            }\r\n                        }\r\n\r\n                        typeName = template.typeName(args);\r\n                        type = scope.findType(typeName);\r\n\r\n                        if (isNull(type)) {\r\n                            type = template.produceType(scope, args);\r\n                            if (isNull(type)) {\r\n                                context.error(sourceNode, EErrors.CannotProduceType, { typeName });\r\n                                return null;\r\n                            }\r\n                            scope.addType(type);\r\n                        }\r\n                    } else {\r\n                        type = scope.findType(typeName);\r\n                    }\r\n\r\n                    if (isNull(type)) {\r\n                        context.error(sourceNode, EErrors.InvalidTypeNameNotType, { typeName });\r\n                        return null;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case 'VectorType':\r\n            case 'MatrixType':\r\n                context.error(sourceNode, EErrors.InvalidTypeVectorMatrix);\r\n                break;\r\n\r\n            case 'BaseType':\r\n            case 'Type':\r\n                return this.analyzeType(context, program, children[0]);\r\n        }\r\n\r\n        return type;\r\n    }\r\n\r\n\r\n    protected analyzeUsage(sourceNode: IParseNode): IVariableUsage {\r\n        sourceNode = sourceNode.children[0];\r\n        const supportedUsages = ['uniform', 'const', 'in', 'out', 'inout', 'static', 'unsigned', 'precise', 'inline'];\r\n        assert(supportedUsages.indexOf(sourceNode.value) !== -1, sourceNode.value);\r\n        return <IVariableUsage>sourceNode.value;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    CbufferDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VarStructDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *       + Annotation \r\n     *       + Semantic \r\n     *         T_NON_TYPE_ID = 'NAME'\r\n     *         T_KW_CBUFFER = 'cbuffer'\r\n     * \r\n     * AST example:\r\n     *    CbufferDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VarStructDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_KW_CBUFFER = 'cbuffer'\r\n     */\r\n    protected analyzeCbufferDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ICbufferInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation = <IAnnotationInstruction>null;\r\n        let semantic = '';\r\n        let id = <IIdInstruction>null;\r\n\r\n        context.beginCbuffer();\r\n\r\n        let ic = children.length - 2;\r\n        if (children[ic].name === 'T_NON_TYPE_ID') {\r\n            id = new IdInstruction({ scope, sourceNode: children[ic], name: children[ic].value });\r\n            ic--;\r\n        }\r\n\r\n        if (children[ic].name === 'Semantic') {\r\n            semantic = this.analyzeSemantic(children[ic]);\r\n\r\n            const match = semantic.match(/^register\\(([utbs]{1})([\\d]+)\\)$/);\r\n            if (match) {\r\n                const rtype = match[1];\r\n                if (rtype !== 'b') {\r\n                    context.warn(children[ic], EWarnings.InvalidCbufferRegister);\r\n                }\r\n            }\r\n\r\n            ic--;\r\n        }\r\n\r\n        if (children[ic].name === 'Annotation') {\r\n            annotation = this.analyzeAnnotation(context, program, children[ic]);\r\n            ic--;\r\n        }\r\n\r\n        ic--;\r\n\r\n        // program.push(EScopeType.k_Cbuffer);\r\n\r\n        let fields = <IVariableDeclInstruction[]>[];\r\n        for (let i = ic; i >= 2; i--) {\r\n            switch (children[i].name) {\r\n                case 'VariableDecl':\r\n                    fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n                    break;\r\n                case 'VarStructDecl':\r\n                    fields = fields.concat(this.analyzeVarStructDecl(context, program, children[i]));\r\n                    break;\r\n                default:\r\n                    context.error(children[i], EErrors.UnknownInstruction, {});\r\n            }\r\n        }\r\n\r\n        // program.pop();\r\n\r\n        context.endCbuffer();\r\n\r\n        const aligment = T_FLOAT4.size; // float4 aligment!\r\n        const name = id.name;\r\n        const type = new ComplexTypeInstruction({ scope, sourceNode, name, fields, aligment });\r\n\r\n        {\r\n            let isAdded = scope.addType(type);\r\n            if (!isAdded) {\r\n                context.error(sourceNode, EErrors.TypeRedefinition, { typeName: name });\r\n            }\r\n        }\r\n\r\n        const cbuf = new CbufferInstruction({ id, type, sourceNode, semantic, annotation, scope });\r\n\r\n        {\r\n            let isAdded = scope.addCbuffer(cbuf);\r\n            if (!isAdded) {\r\n                context.error(sourceNode, EErrors.CbufferRedefinition, { typeName: name });\r\n            }\r\n        }\r\n\r\n        return cbuf;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Variable\r\n     *       + Initializer \r\n     *       + Semantic \r\n     *       + VariableDim\r\n     *              T_PUNCTUATOR_93 = ']'\r\n     *              T_NON_TYPE_ID = 'N'\r\n     *              T_PUNCTUATOR_91 = '['\r\n     *            + VariableDim\r\n     *                   T_NON_TYPE_ID = 'x'\r\n     *                   ^^^^^^^^^^^^^^^^^^\r\n     */\r\n    protected analyzeVariable(context: Context, program: ProgramScope, sourceNode: IParseNode, generalType: IVariableTypeInstruction): IVariableDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let init: IExprInstruction = null;\r\n        let semantic = '';\r\n        let usageFlags = 0;\r\n\r\n        if (!context.func) {\r\n            if (scope.type !== EScopeType.k_Struct) {\r\n                usageFlags |= EVariableUsageFlags.k_Global;\r\n            }\r\n            if (context.cbuffer) {\r\n                usageFlags |= EVariableUsageFlags.k_Cbuffer;\r\n            }\r\n        } else {\r\n            // All variables found inside function definition are arguments.\r\n            if (!context.funcDef) {\r\n                usageFlags |= EVariableUsageFlags.k_Argument;\r\n            }\r\n            usageFlags |= EVariableUsageFlags.k_Local;\r\n        }\r\n\r\n\r\n        let id = <IIdInstruction>null;\r\n        let arrayIndex = <IExprInstruction>null;\r\n        let type = <IVariableTypeInstruction>null;\r\n\r\n        let vdimNode = children[children.length - 1];\r\n        do {\r\n            let vdimChildren = vdimNode.children;\r\n\r\n            if (vdimChildren.length === 1) {\r\n                const name = vdimChildren[0].value;\r\n                id = new IdInstruction({ scope, sourceNode, name });\r\n                break;\r\n            }\r\n\r\n            assert(vdimChildren.length == 4);\r\n\r\n            if (!isNull(arrayIndex)) {\r\n                // usage of generalType.source node instead of sourceNode was done for more clear debugging\r\n                generalType = new VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });\r\n            }\r\n\r\n            arrayIndex = this.analyzeExpr(context, program, vdimChildren[vdimChildren.length - 3]);\r\n            vdimNode = vdimChildren[vdimChildren.length - 1];\r\n        } while (true);\r\n\r\n        // using generalType.source node instead of sourceNode was done for more clear debugging\r\n        type = new VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });\r\n        /**\r\n         * (state block initializer)\r\n         * AST example:\r\n         *    Initializer\r\n         *       + StateBlock \r\n         */\r\n        /**\r\n         * (list initializer)\r\n         * AST example:\r\n         *    Initializer\r\n         *         T_UINT = '1'\r\n         *         T_PUNCTUATOR_61 = '='\r\n         */\r\n        const doInitUsingList = (sourceNode: IParseNode) => \r\n            sourceNode.children[sourceNode.children.length - 1]?.value == '=';\r\n\r\n        for (let i = children.length - 2; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(context, program, children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else if (children[i].name === 'Initializer') {\r\n                \r\n                if (doInitUsingList(children[i])) {\r\n                    init = this.analyzeInitializer(context, program, children[i], type, sourceNode);\r\n                } else {\r\n                    init = this.analyzeStateBlock(context, program, children[i].children[0], type);\r\n                }\r\n\r\n                switch (type.name) {\r\n                    case 'BlendState':\r\n                    case 'SamplerState':\r\n                    case 'SamplerComparisonState':\r\n                    case 'DepthStencilState':\r\n                    case 'RasterizerState':\r\n                        // todo: validate properties\r\n                        console.assert(!doInitUsingList(children[i]));\r\n                        console.assert(!type.isNotBaseArray() || type.length == (<IStateBlockInstruction>init).blocks.length);\r\n                        break;\r\n                    default:\r\n                        console.assert(doInitUsingList(children[i]));\r\n                }\r\n\r\n                if (!init) {\r\n                    // TODO: make it warning\r\n                    context.error(sourceNode, EErrors.InvalidVariableInitializing, { varName: id.name });\r\n                }\r\n            }\r\n        }\r\n\r\n        const varDecl = new VariableDeclInstruction({ sourceNode, scope, type, init, id, semantic, annotation, usageFlags });\r\n        assert(scope.type != EScopeType.k_System);\r\n\r\n        if (SystemScope.hasVariable(varDecl.name)) {\r\n            context.error(sourceNode, EErrors.SystemVariableRedefinition, { varName: varDecl.name });\r\n        }\r\n\r\n        const isAdded = scope.addVariable(varDecl);\r\n        if (!isAdded) {\r\n            switch (scope.type) {\r\n                case EScopeType.k_Global:\r\n                case EScopeType.k_Default:\r\n                    context.error(sourceNode, EErrors.VariableRedefinition, { varName: varDecl.name });\r\n                    break;\r\n                case EScopeType.k_Struct:\r\n                    context.error(sourceNode, EErrors.InvalidNewFieldForStructName, { fieldName: varDecl.name });\r\n                    break;\r\n                case EScopeType.k_Annotation:\r\n                    context.error(sourceNode, EErrors.InvalidNewAnnotationVar, { varName: varDecl.name });\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return varDecl;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AnnotationDecls\r\n     *       + AnnotationDecls \r\n     *       + VariableDecl \r\n     */\r\n    protected analyzeAnnotationDecls(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n        let decls = [];\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'AnnotationDecls':\r\n                    decls.push(...this.analyzeAnnotationDecls(context, program, children[i]));\r\n                    break;\r\n                case 'VariableDecl':\r\n                    decls.push(...this.analyzeVariableDecl(context, program, children[i]));\r\n                    break;\r\n            }\r\n        }\r\n        return decls;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Annotation\r\n     *         T_PUNCTUATOR_62 = '>'\r\n     *         T_PUNCTUATOR_60 = '<'\r\n     */\r\n    protected analyzeAnnotation(context: Context, $program: ProgramScope, sourceNode: IParseNode): IAnnotationInstruction {\r\n        // IP: hucky way to not add annotation variables to real scope\r\n        const program = new ProgramScope(SystemScope.SCOPE); \r\n        const scope = program.currentScope;\r\n        program.push(EScopeType.k_Annotation);\r\n        const decls = [\r\n            ...sourceNode.children.filter(node => node.name == 'AnnotationDecls').map(node => this.analyzeAnnotationDecls(context, program, node)).flat(),\r\n            ...sourceNode.children.filter(node => node.name == 'VariableDecl').map(node => this.analyzeVariableDecl(context, program, node)).flat()\r\n        ];\r\n        program.pop();\r\n        if (!decls || !decls.length) return null;\r\n        return new AnnotationInstruction({ scope, sourceNode, decls });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Semantic\r\n     *         T_NON_TYPE_ID = 'SEMANTIC'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    Semantic\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'u2'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_REGISTER = 'register'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     */\r\n    protected analyzeSemantic(sourceNode: IParseNode): string {\r\n        return sourceNode.children.slice(0, -1).reverse().map(child => child.value).join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Initializer\r\n     *         T_UINT = '10'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     *    Initializer\r\n     *       + CastExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *    Initializer\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     */\r\n    protected analyzeInitializer(context: Context, program: ProgramScope, sourceNode: IParseNode, expectedType: ITypeInstruction, exprSourceNode: IParseNode = null): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        // IP: hacky varification to be sure that it's not a \r\n        if (children[children.length - 1]?.value == '=') {\r\n            console.assert(children[children.length - 1].name === 'T_PUNCTUATOR_61');\r\n            return this.analyzeInitExprChildren(context, program, sourceNode, children.slice(0, -1), expectedType, exprSourceNode);\r\n        }\r\n        console.assert(false, 'not valid branch');\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    protected analyzeExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const name = sourceNode.name;\r\n\r\n        switch (name) {\r\n            case 'ObjectExpr':\r\n                return this.analyzeObjectExpr(context, program, sourceNode);\r\n            case 'ComplexExpr':\r\n                return this.analyzeComplexExpr(context, program, sourceNode);\r\n            case 'PostfixExpr':\r\n                return this.analyzePostfixExpr(context, program, sourceNode);\r\n            case 'UnaryExpr':\r\n                return this.analyzeUnaryExpr(context, program, sourceNode);\r\n            case 'CastExpr':\r\n                return this.analyzeCastExpr(context, program, sourceNode);\r\n            case 'ConditionalExpr':\r\n                return this.analyzeConditionalExpr(context, program, sourceNode);\r\n            case 'MulExpr':\r\n            case 'AddExpr':\r\n                return this.analyzeArithmeticExpr(context, program, sourceNode);\r\n            case 'RelationalExpr':\r\n            case 'EqualityExpr':\r\n                return this.analyzeRelationExpr(context, program, sourceNode);\r\n            case 'LogicalAndExpr':\r\n            case 'LogicalOrExpr':\r\n                return this.analyzeLogicalExpr(context, program, sourceNode);\r\n            case 'AssignmentExpr':\r\n                return this.analyzeAssignmentExpr(context, program, sourceNode);\r\n            case 'AndExpr':\r\n            case 'ShiftExpr':\r\n            case 'InclusiveOrExpr':\r\n            case 'ExclusiveOrExpr':\r\n                return this.analyzeBitwiseExpr(context, program, sourceNode);\r\n            case 'T_NON_TYPE_ID':\r\n                return this.analyzeIdExpr(context, program, sourceNode);\r\n            case 'T_STRING':\r\n            case 'T_UINT':\r\n            case 'T_FLOAT':\r\n            case 'T_KW_TRUE':\r\n            case 'T_KW_FALSE':\r\n                return this.analyzeSimpleExpr(context, program, sourceNode);\r\n            default:\r\n                context.error(sourceNode, EErrors.UnsupportedExpr, { exprName: name });\r\n                break;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *       + StateBlock \r\n     *         T_KW_SAMPLER_STATE = 'sampler_state'\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'fs_skybox'\r\n     *         T_KW_COMPILE = 'compile'\r\n     */\r\n    protected analyzeObjectExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        let name = sourceNode.children[sourceNode.children.length - 1].name;\r\n\r\n        switch (name) {\r\n            /** @deprecated */\r\n            case 'T_KW_COMPILE':\r\n                return this.analyzeCompileExpr(context, program, sourceNode);\r\n            case 'T_KW_COMPILE_SHADER':\r\n                return this.analyzeCompileShader11(context, program, sourceNode);\r\n                return null;\r\n            default:\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ComplexExpr \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_NON_TYPE_ID = 'vs_4_0_level_9_1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_COMPILE_SHADER = 'CompileShader'\r\n     */\r\n    protected analyzeCompileShader11(context: Context, program: ProgramScope, sourceNode: IParseNode): ICompileShader11Instruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        // CompileShader( vs_4_0_level_9_1, RenderSceneVS( 1, true, true ) )\r\n        const shaderNode = children[1];     // RenderSceneVS( 1, true, true )\r\n        const versionNode = children[3];    // vs_4_0_level_9_1\r\n        const ver = versionNode.value;\r\n        const entryNode = shaderNode.children[shaderNode.children.length - 1]; // RenderSceneVS\r\n        const funcName = entryNode.value;\r\n        const args = [];\r\n        for (let i = shaderNode.children.length - 3; i > 0; i--) {\r\n            if (shaderNode.children[i].value !== ',') {\r\n                args.push(this.analyzeExpr(context, program, shaderNode.children[i]));\r\n            }\r\n        }\r\n    \r\n        //findFunction(funcName, args);\r\n        const func = program.globalScope.functions[funcName][0]; // todo: get suitable?\r\n        const shaderType = ver.substring(0, 2);\r\n        const sh = {\r\n            'vs': T_VERTEX_SHADER,\r\n            'ps': T_PIXEL_SHADER,\r\n            'gs': T_GEOMETRY_SHADER,\r\n            'cs': T_COMPUTE_SHADER\r\n        };\r\n\r\n        const type: ITypeInstruction = sh[shaderType];\r\n        assert(isDef(type), `unknown shader type '${shaderType} (${ver})' has been used`);\r\n        return new CompileShader11Instruction({ scope, sourceNode, ver, args, func, type });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'main'\r\n     *         T_KW_COMPILE = 'compile'\r\n     */\r\n    protected analyzeCompileExpr(context: Context, program: ProgramScope, sourceNode: IParseNode, validators?: ICompileValidator[]): CompileExprInstruction {\r\n        const children = sourceNode.children;\r\n        const shaderFuncName = children[children.length - 2].value;\r\n        const scope = program.currentScope;\r\n\r\n        let compileArgs: IExprInstruction[] = null;\r\n        let retType: ITypeInstruction = null;\r\n        let args: (RegExp | ITypeInstruction)[] = null;\r\n\r\n        if (children.length > 4) {\r\n            compileArgs = [];\r\n            for (let i = children.length - 4; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    compileArgs.push(this.analyzeExpr(context, program, children[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        args = compileArgs ? compileArgs.map(asType) : null;\r\n\r\n        let func: IFunctionDeclInstruction = null;\r\n\r\n        if (validators) {\r\n            for (let validator of validators) {\r\n                args = compileArgs ? compileArgs.map(asType) : null;\r\n                retType = null;\r\n\r\n                args = validator.args || args;\r\n                retType = validator.ret || retType;\r\n\r\n                func = program.globalScope.findFunction(shaderFuncName, args);\r\n                if (func) {\r\n                    // skip function if validator is not suitable\r\n                    if (validator.ret && !types.equals(validator.ret, func.def.returnType))\r\n                    {\r\n                        // skip this function\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            func = program.globalScope.findFunction(shaderFuncName, args);\r\n        }\r\n\r\n\r\n        if (isNull(func)) {\r\n            context.error(sourceNode, EErrors.InvalidCompileNotFunction, { funcName: shaderFuncName });\r\n            return null;\r\n        }\r\n\r\n        if (retType) {\r\n            // show error if we found some variant of function but return type mismath\r\n            if (!types.equals(func.def.returnType, retType)) {\r\n                context.error(sourceNode, EErrors.InvalidCompileFunctionNotValid, {\r\n                    funcName: shaderFuncName,\r\n                    funcType: retType.toCode(),\r\n                    tooltip: `Return type mismatch: expected '${retType.toCode()}' a is a '${func.def.returnType.toCode()}' `\r\n                });\r\n                return null;\r\n            }\r\n        }\r\n\r\n        let type = VariableTypeInstruction.wrap(<IVariableTypeInstruction>func.def.returnType, scope);\r\n\r\n        return new CompileExprInstruction({ args: compileArgs, scope, type, operand: func, sourceNode });\r\n    }\r\n\r\n\r\n    // /**\r\n    //  * AST example:\r\n    //  *    ObjectExpr\r\n    //  *       + StateBlock \r\n    //  *         T_KW_SAMPLER_STATE = 'sampler_state'\r\n    //  */\r\n    // protected analyzeSamplerStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n    //     sourceNode = sourceNode.children[0];\r\n\r\n    //     let scope = program.currentScope;\r\n    //     let children = sourceNode.children;\r\n    //     let operator: SamplerOperator = \"sampler_state\";\r\n    //     let texture = null;\r\n    //     let params = <ISamplerStateInstruction[]>[];\r\n\r\n    //     for (let i = children.length - 2; i >= 1; i--) {\r\n    //         let param = this.analyzeSamplerState(context, program, children[i]);\r\n    //         if (!isNull(param)) {\r\n    //             params.push(param);\r\n    //         }\r\n    //     }\r\n\r\n    //     return new SamplerStateBlockInstruction({ sourceNode, scope, operator, params });\r\n    // }\r\n\r\n\r\n    // /**\r\n    //  * AST example:\r\n    //  *    State\r\n    //  *         T_PUNCTUATOR_59 = ';'\r\n    //  *         StateExpr\r\n    //  *              T_PUNCTUATOR_62 = '>'\r\n    //  *              T_NON_TYPE_ID = 'tex0'\r\n    //  *              T_PUNCTUATOR_60 = '<'\r\n    //  *         T_PUNCTUATOR_61 = '='\r\n    //  *         T_NON_TYPE_ID = 'Texture'\r\n    //  */\r\n    // protected analyzeSamplerState(context: Context, program: ProgramScope, sourceNode: IParseNode): SamplerStateInstruction {\r\n\r\n    //     const children = sourceNode.children;\r\n    //     const scope = program.currentScope;\r\n\r\n    //     if (children[children.length - 2].name === 'StateIndex') {\r\n    //         context.error(sourceNode, EErrors.UnsupportedStateIndex);\r\n    //         return null;\r\n    //     }\r\n\r\n    //     let stateExprNode = children[children.length - 3];\r\n    //     let subStateExprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n    //     let stateType = children[children.length - 1].value.toUpperCase();\r\n    //     let stateValue = '';\r\n\r\n    //     if (isNull(subStateExprNode.value)) {\r\n    //         context.error(subStateExprNode, EErrors.InvalidSamplerTexture);\r\n    //         return null;\r\n    //     }\r\n\r\n    //     switch (stateType) {\r\n    //         case 'TEXTURE':\r\n    //             if (stateExprNode.children.length !== 3 || subStateExprNode.value === '{') {\r\n    //                 context.error(subStateExprNode, EErrors.InvalidSamplerTexture);\r\n    //                 return null;\r\n    //             }\r\n\r\n    //             let texNameNode = stateExprNode.children[1];\r\n    //             let texName = texNameNode.value;\r\n    //             if (isNull(texName) || !scope.findVariable(texName)) {\r\n    //                 context.error(stateExprNode.children[1], EErrors.InvalidSamplerTexture);\r\n    //                 return null;\r\n    //             }\r\n\r\n    //             let texDecl = scope.findVariable(texName);\r\n    //             let texId = new IdInstruction({ scope, sourceNode: texNameNode, name: texName });\r\n    //             let tex = new IdExprInstruction({ scope, sourceNode: texNameNode, id: texId, decl: texDecl });\r\n\r\n    //             return new SamplerStateInstruction({ scope, sourceNode, name: stateType, value: tex });\r\n    //         case 'ADDRESSU': /* WRAP_S */\r\n    //         case 'ADDRESSV': /* WRAP_T */\r\n    //             stateValue = subStateExprNode.value.toUpperCase();\r\n    //             switch (stateValue) {\r\n    //                 case 'WRAP':\r\n    //                 case 'CLAMP':\r\n    //                 case 'MIRROR':\r\n    //                     break;\r\n    //                 default:\r\n    //                     // TODO: move to errors\r\n    //                     // console.warn('Webgl don`t support this wrapmode: ' + stateValue);\r\n    //                     return null;\r\n    //             }\r\n    //             break;\r\n\r\n    //         case 'MAGFILTER':\r\n    //         case 'MINFILTER':\r\n    //             stateValue = subStateExprNode.value.toUpperCase();\r\n    //             switch (stateValue) {\r\n    //                 case 'POINT':\r\n    //                     stateValue = 'NEAREST';\r\n    //                     break;\r\n    //                 case 'POINT_MIPMAP_POINT':\r\n    //                     stateValue = 'NEAREST_MIPMAP_NEAREST';\r\n    //                     break;\r\n    //                 case 'LINEAR_MIPMAP_POINT':\r\n    //                     stateValue = 'LINEAR_MIPMAP_NEAREST';\r\n    //                     break;\r\n    //                 case 'POINT_MIPMAP_LINEAR':\r\n    //                     stateValue = 'NEAREST_MIPMAP_LINEAR';\r\n    //                     break;\r\n\r\n    //                 case 'NEAREST':\r\n    //                 case 'LINEAR':\r\n    //                 case 'NEAREST_MIPMAP_NEAREST':\r\n    //                 case 'LINEAR_MIPMAP_NEAREST':\r\n    //                 case 'NEAREST_MIPMAP_LINEAR':\r\n    //                 case 'LINEAR_MIPMAP_LINEAR':\r\n    //                     break;\r\n    //                 default:\r\n    //                     // TODO: move to erros api\r\n    //                     // console.warn('Webgl don`t support this texture filter: ' + stateValue);\r\n    //                     return null;\r\n    //             }\r\n    //             break;\r\n\r\n    //         default:\r\n    //             // TODO: move to erros api\r\n    //             console.warn('Don`t support this texture param: ' + stateType);\r\n    //             return null;\r\n    //     }\r\n\r\n    //     return new SamplerStateInstruction({\r\n    //         sourceNode,\r\n    //         scope,\r\n    //         name: stateType,\r\n    //         value: new StringInstruction({ sourceNode: stateExprNode, scope, value: stateValue })\r\n    //     });\r\n    // }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_FLOAT = '2.'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_FLOAT = '1.'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_TYPE_ID = 'float4'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *       + PostfixPointExpr \r\n     */\r\n    protected analyzeComplexExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'PostfixPointExpr':\r\n            case 'T_NON_TYPE_ID':\r\n                return this.analyzeFunctionCallExpr(context, program, sourceNode);\r\n            case 'BaseType':\r\n            case 'T_TYPE_ID':\r\n                return this.analyzeConstructorCallExpr(context, program, sourceNode);\r\n            default:\r\n                return this.analyzeSimpleComplexExpr(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    protected analyzeCallee(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        return this.analyzeExpr(context, program, children[children.length - 1]);\r\n    }\r\n\r\n\r\n    protected createTracePseudoDeclaration(context: Context, program: ProgramScope, args: IExprInstruction[]): IFunctionDeclInstruction {\r\n        const scope = program.globalScope; // global scope (!)\r\n        const attrs = [new AttributeInstruction({ scope, name: \"extern\", args: null })];\r\n        const impl = null;\r\n        const returnType = VariableTypeInstruction.wrap(T_VOID, scope);\r\n        const id = new IdInstruction({ scope, name: \"trace\" });\r\n        const paramList = args.map((arg, i) => {\r\n            // todo: fully deduce base type \r\n            const type = VariableTypeInstruction.wrapAsConst(arg.type.baseType, scope);\r\n            const id = new IdInstruction({ scope, name: `p${i}` });\r\n            const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n            return new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n        });\r\n        const def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n        const traceFunc = new FunctionDeclInstruction({ scope, def, impl, attrs });\r\n        scope.addFunction(traceFunc);\r\n        return traceFunc;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_NON_TYPE_ID = 'a'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'foo'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PostfixPointExpr\r\n     *         T_NON_TYPE_ID = 'IncrementCounter'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *       + PostfixExpr \r\n     */\r\n    protected analyzeFunctionCallExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        let funcName: string = null;\r\n        let func: IFunctionDeclInstruction = null;\r\n        let callee: IExprInstruction = null;\r\n        let args: IExprInstruction[] = [];\r\n\r\n        switch (firstNodeName) {\r\n            // call as function\r\n            case 'T_NON_TYPE_ID':\r\n                {\r\n                    // TODO: validate intrinsics like 'InterlockedAdd', check that dest is UAV address\r\n                    funcName = children[children.length - 1].value;\r\n\r\n                    if (children.length > 3) {\r\n                        for (let i = children.length - 3; i > 0; i--) {\r\n                            if (children[i].value !== ',') {\r\n                                const arg = this.analyzeExpr(context, program, children[i]);\r\n                                args.push(arg);\r\n                            }\r\n                        }\r\n                    }            \r\n\r\n                    const noStrictTypeWereProvided = args.every(arg => arg?.type != asRelaxedType(arg));\r\n                    // don't relax all types because it's useless\r\n                    // like: (0, 0, 0) => (float|int, float|int)\r\n                    // relax only uint => int if not strict types were provided \r\n                    func = globalScope.findFunction(funcName, args.map(arg => arg?.type || null));\r\n                    // still not found?\r\n                    if (!func) {\r\n                        // last resort for cases like: \"sqrt(2)\"\r\n                        func = globalScope.findFunction(funcName, args.map(asRelaxedType));\r\n                    }\r\n\r\n                    // special case for debug \"void trace(...)\" function\r\n                    if (isNull(func) && funcName === 'trace') {\r\n                         func = this.createTracePseudoDeclaration(context, program, args);\r\n                    }\r\n                }\r\n                break;\r\n            // call as method\r\n            case 'PostfixPointExpr':\r\n                {\r\n                    callee = this.analyzeCallee(context, program, children[children.length - 1]);\r\n                    funcName = children[children.length - 1].children[0].value; // method name\r\n\r\n                    if (children.length > 3) {\r\n                        for (let i = children.length - 3; i > 0; i--) {\r\n                            if (children[i].value !== ',') {\r\n                                const arg = this.analyzeExpr(context, program, children[i]);\r\n                                args.push(arg);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    func = callee.type.getMethod(funcName, args.map(asRelaxedType));\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (isNull(func)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotFunction, { funcName, args: args.map(arg => types.signature(arg?.type)) });\r\n            return null;\r\n        }\r\n\r\n\r\n        if (!isDef(func)) {\r\n            context.error(sourceNode, EErrors.CannotChooseFunction, { funcName });\r\n            return null;\r\n        }\r\n\r\n        if (args.includes(null)) {\r\n            return null;\r\n        }\r\n\r\n        if (func.def.params.filter(p => !p.initExpr).length > args.length) {\r\n            context.error(sourceNode, EErrors.UnsupportedExpr, { funcName });\r\n            return null;\r\n        }\r\n\r\n        args.forEach((x, i) => {\r\n            const param = func.def.params[i];\r\n            const arg = args[i];\r\n            if (!types.equals(param.type, arg.type)) {\r\n                context.warn(arg.sourceNode, EWarnings.ImplicitTypeConversion, { info: `${arg.type.toCode()} => ${param.type.toCode()}` });\r\n            }\r\n        });\r\n\r\n        if (func.instructionType !== EInstructionTypes.k_FunctionDecl &&\r\n            func.instructionType !== EInstructionTypes.k_SystemFunctionDecl) {\r\n            console.error(\"@undefined_behavior\");\r\n            return null;\r\n        }\r\n\r\n\r\n\r\n        const params = func.def.params;\r\n\r\n        for (let i = 0; i < args.length; i++) {\r\n            if (isNull(args[i])) {\r\n                continue;\r\n            }\r\n            if (params[i].type.usages.includes('out')) {\r\n                const decl = expression.unwind(args[i]);\r\n                if (isNull(decl)) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidExprIsNotLValue);\r\n                }\r\n                if (!args[i].type.writable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForWriting);\r\n                }\r\n            } else if (params[i].type.usages.includes('inout')) {\r\n                const decl = expression.unwind(args[i]);\r\n                if (isNull(decl)) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidExprIsNotLValue);\r\n                }\r\n                if (!args[i].type.writable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForWriting);\r\n                }\r\n\r\n                if (!args[i].type.readable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForReading);\r\n                }\r\n            } else {\r\n                if (!args[i].type.readable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForReading);\r\n                }\r\n            }\r\n        }\r\n\r\n        {\r\n            const type = VariableTypeInstruction.wrap(func.def.returnType, scope); // TODO: remove wrap?\r\n            return new FunctionCallInstruction({ scope, type, decl: func, args, sourceNode, callee });\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *       + BaseType \r\n     */\r\n    protected analyzeConstructorCallExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IConstructorCallInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const ctorType = this.analyzeType(context, program, children[children.length - 1]);\r\n\r\n        if (isNull(ctorType)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotType);\r\n            return null;\r\n        }\r\n\r\n        let args: IExprInstruction[] = null;\r\n        if (children.length > 3) {\r\n            let argumentExpr: IExprInstruction = null;\r\n\r\n            args = [];\r\n\r\n            for (let i = children.length - 3; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    argumentExpr = this.analyzeExpr(context, program, children[i]);\r\n                    args.push(argumentExpr);\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: add correct implementation! \r\n        const exprType = findConstructor(ctorType, args);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotConstructor, { typeName: String(ctorType) });\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(args)) {\r\n            for (let i = 0; i < args.length; i++) {\r\n                if (!args[i] || !args[i].type.readable) {\r\n                    context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n                }\r\n            }\r\n        }\r\n\r\n        return new ConstructorCallInstruction({ scope, sourceNode, ctor: exprType, args });\r\n    }\r\n\r\n\r\n    // TODO: add comment!\r\n    protected analyzeSimpleComplexExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let expr = this.analyzeExpr(context, program, children[1]);\r\n        if (isNull(expr)) {\r\n            return null\r\n        }\r\n\r\n        return new ComplexExprInstruction({ scope, sourceNode, expr });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_NON_TYPE_ID = 'val'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     *    PostfixExpr\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     *         T_NON_TYPE_ID = 'some'\r\n     *    PostfixExpr\r\n     *         T_OP_INC = '++'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    protected analyzePostfixExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const symbol = children[children.length - 2].value;\r\n\r\n        switch (symbol) {\r\n            case '[':\r\n                return this.analyzePostfixIndex(context, program, sourceNode);\r\n            case '.':\r\n                return this.analyzePostfixPoint(context, program, sourceNode);\r\n            case '++':\r\n            case '--':\r\n                return this.analyzePostfixArithmetic(context, program, sourceNode);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    protected analyzePostfixIndex(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const postfixExpr = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        if (isNull(postfixExpr)) {\r\n            // TODO: emit error?\r\n            return null;\r\n        }\r\n\r\n        const postfixExprType = <IVariableTypeInstruction>postfixExpr.type;\r\n\r\n        if (!postfixExprType.isArray()) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotArray, { typeName: String(postfixExprType) });\r\n            return null;\r\n        }\r\n\r\n        const indexExpr = this.analyzeExpr(context, program, children[children.length - 3]);\r\n        const indexExprType = indexExpr.type;\r\n\r\n        if (!(types.equals(indexExprType, T_INT) || types.equals(indexExprType, T_UINT))) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotIntIndex, { typeName: String(indexExprType) });\r\n            return null;\r\n        }\r\n\r\n        return new PostfixIndexInstruction({ scope, sourceNode, element: postfixExpr, index: indexExpr });\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param elementType Type of the element. (**element.postfix**)\r\n     * @param fieldName \r\n     */\r\n    static createFieldDecl(elementType: IVariableTypeInstruction, fieldName: string): IVariableDeclInstruction {\r\n        if (!elementType.getField(fieldName)) {\r\n            return null;\r\n        }\r\n\r\n        const decl =\r\n            // FIXME: remove 'logical OR' operation, always use subType\r\n            (elementType.subType || elementType).getField(fieldName); // arrayIndex\r\n\r\n        const { type } = decl;\r\n\r\n        // in case of typical postfix exp. like \"element.postfix\":\r\n        //      elementType => type derived from the parameter or variable declaration or derived from another expr\r\n        //      elementType.subType => original complex (structure) type\r\n        // in case of something else, like ccall with postfix \"float2(1.0, 2.0).yx\":\r\n        //      elementType => original system type\r\n\r\n        const fieldType = new VariableTypeInstruction({ \r\n            scope: type.scope, \r\n            sourceNode: type.sourceNode, \r\n            type, \r\n            readable: elementType.readable, \r\n            writable: elementType.writable, \r\n            /*aligment,*/\r\n            padding: type.padding \r\n        });\r\n\r\n\r\n        const fieldId = new IdInstruction({ scope: decl.scope, name: decl.id.name, sourceNode: decl.id.sourceNode });\r\n\r\n        const field = new VariableDeclInstruction({ \r\n            semantic: decl.semantic,\r\n            scope: decl.scope, \r\n            type: fieldType, \r\n            sourceNode: decl.sourceNode, \r\n            id: fieldId,\r\n            usageFlags: decl.usageFlags\r\n        });\r\n\r\n        \r\n        return Instruction.$withParent(field, elementType);\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param elementType Type of the element. (**element.postfix**)\r\n     */\r\n    protected analyzePostfixPointField(context: Context, program: ProgramScope, sourceNode: IParseNode, elementType: IVariableTypeInstruction): IIdExprInstruction {\r\n        if (isNull(elementType)) {\r\n            return null;\r\n        }\r\n\r\n        const scope = program.currentScope;\r\n        const name = sourceNode.value;                             // fiedl name\r\n        const decl = Analyzer.createFieldDecl(elementType, name);       // field decl\r\n        // const decl = elementType.getField(name);\r\n        \r\n        if (isNull(decl)) {\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        return new IdExprInstruction({ scope, sourceNode, id, decl });;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_NON_TYPE_ID = 'val'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    /** \r\n     * Expressions like: \r\n     *      **(element.postfix)** \r\n     */\r\n    protected analyzePostfixPoint(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const element = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        if (isNull(element)) {\r\n            // TODO: emit error?\r\n            return null;\r\n        }\r\n\r\n        const postfix = this.analyzePostfixPointField(context, program, children[children.length - 3], element.type);\r\n\r\n        if (isNull(postfix)) {\r\n            const fieldName = children[children.length - 3].value;\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotField, { typeName: String(element.type), fieldName });\r\n            return null;\r\n        }\r\n\r\n        return new PostfixPointInstruction({ sourceNode, scope, element, postfix });\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_OP_INC = '++'\r\n     *         T_NON_TYPE_ID = 'b'\r\n     */\r\n    protected analyzePostfixArithmetic(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <PostfixOperator>children[0].value;\r\n\r\n        const postfixExpr = this.analyzeExpr(context, program, children[1]);\r\n        const postfixExprType = <IVariableTypeInstruction>postfixExpr.type;\r\n\r\n        const exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, postfixExprType);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixArithmetic, {\r\n                operator: operator,\r\n                typeName: String(postfixExprType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        return new PostfixArithmeticInstruction({ scope, sourceNode, operator, expr: postfixExpr });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    UnaryExpr\r\n     *         T_NON_TYPE_ID = 'x'\r\n     *         T_PUNCTUATOR_33 = '!'\r\n     */\r\n    protected analyzeUnaryExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const operator = <IUnaryOperator>children[1].value;\r\n        const scope = program.currentScope;\r\n\r\n        let expr = this.analyzeExpr(context, program, children[0]);\r\n        let exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, expr.type);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidUnaryOperation, {\r\n                operator: operator,\r\n                tyename: String(expr.type)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        let unaryExpr: IExprInstruction = null;\r\n\r\n        // shortcut for replacment of unary expressions with literals\r\n        if (operator === '-' || operator === '+') {\r\n            if (instruction.isLiteral(expr)) {\r\n                switch (expr.instructionType) {\r\n                    case EInstructionTypes.k_IntExpr:\r\n                        {\r\n                            let lit = <IntInstruction>expr;\r\n                            let { base, signed, heximal, exp } = lit;\r\n                            signed = operator === '-' || lit.signed;\r\n                            // TODO: emit warning in case of '-100u' expr.\r\n                            base = operator === '-' ? -base : base;\r\n                            unaryExpr = new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n                        }\r\n                        break;\r\n                    case EInstructionTypes.k_FloatExpr:\r\n                        unaryExpr = new FloatInstruction({ scope, sourceNode, value: Number(`${operator}${(<ILiteralInstruction<number>>expr).value}`) });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!unaryExpr) {\r\n            unaryExpr = new UnaryExprInstruction({ scope, sourceNode, expr, operator });\r\n        }\r\n\r\n        return unaryExpr;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    CastExpr\r\n     *         T_NON_TYPE_ID = 'y'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ConstType \r\n     *         T_PUNCTUATOR_40 = '('\r\n     */\r\n    protected analyzeCastExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const type = this.analyzeConstTypeDim(context, program, children[2]);\r\n\r\n        if (!SystemScope.isBase(type)) {\r\n            context.error(sourceNode, EErrors.InvalidCastTypeNotBase, { typeName: String(type) });\r\n        }\r\n\r\n        const sourceExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(sourceExpr)) {\r\n            return null;\r\n        }\r\n\r\n        if (!(<IVariableTypeInstruction>sourceExpr.type).readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n\r\n        return new CastExprInstruction({ scope, sourceNode, sourceExpr, type });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ConditionalExpr\r\n     *         T_KW_FALSE = 'false'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     *         T_KW_TRUE = 'true'\r\n     *         T_PUNCTUATOR_63 = '?'\r\n     *         T_NON_TYPE_ID = 'isOk'\r\n     */\r\n    protected analyzeConditionalExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n\r\n        const conditionExpr = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const leftExpr = this.analyzeExpr(context, program, children[children.length - 3]);\r\n        const rightExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(conditionExpr)) {\r\n            context.error(children[children.length - 1], EErrors.InvalidConditionType, { typeName: '[unknown]' });\r\n            return null;\r\n        }\r\n\r\n        if (isNull(leftExpr)) {\r\n            context.error(children[children.length - 3], EErrors.InvalidConditionType, { typeName: '[unknown]' });\r\n            return null;\r\n        }\r\n\r\n        if (isNull(rightExpr)) {\r\n            context.error(children[0], EErrors.InvalidConditionType, { typeName: '[unknown]' });\r\n            return null;\r\n        }\r\n\r\n        const conditionType = <IVariableTypeInstruction>conditionExpr.type;\r\n        const leftExprType = <IVariableTypeInstruction>leftExpr.type;\r\n        const rightExprType = <IVariableTypeInstruction>rightExpr.type;\r\n\r\n        const boolType = T_BOOL;\r\n\r\n        if (!types.equals(conditionType, boolType)) {\r\n            context.error(conditionExpr.sourceNode, EErrors.InvalidConditionType, { typeName: String(conditionType) });\r\n            return null;\r\n        }\r\n\r\n        if (!types.equals(leftExprType, rightExprType)) {\r\n            context.error(leftExprType.sourceNode, EErrors.InvalidConditonValueTypes, {\r\n                leftTypeName: String(leftExprType),\r\n                rightTypeName: String(rightExprType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!conditionType.readable) {\r\n            context.error(conditionExpr.sourceNode, EErrors.InvalidTypeForReading, { tooltip: `${conditionExpr.toCode()}` });\r\n        }\r\n\r\n        if (!leftExprType.readable) {\r\n            context.error(leftExpr.sourceNode, EErrors.InvalidTypeForReading, { tooltip: `${leftExpr.toCode()}` });\r\n        }\r\n\r\n        if (!rightExprType.readable) {\r\n            context.error(rightExpr.sourceNode, EErrors.InvalidTypeForReading, { tooltip: `${rightExpr.toCode()}` });\r\n        }\r\n\r\n        return new ConditionalExprInstruction({ scope, sourceNode, cond: conditionExpr, left: leftExpr, right: rightExpr });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AddExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_43 = '+'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeArithmeticExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope\r\n        const operator = <IArithmeticOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (!left || !right) {\r\n            context.error(sourceNode, EErrors.InvalidArithmeticOperation, {\r\n                operator: operator,\r\n                leftTypeName: '[unknown]',\r\n                rightTypeName: '[unknown]'\r\n            });\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType,\r\n            rightType, left.sourceNode, right.sourceNode, sourceNode);\r\n\r\n        if (isNull(type)) {\r\n            context.error(sourceNode, EErrors.InvalidArithmeticOperation, {\r\n                operator: operator,\r\n                leftTypeName: String(leftType),\r\n                rightTypeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        return new ArithmeticExprInstruction({ scope, sourceNode, left, right, operator, type });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    RelationalExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_60 = '<'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeRelationExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <RelationOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        const leftType = left && left.type;\r\n        const rightType = right && right.type;\r\n\r\n        const exprType = Analyzer.checkTwoOperandExprTypes(context, operator,\r\n            leftType, rightType,\r\n            left && left.sourceNode, right && right.sourceNode,\r\n            sourceNode);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidRelationalOperation, {\r\n                operator: operator,\r\n                leftTypeName: leftType ? types.signature(leftType) : '[unknown]',\r\n                rightTypeName: rightType ? types.signature(rightType) : '[unknown]'\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!left || !right) {\r\n            return null;\r\n        }\r\n\r\n        return new RelationalExprInstruction({ sourceNode, scope, left, right, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    LogicalOrExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_OP_OR = '||'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeLogicalExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <ILogicalOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const boolType = T_BOOL;\r\n\r\n        if (!types.equals(leftType, boolType)) {\r\n            context.error(leftType.sourceNode, EErrors.InvalidLogicOperation, {\r\n                operator: operator,\r\n                typeName: String(leftType)\r\n            });\r\n            return null;\r\n        }\r\n        if (!types.equals(rightType, boolType)) {\r\n            context.error(rightType.sourceNode, EErrors.InvalidLogicOperation, {\r\n                operator: operator,\r\n                typeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!leftType.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n\r\n        if (!rightType.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n\r\n        return new LogicalExprInstruction({ scope, sourceNode, left, right, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    InclusiveOrExpr\r\n     *       + ComplexExpr \r\n     *         T_PUNCTUATOR_124 = '|'\r\n     *       + ComplexExpr \r\n     */\r\n    protected analyzeBitwiseExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <IBitwiseOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (!left || !right) {\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const type = Analyzer.checkTwoOperandExprTypes(context, operator,\r\n            leftType, rightType,\r\n            left.sourceNode, right.sourceNode,\r\n            sourceNode);\r\n\r\n        if (isNull(type)) {\r\n            context.error(sourceNode, EErrors.InvalidBitwiseOperation, {\r\n                operator: operator,\r\n                leftTypeName: String(leftType),\r\n                rightTypeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        return new BitwiseExprInstruction({ scope, sourceNode, left, right, type, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AssignmentExpr\r\n     *         T_UINT = '10'\r\n     *         T_OP_AE = '+='\r\n     *         T_NON_TYPE_ID = 'x'\r\n     */\r\n    protected analyzeAssignmentExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <AssigmentOperator>children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n\r\n        if (!expression.unwind(left)) {\r\n            // Invalid left-hand side in assignment\r\n            context.error(sourceNode, EErrors.InvalidLeftHandSideInAssignment, {\r\n                operator: operator\r\n            });\r\n        }\r\n\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(left) || isNull(right)) {\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        let exprType = <ITypeInstruction>null;\r\n\r\n        if (operator !== '=') {\r\n            exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode, sourceNode);\r\n            if (isNull(exprType)) {\r\n                context.error(sourceNode, EErrors.InvalidArithmeticAssigmentOperation, {\r\n                    operator: operator,\r\n                    leftTypeName: types.signature(leftType),\r\n                    rightTypeName: types.signature(rightType)\r\n                });\r\n            }\r\n        } else {\r\n            exprType = rightType;\r\n        }\r\n\r\n        // FIXME: show corrent source nodes for left and right expression.\r\n        exprType = Analyzer.checkTwoOperandExprTypes(context, '=', leftType, exprType, left.sourceNode, null, sourceNode);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidAssigmentOperation, {\r\n                leftTypeName: types.signature(leftType),\r\n                rightTypeName: types.signature(rightType)\r\n            });\r\n        }\r\n\r\n        return new AssignmentExprInstruction({ scope, sourceNode, left, right, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    T_NON_TYPE_ID = 'name'\r\n     */\r\n    protected analyzeIdExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const name = sourceNode.value;\r\n\r\n\r\n        // beginning-of-hack\r\n        // hack to support pseudo-dynamic expression\r\n        //\r\n\r\n        const exprSubst = context.expressions[name];\r\n        if (exprSubst)\r\n        {\r\n            return exprSubst(context, program, sourceNode);\r\n        }\r\n\r\n        // end-of-hack\r\n\r\n        // explicit support of built in HLSL 'NULL' define\r\n        if (name === 'NULL') {\r\n            // const { base, signed, heximal, exp } = parseUintLiteral('0');\r\n            // return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal }); \r\n            return new NullInstruction({ scope, sourceNode });\r\n        }\r\n\r\n        const decl = scope.findVariable(name);\r\n\r\n        if (isNull(decl)) {\r\n            context.error(sourceNode, EErrors.UnknownVarName, { varName: name });\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        return new IdExprInstruction({ scope, sourceNode, id, decl });\r\n    }\r\n\r\n\r\n    protected analyzeSimpleExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const name = sourceNode.name;\r\n        const value = sourceNode.value;\r\n        const scope = program.currentScope;\r\n\r\n        switch (name) {\r\n            case 'T_UINT':\r\n                {\r\n                    const { base, signed, heximal, exp } = parseUintLiteral(value);\r\n\r\n                    return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n                }\r\n            case 'T_FLOAT':\r\n                return new FloatInstruction({ scope, sourceNode, value: Number(value) });\r\n            case 'T_STRING':\r\n                return new StringInstruction({ scope, sourceNode, value });\r\n            case 'T_KW_TRUE':\r\n                return new BoolInstruction({ scope, sourceNode, value: true });\r\n            case 'T_KW_FALSE':\r\n                return new BoolInstruction({ scope, sourceNode, value: false });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ConstType\r\n     *       + Type \r\n     */\r\n    protected analyzeConstTypeDim(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        if (children.length > 1) {\r\n            context.error(sourceNode, EErrors.InvalidCastTypeUsage);\r\n            return null;\r\n        }\r\n\r\n        const type = <IVariableTypeInstruction>(this.analyzeType(context, program, children[0]));\r\n\r\n        return type;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeVarStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n\r\n        let usageType = this.analyzeUsageStructDecl(context, program, children[children.length - 1]);\r\n        let vars: IVariableDeclInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'Variable') {\r\n                vars = vars.concat(this.analyzeVariable(context, program, children[i], usageType));\r\n            }\r\n        }\r\n\r\n        return vars;\r\n    }\r\n\r\n\r\n    protected analyzeUsageStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let usages: IVariableUsage[] = [];\r\n        let type: ITypeInstruction = null;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'StructDecl') {\r\n                type = this.analyzeStructDecl(context, program, children[i]);\r\n                const typeDecl = new TypeDeclInstruction({ scope, sourceNode: children[i], type });\r\n                addTypeDecl(context, scope, typeDecl);\r\n            } else if (children[i].name === 'Usage') {\r\n                const usage = this.analyzeUsage(children[i]);\r\n                usages.push(usage);\r\n            }\r\n        }\r\n\r\n        assert(!isNull(type));\r\n        return new VariableTypeInstruction({ scope, sourceNode, usages, type });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StructDecl\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *       + VariableDecl \r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_NON_TYPE_ID = 'S'\r\n     *         T_KW_STRUCT = 'struct'\r\n     *    Struct\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_KW_STRUCT = 'struct'\r\n     */\r\n    protected analyzeStruct(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let name: string = null;\r\n        if (children[children.length - 2].name === 'T_NON_TYPE_ID') {\r\n            name = children[children.length - 2].value;\r\n        }\r\n\r\n        let fields: IVariableDeclInstruction[] = [];\r\n\r\n        program.push(EScopeType.k_Struct);\r\n\r\n        for (let i = children.length - 4; i >= 1; i--) {\r\n            if (children[i].name === 'VariableDecl') {\r\n                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n            }\r\n        }\r\n\r\n        program.pop();\r\n\r\n        let aligment = 1;\r\n\r\n        if (context.cbuffer) {\r\n            aligment = T_FLOAT4.size;\r\n        }\r\n\r\n        return new ComplexTypeInstruction({ scope, sourceNode, fields, name, aligment });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *       + StmtBlock \r\n     *       + FunctionDef \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + FunctionDef \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *       + StmtBlock \r\n     *       + Annotation \r\n     *       + FunctionDef \r\n     */\r\n    protected analyzeFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IFunctionDeclInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n        const lastNodeValue = children[0].value;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let impl: IStmtBlockInstruction = null;\r\n\r\n        program.push(EScopeType.k_Default);\r\n\r\n        const attrs = [];\r\n        while (children[children.length - 1 - attrs.length].name === 'Attribute') {\r\n            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));\r\n        }\r\n\r\n        const def = this.analyzeFunctionDef(context, program, children[children.length - 1 - attrs.length]);\r\n\r\n        if (isNull(def)) {\r\n            // TODO: emit proper error\r\n            context.error(sourceNode, EErrors.UnknownInstruction, {});\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        // looking for function with exact type signatures (that's why we cant use 'asRelaxedType' predicate here!)\r\n        let func = globalScope.findFunction(def.name, def.params.map(asType));\r\n\r\n        // undedined means that there are more than one instance \r\n        if (!isDef(func)) {\r\n            context.error(sourceNode, EErrors.CannotChooseFunction, { funcName: def.name });\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        // todo: handle the case when definition without implementation is occured later than the found function with implementation\r\n        if (!isNull(func) && func.impl) {\r\n            context.error(sourceNode, EErrors.FunctionRedefinition, { funcName: def.name });\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(func)) {\r\n            if (!types.equals(func.def.returnType, def.returnType)) {\r\n                context.error(sourceNode, EErrors.InvalidFuncDefenitionReturnType, { funcName: def.name });\r\n                program.pop();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        assert(context.funcDef === null);\r\n\r\n        // TODO: rewrite context ?\r\n        context.funcDef = def;\r\n\r\n        if (children.length === 3) {\r\n            annotation = this.analyzeAnnotation(context, program, children[1]);\r\n        }\r\n\r\n        if (lastNodeValue !== ';') {\r\n            // TODO: do to increase scope depth inside stmt block!!\r\n            impl = this.analyzeStmtBlock(context, program, children[0]);\r\n        }\r\n\r\n        program.pop();\r\n\r\n        let hasVoidType = types.equals(def.returnType, T_VOID);\r\n\r\n        // validate unreachable code.\r\n        if (!isNull(impl)) {\r\n            let stmtList = impl.stmtList;\r\n\r\n            // stmtList = stmtList.slice().reverse();\r\n            for (let i = stmtList.length - 1; i >= 0; --i) {\r\n                if (stmtList[i].instructionType == EInstructionTypes.k_ReturnStmt) {\r\n                    if (i != stmtList.length - 1) {\r\n                        context.error(stmtList[i + 1].sourceNode, EErrors.UnreachableCode);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        assert(scope == globalScope);\r\n        func = new FunctionDeclInstruction({ sourceNode, scope, def, impl, annotation, attrs: attrs });\r\n\r\n        // NOTE: possible implicit replacement of function \r\n        //       without implementaion inside addFunction() call.\r\n        if (!globalScope.addFunction(func)) {\r\n            context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: def.name });\r\n        }\r\n\r\n        if (!hasVoidType && !context.haveCurrentFunctionReturnOccur && !isNull(impl)) {\r\n            context.error(sourceNode, EErrors.InvalidFunctionReturnStmtNotFound, { funcName: def.name });\r\n        }\r\n\r\n        return func;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    FunctionDef\r\n     *       + ParamList \r\n     *         T_NON_TYPE_ID = 'bar'\r\n     *       + UsageType \r\n     */\r\n    protected analyzeFunctionDef(context: Context, program: ProgramScope, sourceNode: IParseNode): FunctionDefInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const nameNode = children[children.length - 2];\r\n        const name = nameNode.value;\r\n\r\n        const retTypeNode = children[children.length - 1];\r\n        let returnType = this.analyzeUsageType(context, program, retTypeNode);\r\n\r\n        // TODO: is it really needed?\r\n        if (!returnType) {\r\n            context.error(retTypeNode, EErrors.InvalidFunctionReturnType, { funcName: name });\r\n            return null;\r\n        }\r\n\r\n        let id = new IdInstruction({ scope, name, sourceNode: nameNode });\r\n\r\n        let semantic: string = null;\r\n        if (children.length === 4) {\r\n            semantic = this.analyzeSemantic(children[0]);\r\n        }\r\n\r\n        let paramList = this.analyzeParamList(context, program, children[children.length - 3]);\r\n        return new FunctionDefInstruction({ scope, sourceNode, returnType, id, paramList, semantic });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParamList\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ParameterDecl \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + ParameterDecl \r\n     *         T_PUNCTUATOR_40 = '('\r\n     */\r\n    protected analyzeParamList(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n\r\n        const children = sourceNode.children;\r\n        let paramList: IVariableDeclInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'ParameterDecl') {\r\n                let param = this.analyzeParameterDecl(context, program, children[i]);\r\n                paramList.push(param);\r\n            }\r\n        }\r\n\r\n        return paramList;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParameterDecl\r\n     *       + Variable \r\n     *       + ParamUsageType \r\n     */\r\n    protected analyzeParameterDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        const type = this.analyzeParamUsageType(context, program, children[1]);\r\n\r\n        if (isNull(type)) {\r\n            return null;\r\n        }\r\n\r\n        const param = this.analyzeVariable(context, program, children[0], type);\r\n\r\n        return param;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParamUsageType\r\n     *       + Type \r\n     *       + ParamUsage \r\n     */\r\n    protected analyzeParamUsageType(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let usages: IVariableUsage[] = [];\r\n        let type: ITypeInstruction = null;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'Type') {\r\n                type = this.analyzeType(context, program, children[i]);\r\n                if (isNull(type)) {\r\n                    return null;\r\n                }\r\n            }\r\n            else if (children[i].name === 'ParamUsage') {\r\n                usages.push(this.analyzeUsage(children[i]));\r\n            }\r\n        }\r\n\r\n        return new VariableTypeInstruction({ scope, sourceNode, type, usages });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    StmtBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + Stmt \r\n     *       + Stmt \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeStmtBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtBlockInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (!children) {\r\n            return null;\r\n        }\r\n\r\n        let stmtList: IStmtInstruction[] = [];\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            let stmt = this.analyzeStmt(context, program, children[i]);\r\n            if (!isNull(stmt)) {\r\n                stmtList.push(stmt);\r\n            }\r\n        }\r\n\r\n        return new StmtBlockInstruction({ sourceNode, scope, stmtList });\r\n    }\r\n\r\n\r\n    protected analyzeStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        let nonAttrNode = children.length;\r\n        let nonAttrNodeName: string;\r\n\r\n        do {\r\n            nonAttrNodeName = children[--nonAttrNode].name;\r\n        } while (nonAttrNodeName === 'Attribute');\r\n\r\n        switch (nonAttrNodeName) {\r\n            case 'SimpleStmt':\r\n                return this.analyzeSimpleStmt(context, program, children[0]);\r\n            case 'UseDecl':\r\n                this.analyzeUseDecl(context, program, children[0]);\r\n                return null;\r\n            case 'T_KW_WHILE':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n            case 'T_KW_FOR':\r\n                return this.analyzeForStmt(context, program, sourceNode);\r\n            case 'T_KW_IF':\r\n                return this.analyzeIfStmt(context, program, sourceNode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeSimpleStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const firstNodeName: string = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'T_KW_RETURN':\r\n                return this.analyzeReturnStmt(context, program, sourceNode);\r\n\r\n            case 'T_KW_DO':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n\r\n            case 'StmtBlock':\r\n                {\r\n                    program.push(EScopeType.k_Default);\r\n                    let stmtBlock = this.analyzeStmtBlock(context, program, children[0]);\r\n                    program.pop();\r\n                    return stmtBlock;\r\n                }\r\n            case 'T_KW_DISCARD':\r\n            case 'T_KW_BREAK':\r\n            case 'T_KW_CONTINUE':\r\n                return this.analyzeBreakStmt(context, program, sourceNode);\r\n\r\n            case 'TypeDecl':\r\n            case 'VariableDecl':\r\n            case 'VarStructDecl':\r\n                return this.analyzeDeclStmt(context, program, children[0]);\r\n\r\n            default:\r\n                if (children.length === 2) {\r\n                    return this.analyzeExprStmt(context, program, sourceNode);\r\n                }\r\n\r\n                return new SemicolonStmtInstruction({ sourceNode, scope });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_NON_TYPE_ID = 'y'\r\n     *         T_KW_RETURN = 'return'\r\n     */\r\n    protected analyzeReturnStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        assert(context.func);\r\n\r\n        const funcReturnType = context.funcDef.returnType;\r\n        context.haveCurrentFunctionReturnOccur = true;\r\n\r\n        if (children.length === 2) {\r\n            tryResolveProxyType(funcReturnType, T_VOID);\r\n        }\r\n\r\n        if (types.equals(funcReturnType, T_VOID) && children.length === 3) {\r\n            context.error(sourceNode, EErrors.InvalidReturnStmtVoid);\r\n            return null;\r\n        }\r\n        else if (!types.equals(funcReturnType, T_VOID) && children.length === 2) {\r\n            context.error(sourceNode, EErrors.InvalidReturnStmtEmpty);\r\n            return null;\r\n        }\r\n\r\n        let expr: IExprInstruction = null;\r\n        if (children.length === 3) {\r\n            expr = this.analyzeExpr(context, program, children[1]);\r\n\r\n            if (isNull(expr)) {\r\n                context.error(sourceNode, EErrors.InvalidReturnStmtTypesNotEqual);\r\n                return null;\r\n            }\r\n\r\n            tryResolveProxyType(funcReturnType, expr.type); // auto foo() { return typedExpr; }\r\n            tryResolveProxyType(expr.type, funcReturnType); // typedFunc foo() { return auto; }\r\n            \r\n            if (!types.equals(expr.type, funcReturnType)) {\r\n                context.error(sourceNode, EErrors.InvalidReturnStmtTypesNotEqual);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return new ReturnStmtInstruction({ sourceNode, scope, expr });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_KW_BREAK = 'break'\r\n     */\r\n    protected analyzeBreakStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const operator: BreakOperator = <BreakOperator>children[1].value;\r\n\r\n        if (operator === 'discard' && !isNull(context.funcDef)) {\r\n            // context.currentFunction.vertex = (false);\r\n        }\r\n\r\n        return new BreakStmtInstruction({ sourceNode, scope, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeDeclStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const nodeName = sourceNode.name;\r\n\r\n        let declList: IDeclInstruction[] = [];\r\n\r\n        switch (nodeName) {\r\n            case 'TypeDecl':\r\n                declList.push(this.analyzeTypeDecl(context, program, sourceNode));\r\n                break;\r\n            case 'VariableDecl':\r\n                declList = declList.concat(this.analyzeVariableDecl(context, program, sourceNode));\r\n                break;\r\n            case 'VarStructDecl':\r\n                declList = declList.concat(this.analyzeVarStructDecl(context, program, sourceNode));\r\n                break;\r\n        }\r\n\r\n        return new DeclStmtInstruction({ sourceNode, scope, declList });\r\n    }\r\n\r\n\r\n    protected analyzeExprStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const expr = this.analyzeExpr(context, program, children[1]);\r\n        return new ExprStmtInstruction({ sourceNode, scope, expr });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Stmt\r\n     *       + Stmt \r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_WHILE = 'while'\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_WHILE = 'while'\r\n     *       + Stmt \r\n     *         T_KW_DO = 'do'\r\n     */\r\n    protected analyzeWhileStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const isDoWhile = (children[children.length - 1].value === 'do');\r\n        const isNonIfStmt = (sourceNode.name === 'NonIfStmt') ? true : false;\r\n        const boolType = T_BOOL;\r\n\r\n\r\n        let cond: IExprInstruction = null;\r\n        let conditionType: IVariableTypeInstruction = null;\r\n        let body: IStmtInstruction = null;\r\n        let operator: IDoWhileOperator = \"do\";\r\n\r\n        if (isDoWhile) {\r\n            operator = \"do\";\r\n            cond = this.analyzeExpr(context, program, children[2]);\r\n            conditionType = <IVariableTypeInstruction>cond.type;\r\n\r\n            if (!types.equals(conditionType, boolType)) {\r\n                context.error(sourceNode, EErrors.InvalidDoWhileCondition, { typeName: String(conditionType) });\r\n                return null;\r\n            }\r\n\r\n            body = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            operator = \"while\";\r\n            cond = this.analyzeExpr(context, program, children[2]);\r\n            conditionType = <IVariableTypeInstruction>cond.type;\r\n\r\n            if (!types.equals(conditionType, boolType)) {\r\n                context.error(sourceNode, EErrors.InvalidWhileCondition, { typeName: String(conditionType) });\r\n                return null;\r\n            }\r\n\r\n            if (isNonIfStmt) {\r\n                body = this.analyzeNonIfStmt(context, program, children[0]);\r\n            }\r\n            else {\r\n                body = this.analyzeStmt(context, program, children[0]);\r\n            }\r\n        }\r\n\r\n        return new WhileStmtInstruction({ sourceNode, scope, cond, body, operator });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Attribute\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '3'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_UINT = '2'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'loop'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     */\r\n    protected analyzeAttribute(context: Context, program: ProgramScope, sourceNode: IParseNode): IAttributeInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const name = children[children.length - 2].value;\r\n\r\n        let args: ILiteralInstruction<number | boolean>[] = null;\r\n\r\n        if (children.length > 3) {\r\n            let argumentExpr: ILiteralInstruction<boolean | number> = null;\r\n\r\n            args = [];\r\n            for (let i = children.length - 4; i > 1; i--) {\r\n                if (children[i].value !== ',') {\r\n                    argumentExpr = <ILiteralInstruction<number | boolean>>this.analyzeSimpleExpr(context, program, children[i]);\r\n\r\n                    // TODO: emit diagnostics error\r\n                    assert(\r\n                        argumentExpr.instructionType === EInstructionTypes.k_BoolExpr ||\r\n                        argumentExpr.instructionType === EInstructionTypes.k_FloatExpr ||\r\n                        argumentExpr.instructionType === EInstructionTypes.k_IntExpr);\r\n\r\n                    args.push(argumentExpr);\r\n                }\r\n            }\r\n        }\r\n\r\n        return new AttributeInstruction({ scope, sourceNode, name, args });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Stmt\r\n     *       + Stmt \r\n     *         T_KW_ELSE = 'else'\r\n     *       + NonIfStmt \r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_IF = 'if'\r\n     *       + Attribute \r\n     *       + Attribute \r\n     */\r\n    protected analyzeIfStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n\r\n        let attrs = [];\r\n        while (children[children.length - 1 - attrs.length].name === 'Attribute') {\r\n            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));\r\n        }\r\n\r\n        const isIfElse = (children.length - attrs.length === 7);\r\n\r\n        const condNode = children[children.length - 3 - attrs.length];\r\n        const cond = this.analyzeExpr(context, program, condNode);\r\n\r\n        if (!cond || !types.equals(asRelaxedType(cond.type), T_BOOL)) {\r\n            context.error(condNode, EErrors.InvalidIfCondition, { typeName: cond ? String(cond.type) : '[unknown]' });\r\n        } else if (!types.equals(cond.type, T_BOOL)) {\r\n            context.warn(condNode, EWarnings.ImplicitTypeConversion, { tooltip: `${cond.type.name} => bool` });\r\n        }\r\n\r\n        let conseq: IStmtInstruction = null;\r\n        let contrary: IStmtInstruction = null;\r\n\r\n        if (isIfElse) {\r\n            conseq = this.analyzeNonIfStmt(context, program, children[2]);\r\n            contrary = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            conseq = this.analyzeNonIfStmt(context, program, children[0]);\r\n        }\r\n\r\n        if (!cond) {\r\n            return null;\r\n        }\r\n\r\n        return new IfStmtInstruction({ sourceNode, scope, cond, conseq, contrary, attrs: attrs });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    NonIfStmt\r\n     *       + SimpleStmt \r\n     */\r\n    protected analyzeNonIfStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'SimpleStmt':\r\n                return this.analyzeSimpleStmt(context, program, children[0]);\r\n            case 'T_KW_WHILE':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n            case 'T_KW_FOR':\r\n                return this.analyzeForStmt(context, program, sourceNode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeForStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const isNonIfStmt = (sourceNode.name === 'NonIfStmt');\r\n\r\n        let body: IStmtInstruction = null;\r\n        let init: ITypedInstruction = null;\r\n        let cond: IExprInstruction = null;\r\n        let step: IExprInstruction = null;\r\n\r\n        let attrs = [];\r\n        while (children[children.length - 1 - attrs.length].name === 'Attribute') {\r\n            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));\r\n        }\r\n\r\n        if (children[1].name === 'ERROR') {\r\n            return null;\r\n        }\r\n\r\n        program.push();\r\n\r\n        const initSourceNode = children[children.length - 3 - attrs.length];\r\n        const condSourceNode = children[children.length - 4 - attrs.length];\r\n\r\n        init = this.analyzeForInit(context, program, initSourceNode);\r\n        cond = this.analyzeForCond(context, program, condSourceNode);\r\n        step = null;\r\n\r\n        const isEmptyInit = initSourceNode.children[0].name == 'T_PUNCTUATOR_59';\r\n        if (isNull(init) && !isEmptyInit) {\r\n            context.error(initSourceNode, EErrors.InvalidForInitEmptyIterator);\r\n        } else if (init.instructionType !== EInstructionTypes.k_VariableDecl) {\r\n            // EAnalyzerErrors.InvalidForInitExpr\r\n        }\r\n\r\n        if (isNull(cond)) {\r\n            context.error(condSourceNode, EErrors.InvalidForConditionEmpty);\r\n        } else if (cond.instructionType !== EInstructionTypes.k_RelationalExpr) {\r\n            // EAnalyzerErrors.InvalidForConditionRelation\r\n        }\r\n\r\n        if (children.length === 7 + attrs.length) {\r\n            step = this.analyzeForStep(context, program, children[2]);\r\n            if (isNull(step)) {\r\n                context.error(children[2], EErrors.InvalidForStepEmpty);\r\n            }\r\n        }\r\n\r\n        if (isNonIfStmt) {\r\n            body = this.analyzeNonIfStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            body = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n\r\n        //     if (this._step.instructionType === EInstructionTypes.k_UnaryExpr ||\r\n        //         this._step.instructionType === EInstructionTypes.k_AssignmentExpr ||\r\n        //         this._step.instructionType === EInstructionTypes.k_PostfixArithmeticExpr) {\r\n\r\n        //         // todo: rewrite this check!!\r\n        //         // var sOperator: string = this._step.operator;\r\n        //         // if (sOperator !== \"++\" && sOperator !== \"--\" &&\r\n        //         //     sOperator !== \"+=\" && sOperator !== \"-=\") {\r\n        //         //     this._setError(EAnalyzerErrors.BAD_FOR_STEP_OPERATOR, { operator: sOperator });\r\n        //         //     return false;\r\n        //         // }\r\n        //     }\r\n        //     else {\r\n        //         this._setError(EAnalyzerErrors.InvalidForStepExpr);\r\n        //         return false;\r\n        //     }\r\n\r\n        program.pop();\r\n\r\n        return new ForStmtInstruction({ sourceNode, scope, init, cond, step, body });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForInit\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + AssignmentExpr \r\n     *    ForInit\r\n     *       + VariableDecl \r\n     *    ForInit\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Expr \r\n     */\r\n    protected analyzeForInit(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypedInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'VariableDecl':\r\n                // TODO: fixme!! \r\n                // add support for expressions like \"a = 1, b = 2, c = 3\"\r\n                return this.analyzeVariableDecl(context, program, children[0])[0] || null;\r\n            case 'Expr':\r\n            case 'AssignmentExpr':\r\n                return this.analyzeExpr(context, program, children[1]);\r\n        }\r\n\r\n        // ForInit : ';'\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForCond\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + RelationalExpr \r\n     */\r\n    protected analyzeForCond(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        if (children.length === 1) {\r\n            return null;\r\n        }\r\n\r\n        return this.analyzeExpr(context, program, children[1]);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForStep\r\n     *       + UnaryExpr \r\n     */\r\n    protected analyzeForStep(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        if (children.length == 0) {\r\n            return null;\r\n        }\r\n        const step = this.analyzeExpr(context, program, children[0]);\r\n        return step;\r\n    }\r\n\r\n\r\n\r\n    protected analyzePresetProperty(context: Context, program: ProgramScope, sourceNode: IParseNode): IPresetPropertyInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const nameNode = children[children.length - 1];\r\n        const propName = nameNode.value;\r\n        const propExprNode = children[children.length - 3];\r\n        const exprNode = propExprNode.children[propExprNode.children.length - 1];\r\n        const scope = program.currentScope;\r\n\r\n        if (isNull(exprNode.value) || isNull(propName)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            return null;\r\n        }\r\n\r\n        const decl = scope.findVariable(propName);\r\n        if (isNull(decl)) {\r\n            context.warn(sourceNode, EWarnings.PartFx_PresetPropertyHasNotBeenFound);\r\n            return null;\r\n        }\r\n\r\n        const type = decl.type;\r\n\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_PUNCTUATOR_125 = '}'\r\n         *         T_UINT = '1'\r\n         *         T_PUNCTUATOR_44 = ','\r\n         *         T_KW_TRUE = 'true'\r\n         *         T_PUNCTUATOR_123 = '{'\r\n         */\r\n            const args: IExprInstruction[] =[];\r\n            if (exprNode.value === '{' && propExprNode.children.length > 3) {\r\n                for (let i = propExprNode.children.length - 2; i >= 1; i -= 2) {\r\n                    const expr = this.analyzeExpr(context, program, propExprNode.children[i]);\r\n                    // todo: use more strict check same as for InitExpr analyze\r\n                    if (!types.equals(expr.type, type.arrayElementType)) {\r\n                        context.warn(propExprNode.children[i], EWarnings.ImplicitTypeConversion, \r\n                            { tooltip: `${expr.type.name} => ${type.arrayElementType.name}` });\r\n                    }\r\n                    args.push(expr);\r\n                }\r\n            } else {\r\n                if (exprNode.value === '{') {\r\n                    args.push(this.analyzeExpr(context, program, propExprNode.children[1]));\r\n                } else {\r\n                    args.push(this.analyzeExpr(context, program, exprNode));\r\n                }\r\n            }\r\n            \r\n            const id = new IdInstruction({ name: propName, scope, sourceNode: nameNode });\r\n            return new PresetProperty({ scope, sourceNode, id, args });\r\n        }\r\n \r\n \r\n    protected analyzePresetStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IPresetPropertyInstruction[] {\r\n        const children = sourceNode.children;\r\n        let props = []\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            props.push(this.analyzePresetProperty(context, program, children[i]));\r\n        }\r\n        return props;\r\n    }\r\n\r\n    \r\n    /**\r\n     * AST example:\r\n     *    PresetDecl\r\n     *       + PassStateBlock \r\n     *         T_NON_TYPE_ID = 'X'\r\n     *         T_KW_PRESET = 'preset'\r\n     */\r\n    protected analyzePresetDecl(context: Context, program: ProgramScope, sourceNode: IParseNode) {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ sourceNode: children[i], scope, name });\r\n            }\r\n        }\r\n\r\n        const props = this.analyzePresetStateBlock(context, program, children[0]);\r\n\r\n        const preset = new PresetInstruction({\r\n            scope,\r\n            sourceNode,\r\n            id,\r\n            props\r\n        });\r\n\r\n        return preset;\r\n    }\r\n\r\n\r\n\r\n    protected analyzeTechnique11Decl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITechnique11Instruction {\r\n        const children = sourceNode.children;\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let passes: IPass11Instruction[] = null;\r\n        let presets: IPresetInstruction[] = null;\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(context, program, children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else {\r\n                [ passes ] = this.analyzeTechnique11(context, program, children[i]);\r\n            }\r\n        }\r\n\r\n        const technique = new Technique11Instruction({ sourceNode, name, semantic, annotation, passes, scope, presets });\r\n        Analyzer.addTechnique11(context, program, technique);\r\n        return technique;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    protected analyzeTechniqueDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITechniqueInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        context.warn(sourceNode, EWarnings.Deprecated);\r\n\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let passes: IPassInstruction[] = null;\r\n        let presets: IPresetInstruction[] = null;\r\n        let techniqueType: ETechniqueType = ETechniqueType.k_BasicFx;\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(context, program, children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else {\r\n                [passes, presets] = this.analyzeTechnique(context, program, children[i]);\r\n            }\r\n        }\r\n\r\n        const technique = new TechniqueInstruction({ sourceNode, name, techniqueType, semantic, annotation, passes, scope, presets });\r\n        Analyzer.addTechnique(context, program, technique);\r\n        return technique;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    TechniqueBody\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + PassDecl \r\n     *       + PassDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzeTechnique(context: Context, program: ProgramScope, sourceNode: IParseNode): [IPassInstruction[], IPresetInstruction[]] {\r\n        const children = sourceNode.children;\r\n        let passes: IPassInstruction[] = [];\r\n        let presets: IPresetInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            // IP: hack to support preset extension\r\n            if (children[i].children[0].name === 'PresetDecl') {\r\n                let preset = this.analyzePresetDecl(context, program, children[i].children[0]);\r\n                assert(!isNull(preset));\r\n                presets.push(preset);\r\n                continue;\r\n            }\r\n\r\n            let pass = this.analyzePassDecl(context, program, children[i]);\r\n            assert(!isNull(pass));\r\n            passes.push(pass);\r\n        }\r\n\r\n        return [ passes, presets ];\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Technique11Body\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + Pass11Decl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    // todo: add preset support (!)\r\n    // see analyzeTechnique() for example.\r\n    protected analyzeTechnique11(context: Context, program: ProgramScope, sourceNode: IParseNode): [IPass11Instruction[]] {\r\n        const children = sourceNode.children;\r\n        let passes: IPass11Instruction[] = [];\r\n        let iPass = 0;\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let pass = this.analyzePass11Decl(context, program, children[i], iPass);\r\n            assert(!isNull(pass));\r\n            passes.push(pass);\r\n        }\r\n\r\n        return [ passes ];\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *       + Annotation \r\n     *         T_NON_TYPE_ID = 'name'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzePassDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IPassInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);\r\n        const renderStates = this.analyzePassStateBlock(context, program, children[0]);\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ scope, name });\r\n            }\r\n        }\r\n\r\n        const pass = new PassInstruction({\r\n            scope,\r\n            sourceNode,\r\n            renderStates,\r\n            id,\r\n            pixelShader: entry.pixel,\r\n            vertexShader: entry.vertex\r\n        });\r\n        //TODO: add annotation and id\r\n\r\n        return pass;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Pass11Decl\r\n     *       + StmtBlock \r\n     *         T_NON_TYPE_ID = 'P0'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    protected analyzePass11Decl(context: Context, program: ProgramScope, sourceNode: IParseNode, iPass: number = 0): IFunctionDeclInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        \r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ scope, name, sourceNode: children[i] });\r\n            }\r\n        }\r\n\r\n        if (!id) {\r\n            // create fake pass name for better readability\r\n            id = new IdInstruction({ scope, name: `auto_pass_${iPass}` });\r\n        }\r\n        \r\n        const impl = this.analyzeStmtBlock(context, program, children[0]);\r\n        const returnType = VariableTypeInstruction.wrap(T_VOID, scope);\r\n        const def = new FunctionDefInstruction({ scope, id, returnType });\r\n        const pass11 = new FunctionDeclInstruction({ scope, sourceNode, impl, def });\r\n\r\n        //TODO: add annotation and id\r\n        return pass11;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'VertexShader'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzePassStateBlockForShaders(context: Context, program: ProgramScope,\r\n        sourceNode: IParseNode): { vertex: IFunctionDeclInstruction; pixel: IFunctionDeclInstruction; } {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        let pixel: IFunctionDeclInstruction = null;\r\n        let vertex: IFunctionDeclInstruction = null;\r\n\r\n        const supportedTypeNames = ['vertexshader', 'pixelshader'];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let func: IFunctionDeclInstruction = null;\r\n\r\n            const childrenIth = children[i].children;\r\n            const shaderTypeName = childrenIth[childrenIth.length - 1].value.toLowerCase();\r\n\r\n            if (supportedTypeNames.indexOf(shaderTypeName) === -1) {\r\n                continue;\r\n            }\r\n\r\n            func = this.analyzePassStateForShader(context, program, children[i], shaderTypeName);\r\n\r\n            if (!isNull(func)) {\r\n                switch (shaderTypeName) {\r\n                    case 'vertexshader':\r\n                        assert(vertex == null);\r\n                        vertex = func;\r\n                        break;\r\n                    case 'pixelshader':\r\n                        assert(pixel == null);\r\n                        pixel = func;\r\n                        break;\r\n                    default:\r\n                        // TODO: make error!\r\n                        console.error('function is not suitable as shader entry point');\r\n                }\r\n            }\r\n        }\r\n\r\n        return { vertex, pixel };\r\n    }\r\n\r\n\r\n    protected analyzePassStateForShader(context: Context, program: ProgramScope,\r\n        sourceNode: IParseNode, shaderType: string): IFunctionDeclInstruction {\r\n\r\n        assert(shaderType === 'vertexshader' || shaderType === 'pixelshader');\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        const compileExpr = <CompileExprInstruction>this.analyzeExpr(context, program, exprNode);\r\n\r\n        if (!compileExpr) {\r\n            return null;\r\n        }\r\n\r\n        const shaderFunc = compileExpr.function;\r\n\r\n        if (shaderType === 'vertexshader') {\r\n            if (!checkForVertexUsage(shaderFunc.def)) {\r\n                context.error(sourceNode, EErrors.FunctionIsNotCompatibleWithVertexShader, { funcDef: String(shaderFunc) });\r\n            }\r\n        }\r\n        else {\r\n            if (!checkForPixelUsage(shaderFunc.def)) {\r\n                context.error(sourceNode, EErrors.FunctionIsNotCompatibleWithPixelShader, { funcDef: String(shaderFunc) });\r\n            }\r\n        }\r\n\r\n        return shaderFunc;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StateBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + State \r\n     *       + State \r\n     *       + State \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    StateBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + StateBlock \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + StateBlock \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode, type: ITypeInstruction): IStateBlockInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (!type.isNotBaseArray()) {\r\n            let props: Object = {}\r\n            for (let i = children.length - 2; i >= 1; i--) {\r\n                props = { ...props, ...this.analyzeState(context, program, children[i]) };\r\n            }\r\n            return new StateBlockInstruction({ scope, sourceNode, type, props });\r\n        } else {\r\n            let blocks = [];\r\n            for (let i = children.length - 2; i >= 1; i--) {\r\n                if (children[i].value === ',') continue;\r\n                blocks = [ ...blocks, this.analyzeStateBlock(context, program, children[i], (<IVariableTypeInstruction>type).subType) ];\r\n            }\r\n            return new StateBlockInstruction({ scope, sourceNode, type, blocks });\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    State\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + StateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'ZWRITE'\r\n     */\r\n    protected analyzeState(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<any> {\r\n        const children = sourceNode.children;\r\n        const stateName = children[children.length - 1].value;\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        if (isNull(exprNode.value)) {\r\n            console.warn('state is incorrect.'); // TODO: move to warnings\r\n            return {};\r\n        }\r\n\r\n        let states: IMap<any> = {};\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: any[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                values[j] = stateExprNode.children[i].value;\r\n            }\r\n\r\n            // todo: convert values to native types\r\n            states[stateName] = values;\r\n        }\r\n        else {\r\n            let value: string = '';\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value;\r\n            }\r\n            else {\r\n                value = exprNode.value;\r\n            }\r\n\r\n            // todo: convert value to native type\r\n            states[stateName] = value;\r\n        }\r\n        return states;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassStateBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + PassState \r\n     *       + PassState \r\n     *       + PassState \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzePassStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<ERenderStateValues> {\r\n        const children = sourceNode.children;\r\n        let states: IMap<ERenderStateValues> = {}\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            states = { ...states, ...this.analyzePassState(context, program, children[i]) };\r\n        }\r\n        return states;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'ZWRITE'\r\n     */\r\n    protected analyzePassState(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<ERenderStateValues> {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateType = children[children.length - 1].value.toUpperCase();\r\n        const stateName = ERenderStates[stateType];\r\n\r\n        if (!isNumber(stateName)) {\r\n            return {};\r\n        }\r\n\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        if (isNull(exprNode.value)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            return {};\r\n        }\r\n\r\n        let renderStates: IMap<ERenderStateValues> = {};\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: ERenderStateValues[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                values[j] = getRenderStateValue(stateName, stateExprNode.children[i].value.toUpperCase());\r\n            }\r\n\r\n            switch (stateName) {\r\n                case ERenderStates.BLENDFUNC:\r\n                    if (values.length !== 2) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                    renderStates[ERenderStates.SRCBLENDALPHA] = values[0];\r\n                    renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                    renderStates[ERenderStates.DESTBLENDALPHA] = values[1];\r\n                    break;\r\n\r\n                case ERenderStates.BLENDFUNCSEPARATE:\r\n                    if (values.length !== 4) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                    renderStates[ERenderStates.SRCBLENDALPHA] = values[2];\r\n                    renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                    renderStates[ERenderStates.DESTBLENDALPHA] = values[3];\r\n                    break;\r\n\r\n                case ERenderStates.BLENDEQUATIONSEPARATE:\r\n                    if (values.length !== 2) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.BLENDEQUATIONCOLOR] = values[0];\r\n                    renderStates[ERenderStates.BLENDEQUATIONALPHA] = values[1];\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Pass state is incorrect.');\r\n                    return {};\r\n            }\r\n        }\r\n        else {\r\n            let value: string = '';\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value.toUpperCase();\r\n            }\r\n            else {\r\n                value = exprNode.value.toUpperCase();\r\n            }\r\n\r\n            const stateValue = getRenderStateValue(stateName, value);\r\n\r\n            if (stateValue !== ERenderStateValues.UNDEF) {\r\n                switch (stateName) {\r\n                    case ERenderStates.SRCBLEND:\r\n                        renderStates[ERenderStates.SRCBLENDCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.SRCBLENDALPHA] = stateValue;\r\n                        break;\r\n                    case ERenderStates.DESTBLEND:\r\n                        renderStates[ERenderStates.DESTBLENDCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.DESTBLENDALPHA] = stateValue;\r\n                        break;\r\n                    case ERenderStates.BLENDEQUATION:\r\n                        renderStates[ERenderStates.BLENDEQUATIONCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.BLENDEQUATIONALPHA] = stateValue;\r\n                        break;\r\n                    default:\r\n                        renderStates[stateName] = stateValue;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return renderStates;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ImportDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + ComplexNameOpt \r\n     *         T_KW_IMPORT = 'import'\r\n     */\r\n    // TODO: restore functionality! \r\n    protected analyzeImportDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): null {\r\n        const children = sourceNode.children;\r\n        const componentName = this.analyzeComplexName(children[children.length - 2]);\r\n\r\n        // if (!isNull(technique)) {\r\n        //     //We can import techniques from the same file, but on this stage they don`t have component yet.\r\n        //     //So we need special mehanism to add them on more belated stage\r\n        //     // let sShortedComponentName: string = componentName;\r\n        //     if (!isNull(context.moduleName)) {\r\n        //         // sShortedComponentName = componentName.replace(_sProvideNameSpace + \".\", \"\");\r\n        //     }\r\n\r\n        //     throw null;\r\n        //     // let pTechniqueFromSameEffect: ITechniqueInstruction = _pTechniqueMap[componentName] || _pTechniqueMap[sShortedComponentName];\r\n        //     // if (isDefAndNotNull(pTechniqueFromSameEffect)) {\r\n        //     //     technique._addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);\r\n        //     //     return;\r\n        //     // }\r\n        // }\r\n\r\n        const sourceTechnique: ITechniqueInstruction = null;//fx.techniques[componentName];\r\n        if (!sourceTechnique) {\r\n            context.error(sourceNode, EErrors.ImportedComponentNotExists, { componentName: componentName });\r\n            return null;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StructDecl\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_NON_TYPE_ID = 'S'\r\n     *         T_KW_STRUCT = 'struct'\r\n     */\r\n    protected analyzeStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const name = children[children.length - 2].value;\r\n\r\n        program.push(EScopeType.k_Struct);\r\n\r\n        let fields: IVariableDeclInstruction[] = [];\r\n        for (let i = children.length - 4; i >= 1; i--) {\r\n            if (children[i].name === 'VariableDecl') {\r\n                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n            }\r\n        }\r\n\r\n        program.pop();\r\n\r\n        return new ComplexTypeInstruction({ scope, sourceNode, name, fields });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    TypeDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + VariableDim \r\n     *       + ConstType \r\n     *         T_KW_TYPEDEF = 'typedef'\r\n     */\r\n    protected analyzeTypedefDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        // TODO: rework to support complex typ defenitions like \r\n        //  typedef const float4 TYPE_T;\r\n        //          ^^^^^^\r\n        // IP: at the moment type defenitions are not supported\r\n\r\n        const vdimNode = children[1];\r\n        const alias = vdimNode.children[0].value;\r\n        const type = this.analyzeConstTypeDim(context, program, children[2]);\r\n        // this.analyzeConstTypeDim() <= doesn't support 'const float' like expressions with modifiers\r\n\r\n        // const type = new TypeAlias()\r\n        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n        // add support for typealiases\r\n\r\n        const typedef = new TypedefInstruction({ scope, sourceNode, type, alias });\r\n        addTypeAlias(context, scope, typedef);\r\n        \r\n        return typedef;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    TypeDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + StructDecl \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    TypeDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + VariableDim \r\n     *       + ConstType \r\n     *         T_KW_TYPEDEF = 'typedef'\r\n     */\r\n    protected analyzeTypeDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n        if (children.length === 2) {\r\n            type = this.analyzeStructDecl(context, program, children[1]);\r\n        }\r\n        else if (children.length === 4) {\r\n           return this.analyzeTypedefDecl(context, program, sourceNode);\r\n        }\r\n        else {\r\n            context.error(sourceNode, EErrors.UnsupportedTypeDecl);\r\n        }\r\n\r\n\r\n        const typeDecl = new TypeDeclInstruction({ scope, sourceNode, type });\r\n        addTypeDecl(context, scope, typeDecl);\r\n        return typeDecl;\r\n    }\r\n\r\n\r\n    protected analyzeUnknDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IInstruction[] {\r\n        switch (sourceNode.name) {\r\n            case 'TechniqueDecl':\r\n                return [this.analyzeTechniqueDecl(context, program, sourceNode)];\r\n            case 'Technique11Decl':\r\n                return [this.analyzeTechnique11Decl(context, program, sourceNode)];\r\n            case 'UseDecl':\r\n                this.analyzeUseDecl(context, program, sourceNode); // << always 'use strict' by default!\r\n                return null;\r\n            case 'ImportDecl':\r\n                return [this.analyzeImportDecl(context, program, sourceNode)];\r\n            case 'ProvideDecl':\r\n                return [this.analyzeProvideDecl(context, program, sourceNode)];\r\n            case 'TypeDecl':\r\n                return [this.analyzeTypeDecl(context, program, sourceNode)];\r\n            case 'VariableDecl':\r\n                return this.analyzeVariableDecl(context, program, sourceNode);\r\n            case 'VarStructDecl':\r\n                return this.analyzeVarStructDecl(context, program, sourceNode);\r\n            case 'FunctionDecl':\r\n                assert(program.currentScope == program.globalScope);\r\n                let fdecl = null;\r\n                context.beginFunc();\r\n                fdecl = this.analyzeFunctionDecl(context, program, sourceNode);\r\n                context.endFunc();\r\n                return [fdecl];\r\n            case 'CbufferDecl':\r\n                return [this.analyzeCbufferDecl(context, program, sourceNode)];\r\n            case 'SamplerStateDecl':\r\n                return [this.analyzeSamplerStateDecl(context, program, sourceNode)];\r\n            case 'T_PUNCTUATOR_59':\r\n                context.warn(sourceNode, EWarnings.EmptySemicolon);\r\n                return null;\r\n            default:\r\n                context.error(sourceNode, EErrors.UnknownInstruction, { name });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeGlobals(context: Context, program: ProgramScope, slastDocument: ISLASTDocument): IInstruction[] {\r\n        if (isNull(slastDocument) || isNull(slastDocument.root)) {\r\n            return null;\r\n        }\r\n\r\n        const children = slastDocument.root.children;\r\n        let globals: IInstruction[] = [];\r\n\r\n        if (isNull(children)) {\r\n            return [];\r\n        }\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            globals.push(...(this.analyzeUnknDecl(context, program, children[i]) || []));\r\n        }\r\n\r\n        return globals.filter(decl => !!decl);\r\n    }\r\n\r\n\r\n    protected createContext(uri: IFile, expressions?: IMap<IExprSubstCallback>): Context {\r\n        return new Context(uri, expressions);\r\n    }\r\n\r\n    // create new scope\r\n    protected createProgram(document: ISLDocument = null): ProgramScope {\r\n        let parent = <IScope>SystemScope.SCOPE;\r\n        if (!isNull(document)) {\r\n            parent = document.root.scope;\r\n        }\r\n        return new ProgramScope(parent);\r\n    }\r\n\r\n    // extends existing scoope\r\n    protected createProgramEx(document: ISLDocument = null): ProgramScope {\r\n        if (isNull(document)) {\r\n            return this.createProgram();\r\n        }\r\n        return new ProgramScopeEx(document.root.scope);\r\n    }\r\n\r\n    /**\r\n     * Post-analysis validation.\r\n     */\r\n    protected validate(context: Context, program: ProgramScope, root: IInstructionCollector) {\r\n        checkFunctionsForRecursion(context, program);\r\n        program.validate();\r\n    }\r\n\r\n    /**\r\n     * Create a new standalone document.\r\n     * @param slastDocument \r\n     * @param document Context source. The scope of the parent document will be used when creating a new one.\r\n     * @returns \r\n     */\r\n    parse(slastDocument: ISLASTDocument, document?: ISLDocument): ISLDocument {\r\n        const uri = slastDocument.uri;\r\n        const program = this.createProgram(document);\r\n        const context = this.createContext(uri);\r\n\r\n        let instructions: IInstruction[] = null;\r\n        try {\r\n            instructions = this.analyzeGlobals(context, program, slastDocument);\r\n        } catch (e) {\r\n            // critical errors were occured\r\n            // throw e;\r\n            console.error(e);\r\n        }\r\n\r\n        const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n        this.validate(context, program, root);\r\n\r\n        const diagnosticReport = Diagnostics.mergeReports([slastDocument.diagnosticReport, context.diagnostics.resolve()]);\r\n        return { root, diagnosticReport, uri };\r\n    }\r\n\r\n    /**\r\n     * Extend existing document. (Base document stay unchanged (!))\r\n     * @param slastAddition Extension. (Can be null if just copy of base document is needed.)\r\n     * @param slBase Original document to be extneded.\r\n     * @param options \r\n     * @returns \r\n     * \r\n     * The idea is to create new documents which references to existings scope and extends \r\n     * existings instruction list, but leave parent document unchanged. \r\n     */\r\n    extend(\r\n        slastAddition: ISLASTDocument, \r\n        slBase: ISLDocument,\r\n        expressions?: IMap<IExprSubstCallback>\r\n        ): ISLDocument {\r\n        let uri = slBase.uri;\r\n\r\n        // new program (scope chain) holds links to known variales, types etc of parent document\r\n        let program = this.createProgramEx(slBase);\r\n        // context is absolutely new (!)\r\n        let context = this.createContext(uri, expressions);\r\n        let instructions = slBase.root.instructions;\r\n        let diagnosticReport = slBase.diagnosticReport;\r\n\r\n        if (slastAddition)\r\n        {\r\n            uri = slastAddition.uri;\r\n            try {\r\n                // new list holds links to existings instructions (!)\r\n                instructions = instructions.concat(this.analyzeGlobals(context, program, slastAddition));\r\n            } catch (e) {\r\n                // critical errors were occured\r\n                // throw e;\r\n                console.error(e);\r\n            }\r\n\r\n            diagnosticReport = Diagnostics.mergeReports([diagnosticReport, slastAddition.diagnosticReport, context.diagnostics.resolve()]);\r\n        }\r\n        \r\n        const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n        this.validate(context, program, root);\r\n        return { root, diagnosticReport, uri };\r\n    }\r\n\r\n\r\n    // function addFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode, func: IFunctionDeclInstruction): void {\r\n    //     if (isSystemFunction(func)) {\r\n    //         context.error(sourceNode, EErrors.SystemFunctionRedefinition, { funcName: func.name });\r\n    //     }\r\n\r\n    //     let isFunctionAdded: boolean = program.addFunction(func);\r\n\r\n    //     if (!isFunctionAdded) {\r\n    //         context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: func.name });\r\n    //     }\r\n    // }\r\n\r\n\r\n    protected static addTechnique11(context: Context, program: ProgramScope, technique: ITechnique11Instruction): void {\r\n        let name: string = technique.name;\r\n\r\n        if (!isNull(program.globalScope.findTechnique11(name))) {\r\n            context.error(technique.sourceNode, EErrors.TechniqueNameRedefinition, { techName: name });\r\n            return;\r\n        }\r\n\r\n        program.globalScope.addTechnique11(technique);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    protected static addTechnique(context: Context, program: ProgramScope, technique: ITechniqueInstruction): void {\r\n        let name: string = technique.name;\r\n\r\n        if (!isNull(program.globalScope.findTechnique(name))) {\r\n            context.error(technique.sourceNode, EErrors.TechniqueNameRedefinition, { techName: name });\r\n            return;\r\n        }\r\n\r\n        program.globalScope.addTechnique(technique);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * Check the possibility of using the operator between the two types.\r\n    * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.\r\n     *\r\n     * @operator {string} One of the operators: + - * / % += -= *= /= %= = < > <= >= == != =\r\n     * @leftType {ITypeInstruction} Type of the left side of the expression.\r\n     * @rightType {ITypeInstruction} Type of the right side of the expression.\r\n     */\r\n    static checkTwoOperandExprTypes(\r\n        context: Context,\r\n        operator: string,\r\n        leftType: ITypeInstruction,\r\n        rightType: ITypeInstruction,\r\n        leftSourceNode: IParseNode = null,\r\n        rightSourceNode: IParseNode = null,\r\n        exprSourceNode: IParseNode = null, \r\n        { isInitializing = false } = {}): ITypeInstruction {\r\n\r\n        if (!leftType || !rightType) {\r\n            return null;\r\n        }\r\n\r\n        leftSourceNode = leftSourceNode || leftType.sourceNode;\r\n        rightSourceNode = rightSourceNode || rightType.sourceNode;\r\n\r\n        const isComplex = leftType.isComplex() || rightType.isComplex();\r\n        const isArray = leftType.isNotBaseArray() || rightType.isNotBaseArray();\r\n        // const isSampler = isSamplerType(leftType) || isSamplerType(rightType);\r\n\r\n        \r\n        const constBoolType = (len: number) => {\r\n            if (len >= 1 && len <= 4) {\r\n                let ba = [ T_BOOL, T_BOOL2, T_BOOL3, T_BOOL4 ];\r\n                return VariableTypeInstruction.wrapAsConst(ba[len - 1], SystemScope.SCOPE);\r\n            }\r\n            console.error('unsupported code branch');\r\n            return null;\r\n        }\r\n\r\n        if (isArray/* || isSampler*/) {\r\n            // TODO: allow expressions like: arr1 = arr2; ??\r\n            return null;\r\n        }\r\n\r\n        if (Analyzer.isAssignmentOperator(operator)) {\r\n            if (!leftType.writable && !isInitializing) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForWriting);\r\n            }\r\n\r\n            if (!rightType.readable) {                \r\n                context.error(rightSourceNode, EErrors.InvalidTypeForReading);\r\n            }\r\n\r\n            if (operator !== '=' && !leftType.readable) {\r\n                // temp solution for cases like:\r\n                // void f(out int x) \r\n                // {\r\n                //      x = 10;\r\n                //      x |= 1; // << allow to write here\r\n                // }\r\n                context.error(exprSourceNode, EErrors.InvalidTypeForReading, { tooltip: `lvalue is not readable` });\r\n            }\r\n        }\r\n        else {\r\n            if (!leftType.readable) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForReading);\r\n            }\r\n\r\n            if (!rightType.readable) {\r\n                context.error(rightSourceNode, EErrors.InvalidTypeForReading);\r\n            }\r\n        }\r\n\r\n        if (isComplex) {\r\n            if (operator === '=' && types.equals(leftType, rightType)) {\r\n                return <IVariableTypeInstruction>leftType;\r\n            }\r\n            // samplers and arrays can't be compared directly\r\n            else if (Analyzer.isEqualityOperator(operator) && !leftType.isComplex()) {\r\n                return constBoolType(1);\r\n            }\r\n\r\n            // TODO: emit error (unsupported operation on complex values)\r\n            return null;\r\n        }\r\n\r\n        // FIXME: use operands' scope instead of system scope?\r\n        let leftBaseType = VariableTypeInstruction.wrap(<SystemTypeInstruction>leftType.baseType, SystemScope.SCOPE);\r\n        let rightBaseType = VariableTypeInstruction.wrap(<SystemTypeInstruction>rightType.baseType, SystemScope.SCOPE);\r\n\r\n\r\n        if (Analyzer.isBitwiseOperator(operator)) {\r\n            if (!SystemScope.isIntBasedType(leftType) && \r\n                !SystemScope.isUintBasedType(leftType)) {\r\n                if (!SystemScope.isBoolBasedType(leftType)) {\r\n                    // todo: use correct error\r\n                    context.error(leftSourceNode, EErrors.InvalidCastUnknownType, { tooltip: `${leftType.name} => int` });\r\n                } else {\r\n                    context.warn(leftSourceNode, EWarnings.ImplicitTypeConversion, { tooltip: 'bool => int' });\r\n                }\r\n                leftBaseType = VariableTypeInstruction.wrap(T_INT, SystemScope.SCOPE);\r\n            }\r\n\r\n            if (!SystemScope.isIntBasedType(rightType) && \r\n                !SystemScope.isUintBasedType(rightType)) {\r\n                if (!SystemScope.isBoolBasedType(rightType)) {\r\n                    // todo: use correct error\r\n                    context.error(rightSourceNode, EErrors.InvalidCastUnknownType, { tooltip: `${rightType.name} => int` });\r\n                } else {\r\n                    context.warn(rightSourceNode, EWarnings.ImplicitTypeConversion, { tooltip: 'bool => int' });\r\n                }\r\n                rightBaseType = VariableTypeInstruction.wrap(T_INT, SystemScope.SCOPE);\r\n            }\r\n\r\n            switch (operator) {\r\n                case '&':\r\n                case '|':\r\n                case '^':\r\n                    if (!types.equals(leftBaseType, rightType)) {\r\n                        // TODO: emit warning (bitwise between int and uint)\r\n                    }\r\n            }\r\n\r\n            return leftBaseType;\r\n        }\r\n\r\n        // hack to allow int/uint comparisson\r\n        if (types.equals(leftType, asRelaxedType(rightType))) {\r\n            if (!types.equals(leftType, rightType)) {\r\n                context.warn(exprSourceNode, EWarnings.ImplicitTypeConversion, { tooltip: `${leftType.name} [${operator}] ${rightType.name}` });\r\n            }\r\n\r\n            if (Analyzer.isArithmeticalOperator(operator)) {\r\n                if (!SystemScope.isMatrixType(leftType) || (operator !== '/' && operator !== '/=')) {\r\n                    return leftBaseType;\r\n                }\r\n\r\n                // TODO: emit error (cannot perfome devision with matrices)\r\n                return null;\r\n            }\r\n            else if (Analyzer.isRelationalOperator(operator)) {\r\n                if (SystemScope.isScalarType(leftType) || SystemScope.isVectorType(leftType)) {\r\n                    return constBoolType(leftType.length);\r\n                }\r\n\r\n                // TODO: allow vectors? for ex: vec3 < vec3 => bool3\r\n                // TODO: emit error (cannot perfome comparison with non-scalar)\r\n                return null;\r\n            }\r\n            else if (Analyzer.isEqualityOperator(operator)) {\r\n                return constBoolType(leftType.length);\r\n            }\r\n            else if (operator === '=') {\r\n                return leftBaseType;\r\n            }\r\n\r\n            // TODO: emit error (unknonw operation)\r\n            return null;\r\n        }\r\n\r\n        // op: \"+\", \"-\", \"*\", \"/\"\r\n        //     \"+=\", \"-=\", \"*=\", \"/=\", \"%=\"\r\n        if (Analyzer.isArithmeticalOperator(operator)) {\r\n\r\n            // op: \"+\", \"-\", \"*\", \"/\", \"%\"\r\n\r\n            const length =\r\n                SystemScope.isScalarType(leftType) \r\n                    ? rightType.length \r\n                    : SystemScope.isScalarType(rightType) \r\n                        ? leftType.length \r\n                        : Math.min(leftType.length, rightType.length);\r\n\r\n            const baseType = SystemScope.determMostPreciseBaseType(leftType, rightType);\r\n            const resultType = SystemScope.findType(`${baseType.name}${length === 1 ? '' : length}`);\r\n\r\n            if (!resultType) {\r\n                assert(false, `cannot determ result type for \"${leftType.toCode()} ${operator} ${rightType.toCode()}\"`);\r\n                return null;\r\n            }\r\n\r\n\r\n            // op: \"+=\", \"-=\", \"*=\", \"/=\", \"%=\"\r\n            if (Analyzer.isAssignmentOperator(operator)) {\r\n                if (!types.equals(leftType, resultType)) {\r\n                    // TODO: add support for imlicit conversions\r\n                    // TODO: emit error (operator cannot be used with a given lvalue)\r\n                    context.error(exprSourceNode, EErrors.OperatorCannotBeUsedWithGivenLValue, {});\r\n                    return null;\r\n                }\r\n            }\r\n\r\n\r\n            if (resultType.length < leftType.length || resultType.length < rightType.length) {\r\n                context.warn(exprSourceNode, EWarnings.ImplicitTypeTruncation, {\r\n                    tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${resultType.toCode()}`\r\n                });\r\n            }\r\n\r\n            if (!types.equals(SystemScope.determBaseType(leftType), SystemScope.determBaseType(rightType))) {\r\n                // do not emit errors for expr like: float2 * float, int2 + int etc..\r\n                context.warn(exprSourceNode, EWarnings.ImplicitTypeConversion, {\r\n                    tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${resultType.toCode()}`\r\n                });\r\n            }\r\n\r\n            /**\r\n             * Special case for matrices\r\n             */\r\n            if (operator === '*' || operator === '*=') {\r\n                if (SystemScope.isMatrixType(leftType) && SystemScope.isVectorType(rightType)) {\r\n                    if (leftType.length === rightType.length) {\r\n                        return rightBaseType;\r\n                    }\r\n                    return null;\r\n                }\r\n                else if (SystemScope.isMatrixType(rightType) && SystemScope.isVectorType(leftType)) {\r\n                    if (leftType.length === rightType.length) {\r\n                        return leftBaseType;\r\n                    }\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            return <IVariableTypeInstruction>resultType;\r\n        }\r\n\r\n        if (operator === '=') {\r\n            if (SystemScope.isScalarType(rightType)) {\r\n                if (SystemScope.determTypePrecision(leftType) > SystemScope.determTypePrecision(rightType)) {\r\n                    context.warn(exprSourceNode, EWarnings.ImplicitTypeConversion, {\r\n                        tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${leftType.toCode()}`\r\n                    });\r\n                    return leftType;\r\n                }\r\n\r\n                if (SystemScope.isIntegerType(leftType) && SystemScope.isIntegerType(rightType)) {\r\n                    context.warn(exprSourceNode, EWarnings.ImplicitTypeConversion, {\r\n                        tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${leftType.toCode()}`\r\n                    });\r\n                    return leftType;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Check the ability to use the operator to the data type.\r\n* Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.\r\n     *\r\n     * @operator {string} One of the operators: + - ! ++ --\r\n     * @leftType {IVariableTypeInstruction} Operand type\r\n     */\r\n    protected static checkOneOperandExprType(context: Context, sourceNode: IParseNode, operator: string,\r\n        type: IVariableTypeInstruction): IVariableTypeInstruction {\r\n\r\n        const isComplex = type.isComplex();\r\n        const isArray = type.isNotBaseArray();\r\n        // const isSampler = isSamplerType(type);\r\n\r\n        if (isComplex || isArray/* || isSampler*/) {\r\n            return null;\r\n        }\r\n\r\n        if (!type.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n\r\n\r\n        if (operator === '++' || operator === '--') {\r\n            if (!type.writable) {\r\n                context.error(sourceNode, EErrors.InvalidTypeForWriting);\r\n            }\r\n\r\n            return type;\r\n        }\r\n\r\n        if (operator === '!') {\r\n            const boolType = <IVariableTypeInstruction>T_BOOL;\r\n            // validate(boolType, EInstructionTypes.k_VariableDecl);\r\n\r\n            if (types.equals(type, boolType)) {\r\n                return boolType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            if (SystemScope.isBoolBasedType(type)) {\r\n                return null;\r\n            }\r\n            else {\r\n                return (<SystemTypeInstruction>type.baseType) as any; // << TODO: fixme!!!! remove \"any\"!\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    protected static isAssignmentOperator(operator: string): boolean {\r\n        return operator === '+=' || operator === '-=' ||\r\n            operator === '*=' || operator === '/=' ||\r\n            operator === '%=' || operator === '=' || \r\n            operator === '|=' || operator === '&=' || \r\n            operator === '>>=' || operator === '<<=' || operator === '^=';\r\n    }\r\n\r\n    protected static isBitwiseOperator(operator: string): boolean {\r\n        return operator === '>>' || operator === '<<' ||\r\n            operator === '|' || operator === '&' || operator === '^' || \r\n            operator === '|=' || operator === '&=' ||\r\n            operator === '>>=' || operator === '<<=' || operator === '^=';\r\n    }\r\n\r\n    protected static isArithmeticalOperator(operator: string): boolean {\r\n        return operator === '+' || operator === '+=' ||\r\n            operator === '-' || operator === '-=' ||\r\n            operator === '*' || operator === '*=' ||\r\n            operator === '/' || operator === '/=' ||\r\n            operator === '%' || operator === '%=';\r\n    }\r\n\r\n\r\n    protected static isRelationalOperator(operator: string): boolean {\r\n        return operator === '>' || operator === '>=' ||\r\n            operator === '<' || operator === '<=';\r\n    }\r\n\r\n\r\n    protected static isEqualityOperator(operator: string): boolean {\r\n        return operator === '==' || operator === '!=';\r\n    }\r\n}\r\n\r\n\r\n","import { assert, isBoolean, isNull, isNumber, PropertiesDiff } from \"@lib/common\";\r\nimport { types } from \"@lib/fx/analisys/helpers\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { EInstructionTypes, IAnnotationInstruction, ICompileExprInstruction, IDeclInstruction, IExprInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdInstruction, IInstruction, IInstructionCollector, IPassInstruction, IStmtInstruction, ITypedInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IFile, IParseNode } from \"@lib/idl/parser/IParser\";\r\nimport { EPassDrawMode, IPartFxInstruction, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { Analyzer, Context, ICompileValidator } from \"./Analyzer\";\r\nimport { IdInstruction } from \"./instructions/IdInstruction\";\r\nimport { DrawInstruction } from \"./instructions/part/DrawInstruction\";\r\nimport { PartFxInstruction } from \"./instructions/part/PartFxInstruction\";\r\nimport { PartFxPassInstruction } from \"./instructions/part/PartFxPassInstruction\";\r\nimport { SpawnInstruction } from \"./instructions/part/SpawnInstruction\";\r\nimport { ProgramScope } from \"./ProgramScope\";\r\nimport * as SystemScope from './SystemScope';\r\nimport { T_BOOL, T_INT, T_VOID } from \"./SystemScope\";\r\n\r\ntype IPartFxPassProperties = PropertiesDiff<IPartFxPassInstruction, IPassInstruction>;\r\n// type is internal property which is always ETechniqueType.k_PartFx for particle fx's,\r\n// so we can omit it.\r\ntype IPartFxProperties = Omit<PropertiesDiff<IPartFxInstruction, IDeclInstruction>, \"type\">;\r\n\r\nconst asType = (instr: ITypedInstruction): ITypeInstruction => instr ? instr.type : null;\r\n\r\nexport class FxContext extends Context {\r\n    /** Main particle structure type describing particle's simulation. */\r\n    particleCore: ITypeInstruction;\r\n    /** Particle instance structure type which describe per pass render instance of the particle. */\r\n    particleInstance: ITypeInstruction;\r\n\r\n    spawnStmts: SpawnInstruction[] = [];\r\n    drawStmts: { instr: DrawInstruction, ctx: IFunctionDefInstruction }[] = [];\r\n\r\n    // beginFunc(): void {\r\n    //     super.beginFunc();\r\n    // }\r\n\r\n    // endFunc(): void {\r\n    //     super.endFunc();\r\n    // }\r\n\r\n    beginPartFxPass(): void {\r\n        this.beginPass();\r\n        this.particleInstance = null;\r\n    }\r\n\r\n\r\n    endPartFxPass(): void {\r\n        this.particleInstance = null;\r\n        this.endPass();\r\n    }\r\n\r\n\r\n    beginPartFx(): void {\r\n        this.particleCore = null;\r\n    }\r\n\r\n\r\n    endPartFx(): void {\r\n        this.particleCore = null;\r\n    }\r\n}\r\n\r\n\r\nfunction sliceNode(source: IParseNode, from: number, to?: number): IParseNode {\r\n    const { children, parent, name, value, loc } = source;\r\n    return {\r\n        children: children.slice(from, to),\r\n        parent,\r\n        name,\r\n        value,\r\n        loc\r\n    };\r\n}\r\n\r\n\r\nexport class FxAnalyzer extends Analyzer {\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'Init'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '10'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_SPAWN = 'spawn'\r\n     */\r\n    protected analyzeSpawnStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const name = children.slice(-5, -4)[0].value;\r\n        const args = <IExprInstruction[]>[];\r\n\r\n        for (let i = children.length - 7; i >= 2; i--) {\r\n            if (children[i].value !== ',') {\r\n                const arg = this.analyzeExpr(context, program, children[i]);\r\n                args.push(arg);\r\n            }\r\n        }\r\n\r\n        // const { base, signed, heximal, exp } = parseUintLiteral(children.slice(-3, -2)[0].value);\r\n        // const count = new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n\r\n        const count = this.analyzeExpr(context, program, children.slice(-3, -2)[0]);\r\n        \r\n        // find function name(args)\r\n\r\n        const spawnStmt = new SpawnInstruction({ sourceNode, scope, name, args, count });\r\n        context.spawnStmts.push(spawnStmt);\r\n\r\n        return spawnStmt;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'part'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'P0'\r\n     *         T_KW_DRAW = 'draw'\r\n     */\r\n     protected analyzeDrawStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const name = children[children.length - 2].value;\r\n        const args = <IExprInstruction[]>[];\r\n\r\n        for (let i = children.length - 4; i >= 2; i--) {\r\n            if (children[i].value !== ',') {\r\n                const arg = this.analyzeExpr(context, program, children[i]);\r\n                args.push(arg);\r\n            }\r\n        }\r\n\r\n        const instr = new DrawInstruction({ sourceNode, scope, name, args });\r\n        const ctx = context.funcDef;\r\n        context.drawStmts.push({ instr, ctx });\r\n        \r\n        return instr;\r\n    }\r\n\r\n\r\n\r\n    protected analyzeSimpleStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const firstNodeName: string = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'T_KW_SPAWN':\r\n                return this.analyzeSpawnStmt(context, program, sourceNode);\r\n            case 'T_KW_DRAW':\r\n                return this.analyzeDrawStmt(context, program, sourceNode);\r\n            default:\r\n                return super.analyzeSimpleStmt(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *         T_NON_TYPE_ID = 'P0'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    protected analyzePartFXPassDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxPassInstruction {\r\n\r\n        context.beginPartFxPass();\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);\r\n        const renderStates = this.analyzePassStateBlock(context, program, children[0]);\r\n\r\n        // temp solution in order to not highlight useless pass states in the next analysis call.\r\n        context.renderStates = renderStates;\r\n\r\n        const fxStates = this.analyzePartFxStateBlock(context, program, children[0]);\r\n\r\n        let sorting = isBoolean(fxStates.sorting) ? fxStates.sorting : false;\r\n        const prerenderRoutine = fxStates.prerenderRoutine || null;\r\n        const geometry = fxStates.geometry || null;\r\n        const instanceCount = fxStates.instanceCount || 1;\r\n\r\n        if (sorting && prerenderRoutine && types.equals(prerenderRoutine.function.def.returnType, T_VOID))\r\n        {\r\n            context.warn(sourceNode, EWarnings.PartFx_SortingCannotBeApplied);\r\n            context.warn(prerenderRoutine.function.def.sourceNode, EWarnings.PartFx_SortingCannotBeApplied);\r\n        }\r\n\r\n        //\r\n        // Validation of the shader input\r\n        //\r\n\r\n        let pixelShader = entry.pixel;\r\n\r\n        /**\r\n         * Vertex shader validation pattern:\r\n         *  PixelInputType VertexShader(PartInstance partInstance, Geometry geometry);\r\n         */\r\n\r\n        let vertexShader = entry.vertex;\r\n        if (vertexShader) {\r\n            const requiredSemantics = ['POSITION', 'POSITION0'];\r\n            let hasInstance = false;\r\n            let hasRequiredSemantics = false;\r\n            for (const param of vertexShader.def.params) {\r\n                hasInstance = hasInstance ||\r\n                    param.type.subType === context.particleInstance;\r\n                hasRequiredSemantics = hasRequiredSemantics ||\r\n                    !!requiredSemantics.find(semantic => param.type.hasFieldWithSematics(semantic));\r\n            }\r\n\r\n            if (!hasInstance) {\r\n                context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,\r\n                    { tooltip: 'vertex shader must have a valid material param which is compatible with prerender routine.' });\r\n                vertexShader = pixelShader = null;\r\n            }\r\n\r\n            // if (!hasRequiredSemantics) {\r\n            //     context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,\r\n            //         { tooltip: 'doesn\\'t have requiredsemantics.' });\r\n            //     vertexShader = pixelShader = null;\r\n            // }\r\n        }\r\n\r\n        //\r\n        // Rest\r\n        //\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ sourceNode: children[i], scope, name });\r\n            }\r\n        }\r\n\r\n        let drawMode = EPassDrawMode.k_Auto;\r\n        if (id) {\r\n            if (context.drawStmts.find(x => x.instr.name == id.name)) {\r\n                drawMode = EPassDrawMode.k_Manual;\r\n            }\r\n        }\r\n\r\n\r\n        const pass = new PartFxPassInstruction({\r\n            scope,\r\n            sourceNode,\r\n            id,\r\n\r\n            sorting,\r\n            geometry,\r\n            instanceCount,\r\n            prerenderRoutine,\r\n            drawMode,\r\n\r\n            renderStates,\r\n            pixelShader,\r\n            vertexShader\r\n        });\r\n\r\n        //TODO: add annotation and id\r\n\r\n        context.endPartFxPass();\r\n\r\n        return pass;\r\n    }\r\n\r\n\r\n    // TODO: use explicit return type\r\n    protected analyzePartFxStateBlock(context: FxContext, program: ProgramScope, sourceNode: IParseNode): Partial<IPartFxPassProperties> {\r\n        const children = sourceNode.children;\r\n        let states: Partial<IPartFxPassProperties> = {}\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            states = { ...states, ...this.analyzePartFXPassProperies(context, program, children[i]) };\r\n        }\r\n        return states;\r\n    }\r\n\r\n\r\n    /**\r\n    * AST example:\r\n    *    PassState\r\n    *         T_PUNCTUATOR_59 = ';'\r\n    *       + PassStateExpr \r\n    *         T_PUNCTUATOR_61 = '='\r\n    *         T_NON_TYPE_ID = 'STATE_ONE'\r\n    */\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'STATE_TWO'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PassStateExpr\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_KW_TRUE = 'true'\r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    // TODO: add explicit type for fx statess\r\n    protected analyzePartFXPassProperies(context: FxContext, program: ProgramScope, sourceNode: IParseNode): Partial<IPartFxPassProperties> {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateName: string = children[children.length - 1].value.toUpperCase();\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        let fxStates: Partial<IPartFxPassProperties> = {};\r\n\r\n        if (isNull(exprNode.value) || isNull(stateName)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            // TODO: return correct state list\r\n            return fxStates;\r\n        }\r\n\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_PUNCTUATOR_125 = '}'\r\n         *         T_UINT = '1'\r\n         *         T_PUNCTUATOR_44 = ','\r\n         *         T_KW_TRUE = 'true'\r\n         *         T_PUNCTUATOR_123 = '{'\r\n         */\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: string[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                // TODO: validate values with names\r\n                values[j] = stateExprNode.children[i].value.toUpperCase();\r\n            }\r\n\r\n            switch (stateName) {\r\n                // case ERenderStates.BLENDFUNC:\r\n                //     if (values.length !== 2) {\r\n                //         console.warn('Pass state are incorrect.');\r\n                //         return {};\r\n                //     }\r\n                //     renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                //     renderStates[ERenderStates.SRCBLENDALPHA] = values[0];\r\n                //     renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                //     renderStates[ERenderStates.DESTBLENDALPHA] = values[1];\r\n                //     break;\r\n                default:\r\n                    console.warn('Pass fx state is incorrect.');\r\n                    return fxStates;\r\n            }\r\n        }\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_NON_TYPE_ID = 'FALSE'\r\n         */\r\n        else {\r\n            let value: string = null;\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value.toUpperCase();\r\n            }\r\n            else {\r\n                value = exprNode.value.toUpperCase();\r\n            }\r\n\r\n            switch (stateName) {\r\n                case ('InstanceCount'.toUpperCase()):\r\n                    fxStates.instanceCount = Number(value) || 1;\r\n                    break;\r\n                case ('Geometry'.toUpperCase()):\r\n                    // Geometry = \"sfx_leaves\";\r\n                    if (exprNode.name == \"T_STRING\")\r\n                    {\r\n                        value = value.replace(/^\"(.+)\"$/,'$1');\r\n                    }\r\n                    // Geometry = Sphere;\r\n                    else\r\n                    {\r\n                        console.assert(exprNode.name === 'T_NON_TYPE_ID');\r\n                    }\r\n                    fxStates.geometry = value.toLowerCase();\r\n                    break;\r\n                case ('Sorting'.toUpperCase()):\r\n                    // TODO: use correct validation with diag error output\r\n                    assert(value == 'TRUE' || value == 'FALSE');\r\n                    fxStates.sorting = (value === 'TRUE');\r\n                    break;\r\n                case ('PrerenderRoutine'.toUpperCase()):\r\n                    {\r\n                        /**\r\n                        * Prerender routine expected as 'void prerender(Part part, out DefaultShaderInput input)'.\r\n                        */\r\n                        let validators: ICompileValidator[] = [\r\n                            /* void prerender(in Part part, inout PartInstance instance) */\r\n                            { ret: T_VOID, args: [context.particleCore, null] },\r\n                            /* void prerender(in Part part, inout PartInstance instance, int instanceId) */\r\n                            { ret: T_VOID, args: [context.particleCore, null, SystemScope.T_INT] },\r\n                            /* int prerender(in Part part, inout PartInstance instance) */\r\n                            { ret: T_INT, args: [context.particleCore, null] },\r\n                            /* int prerender(in Part part, inout PartInstance instance, int instanceId) */\r\n                            { ret: T_INT, args: [context.particleCore, null, SystemScope.T_INT] },\r\n                        ];\r\n\r\n                        //\r\n                        // TODO: add string-based validators like this:\r\n                        // void prerender(Part part, PartInstance instance, int instanceId?: INSTANCE_ID);\r\n                        //\r\n\r\n                        let prerenderRoutine = this.analyzeCompileExpr(context, program, exprNode, validators);\r\n\r\n                        if (!prerenderRoutine) {\r\n                            break;\r\n                        }\r\n\r\n                        //\r\n                        // check arguments\r\n                        //\r\n\r\n                        let fn = prerenderRoutine.function;\r\n\r\n                        /** first argument's type */\r\n                        let argv = fn.def.params.map(param => param.type);\r\n\r\n                        if (argv.length < 2) {\r\n                            context.error(exprNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' count mismatch.` });\r\n                            prerenderRoutine = null;\r\n                        }\r\n\r\n                        if (!argv[0].readable || argv[0].subType !== context.particleCore ||\r\n                            argv[0].isNotBaseArray() ||\r\n                            !(argv[1].usages.includes('out') || argv[1].usages.includes('inout')) || !argv[1].writable || argv[1].isNotBaseArray()) {\r\n                            context.error(exprNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' type mismatch.` });\r\n                            prerenderRoutine = null;\r\n                        }\r\n\r\n                        //         argv[1]: \"out PartInstance\"\r\n                        // argv[1].subType: \"PartInstance\"\r\n                        context.particleInstance = argv[1].subType;\r\n                        fxStates.prerenderRoutine = prerenderRoutine;\r\n                    }\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n\r\n        return fxStates;\r\n    }\r\n\r\n\r\n    protected analyzePartFXBody(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxProperties {\r\n        let passes: IPartFxPassInstruction[] = [];\r\n        let spawnRoutine: ICompileExprInstruction = null;\r\n        let initRoutine: ICompileExprInstruction = null;\r\n        let updateRoutine: ICompileExprInstruction = null;\r\n        let particle: ITypeInstruction = null;\r\n        let capacity: number = null;\r\n\r\n        const children = sourceNode.children;\r\n\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'PassState':\r\n                    {\r\n                        let sourceNode = children[i];\r\n                        let stateName = sourceNode.children[3].value; // \"T_NON_TYPE_ID\"\r\n                        switch (stateName.toUpperCase()) {\r\n                            case ('Capacity'.toUpperCase()):\r\n                                {\r\n                                    // TODO: make correct validation of the capacity value and emit errors\r\n                                    //       through diagnostics system. \r\n                                    const snum = sourceNode.children[1].children[0].value;\r\n                                    assert(isNumber(Number(snum)));\r\n                                    capacity = Number(snum) || -1;\r\n                                    // capacity must be multiple of 64 because of group size is 64\r\n                                    // and we run thread for every alive particle\r\n                                    // todo: fix it usind condition in the beginning of the shader\r\n                                    capacity = Math.floor((capacity + 63) / 64) * 64;\r\n                                    break;\r\n                                }\r\n                            case ('SpawnRoutine'.toUpperCase()):\r\n                                {\r\n                                    /**\r\n                                     * Spawn routine expected as 'int spawn(void)'.\r\n                                     */\r\n                                    let validators = [\r\n                                        { ret: T_INT, args: [] },       // int f(void)\r\n                                        { ret: T_VOID, args: [/.*/] },  // void f(EMITTER emit)\r\n                                        { ret: T_VOID, args: [] },      // void f(void)\r\n                                    ];\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    spawnRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    const params = spawnRoutine.function.def.params;\r\n                                    if (params.length > 0) {\r\n                                        if (!params[0].type.usages.includes('inout')) {\r\n                                            context.warn(params[0].type.sourceNode, EWarnings.PartFx_EmitterPersistentDataMustBeMarkedAsInout);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case ('InitRoutine'.toUpperCase()):\r\n                                {\r\n                                    /** Init routine expected as 'void init(in Part part)'. */\r\n                                    let validators: ICompileValidator[] = [\r\n                                        { ret: T_VOID, args: [null, /u?int/] },          /* init(PART part, int partId) */\r\n                                        { ret: T_VOID, args: [null, /u?int/, /u?int/] }, /* init(PART part, int partId, int spawnId) */\r\n                                        { ret: T_VOID, args: [null] },                   /* init(PART part) */\r\n                                    ];\r\n\r\n                                    // TODO: show error in case of both functions are found\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    initRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    if (!initRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    //\r\n                                    // check arguments\r\n                                    //\r\n\r\n                                    let fn = initRoutine.function;\r\n                                    /** first argument's type */\r\n                                    let type = fn.def.params[0].type;\r\n\r\n                                    if ((!type.usages.includes('out') && !type.usages.includes('inout')) || type.isNotBaseArray()) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });\r\n                                        initRoutine = null;\r\n                                    }\r\n\r\n                                    if (particle && type.subType !== particle) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    // type is referencing to VariableType of argument,\r\n                                    // while substitute type referencing to declaration. \r\n                                    particle = type.subType;\r\n                                }\r\n                                break;\r\n                            case ('UpdateRoutine'.toUpperCase()):\r\n                                {\r\n                                    /**\r\n                                     * Update routine expected as 'void update(inout Part part)'.\r\n                                     */\r\n                                    let validators: ICompileValidator[] = [\r\n                                        { ret: T_BOOL, args: [null, T_INT] }, /* update(PART part, int partId) */\r\n                                        { ret: T_BOOL, args: [null] },        /* update(PART part) */\r\n                                    ];\r\n\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    updateRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    if (!updateRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    //\r\n                                    // check arguments\r\n                                    //\r\n\r\n                                    const fn = updateRoutine.function;\r\n                                    const fdef = fn.def;\r\n                                    const paramList = fdef.params;\r\n\r\n                                    if (paramList.length < 1 || paramList.length > 2) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    /** first argument's type */\r\n                                    let type = paramList[0].type;\r\n\r\n                                    if (!type.usages.includes('out') && !type.usages.includes('inout') || type.isNotBaseArray()) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    if (particle && type.subType !== particle) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    //\r\n                                    // Check return type\r\n                                    //\r\n\r\n                                    if (!types.equals(fdef.returnType, T_BOOL)) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' return type mismatch. 'boolean' is expected.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    if (!updateRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    // type is referencing to VariableType of argument,\r\n                                    // while substitute type referencing to declaration. \r\n                                    particle = type.subType;\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Note: all fx properties should be parsed prior to pass declaraion analysis\r\n        // because some of them are critical for pass validation\r\n        context.particleCore = particle;\r\n\r\n        const presets = [];\r\n\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'PassDecl':\r\n                    {\r\n                        // hack to support presets extension\r\n                        if (children[i].children[0].name === 'PresetDecl') {\r\n                            presets.push(this.analyzePresetDecl(context, program, children[i].children[0]));\r\n                            break;\r\n                        }\r\n\r\n                        let pass = this.analyzePartFXPassDecl(context, program, children[i]);\r\n\r\n                        if (!pass.isValid()) {\r\n                            context.warn((pass.id && pass.id.sourceNode) || children[i], EWarnings.IncompletePass, {\r\n                                techniqueName: pass.name,\r\n                                tooltip: `The pass is not completed. Not all required parameters are specified.`\r\n                            });\r\n                        }\r\n\r\n                        assert(!isNull(pass));\r\n                        passes.push(pass);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        return { passes, spawnRoutine, initRoutine, updateRoutine, particle, capacity, presets };\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PartFxDecl\r\n     *       + PartFxBody \r\n     *       + Annotation \r\n     *       + Semantic \r\n     *       + ComplexNameOpt \r\n     *         T_KW_FXPART = 'partFx'\r\n     */\r\n    protected analyzePartFXDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxInstruction {\r\n        const children = sourceNode.children;\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let props: IPartFxProperties = null;\r\n\r\n        context.beginPartFx();\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n\r\n            switch (children[i].name) {\r\n                case 'Annotation':\r\n                    annotation = this.analyzeAnnotation(context, program, children[i]);\r\n                    break;\r\n                case 'Semantic':\r\n                    semantic = this.analyzeSemantic(children[i]);\r\n                    break;\r\n                case 'PartFxBody':\r\n                    props = this.analyzePartFXBody(context, program, children[i]);\r\n                    break;\r\n\r\n            }\r\n\r\n        }\r\n        //\r\n        // draw operator finalization\r\n        //\r\n\r\n        for (const stmt of context.drawStmts) {\r\n            const { instr, ctx } = stmt;\r\n            const pass = props.passes.find(pass => pass.id.name == instr.name);\r\n            if (!pass) {\r\n                // emit warning not an error\r\n                // because in some cases it may be useful to have several effects with\r\n                // common update routine but different pass set\r\n                context.warn(instr.sourceNode, EWarnings.PartFx_RenderPassWasNotFound, { \r\n                    techniqueName: name,\r\n                    tooltip: `The technique doesn't have pass with name <${instr.name}>`\r\n                 });\r\n            }\r\n\r\n            const p0Type = ctx.params[0].type;\r\n            if (!types.equals(p0Type, context.particleCore) || !p0Type.readable) {\r\n                context.error(instr.sourceNode, EErrors.PartFx_DrawOpOnlyAllowedWithinUpdateRoutine,\r\n                    { tooltip: 'Draw operator only allowed within update routine' });\r\n            }\r\n        }\r\n\r\n        context.endPartFx();\r\n\r\n        const partFx = new PartFxInstruction({\r\n            sourceNode, name, semantic, annotation, scope, ...props\r\n        });\r\n\r\n        if (!partFx.isValid()) {\r\n            // highlight name only\r\n            context.warn(children[children.length - 2], EWarnings.IncompleteTechnique, {\r\n                techniqueName: partFx.name,\r\n                tooltip: `The technique is not completed. Not all required parameters are specified.`\r\n            });\r\n        }\r\n\r\n        FxAnalyzer.addTechnique(context, program, partFx);\r\n        return partFx;\r\n    }\r\n\r\n\r\n    protected analyzeUnknDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IInstruction[] {\r\n        switch (sourceNode.name) {\r\n            case 'PartFxDecl':\r\n                return [this.analyzePartFXDecl(context, program, sourceNode)];\r\n            default:\r\n                return super.analyzeUnknDecl(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n    protected createContext(uri: IFile): FxContext {\r\n        return new FxContext(uri);\r\n    }\r\n\r\n\r\n    protected validate(context: FxContext, program: ProgramScope, root: IInstructionCollector) {\r\n        super.validate(context, program, root);\r\n\r\n        const scope = program.globalScope;\r\n\r\n        if (!root.instructions) {\r\n            return;\r\n        }\r\n\r\n        // NOTE: all effects are assumed to be valid\r\n        const fxList = <IPartFxInstruction[]>root.instructions.filter(instr => instr.instructionType === EInstructionTypes.k_PartFxDecl);\r\n\r\n\r\n        //\r\n        // spawn operator validation\r\n        //\r\n\r\n        for (const spawnStmt of context.spawnStmts) {\r\n            const bImportedEffect = false;\r\n            //parse as the spawn from the same effect\r\n\r\n            assert(!bImportedEffect, 'unsupported');\r\n\r\n            if (!bImportedEffect) {\r\n\r\n                let initializer = <IFunctionDeclInstruction>null;\r\n                for (const fx of fxList) {\r\n                    // looking for:\r\n                    // Init(out Part part, int partId: PART_ID, int spawnId: SPAWN_ID, ...parameters)\r\n                    // Init(out Part part, int partId: PART_ID, ...parameters)\r\n                    // Init(out Part part, ...parameters)\r\n                    let argsList = [[/u?int/, /u?int/], [/u?int/], []]\r\n                        .map(v => [ fx.particle, ...v, ...spawnStmt.args.map(asType) ]);\r\n\r\n                    for (const args of argsList) {\r\n                        initializer = scope.findFunction(spawnStmt.name, args);\r\n                        if (initializer) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (initializer) {\r\n                        // spawnStmt.$resolve(fx, initializer);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!initializer) {\r\n                    context.error(spawnStmt.sourceNode, EErrors.PartFx_InvalidSpawnStmtInitializerNotFound,\r\n                        { tooltip: 'Invalid spawn statement. Effect initializer not found.' });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n","import { assert, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EScopeType, ICbufferInstruction, IFunctionDeclInstruction, IScope, ITechnique11Instruction, ITechniqueInstruction, ITypeInstruction, ITypeTemplate, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { isString } from \"@lib/util/s3d/type\";\r\n\r\nimport { fn } from \"./helpers\";\r\n\r\nexport interface IScopeSettings {\r\n    type?: EScopeType;\r\n    parent?: IScope;\r\n    strictMode?: boolean;\r\n}\r\n\r\n\r\n\r\nexport class Scope implements IScope {\r\n    strictMode: boolean;\r\n\r\n    readonly parent: IScope;\r\n    readonly type: EScopeType;\r\n\r\n    readonly variables: IMap<IVariableDeclInstruction>;\r\n    readonly types: IMap<ITypeInstruction>;\r\n    readonly functions: IMap<IFunctionDeclInstruction[]>;\r\n    readonly techniques: IMap<ITechniqueInstruction>;\r\n    readonly techniques11: IMap<ITechnique11Instruction>;\r\n    readonly typeTemplates: IMap<ITypeTemplate>;\r\n    readonly cbuffers: IMap<ICbufferInstruction>;\r\n\r\n    constructor(scope: Scope);\r\n    constructor(settings: IScopeSettings);\r\n    constructor(params) {\r\n        let type: EScopeType;\r\n        let strictMode: boolean;\r\n        let parent: IScope;\r\n\r\n        if (params instanceof Scope)\r\n        {\r\n            let scope = params as Scope;\r\n            ({ type = EScopeType.k_Default, parent = null, strictMode = false } = scope);\r\n\r\n            this.variables = { ...(scope.variables) };\r\n            this.types = { ...scope.types };\r\n            this.functions = { ...scope.functions };\r\n            this.techniques = { ...scope.techniques };\r\n            this.techniques11 = { ...scope.techniques11 };\r\n            this.typeTemplates = { ...scope.typeTemplates };\r\n            this.cbuffers = { ...scope.cbuffers };\r\n        } \r\n        else \r\n        {\r\n            let settings = params as IScopeSettings;\r\n            ({ type = EScopeType.k_Default, parent = null, strictMode = false } = settings);\r\n\r\n            this.variables = {};\r\n            this.types = {};\r\n            this.functions = {};\r\n            this.techniques = {};\r\n            this.techniques11 = { };\r\n            this.typeTemplates = {};\r\n            this.cbuffers = {};\r\n        }\r\n\r\n        this.type = type;\r\n        this.parent = parent;\r\n        this.strictMode = strictMode;\r\n    }\r\n\r\n\r\n    isStrict(): boolean {\r\n        return this.filter(scope => scope.strictMode);\r\n    }\r\n\r\n\r\n    findVariable(varName: string): IVariableDeclInstruction {\r\n        return this.filter(scope => scope.variables[varName] || null);\r\n    }\r\n\r\n\r\n    findTypeTemplate(typeName: string): ITypeTemplate {\r\n        return this.filter(scope => scope.typeTemplates[typeName] || null);\r\n    }\r\n\r\n\r\n    findType(typeName: string): ITypeInstruction {\r\n        return this.filter(scope => scope.types[typeName] || null);\r\n    }\r\n\r\n\r\n    /**\r\n     * Find function by name and list of types.\r\n     * returns:\r\n     *   'null' if there is no requested function; \r\n     *   'undefined' if there more then one function; \r\n     *    function if all is ok;\r\n     */\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    findFunction(funcName: string, args: Array<ITypeInstruction | RegExp> = null): IFunctionDeclInstruction | null | undefined {\r\n        return this.filter(scope => fn.matchList(scope.functions[funcName], args))\r\n    }\r\n\r\n\r\n    findTechnique(techName: string): ITechniqueInstruction {\r\n        return this.filter(scope => scope.techniques[techName] || null);\r\n    }\r\n\r\n\r\n    findTechnique11(techName: string): ITechnique11Instruction {\r\n        return this.filter(scope => scope.techniques11[techName] || null);\r\n    }\r\n\r\n\r\n    findCbuffer(cbufName: string): ICbufferInstruction {\r\n        return this.filter(scope => scope.cbuffers[cbufName] || null);\r\n    }\r\n\r\n\r\n    findFunctionInScope(func: IFunctionDeclInstruction): IFunctionDeclInstruction {\r\n        let res = fn.matchList(this.functions[func.name], func.def.params.map(param => param? param.type : null));\r\n        assert(res !== undefined);\r\n        return res;\r\n    }\r\n\r\n    \r\n    addVariable(variable: IVariableDeclInstruction): boolean {\r\n        let variableMap = this.variables;\r\n        let varName = variable.name;\r\n\r\n        if (!this.variables[varName]) {\r\n            variableMap[varName] = variable;\r\n            assert(variable.scope === this);\r\n        }\r\n        else {\r\n            // console.error(`letiable '${varName}' already exists in scope:`, this);\r\n            return false;\r\n        }\r\n    \r\n        return true;\r\n    }\r\n\r\n\r\n    addTypeTemplate(template: ITypeTemplate): boolean {\r\n        if (isDefAndNotNull(this.typeTemplates[template.name])) {\r\n            return false;\r\n        }\r\n\r\n        this.typeTemplates[template.name] = template;\r\n        return true;\r\n    }\r\n\r\n    // todo: remove scopeId from argumts, use type.scope instead.\r\n    addType(type: ITypeInstruction): boolean {\r\n        if (this.types[type.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.types[type.name] = type;\r\n        console.assert(type.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    addTypeAlias(t: string | ITypeInstruction, aliasName: string): boolean {\r\n        let typeName = null;\r\n        let type = null;\r\n\r\n        if (isString(t)) {\r\n            typeName = t;\r\n            type = this.findType(typeName);\r\n        } else {\r\n            type = t;\r\n            typeName = type.name;\r\n        }\r\n        \r\n        const alias = this.findType(aliasName);\r\n\r\n        if (alias) {\r\n            return false;\r\n        }\r\n\r\n        if (!type) {\r\n            return false;\r\n        }\r\n\r\n        // original type must be part of this scope?\r\n        if (!this.findType(typeName)) {\r\n            return false;\r\n        }\r\n\r\n        this.types[aliasName] = type;\r\n        return true;\r\n    }\r\n\r\n\r\n    addFunction(func: IFunctionDeclInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n        assert(func.scope === this);\r\n\r\n        let funcMap = this.functions;\r\n        let funcName = func.name;\r\n\r\n        funcMap[funcName] = funcMap[funcName] || [];\r\n        const funcOverloads = funcMap[funcName];\r\n\r\n        let targetFunc = this.findFunctionInScope(func);\r\n\r\n        if (!targetFunc) {\r\n            funcOverloads.push(func);\r\n        } else {\r\n            assert(!isNull(func.impl));\r\n            assert(isNull(targetFunc.impl));\r\n            let i = funcOverloads.indexOf(targetFunc);\r\n            funcOverloads[i] = func;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    addTechnique(technique: ITechniqueInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n\r\n        if (this.techniques[technique.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.techniques[technique.name] = technique;\r\n        assert(technique.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    addTechnique11(technique11: ITechnique11Instruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n\r\n        if (this.techniques11[technique11.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.techniques11[technique11.name] = technique11;\r\n        assert(technique11.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    addCbuffer(cbuf: ICbufferInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n\r\n        if (this.cbuffers[cbuf.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.cbuffers[cbuf.name] = cbuf;\r\n        assert(cbuf.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    private filter<T>(cb: (scope: IScope) => T | null): T \r\n    {\r\n        let scope: IScope = this;\r\n        while (!isNull(scope)) {\r\n            let res = cb(scope);\r\n            if (!isNull(res)) {\r\n                return res;\r\n            }\r\n            scope = scope.parent;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class ProgramScope {\r\n    globalScope: IScope;\r\n    currentScope: IScope;\r\n\r\n\r\n    constructor(parent: IScope) {\r\n        if (!isNull(parent))\r\n        {\r\n            let type = EScopeType.k_Global;\r\n            this.globalScope = new Scope({ parent, type });\r\n            this.currentScope = this.globalScope;\r\n        }\r\n    }\r\n\r\n\r\n    validate(): void {\r\n        assert(this.currentScope === this.globalScope);\r\n    }\r\n\r\n\r\n    push(type: EScopeType = EScopeType.k_Default): void {\r\n        assert(this.currentScope !== null);\r\n        assert(type >= EScopeType.k_Default);\r\n\r\n        let parent = this.currentScope;\r\n        let scope = new Scope({ parent, type });\r\n\r\n        this.currentScope = scope;\r\n    }\r\n\r\n\r\n    pop(): void {\r\n        assert(this.currentScope !== null);\r\n        this.currentScope = this.currentScope.parent;\r\n        assert(this.currentScope !== null);\r\n    }\r\n}\r\n\r\n\r\nexport class ProgramScopeEx extends ProgramScope {\r\n    constructor(parent: IScope) {\r\n        super(null);\r\n        this.globalScope = new Scope(parent); // clone scope\r\n        this.currentScope = this.globalScope;\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { Scope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { EScopeType, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { addSystemFunctions } from \"./system/api\";\r\nimport { addSystemTypeBuiltin } from \"./system/builtin\";\r\nimport { addSystemTypeMatrix } from \"./system/matrix\";\r\nimport { addSystemTypeScalar } from \"./system/scalar\";\r\nimport {\r\n    isBoolBasedType, isFloatBasedType, isHalfBasedType, isIntBasedType, isMatrixType, isScalarType, isUintBasedType,\r\n    isVectorType\r\n} from \"./system/utils\";\r\nimport { addSystemTypeVector } from \"./system/vector\";\r\nexport {\r\n    isBase, isBlendState, isBoolBasedType, isBuffer, isDepthStencilState, isFloatBasedType, isFloatType, isHalfBasedType,\r\n    isIntBasedType, isIntegerType, isMatrixType, isPipelineState, isRasterizerState, isSamplerState, isScalarType,\r\n    isTexture, isUAV, isUintBasedType, isVectorType, resolveRegister\r\n} from './system/utils';\r\n\r\nconst scope = new Scope({ type: EScopeType.k_System });\r\n\r\naddSystemTypeScalar(scope);\r\naddSystemTypeVector(scope);\r\naddSystemTypeMatrix(scope);\r\naddSystemTypeBuiltin(scope);\r\naddSystemFunctions(scope);\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\n export const findType = (typeName: string) => scope.findType(typeName);\r\n export const findVariable = (varName: string) => scope.findVariable(varName);\r\n export const findTechnique = (techName: string) => scope.findTechnique(techName);\r\n export const findFunction = (funcName: string, args?: ITypeInstruction[]) => scope.findFunction(funcName, args);\r\n \r\n export const hasType = (typeName: string) => !isNull(scope.findType(typeName));\r\n export const hasVariable = (varName: string) => !isNull(scope.findVariable(varName));\r\n export const hasTechnique = (techName: string) => !isNull(scope.findTechnique(techName));\r\n\r\nexport const SCOPE = scope;\r\n\r\nexport const T_VOID = scope.findType(\"void\");\r\nexport const T_STRING = scope.findType(\"string\");\r\nexport const T_NULL = scope.findType(\"null_t\");\r\n\r\nexport const T_SAMPLER_STATE = scope.findType(\"SamplerState\");\r\nexport const T_BLEND_STATE = scope.findType(\"BlendState\");\r\nexport const T_DEPTH_STENCIL_STATE = scope.findType(\"DepthStencilState\");\r\n\r\nexport const T_FLOAT = scope.findType(\"float\");\r\nexport const T_FLOAT2 = scope.findType(\"float2\");\r\nexport const T_FLOAT3 = scope.findType(\"float3\");\r\nexport const T_FLOAT4 = scope.findType(\"float4\");\r\n\r\nexport const T_HALF = scope.findType(\"half\");\r\nexport const T_HALF2 = scope.findType(\"half2\");\r\nexport const T_HALF3 = scope.findType(\"half3\");\r\nexport const T_HALF4 = scope.findType(\"half4\");\r\n\r\nexport const T_FLOAT2X2 = scope.findType(\"float2x2\");\r\nexport const T_FLOAT2X3 = scope.findType(\"float2x3\");\r\nexport const T_FLOAT2X4 = scope.findType(\"float2x4\");\r\nexport const T_FLOAT3X2 = scope.findType(\"float3x2\");\r\nexport const T_FLOAT3X3 = scope.findType(\"float3x3\");\r\nexport const T_FLOAT3X4 = scope.findType(\"float3x4\");\r\nexport const T_FLOAT4X2 = scope.findType(\"float4x2\");\r\nexport const T_FLOAT4X3 = scope.findType(\"float4x3\");\r\nexport const T_FLOAT4X4 = scope.findType(\"float4x4\");\r\n\r\nexport const T_BOOL = scope.findType(\"bool\");\r\nexport const T_BOOL2 = scope.findType(\"bool2\");\r\nexport const T_BOOL3 = scope.findType(\"bool3\");\r\nexport const T_BOOL4 = scope.findType(\"bool4\");\r\n\r\nexport const T_BOOL2X2 = scope.findType(\"bool2x2\");\r\nexport const T_BOOL3X3 = scope.findType(\"bool3x3\");\r\nexport const T_BOOL4X4 = scope.findType(\"bool4x4\");\r\n\r\nexport const T_INT = scope.findType(\"int\");\r\nexport const T_INT2 = scope.findType(\"int2\");\r\nexport const T_INT3 = scope.findType(\"int3\");\r\nexport const T_INT4 = scope.findType(\"int4\");\r\n\r\nexport const T_UINT = scope.findType(\"uint\");\r\nexport const T_UINT2 = scope.findType(\"uint2\");\r\nexport const T_UINT3 = scope.findType(\"uint3\");\r\nexport const T_UINT4 = scope.findType(\"uint4\");\r\n\r\nexport const T_INT2X2 = scope.findType(\"int2x2\");\r\nexport const T_INT3X3 = scope.findType(\"int3x3\");\r\nexport const T_INT4X4 = scope.findType(\"int4x4\");\r\n\r\n// export const T_SAMPLER = scope.findType(\"sampler\");\r\n// export const T_SAMPLER_2D = scope.findType(\"sampler2D\");\r\n// export const T_SAMPLER_CUBE = scope.findType(\"samplerCUBE\");\r\n\r\nexport const T_VERTEX_SHADER = scope.findType(\"VertexShader\");\r\nexport const T_PIXEL_SHADER = scope.findType(\"PixelShader\");\r\nexport const T_COMPUTE_SHADER = scope.findType(\"ComputeShader\");\r\nexport const T_GEOMETRY_SHADER = scope.findType(\"GeometryShader\");\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport function determBaseType(type: ITypeInstruction): ITypeInstruction {\r\n    if (isScalarType(type)) {\r\n        return type;\r\n    }\r\n\r\n    if (isVectorType(type) || isMatrixType(type)) {\r\n        if (isFloatBasedType(type)) {\r\n            return T_FLOAT;\r\n        }\r\n\r\n        if (isIntBasedType(type)) {\r\n            return T_INT;\r\n        }\r\n\r\n        if (isUintBasedType(type)) {\r\n            return T_UINT;\r\n        }\r\n\r\n        if (isHalfBasedType(type)) {\r\n            return T_HALF;\r\n        }\r\n\r\n        if (isBoolBasedType(type)) {\r\n            return T_BOOL;\r\n        }\r\n    }\r\n\r\n    assert(false, `cannot determ base type of ${type.name}`);\r\n    return null;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nenum ETypePrecision {\r\n    k_Bool,\r\n    k_Uint,\r\n    k_Int,\r\n    k_Half,\r\n    k_Float,\r\n    k_Unknown = NaN\r\n};\r\n\r\nexport function determTypePrecision(type: ITypeInstruction): ETypePrecision {\r\n    if (isFloatBasedType(type)) return ETypePrecision.k_Float;\r\n    if (isHalfBasedType(type)) return ETypePrecision.k_Half;\r\n    if (isIntBasedType(type)) return ETypePrecision.k_Int;\r\n    if (isUintBasedType(type)) return ETypePrecision.k_Uint;\r\n    if (isBoolBasedType(type)) return ETypePrecision.k_Bool;\r\n    return ETypePrecision.k_Unknown;\r\n}\r\n\r\n\r\nexport function typePrecisionAsType(precision: ETypePrecision): ITypeInstruction {\r\n    switch (precision) {\r\n        case ETypePrecision.k_Float: return T_FLOAT;\r\n        case ETypePrecision.k_Half: return T_HALF;\r\n        case ETypePrecision.k_Int: return T_INT;\r\n        case ETypePrecision.k_Uint: return T_UINT;\r\n        case ETypePrecision.k_Bool: return T_BOOL;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Determining the most precise type of two types.\r\n * Type hierarchy: \r\n *  float => half => int => uint => bool\r\n */\r\nexport function determMostPreciseBaseType(left: ITypeInstruction, right: ITypeInstruction) {\r\n    assert(isScalarType(left) || isVectorType(left));\r\n    assert(isScalarType(right) || isVectorType(right));\r\n\r\n    const type = typePrecisionAsType(Math.max(determTypePrecision(left), determTypePrecision(right)));\r\n\r\n    assert(type !== null, 'cannot determ base type');\r\n    return type;\r\n}\r\n\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, IComplexExprInstruction, IExprInstruction, IIdExprInstruction, IInstruction, ILiteralInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"./instruction\";\r\n\r\nexport namespace expression {\r\n    /**\r\n     * unwind operation returns declaration in case of correct l-value expression;\r\n     */\r\n    export function unwind(expr: IExprInstruction): IVariableDeclInstruction {\r\n        if (isNull(expr)) {\r\n            return null;\r\n        }\r\n\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                return unwind((<IPostfixPointInstruction>expr).element);\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                return unwind((<IPostfixIndexInstruction>expr).element);\r\n            case EInstructionTypes.k_IdExpr:\r\n                return (<IIdExprInstruction>expr).decl;\r\n            case EInstructionTypes.k_BitwiseExpr:\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                // arithmetic expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_InitExpr:\r\n                assert(false, 'init expression doesn\\'t support unwind operation');\r\n                return null;\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                // todo: reseach how it work in HLSL\r\n                //// assigment expression returns right-hand value;\r\n                return unwind((<IAssignmentExprInstruction>expr).left);\r\n            case EInstructionTypes.k_CastExpr:\r\n                // cast expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                // unary expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                // relation expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                // ctor call expression is not allowed as l-value;\r\n                // todo: allow it?\r\n                return null;\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return unwind((<IComplexExprInstruction>expr).expr);\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_StringExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n                // literal cannot be a left-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                // function call expression returns right-hand value;\r\n                return null;\r\n            default:\r\n                assert(false, \"unsupported expr found\");\r\n                return null;\r\n        }\r\n    }\r\n\r\n    \r\n    function evalVal(val: IInstruction) {\r\n        if (!val) {\r\n            return 0;\r\n        }\r\n\r\n        if (instruction.isLiteral(val)) {\r\n            return (<ILiteralInstruction<number>>val).value;\r\n        } \r\n            \r\n        if (val.instructionType === EInstructionTypes.k_CastExpr) {\r\n            return evalConst((<ICastExprInstruction>val).expr);\r\n        }\r\n\r\n        if (val.instructionType === EInstructionTypes.k_IdExpr) {\r\n            const idExpr = (<IIdExprInstruction>val);\r\n            if (idExpr.decl.isGlobal()) { // and is constant?\r\n                console.assert(idExpr.decl.initExpr.instructionType !== EInstructionTypes.k_InitExpr);\r\n                return evalConst(idExpr.decl.initExpr);\r\n            }\r\n        }\r\n        \r\n        return -1;\r\n    }\r\n\r\n    // simples possible evalator for minimal compartibility\r\n    export function evalConst(expr: IExprInstruction): number\r\n    {\r\n        const val = evalVal(expr);\r\n        if (val >= 0) {\r\n            return val;\r\n        }\r\n\r\n        if (expr.instructionType !== EInstructionTypes.k_ArithmeticExpr) {\r\n            console.error(`expr \"${expr.toCode()}\" could not be evaluated`);\r\n            return -1;\r\n        }\r\n\r\n        const { left, right, operator } = <IArithmeticExprInstruction>expr;\r\n        const lval = evalConst(left);\r\n        const rval = evalConst(right);\r\n        \r\n        if (lval >= 0 && rval >= 0) {\r\n            switch (operator) {\r\n                // todo: use round ? check if integers only\r\n                case '*': return rval * lval;\r\n                case '/': return rval / lval;\r\n                case '+': return rval + lval;\r\n                case '-': return rval - lval;\r\n                default:\r\n                    console.error('unsupported operator');\r\n            }\r\n        }\r\n\r\n        console.error(`expr \"${expr.toCode()}\" could not be evaluated`);\r\n        return -1;\r\n    }\r\n\r\n}\r\n","import { IFunctionDefInstruction, IVariableDeclInstruction, ITypeInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types } from \"@lib/fx/analisys/helpers\";\r\nimport { isNull } from \"@lib/common\";\r\n\r\nexport namespace fn {\r\n\r\n    function signatureParam(param: IVariableDeclInstruction, strong: boolean): string {\r\n        return `${types.signature(param.type, strong)}${param.initExpr ? '?' : ''}`;\r\n    }\r\n\r\n    export function signature(def: IFunctionDefInstruction, strong: boolean = false): string {\r\n        const { name, params } = def;\r\n        return `${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;\r\n    }\r\n\r\n    export function signatureEx(def: IFunctionDefInstruction, strong: boolean = false): string {\r\n        const { name, returnType, params } = def;\r\n        return `${types.signature(returnType, strong)} ${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;\r\n    }\r\n\r\n\r\n    export function numArgsRequired(def: IFunctionDefInstruction): number {\r\n        return def.params.filter((param) => !param || !param.initExpr).length;\r\n    }\r\n\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function match(def: IFunctionDefInstruction, args: Array<ITypeInstruction | RegExp>, strong: boolean = false): boolean {\r\n        if (!strong && isNull(args)) {\r\n            return true;\r\n        }\r\n\r\n        if (args.length > def.params.length || numArgsRequired(def) > args.length) {\r\n            return false;\r\n        }\r\n\r\n        return args.every((arg, i) => \r\n            (!strong && isNull(arg)) ||\r\n            (!strong && isNull(def.params[i].type)) ||\r\n            types.equals(arg, def.params[i].type, strong)\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * Find function by name and list of types.\r\n     * returns:\r\n     *   'null' if there is no requested function; \r\n     *   'undefined' if there more then one function; \r\n     *    function if all is ok;\r\n     */\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function matchList(funcList: IFunctionDeclInstruction[],\r\n        args: Array<ITypeInstruction | RegExp>,\r\n        strong: boolean = false): IFunctionDeclInstruction | null | undefined {\r\n\r\n        if (!funcList) {\r\n            return null;\r\n        }\r\n\r\n        const res = funcList.filter(func => fn.match(func.def, args, strong));\r\n        if (res.length > 1) {\r\n            return undefined;\r\n        }\r\n\r\n        if (res.length === 1) {\r\n            return res[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n}","export { expression } from './expression';\r\nexport { fn } from './fn';\r\nexport { instruction } from './instruction';\r\nexport { types } from './types';\r\nexport { variable } from './variable';\r\n\r\n","import { EInstructionTypes, IInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport namespace instruction {\r\n    export const UNDEFINE_LENGTH: number = 0xffffff;\r\n    export const UNDEFINE_SIZE: number = 0xffffff;\r\n    export const UNDEFINE_PADDING: number = 0xffffff;\r\n    export const UNDEFINE_NAME: string = \"undef\";\r\n\r\n    export function isExpression(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_ConditionalExpr:\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n            case EInstructionTypes.k_BitwiseExpr:\r\n            case EInstructionTypes.k_InitExpr:\r\n            case EInstructionTypes.k_IdExpr:\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n            case EInstructionTypes.k_ComplexExpr:\r\n            case EInstructionTypes.k_CastExpr:\r\n            case EInstructionTypes.k_UnaryExpr:\r\n            case EInstructionTypes.k_RelationalExpr:\r\n            case EInstructionTypes.k_LogicalExpr:\r\n                // todo: add other types!!!\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    export function isStatement(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_Stmt:\r\n            case EInstructionTypes.k_DeclStmt:\r\n            case EInstructionTypes.k_ReturnStmt:\r\n            case EInstructionTypes.k_IfStmt:\r\n            case EInstructionTypes.k_StmtBlock:\r\n            case EInstructionTypes.k_ExprStmt:\r\n            case EInstructionTypes.k_WhileStmt:\r\n            case EInstructionTypes.k_ForStmt:\r\n            case EInstructionTypes.k_BreakStmt:\r\n            case EInstructionTypes.k_SemicolonStmt:\r\n                // todo: add other types!!!\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    export function isLiteral(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n            case EInstructionTypes.k_StringExpr:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { isDefAndNotNull } from \"@lib/util/s3d/type\";\r\nimport { instruction } from \"./instruction\";\r\nimport { variable } from \"./variable\";\r\n\r\nexport namespace types {\r\n\r\n    // todo: rename it\r\n    /** @deprecated */\r\n    export function isInheritedFromVariableDecl(type: ITypeInstruction): boolean {\r\n        if (isNull(type.parent)) {\r\n            return false;\r\n        }\r\n        const parentType = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableDecl) {\r\n            return true;\r\n        }\r\n        else if (parentType === EInstructionTypes.k_VariableType) {\r\n            return isInheritedFromVariableDecl(<IVariableTypeInstruction>type.parent);\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function isTypeOfField(type: ITypeInstruction): boolean {\r\n        if (isNull(type.parent)) {\r\n            return false;\r\n        }\r\n\r\n        if (type.parent.instructionType === EInstructionTypes.k_VariableDecl) {\r\n            let pParentDecl: IVariableDeclInstruction = <IVariableDeclInstruction>type.parent;\r\n            return pParentDecl.isField();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentContainer(type: IVariableTypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type) || !isTypeOfField(type)) {\r\n            return null;\r\n        }\r\n\r\n        let containerType: IVariableTypeInstruction = <IVariableTypeInstruction>findParentVariableDecl(type).parent;\r\n        if (!isInheritedFromVariableDecl(containerType)) {\r\n            return null;\r\n        }\r\n\r\n        return findParentVariableDecl(containerType);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentVariableDecl(type: ITypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        let parentType: EInstructionTypes = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableDecl) {\r\n            return <IVariableDeclInstruction>type.parent;\r\n        }\r\n\r\n        return findParentVariableDecl(<IVariableTypeInstruction>type.parent);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentVariableDeclName(type: ITypeInstruction): string {\r\n        let varDecl = findParentVariableDecl(type)\r\n        return isNull(varDecl) ? null : varDecl.name;\r\n    }\r\n\r\n\r\n\r\n    /** @deprecated */\r\n    export function finParentTypeDecl(type: ITypeInstruction): ITypeDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        let parentType = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_TypeDecl) {\r\n            return <ITypeDeclInstruction>type.parent;\r\n        }\r\n        return finParentTypeDecl(<ITypeInstruction>type.parent);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function finParentTypeDeclName(type: IVariableTypeInstruction): string {\r\n        let typeDecl = finParentTypeDecl(type);\r\n        return isNull(typeDecl) ? null : typeDecl.name;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function resolveVariableDeclFullName(type: ITypeInstruction): string {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            console.error(\"Not from variable decl\");\r\n            return null;\r\n        }\r\n\r\n        return variable.fullName(findParentVariableDecl(type));\r\n    }\r\n\r\n\r\n    // todo: add comment\r\n    // todo: review this code\r\n    /** @deprecated */\r\n    export function findMainVariable(type: ITypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        if (isTypeOfField(type)) {\r\n            return findMainVariable(<IVariableTypeInstruction>type.parent.parent);\r\n        }\r\n        return findParentVariableDecl(type);\r\n    }\r\n\r\n    //\r\n    // Signatures\r\n    //\r\n\r\n    function signatureVType(vtype: IVariableTypeInstruction, strong: boolean): string {\r\n        let prefix = '';\r\n        if (strong) {\r\n            if (vtype.usages.length > 0) {\r\n                prefix = `${vtype.usages.join('_')}_`;\r\n            }\r\n        }\r\n        let postfix = '';\r\n        if (vtype.isNotBaseArray()) {\r\n            postfix = '[]';\r\n            if (vtype.length !== instruction.UNDEFINE_LENGTH) {\r\n                postfix = `[${vtype.length}]`;\r\n            }\r\n        }\r\n        // skip all variable type wrappers\r\n        // is it safe?\r\n        let subType = vtype.subType;\r\n        while (subType.instructionType == EInstructionTypes.k_VariableType)\r\n            subType = (<IVariableTypeInstruction>subType).subType;\r\n        return `${prefix}${signature(subType)}${postfix}`;\r\n    }\r\n\r\n\r\n    // function signatureVTypeRelaxed(vtype: IVariableTypeInstruction)\r\n\r\n\r\n    export function signature(type: ITypeInstruction, strong: boolean = false): string {\r\n        if (!isDefAndNotNull(type)) {\r\n            assert(!strong);\r\n            return '*';\r\n        }\r\n        switch (type.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return signatureVType(<IVariableTypeInstruction>type, strong);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return `${type.name}${type.instructionID}`;\r\n            case EInstructionTypes.k_ProxyType:\r\n                return type.baseType ? signature(type.baseType) : type.name;\r\n            case EInstructionTypes.k_SystemType:\r\n                return type.name;\r\n            default:\r\n                assert(false, 'unsupported type');\r\n                return null;\r\n        }\r\n    }\r\n\r\n    // export function relaxType(type: ITypeInstruction): ITypeInstruction | RegExp {\r\n    //     if (!type) {\r\n    //         return null;\r\n    //     }\r\n\r\n\r\n    //     if (types.equals(type, T_INT) || types.equals(type, T_UINT)) {\r\n    //         // temp workaround in order to match int to uint and etc. \r\n    //         return /^int$|^uint$/g;\r\n    //     }\r\n\r\n    //     return type;\r\n    // }\r\n\r\n\r\n    // // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    // export function asRelaxedType(instr: ITypedInstruction): ITypeInstruction | RegExp {\r\n    //     if (!instr) {\r\n    //         return null;\r\n    //     }\r\n\r\n    //     return relaxType(instr.type);\r\n    // };\r\n\r\n    //\r\n    // hash\r\n    //\r\n\r\n    function hashVType(vtype: IVariableTypeInstruction, strong: boolean): string {\r\n        let postfix = '';\r\n        if (strong ? vtype.isArray() : vtype.isNotBaseArray()) {\r\n            postfix = '[]';\r\n            if (vtype.length !== instruction.UNDEFINE_LENGTH) {\r\n                postfix = `[${vtype.length}]`;\r\n            }\r\n        }\r\n\r\n        return `${hash(vtype.subType)}${postfix}`;\r\n    }\r\n\r\n    function hashComplex(ctype: ITypeInstruction, strong: boolean): string {\r\n        return `{${ctype.fields.map(field => hash(field.type, strong)).join(';')}}`;\r\n    }\r\n\r\n    export function hash(type: ITypeInstruction, strong: boolean = false): string {\r\n        switch (type.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return hashVType(<IVariableTypeInstruction>type, strong);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return hashComplex(type, strong);\r\n            case EInstructionTypes.k_ProxyType:\r\n                return type.baseType ? hash(type.baseType) : type.name;\r\n            case EInstructionTypes.k_SystemType:\r\n                return type.name;\r\n            default:\r\n                assert(false, 'unsupported type');\r\n                return null;\r\n        }\r\n    }\r\n\r\n    export function compareRelaxed(a: ITypeInstruction, b: ITypeInstruction, strong: boolean = false): boolean {\r\n        return hash(a, strong) === hash(b, strong);\r\n    }\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function compare(a: ITypeInstruction | RegExp, b: ITypeInstruction | RegExp, strong: boolean = false): boolean {\r\n        if (isNull(a) || isNull(b)) {\r\n            return false;\r\n        }\r\n\r\n        if (a instanceof RegExp && b instanceof RegExp) {\r\n            assert(false);\r\n            return false;\r\n        }\r\n\r\n        if (a instanceof RegExp) {\r\n            let ra = <RegExp>a;\r\n            let sb = signature(<ITypeInstruction>b, strong);\r\n            return !!sb.match(ra);\r\n        }\r\n\r\n        if (b instanceof RegExp) {\r\n            let sa = signature(<ITypeInstruction>a, strong);\r\n            let rb = <RegExp>b;\r\n            return !!sa.match(rb);\r\n        }\r\n\r\n        let ta = <ITypeInstruction>a;\r\n        let tb = <ITypeInstruction>b;\r\n        if (ta.isArray() && tb.isArray()) {\r\n            if (ta.length === instruction.UNDEFINE_LENGTH ||\r\n                tb.length === instruction.UNDEFINE_LENGTH) {\r\n                \r\n                // wnen both types are undefined is valid \r\n                if (ta.length !== tb.length) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return signature(ta, strong) === signature(tb, strong);\r\n    }\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function equals(a: ITypeInstruction | RegExp, b: ITypeInstruction | RegExp, strong: boolean = false): boolean {\r\n        return compare(a, b, strong);\r\n    }\r\n\r\n    //\r\n    // utils\r\n    //\r\n\r\n    export function alignSize(size: number, aligment: number): number {\r\n        if (size === instruction.UNDEFINE_SIZE) {\r\n            return size;\r\n        }\r\n        \r\n        const unaligned = size % aligment;\r\n        return unaligned !== 0 ? size + aligment - unaligned : size;\r\n    }\r\n}\r\n","import { assert } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDefInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { types } from \"./types\";\r\n\r\nexport namespace variable {\r\n    /**\r\n     * @param decl Variable declaraion (decl.isParameter() must be true).\r\n     * @returns Serial number of the declaration among the function parameters or -1 otherwise.\r\n     */\r\n    export function parameterIndex(decl: IVariableDeclInstruction): number {\r\n        if (!decl.isParameter()) {\r\n            console.error('invalid call.');\r\n            return -1;\r\n        }\r\n        // all parameters must be a children on function definition!\r\n        assert(decl.parent.instructionType === EInstructionTypes.k_FunctionDef);\r\n        return (<IFunctionDefInstruction>decl.parent).params.indexOf(decl);\r\n    }\r\n\r\n    /**\r\n     * @returns Offset in bytes from the beginning of the parameters' list.\r\n     */\r\n    export function parameterOffset(decl: IVariableDeclInstruction): number {\r\n        // todo: add support for 'inout', 'out' usages \r\n        if (!decl.isParameter()) {\r\n            console.error('invalid call.');\r\n            return 0;\r\n        }\r\n\r\n        let idx = parameterIndex(decl);\r\n        let offset = 0;\r\n        for (let i = 0; i < idx; ++i) {\r\n            offset += (<IFunctionDefInstruction>decl.parent).params[i].type.size;\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    /**\r\n     * Helper:\r\n     *  Returns 'structName.fieldName' for structs;\r\n     *  Returns 'varName' for variables;\r\n     */\r\n    export function fullName(decl: IVariableDeclInstruction) {\r\n        if (decl.isField() &&\r\n            types.findParentVariableDecl(<IVariableTypeInstruction>decl.parent)) {\r\n\r\n            let name = '';\r\n            let parentType = decl.parent.instructionType;\r\n\r\n            if (parentType === EInstructionTypes.k_VariableType) {\r\n                name = types.resolveVariableDeclFullName(<IVariableTypeInstruction>decl.parent);\r\n            }\r\n\r\n            name += '.' + decl.name;\r\n            return name;\r\n        }\r\n        return decl.name;\r\n    }\r\n}","import { EInstructionTypes, IAnnotationInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IAnnotationSettings extends IInstructionSettings {\r\n    decls: IVariableDeclInstruction[];\r\n}\r\n\r\nexport class AnnotationInstruction extends Instruction implements IAnnotationInstruction {\r\n    \r\n    readonly decls: IVariableDeclInstruction[];\r\n\r\n    constructor({ decls, ...settings }: IAnnotationSettings) {\r\n        super({ instrType: EInstructionTypes.k_Annotation, ...settings });\r\n\r\n        this.decls = decls;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IArithmeticOperator, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IArithmeticExprInstructionSettings extends IExprInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: IArithmeticOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr + / - * % someExpr\r\n * (+|-|*|/|%) Instruction Instruction\r\n */\r\nexport class ArithmeticExprInstruction extends ExprInstruction implements IArithmeticExprInstruction {\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n    protected _operator: IArithmeticOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IArithmeticExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ArithmeticExpr, ...settings });\r\n\r\n        this._leftOperand = Instruction.$withParent(left, this);\r\n        this._rightOperand = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n    get operator(): IArithmeticOperator {\r\n        return this._operator;\r\n    }\r\n\r\n    toCode(): string {\r\n        var sCode: string = \"\";\r\n        sCode += this._leftOperand.toCode();\r\n        sCode += ` ${this.operator} `;\r\n        sCode += this._rightOperand.toCode();\r\n        return sCode;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return this.left.isConst() && this.right.isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IAssignmentExprInstruction, IExprInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type AssigmentOperator = \"=\" | \"+=\" | \"-=\" | \"/=\" | \"*=\" | \"%=\" | \"|=\" | \"&=\" | \">>=\" | \"<<=\" | \"^=\";\r\n\r\nexport interface IAssignmentExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: ITypedInstruction;\r\n    operator: AssigmentOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr = += -= /= *= %= someExpr\r\n * (=|+=|-=|*=|/=|%=) Instruction Instruction\r\n */\r\nexport class AssignmentExprInstruction extends ExprInstruction implements IAssignmentExprInstruction {\r\n    protected _leftValue: IExprInstruction;\r\n    protected _rightValue: ITypedInstruction;\r\n    protected _operator: AssigmentOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IAssignmentExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_AssignmentExpr, type: left.type, ...settings });\r\n\r\n        this._leftValue = Instruction.$withParent(left, this);\r\n        this._rightValue = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftValue;\r\n    }\r\n\r\n    get right(): ITypedInstruction {\r\n        return this._rightValue;\r\n    }\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n        code += this.left.toCode();\r\n        code += this.operator;\r\n        code += this.right.toCode();\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IAttributeInstruction, IInstruction, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IAttributeInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    args?: ILiteralInstruction<boolean | number>[];\r\n}\r\n\r\n/**\r\n * Represent attributes:\r\n *  [numthreads(1, 2, 3)]\r\n *  [loop]\r\n *  [branch]\r\n */\r\nexport class AttributeInstruction extends Instruction implements IAttributeInstruction {\r\n    \r\n    readonly name: string;\r\n    readonly args: ILiteralInstruction<number | boolean>[];\r\n\r\n    constructor({ name, args = null, ...settings }: IAttributeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Attribute, ...settings });\r\n\r\n        this.name = name;\r\n        this.args = args;\r\n    }    \r\n\r\n    toCode(): string {\r\n        return `[${this.name}${ this.args.length > 0 ? `(${this.args.map(arg => arg.toCode()).join(', ')})`: `` }]`;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IBitwiseExprInstruction, IBitwiseOperator, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IBitwiseExprInstructionSettings extends IExprInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: IBitwiseOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr >> << | & ^ someExpr\r\n * (>>,<<,|,&,^) Instruction Instruction\r\n */\r\nexport class BitwiseExprInstruction extends ExprInstruction implements IBitwiseExprInstruction {\r\n    readonly left: IExprInstruction;\r\n    readonly right: IExprInstruction;\r\n    readonly operator: IBitwiseOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IBitwiseExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BitwiseExpr, ...settings });\r\n\r\n        this.left = Instruction.$withParent(left, this);\r\n        this.right = Instruction.$withParent(right, this);\r\n        this.operator = operator;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return `${this.left.toCode()} ${this.operator} ${this.right.toCode()}`;\r\n    }\r\n\r\n    // FIXME: use isConstExpr instead!\r\n    isConst(): boolean {\r\n        return this.left.isConst() && this.right.isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_BOOL } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IBoolInstructionSettings extends IInstructionSettings {\r\n    value: boolean;\r\n}\r\n\r\nexport class BoolInstruction extends ExprInstruction implements ILiteralInstruction<boolean> {\r\n    readonly value: boolean;\r\n\r\n    constructor({ value, scope, ...settings }: IBoolInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BoolExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_BOOL, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n    }\r\n\r\n    \r\n    toString(): string {\r\n        return String(this.value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.value ? \"true\" : \"false\";\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { StmtInstruction } from \"@lib/fx/analisys/instructions/StmtInstruction\";\r\n\r\nexport type BreakOperator = \"break\" | \"discard\";\r\n\r\nexport interface IBreakStmtInstructionSettings extends IInstructionSettings {\r\n    operator?: BreakOperator;\r\n}\r\n\r\n/**\r\n * Reprsernt continue; break; discard;\r\n * (continue || break || discard) \r\n */\r\nexport class BreakStmtInstruction extends StmtInstruction {\r\n    protected _operator: BreakOperator;\r\n\r\n    constructor({ operator = \"break\", ...settings }: IBreakStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BreakStmt, ...settings });\r\n        this._operator = operator;\r\n    }\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n    // todo: validate operator's name\r\n    toCode(): string {\r\n        console.assert(this.operator == \"break\");\r\n        return this.operator + \";\";\r\n    }\r\n}\r\n","import { types } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, ICastExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ICastExprInstructionSettings extends IExprInstructionSettings {\r\n    sourceExpr: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent (type) expr\r\n * EMPTY_OPERATOR VariableTypeInstruction Instruction\r\n */\r\nexport class CastExprInstruction extends ExprInstruction implements ICastExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n\r\n    constructor({ sourceExpr, ...settings }: ICastExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CastExpr, ...settings });\r\n        this.expr = Instruction.$withParent(sourceExpr, this);\r\n    }\r\n\r\n    toCode(): string {\r\n        return `(${this.type.toCode()})(${this.expr.toCode()})`;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isUseless() {\r\n        return types.equals(this.type, this.expr.type);\r\n    }\r\n    \r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n","import { EInstructionTypes, ICbufferInstruction, IIdInstruction, ITypeInstruction, IVariableTypeInstruction, IRegister } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\nimport { variable } from \"../helpers\";\r\n\r\nexport interface ICbufferDeclInstructionSettings extends IDeclInstructionSettings {\r\n    id: IIdInstruction;\r\n    type: ITypeInstruction;\r\n}\r\n\r\nexport class CbufferInstruction extends DeclInstruction implements ICbufferInstruction {\r\n    protected _id: IIdInstruction;\r\n    protected _type: ITypeInstruction;\r\n\r\n    constructor({ id, type, ...settings }: ICbufferDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CbufferDecl, ...settings });\r\n\r\n        this._id = Instruction.$withParent(id, this);\r\n        this._type = Instruction.$withParent(type, this);\r\n    }\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n    get name(): string {\r\n        return this.id.name;\r\n    }\r\n\r\n    get type(): ITypeInstruction {\r\n        return this._type;\r\n    }\r\n}\r\n","import { EInstructionTypes, ICompileExprInstruction, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\n\r\nexport interface ICompileExprInstructionSettings extends IExprInstructionSettings {\r\n    operand: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n/**\r\n * Represents compile vs_func(...args)\r\n * compile IdExprInstruction ExprInstruction ... ExprInstruction\r\n */\r\n/** @deprecated */\r\nexport class CompileExprInstruction extends ExprInstruction implements ICompileExprInstruction {\r\n    protected _operand: IFunctionDeclInstruction;\r\n    protected _args: IExprInstruction[];\r\n\r\n\r\n    constructor({ operand, args = null, ...settings }: ICompileExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CompileExpr, ...settings });\r\n\r\n        this._operand = operand;//Instruction.$withParent(operand, this);\r\n        this._args = args;//(args || []).map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n\r\n    \r\n    get function(): IFunctionDeclInstruction {\r\n        return <IFunctionDeclInstruction>this._operand;\r\n    }\r\n\r\n    \r\n    get args(): IExprInstruction[] {\r\n        return this._args;\r\n    }\r\n}\r\n","import { EInstructionTypes, ICompileShader11Instruction, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ICompileShader11InstructionSettings extends IExprInstructionSettings {\r\n    ver: string;\r\n    func: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n/**\r\n * Represents CompileShader( vs_4_0_level_9_1, RenderSceneVS( 1, true, true ) )\r\n */\r\nexport class CompileShader11Instruction extends ExprInstruction implements ICompileShader11Instruction {\r\n    readonly ver: string;\r\n    readonly func: IFunctionDeclInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    constructor({ ver, func, args, ...settings }: ICompileShader11InstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CompileShader11Expr, ...settings });\r\n\r\n        this.func = Instruction.$withNoParent(func);\r\n        this.ver = ver;\r\n        this.args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { EInstructionTypes, IComplexExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IComplexExprInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent (expr)\r\n * EMPTY_OPERATOR ExprInstruction\r\n */\r\nexport class ComplexExprInstruction extends ExprInstruction implements IComplexExprInstruction {\r\n    protected _expr: IExprInstruction;\r\n\r\n\r\n    constructor({ expr, ...settings }: IComplexExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ComplexExpr, type: expr.type, ...settings });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    \r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return \"(\" + this.expr.toCode() + \")\";\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n","import { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { instruction, types } from \"../helpers\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IComplexTypeInstructionSettings extends IInstructionSettings {\r\n    name?: string;\r\n    fields: IVariableDeclInstruction[]; // << todo: replace this Array<Instruction>;\r\n    aligment?: number;\r\n}\r\n\r\n// todo: merge with system tpye ?\r\nexport class ComplexTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _name: string;\r\n    protected _fields: IMap<IVariableDeclInstruction>;\r\n    protected _aligment: number;\r\n\r\n    constructor({ name = null, fields, aligment = 1 /* byte */, ...settings }: IComplexTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ComplexType, ...settings });\r\n\r\n        this._name = name;\r\n        this._fields = {};\r\n        this._aligment = aligment;\r\n\r\n        this.addFields(fields.filter(field => !isNull(field)).map(field => Instruction.$withParent(field, this)));\r\n    }\r\n\r\n    \r\n    get writable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    get readable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    get size(): number {\r\n        return this.calculatePaddings(false);\r\n    }\r\n\r\n\r\n    get aligment(): number {\r\n        return this._aligment;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this;\r\n    }\r\n\r\n    \r\n    get arrayElementType(): ITypeInstruction {\r\n        return null;\r\n    }\r\n\r\n    \r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n    \r\n    get length(): number {\r\n        return 0;\r\n    }\r\n\r\n    \r\n    get fields(): IVariableDeclInstruction[] {\r\n        return Object.values(this._fields);\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return [];\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this.name || types.hash(this);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        var code: string = \"struct \" + this._name + \"{\";\r\n\r\n        for (var i: number = 0; i < this.fields.length; i++) {\r\n            code += \"\\t\" + this.fields[i].toCode() + \";\\n\";\r\n        }\r\n\r\n        code += \"}\";\r\n\r\n        return code;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    isArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isNotBaseArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isComplex(): boolean {\r\n        return true;\r\n    }\r\n\r\n\r\n    private addField(variable: IVariableDeclInstruction): void {\r\n        this._fields[variable.name] = variable;\r\n    }\r\n\r\n    private addFields(fields: IVariableDeclInstruction[]): void {\r\n        for (var i = 0; i < fields.length; i++) {\r\n            this.addField(fields[i]);\r\n        }\r\n\r\n        this.calculatePaddings();\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return !!this.getFieldBySemantics(semantic);\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this._fields[fieldName] || null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return null;\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            if (semantic == field.semantic) {\r\n                return field;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            let semantic = field.semantic;\r\n            if (semantic == null || semantic == '') {\r\n                return true;\r\n            }\r\n            if (field.type.hasFieldWithoutSemantics()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        let fieldBySemantics: IMap<IVariableDeclInstruction> = {};\r\n\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            let semantic = field.semantic;\r\n            \r\n            if (isDefAndNotNull(fieldBySemantics[semantic])) {\r\n                return false;\r\n            }\r\n\r\n            fieldBySemantics[semantic] = field;\r\n\r\n            if (field.type.isComplex() && !field.type.hasAllUniqueSemantics()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    private calculatePaddings(override = true): number {\r\n        const aligment = this._aligment;\r\n        let padding = 0;\r\n\r\n        let aligned = (offset, align) => (offset + (align - 1)) & ~(align - 1);\r\n\r\n        for (let i = 0; i < this.fields.length; i++) {\r\n            const varType = this.fields[i].type;\r\n            const varSize = varType.size;\r\n\r\n            if (varSize === instruction.UNDEFINE_SIZE) {\r\n                assert(false, 'cannot calc padding');\r\n                return instruction.UNDEFINE_SIZE;\r\n            }\r\n\r\n            let a = aligned(padding, aligment);\r\n            let b = aligned(padding + varSize, aligment);\r\n            if (b > a) {\r\n                padding = a;   \r\n            }\r\n            if (override)\r\n                varType.$overwritePadding(padding, aligment);\r\n            padding += varSize;   \r\n        }\r\n\r\n        return aligned(padding, aligment);\r\n    }\r\n}\r\n","import { EInstructionTypes, IConditionalExprInstruction, IExprInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types } from '@lib/fx/analisys/helpers';\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IConditionalExprInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    left: ITypedInstruction;\r\n    right: ITypedInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represen boolExpr ? someExpr : someExpr\r\n * EMPTY_OPERATOR Instruction Instruction Instruction \r\n */\r\nexport class ConditionalExprInstruction extends ExprInstruction implements IConditionalExprInstruction {\r\n    protected _cond: IExprInstruction;\r\n    protected _leftValue: ITypedInstruction;\r\n    protected _rightValue: ITypedInstruction;\r\n\r\n    constructor({ cond, left, right, ...settings }: IConditionalExprInstructionSettings) {\r\n        // todo: do not use {left.type} here\r\n        super({ instrType: EInstructionTypes.k_ConditionalExpr, type: left.type, ...settings});\r\n\r\n        console.assert(types.equals(left.type, right.type));\r\n        \r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._leftValue = Instruction.$withParent(left, this);\r\n        this._rightValue = Instruction.$withParent(right, this);\r\n    }\r\n\r\n\r\n    get condition(): IExprInstruction {\r\n        return this._cond;\r\n    }\r\n\r\n    \r\n    get left(): ITypedInstruction {\r\n        return this._leftValue;\r\n    }\r\n\r\n\r\n    get right(): ITypedInstruction {\r\n        return this._rightValue;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '(';\r\n        code += this.condition.toCode();\r\n        code += '?';\r\n        code += this.left.toCode();\r\n        code += ':';\r\n        code += this.right.toCode();\r\n        code += ')';\r\n        return code;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.condition).isConst() &&\r\n            (<IExprInstruction>this.left).isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, IConstructorCallInstruction, IExprInstruction, IInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IConstructorCallInstructionSettings extends IInstructionSettings {\r\n    ctor: IVariableTypeInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Resresnt ctor(arg1,..., argn)\r\n * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction \r\n */\r\nexport class ConstructorCallInstruction extends ExprInstruction implements IConstructorCallInstruction {\r\n    protected _args: IInstruction[];\r\n    protected _ctor: IVariableTypeInstruction;\r\n    \r\n\r\n    constructor({ ctor, args = null, ...settings }: IConstructorCallInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ConstructorCallExpr, type: ctor.subType, ...settings });\r\n\r\n        this._args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n        this._ctor = Instruction.$withParent(ctor, this);\r\n    }\r\n\r\n    \r\n    get args() : IInstruction[] {\r\n        return this._args;\r\n    }\r\n\r\n    \r\n    get ctor(): IVariableTypeInstruction {\r\n        return this._ctor;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n\r\n        code += this.ctor.toCode();\r\n        code += \"(\";\r\n\r\n        for (var i: number = 0; i < this.args.length; i++) {\r\n            code += this.args[i].toCode();\r\n            if (i !== this.args.length - 1) {\r\n                code += \",\";\r\n            }\r\n        }\r\n\r\n        code += \")\";\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        for (var i: number = 0; i < this.args.length; i++) {\r\n            if (!(<IExprInstruction>this.args[i]).isConst()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, IAnnotationInstruction, IDeclInstruction, IIdInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IDeclInstructionSettings extends IInstructionSettings {\r\n    readonly semantic?: string;\r\n    readonly annotation?: IAnnotationInstruction;\r\n}\r\n\r\n\r\nexport class DeclInstruction extends Instruction implements IDeclInstruction {\r\n    protected _semantic: string\r\n    protected _annotation: IAnnotationInstruction;\r\n    \r\n    constructor({ semantic = null, annotation = null, ...settings }: IDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Decl, ...settings });\r\n\r\n        this._semantic = semantic;\r\n        this._annotation = Instruction.$withParent(annotation, this);\r\n    }\r\n\r\n\r\n    get semantic(): string {\r\n        return this._semantic;\r\n    }\r\n\r\n\r\n    get annotation(): IAnnotationInstruction {\r\n        return this._annotation;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return null;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return null;\r\n    }\r\n}\r\n","import { EInstructionTypes, IDeclInstruction, IDeclStmtInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IDeclStmtInstructionSettings extends IInstructionSettings {\r\n    declList?: IDeclInstruction[];\r\n}\r\n\r\n/**\r\n * Represent TypeDecl or VariableDecl or VarStructDecl\r\n * EMPTY DeclInstruction\r\n */\r\nexport class DeclStmtInstruction extends StmtInstruction implements IDeclStmtInstruction {\r\n    private _declList: IDeclInstruction[];\r\n\r\n    \r\n    constructor({ declList = null, ...settings }: IDeclStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_DeclStmt, ...settings });\r\n        \r\n        this._declList = (declList || []).map(decl => Instruction.$withParent(decl, this));\r\n    }\r\n\r\n\r\n    get declList(): IDeclInstruction[] {\r\n        return this._declList;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code = '';\r\n        var declList = <IVariableDeclInstruction[]>this.declList;\r\n\r\n        for (var i: number = 0; i < this.declList.length; i++) {\r\n            code += declList[i].toCode() + \";\\n\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n\r\n\r\n\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { ITypedInstructionSettings, TypedInstruction } from \"@lib/fx/analisys/instructions/TypedInstruction\";\r\nimport { EInstructionTypes, IAssignmentExprInstruction, IComplexExprInstruction, IExprInstruction, IIdExprInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IExprInstructionSettings extends ITypedInstructionSettings {\r\n    \r\n}\r\n\r\nexport class ExprInstruction extends TypedInstruction implements IExprInstruction {\r\n    protected _evalResult: any;\r\n\r\n    constructor({ ...settings }: ITypedInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Expr, ...settings });\r\n        this._evalResult = null;\r\n    }\r\n\r\n    get type(): IVariableTypeInstruction {\r\n        return <IVariableTypeInstruction>super.type;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        // console.error(\"@pure_virtual\");\r\n        return false;\r\n    }\r\n\r\n    isConstExpr(): boolean {\r\n        // todo: implement it properly\r\n        return true;\r\n    }\r\n}\r\n","import { IInstructionSettings, Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { StmtInstruction } from \"@lib/fx/analisys/instructions/StmtInstruction\";\r\nimport { EInstructionTypes, IExprInstruction, IExprStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IExprStmtInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n/**\r\n * Represent expr;\r\n * EMPTY_OPERTOR ExprInstruction \r\n */\r\nexport class ExprStmtInstruction extends StmtInstruction implements IExprStmtInstruction {\r\n    protected _expr: IExprInstruction;\r\n\r\n    constructor({ expr, ...settings }: IExprStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ExprStmt, ...settings });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n    toCode(): string {\r\n        return (this._expr ? this._expr.toCode() : '') + ';';\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_FLOAT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IFloatInstructionSettings extends IInstructionSettings {\r\n    value: number;\r\n}\r\n\r\nexport class FloatInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n    readonly value: number;\r\n    /**\r\n     * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n     */\r\n    constructor({ value, scope, ...settings }: IFloatInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FloatExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_FLOAT, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n    }\r\n\r\n    \r\n    toString(): string {\r\n        return String(this.value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return `${this.value}${this.value % 1 === 0? '.': ''}`;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EAnalyzerErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { ECheckStage, EInstructionTypes, IExprInstruction, IForStmtInstruction, IStmtInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IForStmtInstructionSettings extends IInstructionSettings {\r\n    init?: ITypedInstruction;\r\n    cond?: IExprInstruction;\r\n    step?: IExprInstruction;\r\n    body?: IStmtInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent for(forInit forCond ForStep) stmt\r\n * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction\r\n */\r\nexport class ForStmtInstruction extends StmtInstruction implements IForStmtInstruction {\r\n    protected _init: ITypedInstruction;\r\n    protected _cond: IExprInstruction;\r\n    protected _step: IExprInstruction;\r\n    protected _body: IStmtInstruction;\r\n\r\n    constructor({ init = null, cond = null, step = null, body = null, ...settings }: IForStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ForStmt, ...settings });\r\n\r\n        this._init = Instruction.$withParent(init, this);\r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._step = Instruction.$withParent(step, this);\r\n        this._body = Instruction.$withParent(body, this);\r\n    }\r\n\r\n\r\n    get init(): ITypedInstruction {\r\n        return this._init;\r\n    }\r\n\r\n\r\n    get cond(): IExprInstruction {\r\n        return this._cond;\r\n    }\r\n\r\n\r\n    get step(): IExprInstruction {\r\n        return this._step;\r\n    }\r\n\r\n\r\n    get body(): IStmtInstruction {\r\n        return this._body;\r\n    }\r\n\r\n    toCode(): string {\r\n        var code: string = \"for(\";\r\n\r\n        code += this._init.toCode() + \";\";\r\n        code += this._cond.toCode() + \";\";\r\n        code += this._step.toCode() + \")\";\r\n        code += this._body.toCode();\r\n\r\n        return code;\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IFunctionCallInstructionSettings extends IExprInstructionSettings {\r\n    decl: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n    callee?: IExprInstruction;\r\n}\r\n\r\n/**\r\n * Respresnt func(arg1,..., argn)\r\n * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction \r\n */\r\nexport class FunctionCallInstruction extends ExprInstruction implements IFunctionCallInstruction {\r\n    readonly callee: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    // helpers\r\n    readonly decl: IFunctionDeclInstruction; // << move to resolveDecl() method.\r\n    \r\n    constructor({ decl, args, callee, ...settings }: IFunctionCallInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionCallExpr, ...settings });\r\n        \r\n        this.callee = callee;\r\n        this.args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n        this.decl = decl;\r\n    }\r\n\r\n\r\n\r\n    toCode(): string {\r\n        const { callee, decl: { def }, args } = this;\r\n        return `${callee ? callee.toCode() + '.' : ''}${def.id.toCode()}(${args.map(arg => arg.toCode()).join(',')})`;\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IAttributeInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdInstruction, IStmtBlockInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IFunctionDeclInstructionSettings extends IDeclInstructionSettings {\r\n    def: IFunctionDefInstruction;\r\n    impl?: IStmtBlockInstruction;\r\n    attrs?: IAttributeInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]\r\n * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction\r\n */\r\nexport class FunctionDeclInstruction extends DeclInstruction implements IFunctionDeclInstruction {\r\n    readonly def: IFunctionDefInstruction;\r\n    readonly impl: IStmtBlockInstruction;\r\n    readonly attrs: IAttributeInstruction[];\r\n    \r\n\r\n    constructor({ def, impl = null, attrs = null, ...settings }: IFunctionDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionDecl, ...settings });\r\n\r\n        this.def = Instruction.$withParent(def, this);\r\n        this.impl = Instruction.$withParent(impl, this);\r\n        this.attrs = (attrs || []).map(attr => Instruction.$withParent(attr, this));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.def.name;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this.def.id;\r\n    }\r\n\r\n\r\n    get semantic(): string {\r\n        return this.def.semantic;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code = '';\r\n        code += this.def.toCode();\r\n        if (this.impl) {\r\n            code += this.impl.toCode();\r\n        } else {\r\n            code += ';';\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","import { DeclInstruction, IDeclInstructionSettings } from \"@lib/fx/analisys/instructions/DeclInstruction\";\r\nimport { Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { EInstructionTypes, IFunctionDefInstruction, IIdInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { fn, types } from \"@lib/fx/analisys/helpers\";\r\n\r\nexport interface IFunctionDefInstructionSettings extends IDeclInstructionSettings {\r\n    returnType: IVariableTypeInstruction;\r\n    id: IIdInstruction;\r\n    paramList?: IVariableDeclInstruction[];\r\n}\r\n\r\n/**\r\n * Represent type func(...args)[:Semantic]\r\n * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction\r\n */\r\nexport class FunctionDefInstruction extends DeclInstruction implements IFunctionDefInstruction {\r\n    readonly params: IVariableDeclInstruction[];\r\n    readonly returnType: IVariableTypeInstruction;\r\n    \r\n    protected _id: IIdInstruction;\r\n\r\n    constructor({ returnType, id, paramList = [], ...settings }: IFunctionDefInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionDef, ...settings });\r\n\r\n        this.params = paramList.map(param => Instruction.$withParent(param, this));\r\n        this.returnType = Instruction.$withParent(returnType, this);\r\n        this._id = Instruction.$withParent(id, this);\r\n    }\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n    \r\n\r\n    get name(): string {\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        let def = types.signature(this.returnType) + \" \" + this.name + \"(\";\r\n\r\n        for (let i: number = 0; i < this.params.length; i++) {\r\n            def += types.signature(this.params[i].type) + \",\";\r\n        }\r\n\r\n        def += \")\";\r\n        // TODO: add semantic\r\n        return def;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        const { _id: id, returnType, params } = this;\r\n        return `${returnType.toCode()} ${id.toCode()}(${params.map(param => param.toCode()).join(', ')})`;\r\n    }\r\n}\r\n","import { EInstructionTypes, IIdExprInstruction, IIdInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IIdExprInstructionSettings extends IInstructionSettings {\r\n    id: IIdInstruction;\r\n    decl: IVariableDeclInstruction;\r\n}\r\n\r\n\r\nexport class IdExprInstruction extends ExprInstruction implements IIdExprInstruction {\r\n    readonly id: IIdInstruction;\r\n    // helpers\r\n    readonly decl: IVariableDeclInstruction; // << move to resolveDecl() method.\r\n\r\n    constructor({ id, decl, ...settings }: IIdExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IdExpr, type: decl.type, ...settings });\r\n\r\n        this.id = Instruction.$withParent(id, this);\r\n        this.decl = decl;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.id.name;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.type.isConst();\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this.decl.id.toCode();\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IIdInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IIdInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n}\r\n\r\nexport class IdInstruction extends Instruction implements IIdInstruction {\r\n    readonly name: string;\r\n\r\n    constructor({ name, ...settings }: IIdInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Id, ...settings });\r\n        this.name = name;\r\n    }\r\n    \r\n    \r\n    toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.name;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IAttributeInstruction, IExprInstruction, IIfStmtInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IIfStmtInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    conseq: IStmtInstruction;\r\n    contrary?: IStmtInstruction;\r\n    attrs?: IAttributeInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent if(expr) stmt or if(expr) stmt else stmt\r\n * ( if || if_else ) Expr Stmt [Stmt]\r\n */\r\nexport class IfStmtInstruction extends StmtInstruction implements IIfStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly conseq: IStmtInstruction;\r\n    readonly contrary: IStmtInstruction;\r\n    readonly attrs: IAttributeInstruction[];\r\n    \r\n    constructor({ cond, conseq, attrs = null, contrary = null, ...settings }: IIfStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IfStmt, ...settings });\r\n\r\n        this.cond = Instruction.$withParent(cond, this);\r\n        this.conseq = Instruction.$withParent(conseq, this);\r\n        this.contrary = Instruction.$withParent(contrary, this);\r\n        this.attrs = (attrs || []).map(attr => Instruction.$withParent(attr, this));\r\n    }\r\n\r\n\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n        if (isNull(this.contrary)) {\r\n            code += \"if(\";\r\n            code += this.cond.toCode() + \")\";\r\n            code += this.conseq.toCode();\r\n        }\r\n        else {\r\n            code += \"if(\";\r\n            code += this.cond.toCode() + \") \";\r\n            code += this.conseq.toCode();\r\n            code += \"else \";\r\n            code += this.contrary.toCode();\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { instruction, types } from \"@lib/fx/analisys/helpers\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, EScopeType, IExprInstruction, IInitExprInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represents:\r\n *   int a[3] = { 1, 2, 3 };\r\n *              -----------\r\n */\r\n\r\nexport interface IInitExprInstructionSettings extends IExprInstructionSettings {\r\n    type: IVariableTypeInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\nexport class InitExprInstruction extends ExprInstruction implements IInitExprInstruction {\r\n    private _args: IExprInstruction[];\r\n\r\n    constructor({ type, args = [], ...settings }: IInitExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_InitExpr, type, ...settings });\r\n        this._args = args.map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n\r\n\r\n    get args(): IExprInstruction[] {\r\n        return this._args;\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return this.type.isNotBaseArray();\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code: string = '';\r\n\r\n        if (!isNull(this.type)) {\r\n            code += this.type.toCode();\r\n        }\r\n        code += \"(\";\r\n\r\n        for (let i: number = 0; i < this.args.length; i++) {\r\n            code += this.args[i].toCode();\r\n\r\n            if (i !== this.args.length - 1) {\r\n                code += \",\";\r\n            }\r\n        }\r\n\r\n        code += \")\";\r\n\r\n        return code;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        let bConst: boolean;\r\n        let args: IExprInstruction[] = <IExprInstruction[]>this.args;\r\n\r\n        for (let i: number = 0; i < args.length; i++) {\r\n            if (!args[i].isConst()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param type The type of the variable for which the initializer was created.\r\n     */\r\n    // TODO: move it to Analysis.ts\r\n    optimizeForVariableType(type: IVariableTypeInstruction): boolean {\r\n        // It's a global user defined array or just not unit array;\r\n        // Trying to exclude types like float1.\r\n        if ((type.isNotBaseArray() && type.scope.type <= EScopeType.k_Global) ||\r\n            (type.isArray() && this.args.length > 1)) {\r\n\r\n            if (type.length === instruction.UNDEFINE_LENGTH ||\r\n                (type.isNotBaseArray() && this.args.length !== type.length) ||\r\n                (!type.isNotBaseArray() && this.args.length !== type.baseType.length)) {\r\n                return false;\r\n            }\r\n\r\n            let arrayElementType = <IVariableTypeInstruction>type.arrayElementType;\r\n\r\n            for (let i = 0; i < this.args.length; i++) {\r\n                let testedInstruction = (<IExprInstruction>this.args[i]);\r\n\r\n                if (testedInstruction.instructionType === EInstructionTypes.k_InitExpr) {\r\n                    if (!(<IInitExprInstruction>testedInstruction).optimizeForVariableType(arrayElementType)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    // if (SystemScope.isSamplerType(arrayElementType)) {\r\n                    //     if (testedInstruction.instructionType !== EInstructionTypes.k_SamplerStateBlockExpr) {\r\n                    //         return false;\r\n                    //     }\r\n                    // }\r\n                    // else \r\n                    {\r\n                        if (!types.equals(testedInstruction.type, arrayElementType)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._type = type.baseType;\r\n            return true;\r\n        }\r\n        else {\r\n            let firstInstruction = <IExprInstruction>this.args[0];\r\n\r\n            if (this.args.length === 1 &&\r\n                firstInstruction.instructionType !== EInstructionTypes.k_InitExpr) {\r\n\r\n                // if (SystemScope.isSamplerType(type)) {\r\n                //     if (firstInstruction.instructionType === EInstructionTypes.k_SamplerStateBlockExpr) {\r\n                //         return true;\r\n                //     }\r\n                //     else {\r\n                //         return false;\r\n                //     }\r\n                // }\r\n\r\n                // TODO: remove this hack!!\r\n                if (types.equals(firstInstruction.type, SystemScope.T_INT) || types.equals(firstInstruction.type, SystemScope.T_UINT)) {\r\n                    if (types.equals(type, SystemScope.T_INT) || types.equals(type, SystemScope.T_UINT)) {\r\n                        return true;\r\n                    }   \r\n                }\r\n\r\n                if (types.equals(firstInstruction.type, type)) {\r\n                    return true;\r\n                }\r\n                \r\n                return false;\r\n            }\r\n            else if (this.args.length === 1) {\r\n                return false;\r\n            }\r\n\r\n            let args = <IInitExprInstruction[]>this.args;\r\n            let fieldNameList = type.fields.map(f => f.name);\r\n\r\n            for (let i = 0; i < args.length; i++) {\r\n                let fieldType = type.getField(fieldNameList[i]).type;\r\n                if (!args[i].optimizeForVariableType(fieldType)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            this._type = type.baseType;\r\n            return true;\r\n        }\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { ECheckStage, EInstructionTypes, IInstruction, IInstructionError, IScope, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\nexport interface IInstructionSettings {\r\n    scope: IScope;\r\n\r\n    sourceNode?: IParseNode;\r\n    visible?: boolean;\r\n\r\n    instrType?: EInstructionTypes;\r\n}\r\n\r\nexport class Instruction implements IInstruction {\r\n    private _sourceNode: IParseNode;\r\n    private _instructionID: number;\r\n    private _instructionType: EInstructionTypes;\r\n    private _scope: IScope;\r\n    private _parent: IInstruction;\r\n    private _lastError: IInstructionError;\r\n\r\n    private static INSTRUCTION_COUNTER: number = 0;\r\n\r\n    constructor({\r\n        scope,\r\n        instrType/* = EInstructionTypes.k_Instruction*/,\r\n        sourceNode = null,\r\n        visible = true\r\n    }: IInstructionSettings) {\r\n\r\n        this._sourceNode = sourceNode;\r\n        this._instructionType = instrType;\r\n        this._instructionID = (Instruction.INSTRUCTION_COUNTER++);\r\n        this._scope = scope;\r\n        this._parent = null;\r\n        this._lastError = null;\r\n    }\r\n\r\n\r\n    get parent(): IInstruction {\r\n        // console.assert(this._parent, \"Parent is not defined!\");\r\n        return this._parent;\r\n    }\r\n\r\n\r\n    get instructionType(): EInstructionTypes {\r\n        console.assert(this._instructionType != EInstructionTypes.k_Instruction, \"Instruction type 'k_Instruction' is forbidden.\");\r\n        return this._instructionType;\r\n    }\r\n\r\n    get instructionName(): string {\r\n        return EInstructionTypes[this.instructionType];\r\n    }\r\n\r\n\r\n    get instructionID(): number {\r\n        return this._instructionID;\r\n    }\r\n\r\n\r\n    get scope(): IScope {\r\n        if (!isNull(this._scope)) {\r\n            return this._scope;\r\n        }\r\n\r\n        if (!isNull(this.parent)) {\r\n            return this.parent.scope;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    get sourceNode(): IParseNode {\r\n        return this._sourceNode;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        console.error(\"@pure_virtual\");\r\n        return null;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        console.error(\"@pure_virtual\");\r\n        return null;\r\n    }\r\n\r\n\r\n    $withParent<T extends IInstruction>(parent: IInstruction | null): T {\r\n        console.assert(this._parent == null, \"parent redefenition detected!\");\r\n        if (this.instructionType === EInstructionTypes.k_SystemType && (this as any).name === 'float' && this._parent == null && parent != null) {\r\n            debugger;\r\n        }\r\n        this._parent = parent;\r\n        // todo: remove this hack!\r\n        return <any>this;\r\n    }\r\n\r\n\r\n    // An auxiliary function created to maintain the clarity of the code.\r\n    $withNoParent<T extends IInstruction>(): T {\r\n        return <any>this;\r\n    }\r\n\r\n\r\n    static $withParent<T extends IInstruction>(child: T, parent: IInstruction): T | null {\r\n        if (isNull(child)) {\r\n            return null;\r\n        }\r\n        return child.$withParent(parent);\r\n    }\r\n\r\n    static $withNoParent<T extends IInstruction>(child: T): T | null {\r\n        if (isNull(child)) {\r\n            return null;\r\n        }\r\n        return child.$withNoParent();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import { EInstructionTypes, IInstruction, IInstructionCollector } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IInstructionCollectorSettings extends IInstructionSettings {\r\n    instructions?: IInstruction[];\r\n}\r\n\r\nexport class InstructionCollector extends Instruction implements IInstructionCollector {\r\n    protected _instructions: IInstruction[];\r\n\r\n    constructor({ instructions = [], ...settings }: IInstructionCollectorSettings) {\r\n        super({ instrType: EInstructionTypes.k_Collector, ...settings });\r\n\r\n        this._instructions = instructions;\r\n    }\r\n\r\n\r\n    get instructions(): IInstruction[] {\r\n        return this._instructions;\r\n    }\r\n\r\n    push(instr: IInstruction): void {\r\n        this._instructions.push(instr);\r\n    }\r\n\r\n    toCode(): string {\r\n        let code = \"\";\r\n        for (const instr of  this.instructions) {\r\n            switch (instr.instructionType) {\r\n                case EInstructionTypes.k_VariableDecl:\r\n                    code += instr.toCode() + ';\\n';\r\n                break;\r\n                default:\r\n                    code += instr.toCode() + '\\n';\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n}","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_INT, T_UINT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IIntInstructionSettings extends IInstructionSettings {\r\n    signed: boolean;\r\n    base: number;\r\n    exp: number;\r\n    heximal?: boolean;\r\n}\r\n\r\nexport class IntInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n    readonly signed: boolean;\r\n    readonly base: number;\r\n    readonly exp: number;\r\n    readonly heximal: boolean;\r\n\r\n\r\n    constructor({ base, signed, exp, heximal = false, scope, ...settings }: IIntInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IntExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes \r\n            type: VariableTypeInstruction.wrapAsConst(signed ? T_INT : T_UINT, SCOPE), scope, ...settings });\r\n\r\n        this.base = base;\r\n        this.exp = exp;\r\n        this.signed = signed;\r\n        this.heximal = heximal;\r\n\r\n        if (!signed) {\r\n            this.base >>>= 0;\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return (this.base * Math.pow(10, this.exp));\r\n    }\r\n\r\n    toString(): string {\r\n        return `${this.heximal ? '0x' : ''}${this.base.toString(this.heximal ? 16 : 10).toUpperCase()}${this.exp !== 0? `e${this.exp}`: ''}${this.signed? '': 'u'}`;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.toString();\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, IExprInstruction, ILogicalExprInstruction, ILogicalOperator } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ILogicalExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: ILogicalOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent boolExpr && || boolExpr\r\n * (&& | ||) Instruction Instruction\r\n */\r\nexport class LogicalExprInstruction extends ExprInstruction implements ILogicalExprInstruction {\r\n    protected _operator: ILogicalOperator;\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n\r\n    constructor({ left, right, operator, ...settings }: ILogicalExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_LogicalExpr, type: SystemScope.T_BOOL, ...settings });\r\n\r\n        this._leftOperand = Instruction.$withParent(left, this);\r\n        this._rightOperand = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get operator(): ILogicalOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var sCode: string = \"\";\r\n        sCode += this.left.toCode();\r\n        sCode += this.operator;\r\n        sCode += this.right.toCode();\r\n        return sCode;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.left).isConst() &&\r\n            (<IExprInstruction>this.right).isConst();\r\n    }\r\n}\r\n\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { T_NULL } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\n\r\nexport class NullInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n\r\n    constructor({ scope, ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_NullExpr, type: T_NULL, scope, ...settings });\r\n    }\r\n\r\n    get value(): number {\r\n        return null;\r\n    }\r\n\r\n    toString(): string {\r\n        return `NULL`;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.toString();\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { isNull, isNumber } from \"@lib/common\";\r\nimport { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction, IIdInstruction, IPassInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IPassInstructionSettings extends IDeclInstructionSettings {\r\n    vertexShader?: IFunctionDeclInstruction;\r\n    pixelShader?: IFunctionDeclInstruction;\r\n    renderStates?: IMap<ERenderStateValues>;\r\n    id?: IIdInstruction;\r\n}\r\n\r\n\r\nexport class PassInstruction extends DeclInstruction implements IPassInstruction {\r\n    protected _id: IIdInstruction;\r\n    protected _vertexShader: IFunctionDeclInstruction;\r\n    protected _pixelShader: IFunctionDeclInstruction;\r\n    protected _passStateMap: IMap<ERenderStateValues>;\r\n\r\n    constructor({ id = null, vertexShader = null, pixelShader = null, renderStates = {}, ...settings }: IPassInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PassDecl, ...settings });\r\n\r\n        this._passStateMap = {};\r\n        PassInstruction.clearRenderStateMap(this._passStateMap);\r\n        PassInstruction.copyRenderStateMap(renderStates, this._passStateMap);\r\n \r\n        this._vertexShader = Instruction.$withNoParent(vertexShader);\r\n        this._pixelShader = Instruction.$withNoParent(pixelShader);\r\n\r\n        this._id = id;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        if (isNull(this._id)) {\r\n            return null;\r\n        }\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get vertexShader(): IFunctionDeclInstruction {\r\n        return this._vertexShader;\r\n    }\r\n\r\n    get pixelShader(): IFunctionDeclInstruction {\r\n        return this._pixelShader;\r\n    }\r\n\r\n\r\n    getState(state: ERenderStates): ERenderStateValues {\r\n        return this._passStateMap[state];\r\n    }\r\n\r\n    get renderStates(): IMap<ERenderStateValues> {\r\n        return this._passStateMap;\r\n    }\r\n\r\n\r\n    // TODO: move it to helpers\r\n    private static copyRenderStateMap(from: IMap<ERenderStateValues>, to: IMap<ERenderStateValues>): void {\r\n        if (isNull(from)) {\r\n            return;\r\n        }\r\n\r\n        Object\r\n            .keys(ERenderStates)\r\n            .filter(k => isNumber(ERenderStates[k]))\r\n            .map(k => ERenderStates[k])\r\n            .forEach(rs => { to[rs] = from[rs] || to[rs] });\r\n    }\r\n\r\n\r\n    // TODO: move it to helpers\r\n    private static clearRenderStateMap(map: IMap<ERenderStateValues>): void {\r\n        Object\r\n            .keys(ERenderStates)\r\n            .filter(k => isNumber(ERenderStates[k]))\r\n            .map(k => ERenderStates[k])\r\n            .forEach(rs => { map[rs] = ERenderStateValues.UNDEF });\r\n    }\r\n\r\n\r\n    isValid(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IPostfixArithmeticInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type PostfixOperator = \"++\" | \"--\";\r\n\r\nexport interface IPostfixArithmeticInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n    operator: PostfixOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr ++\r\n * (-- | ++) Instruction\r\n */\r\nexport class PostfixArithmeticInstruction extends ExprInstruction implements IPostfixArithmeticInstruction {\r\n    protected _operator: PostfixOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n    \r\n    constructor({ expr, operator, ...settings }: IPostfixArithmeticInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PostfixArithmeticExpr, type: expr.type, ...settings });\r\n\r\n        this._operator = operator;\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n\r\n        code += this.expr.toCode();\r\n        code += this.operator;\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IPostfixIndexInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPostfixIndexInstructionSettings extends IInstructionSettings {\r\n    element: IExprInstruction;\r\n    index: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent element[index]\r\n * EMPTY_OPERATOR Instruction ExprInstruction\r\n */\r\nexport class PostfixIndexInstruction extends ExprInstruction implements IPostfixIndexInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly index: IExprInstruction;\r\n\r\n    constructor({ element, index, ...settings }: IPostfixIndexInstructionSettings) {\r\n        super({ \r\n            instrType: EInstructionTypes.k_PostfixIndexExpr, \r\n            type: (element.type as IVariableTypeInstruction).arrayElementType, ...settings });\r\n            \r\n        this.element = Instruction.$withParent(element, this);\r\n        this.index = Instruction.$withParent(index, this);\r\n    }\r\n\r\n    toCode(): string {\r\n        return `${this.element.toCode()}[${this.index.toCode()}]`;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return this.element.isConst() && this.index.isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IExprInstruction, IIdExprInstruction, IPostfixPointInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPostfixPointInstructionSettings extends IInstructionSettings {\r\n    element: IExprInstruction;\r\n    postfix: IIdExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr.id\r\n * EMPTY_OPERATOR Instruction IdInstruction\r\n */\r\nexport class PostfixPointInstruction extends ExprInstruction implements IPostfixPointInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly postfix: IIdExprInstruction;\r\n\r\n\r\n    constructor({ element, postfix, ...settings }: IPostfixPointInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PostfixPointExpr, type: postfix.type, ...settings });\r\n        \r\n        this.element = Instruction.$withParent(element, this);\r\n        this.postfix = Instruction.$withParent(postfix, this);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return `${this.element.toCode()}.${this.postfix.toCode()}`;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.element.isConst();\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IIdInstruction, IPresetInstruction, IPresetPropertyInstruction } from \"@lib/idl/IInstruction\";\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IPresetInstructionSettings extends IDeclInstructionSettings {\r\n    id?: IIdInstruction;\r\n    props: IPresetPropertyInstruction[];\r\n}\r\n\r\nexport class PresetInstruction extends DeclInstruction implements IPresetInstruction {\r\n    protected _id: IIdInstruction;\r\n    protected _props: IPresetPropertyInstruction[];\r\n\r\n    constructor({ props, id = null, ...settings }: IPresetInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PresetDecl, ...settings });\r\n        this._id = Instruction.$withParent(id, this);\r\n        this._props = props.map(prop => Instruction.$withParent(prop, this));\r\n    }\r\n\r\n    \r\n    get id(): IIdInstruction { \r\n        return this._id; \r\n    }\r\n\r\n\r\n    get name(): string {\r\n        if (isNull(this._id)) {\r\n            return null;\r\n        }\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get props(): IPresetPropertyInstruction[] {\r\n        return this._props;\r\n    }\r\n\r\n    toCode(): string {\r\n        return `${this.id} = {\\n${this.props.map(prop => prop.toCode()).join(';\\n')}\\n}`;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IIdInstruction, IPresetPropertyInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPresetInstructionSettings extends IInstructionSettings {\r\n    id: IIdInstruction;\r\n    args: IExprInstruction[];\r\n}\r\n\r\nexport class PresetProperty extends Instruction implements IPresetPropertyInstruction {\r\n    readonly id: IIdInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    constructor({ id, args, ...settings }: IPresetInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PresetProperty, ...settings });\r\n        this.id = Instruction.$withParent(id, this);\r\n        this.args = args.map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n\r\n    resolveDeclaration(): IVariableDeclInstruction {\r\n        return this.scope.findVariable(this.id.name);\r\n    }\r\n\r\n    toCode() {\r\n        return `${this.id} = { ${this.args.map(arg => arg.toCode()).join(',')} }`;\r\n    }\r\n}\r\n","import { EInstructionTypes, IProvideInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IProvideInstructionSettings extends IInstructionSettings {\r\n    moduleName: string;\r\n}\r\n\r\nexport class ProvideInstruction extends Instruction implements IProvideInstruction {\r\n    protected _value: string;\r\n\r\n    constructor({ moduleName, ...settings }: IProvideInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Provide, ...settings });\r\n        \r\n        this._value = moduleName;\r\n    }\r\n\r\n    get moduleName(): string {\r\n        return this._value;\r\n    }\r\n\r\n    toString(): string {\r\n        return this._value;\r\n    }\r\n\r\n    toCode(): string {\r\n        return this._value;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { instruction, types } from \"../helpers\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport class ProxyTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _host: ITypeInstruction;\r\n\r\n    constructor(settings: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ProxyType, ...settings });\r\n        this._host = null;\r\n    }\r\n\r\n    get host(): ITypeInstruction {\r\n        return this._host;\r\n    }\r\n    \r\n    get writable(): boolean {\r\n        return this.isResolved() ? this.host.writable : true;\r\n    }\r\n\r\n    \r\n    get readable(): boolean {\r\n        return this.isResolved() ? this.host.writable : true;\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this.isResolved() ? this.host.name : 'auto';\r\n    }\r\n\r\n    \r\n    get size(): number {\r\n        return this.isResolved() ? this.host.size : instruction.UNDEFINE_SIZE;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this.host;\r\n    }\r\n\r\n    \r\n    get arrayElementType(): ITypeInstruction {\r\n        return this.isResolved() ? this.host.arrayElementType : null;\r\n    }\r\n\r\n    \r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n    \r\n    get length(): number {\r\n        return this.isResolved() ? this.host.length : instruction.UNDEFINE_LENGTH;\r\n    }\r\n\r\n    \r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.isResolved() ? this.host.fields : [];\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return [];\r\n    }\r\n\r\n\r\n    isResolved(): boolean {\r\n        return !isNull(this.host);\r\n    }\r\n\r\n\r\n    resolve(host: ITypeInstruction) {\r\n        this._host = host;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this.isResolved() ? this.host.toString() : this.name;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        return this.isResolved() ? this.host.toDeclString() : null;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.isResolved() ? this.host.toCode() : this.name;\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return this.isResolved() ? this.host.isArray() : false;\r\n    }\r\n\r\n    \r\n    isNotBaseArray(): boolean {\r\n        return this.isResolved() ? this.host.isNotBaseArray() : false;\r\n    }\r\n\r\n    \r\n    isComplex(): boolean {\r\n        return this.isResolved() ? this.host.isComplex() : false;\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return this.isResolved() ? this.host.hasFieldWithSematics(semantic) : false;\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this.isResolved() ? this.host.getField(fieldName) : null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return this.isResolved() ? this.host.getMethod(methodName, args) : null;\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        return this.isResolved() ? this.host.getFieldBySemantics(semantic) : null;\r\n    }\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return this.isResolved() ? this.host.hasFieldWithoutSemantics() : false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return this.isResolved() ? this.host.hasAllUniqueSemantics() : false;\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, IExprInstruction, IRelationalExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { assert } from \"console\";\r\n\r\nexport type RelationOperator = \"==\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\";\r\n\r\nexport interface IRelationalExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: RelationOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr == != < > <= >= someExpr\r\n * (==|!=|<|>|<=|>=) Instruction Instruction\r\n */\r\nexport class RelationalExprInstruction extends ExprInstruction implements IRelationalExprInstruction {\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n    protected _operator: RelationOperator;\r\n\r\n\r\n    constructor({ left, right, operator, instrType, ...settings }: IRelationalExprInstructionSettings) {\r\n        super({ \r\n            instrType: EInstructionTypes.k_RelationalExpr, \r\n            type: SystemScope[`T_BOOL${left.type.length > 1 ? left.type.length : ''}`], \r\n            ...settings \r\n        });\r\n        this._leftOperand = left;\r\n        this._rightOperand = right;\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n\r\n    get operator(): RelationOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n        code += this.left.toCode();\r\n        code += ` ${this.operator} `;\r\n        code += this.right.toCode();\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.left).isConst() &&\r\n            (<IExprInstruction>this.right).isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IExprInstruction, IReturnOperator, IReturnStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IReturnStmtInstructionSettings extends IInstructionSettings {\r\n    expr?: IExprInstruction;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Represent return expr;\r\n * return ExprInstruction\r\n */\r\nexport class ReturnStmtInstruction extends StmtInstruction implements IReturnStmtInstruction {\r\n    protected _operator: IReturnOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n    constructor({ expr = null, ...settings }: IReturnStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ReturnStmt, ...settings });\r\n        \r\n        this._operator = \"return\";\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    \r\n    get operator(): IReturnOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        if (this.expr) {\r\n            return \"return \" + this.expr.toCode() + \";\";\r\n        }\r\n        else {\r\n            return \"return;\";\r\n        }\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\n/**\r\n * Represent empty statement only semicolon ;\r\n * ;\r\n */\r\nexport class SemicolonStmtInstruction extends StmtInstruction {\r\n    \r\n    constructor({ ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SemicolonStmt, ...settings });\r\n    }\r\n\r\n    toCode(): string {\r\n        return \";\";\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IStateBlockInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represents this kind of initialization:\r\n *   DepthStencilState depthState { DepthEnable = TRUE; };\r\n *                                ^^^^^^^^^^^^^^^^^^^^^^^\r\n */\r\n\r\nexport interface IInitExprInstructionSettings extends IExprInstructionSettings {\r\n    props?: Object;\r\n    blocks?: IStateBlockInstruction[];\r\n}\r\n\r\nexport class StateBlockInstruction extends ExprInstruction implements IStateBlockInstruction {\r\n    readonly props: Object;\r\n    readonly blocks: IStateBlockInstruction[];\r\n\r\n    constructor({ type, blocks = null, props = null, ...settings }: IInitExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StateBlockExpr, type, ...settings });\r\n        this.props = props;\r\n        this.blocks = blocks;\r\n    }\r\n\r\n    toCode(): string {\r\n        console.error(`not implemeted`);\r\n        return null;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, IStmtBlockInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IStmtBlockInstructionSettings extends IInstructionSettings {\r\n    stmtList: IStmtInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent {stmts}\r\n * EMPTY_OPERATOR StmtInstruction ... StmtInstruction\r\n */\r\nexport class StmtBlockInstruction extends StmtInstruction implements IStmtBlockInstruction {\r\n    protected _stmtList: IStmtInstruction[];\r\n\r\n    \r\n    constructor({ stmtList, ...settings }: IStmtBlockInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StmtBlock, ...settings });\r\n        this._stmtList = stmtList.map(stmt => Instruction.$withParent(stmt, this));\r\n    }\r\n\r\n\r\n    get stmtList(): IStmtInstruction[] {\r\n        return this._stmtList;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"{\" + \"\\n\";\r\n\r\n        for (var i: number = 0; i < this.stmtList.length; i++) {\r\n            code += \"\\t\" + this.stmtList[i].toCode() + \"\\n\";\r\n        }\r\n\r\n        code += \"}\";\r\n\r\n        return code;\r\n    }\r\n}\r\n","import { EInstructionTypes, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represent all kind of statements\r\n */\r\nexport class StmtInstruction extends Instruction implements IStmtInstruction {\r\n    \r\n    constructor({ ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Stmt, ...settings });\r\n    }    \r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_STRING } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IStringInstructionSettings extends IInstructionSettings {\r\n    value: string;\r\n}\r\n\r\n\r\nexport class StringInstruction extends ExprInstruction implements ILiteralInstruction<string> {\r\n    protected _value: string;\r\n\r\n\t/**\r\n\t * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n\t */\r\n    constructor({ value, scope, ...settings }: IStringInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StringExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_STRING, SCOPE), scope, ...settings });\r\n        \r\n        this._value = value;\r\n    }\r\n\r\n    \r\n    get value(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this._value;\r\n    }\r\n    \r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { FunctionDeclInstruction, IFunctionDeclInstructionSettings } from \"./FunctionDeclInstruction\";\r\n\r\nexport interface ISystemFunctionInstructionSettings extends IFunctionDeclInstructionSettings {\r\n    vertex?: boolean;\r\n    pixel?: boolean;\r\n}\r\n\r\n\r\nexport class SystemFunctionInstruction extends FunctionDeclInstruction implements IFunctionDeclInstruction {\r\n    protected _bForVertex: boolean;\r\n    protected _bForPixel: boolean;\r\n    // protected _bForCompute;\r\n    // protected _bForGeometry;\r\n    \r\n     constructor({ vertex = true, pixel = true, impl = null, ...settings }: ISystemFunctionInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SystemFunctionDecl, impl: null, ...settings });\r\n        \r\n        assert(isNull(impl));\r\n\r\n        this._bForVertex = vertex;\r\n        this._bForPixel = pixel;\r\n    }\r\n\r\n\r\n    checkVertexUsage(): boolean {\r\n        return this._bForVertex;\r\n    }\r\n\r\n\r\n    checkPixelUsage(): boolean {\r\n        return this._bForPixel;\r\n    }\r\n\r\n\r\n    $makeVertexCompatible(val: boolean): void {\r\n        console.warn(\"@deprecated\");\r\n        this._bForVertex = val;\r\n    }\r\n\r\n\r\n    $makePixelCompatible(val: boolean): void {\r\n        console.warn(\"@deprecated\");\r\n        this._bForPixel = val;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { fn, instruction, types } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ISystemTypeInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    \r\n    size: number;\r\n    elementType?: ITypeInstruction;\r\n    length?: number;\r\n    \r\n    fields?: IVariableDeclInstruction[];\r\n    methods?: IFunctionDeclInstruction[];\r\n    \r\n    writable?: boolean;\r\n    readable?: boolean;\r\n}\r\n\r\nexport class SystemTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _name: string;\r\n    protected _size: number;\r\n    protected _elementType: ITypeInstruction;\r\n    protected _length: number;\r\n    \r\n    protected _fields: IVariableDeclInstruction[];\r\n    protected _methods: IFunctionDeclInstruction[];\r\n    \r\n    protected _bIsWritable: boolean;\r\n    protected _bIsReadable: boolean;\r\n\r\n    constructor({\r\n        name, \r\n        size = 0,\r\n        elementType = null, \r\n        length = 1, \r\n        fields = [],\r\n        methods = [],\r\n        writable = true, \r\n        readable = true, \r\n        ...settings\r\n    }: ISystemTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SystemType, ...settings });\r\n\r\n        this._name = name;\r\n        this._size = size;\r\n        this._elementType = Instruction.$withNoParent(elementType);\r\n        this._length = length;\r\n        this._fields = [];\r\n        this._methods = [];\r\n        this._bIsWritable = writable;\r\n        this._bIsReadable = readable;\r\n        fields.forEach(field => this.addField(field));\r\n        methods.forEach(method => this.addMethod(method));\r\n    }\r\n\r\n\r\n    get writable(): boolean {\r\n        return this._bIsWritable;\r\n    }\r\n\r\n\r\n    get readable(): boolean {\r\n        return this._bIsReadable;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    get size(): number {\r\n        if (this.isArray()) {\r\n            if (this.length === instruction.UNDEFINE_LENGTH) {\r\n                return instruction.UNDEFINE_LENGTH;\r\n            }\r\n            return this.arrayElementType.size * this.length;\r\n        }\r\n        return this._size;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this;\r\n    }\r\n\r\n\r\n    get arrayElementType(): ITypeInstruction {\r\n        return this._elementType;\r\n    }\r\n\r\n\r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n\r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this._fields;\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return this._methods;\r\n    }\r\n\r\n\r\n    toDeclString(): string {\r\n        console.warn('@pure_virtual');\r\n        return '';\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return !isNull(this.arrayElementType);\r\n    }\r\n\r\n\r\n    isNotBaseArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isComplex(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainPointer(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this.name || types.hash(this);\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this._fields.find(field => field.name === fieldName) || null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction | undefined | null {\r\n        const list = this._methods.filter(method => method.name === methodName);\r\n        return fn.matchList(list, args);\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        console.error(\"@undefined_behavior\");\r\n        return null;\r\n    }\r\n\r\n\r\n    /** internal api */\r\n    addField(field: IVariableDeclInstruction): void {\r\n        console.assert(this.getField(field.name) === null);\r\n        this._fields.push(Instruction.$withParent(field, this));\r\n    }\r\n\r\n    /** internal api */\r\n    addMethod(method: IFunctionDeclInstruction): void {\r\n        console.assert(isNull(this.getMethod(method.name, method.def.params.map(param => param.type))));\r\n        this._methods.push(Instruction.$withParent(method, this));\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IPass11Instruction, IPresetInstruction, ITechnique11Instruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from './Instruction';\r\n\r\nexport interface ITechniqueInstructionSettings extends IDeclInstructionSettings {\r\n    name: string;\r\n    passes: IPass11Instruction[];\r\n    presets: IPresetInstruction[];\r\n}\r\n\r\n\r\nexport class Technique11Instruction extends DeclInstruction implements ITechnique11Instruction {\r\n    protected _name: string;\r\n\r\n    readonly passes: IPass11Instruction[];\r\n\r\n    constructor({ name, passes, presets, ...settings }: ITechniqueInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Technique11Decl, ...settings });\r\n        \r\n        this._name = name;\r\n        this.passes = passes?.map(pass => Instruction.$withParent(pass, this));\r\n    }\r\n\r\n    get name() {\r\n        return this._name;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isValid(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, ETechniqueType, IPassInstruction, IPresetInstruction, ITechniqueInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from './Instruction';\r\n\r\nexport interface ITechniqueInstructionSettings<PassType extends IPassInstruction> extends IDeclInstructionSettings {\r\n    name: string;\r\n    techniqueType: ETechniqueType;\r\n    passes: PassType[];\r\n    presets: IPresetInstruction[];\r\n}\r\n\r\n\r\nexport class TechniqueInstruction<PassType extends IPassInstruction> extends DeclInstruction implements ITechniqueInstruction {\r\n    readonly type: ETechniqueType;\r\n    readonly passes: PassType[];\r\n\r\n    readonly presets: IPresetInstruction[];\r\n\r\n    protected _name: string;\r\n\r\n    constructor({ name, techniqueType, passes, presets, ...settings }: ITechniqueInstructionSettings<PassType>) {\r\n        super({ instrType: EInstructionTypes.k_TechniqueDecl, ...settings });\r\n        \r\n        this._name = name;\r\n        this.passes = passes?.map(pass => Instruction.$withParent(pass, this));\r\n        this.type = techniqueType;\r\n\r\n        this.presets = presets;\r\n    }\r\n\r\n\r\n    get name() {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    isValid(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isDef, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypeDeclInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypeDeclInstructionSettings extends IDeclInstructionSettings {\r\n    type: ITypeInstruction;\r\n}\r\n\r\n\r\n// TODO: add description comment.\r\nexport class TypeDeclInstruction extends DeclInstruction implements ITypeDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n\r\n    constructor({ type, ...settings }: ITypeDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_TypeDecl, ...settings });\r\n        this.type =  Instruction.$withParent(type, this);\r\n        assert(isDef(this.type));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.type.name;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return this.type.toDeclString() + \";\";\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypedInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypedInstructionSettings extends IInstructionSettings {\r\n    type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport class TypedInstruction extends Instruction implements ITypedInstruction {\r\n    protected _type: ITypeInstruction;\r\n\r\n    constructor({ type, ...settings }: ITypedInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Typed, ...settings });\r\n        \r\n        this._type = Instruction.$withNoParent(type);\r\n\r\n        // todo: remove this check\r\n        if (isNull(this._type)) {\r\n            console.warn(\"Something goes wrong! Type is not specified!\", this);\r\n        }\r\n    }\r\n\r\n\r\n    get type(): ITypeInstruction {\r\n        return this._type;\r\n    }\r\n}\r\n","import { assert, isDef } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypedefInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypedefInstructionSettings extends IDeclInstructionSettings {\r\n    type: ITypeInstruction;\r\n    alias: string;\r\n}\r\n\r\n\r\n// TODO: add description comment.\r\nexport class TypedefInstruction extends DeclInstruction implements ITypedefInstruction {\r\n    readonly type: ITypeInstruction;\r\n    readonly alias: string;\r\n\r\n    constructor({ type, alias, ...settings }: ITypedefInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_TypedefDecl, ...settings });\r\n        this.type =  Instruction.$withNoParent(type);\r\n        this.alias = alias;\r\n        assert(isDef(this.type));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.type?.name;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return `typedef ${this.type.toDeclString()} ${this.alias};`;\r\n    }\r\n}\r\n","import { SCOPE, T_BOOL } from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, IExprInstruction, IUnaryExprInstruction, IUnaryOperator } from '@lib/idl/IInstruction';\r\n\r\nimport { ExprInstruction } from './ExprInstruction';\r\nimport { IInstructionSettings, Instruction } from './Instruction';\r\nimport { VariableTypeInstruction } from './VariableTypeInstruction';\r\n\r\nexport interface IUnaryExprInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n    operator: IUnaryOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent + - ! ++ -- expr\r\n * (+|-|!|++|--|) Instruction\r\n */\r\nexport class UnaryExprInstruction extends ExprInstruction implements IUnaryExprInstruction {\r\n    protected _operator: IUnaryOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n\r\n    constructor({ expr, operator, ...settings }: IUnaryExprInstructionSettings) {\r\n        super({\r\n            instrType: EInstructionTypes.k_UnaryExpr,\r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: operator === '!'\r\n                ? VariableTypeInstruction.wrapAsConst(T_BOOL, SCOPE)\r\n                : expr.type,\r\n            ...settings\r\n        });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get operator(): IUnaryOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var sCode: string = '';\r\n        sCode += this.operator;\r\n        sCode += this.expr.toCode();\r\n\r\n        return sCode;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n","import { assert, isNull } from '@lib/common';\r\nimport { EInstructionTypes, IExprInstruction, IIdInstruction, IInitExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from './DeclInstruction';\r\nimport { Instruction } from './Instruction';\r\n\r\n// import * as SystemScope from '@lib/fx/analisys/SystemScope';\r\n\r\nexport interface IVariableDeclInstructionSettings extends IDeclInstructionSettings {\r\n    id: IIdInstruction;\r\n    type: IVariableTypeInstruction;\r\n    init?: IExprInstruction;\r\n\r\n    // EVariableUsageFlags\r\n    usageFlags?: number;\r\n}\r\n\r\n/**\r\n * @deprecated\r\n */\r\nexport enum EVariableUsageFlags {\r\n    k_Local     = 0x01,\r\n    k_Global    = 0x02,\r\n    k_Argument  = 0x04,\r\n    k_Cbuffer   = 0x08\r\n}\r\n\r\n/**\r\n * Represent type var_name [= init_expr]\r\n * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction\r\n */\r\nexport class VariableDeclInstruction extends DeclInstruction implements IVariableDeclInstruction {\r\n\r\n    protected _id: IIdInstruction;\r\n    protected _type: IVariableTypeInstruction;\r\n    protected _initExpr: IExprInstruction;\r\n    protected _usageFlags: number;\r\n\r\n \r\n    constructor({ id, type, init = null, usageFlags = 0, ...settings }: IVariableDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_VariableDecl, ...settings });\r\n\r\n        this._id = Instruction.$withParent(id, this);\r\n        this._type = Instruction.$withNoParent(type);\r\n        this._initExpr = Instruction.$withParent(init, this);\r\n        this._usageFlags = usageFlags;\r\n\r\n        assert(!this.isParameter() || (isNull(this.parent) || this.parent.instructionType == EInstructionTypes.k_FunctionDef));\r\n        assert(this.isLocal() || !this.isLocal());\r\n        assert(!this.isParameter() || this.isLocal());\r\n    }\r\n\r\n\r\n    get usageFlags(): number {\r\n        return this._usageFlags;\r\n    }\r\n\r\n\r\n    get initExpr(): IExprInstruction {\r\n        return this._initExpr;\r\n    }\r\n\r\n\r\n    get type(): IVariableTypeInstruction {\r\n        return <IVariableTypeInstruction>this._type;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n\r\n    isGlobal(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Global);\r\n    }\r\n\r\n\r\n    isLocal(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Local);\r\n    }\r\n\r\n\r\n    isParameter(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Argument);\r\n    }\r\n\r\n\r\n    isField(): boolean {\r\n        if (isNull(this.parent)) {\r\n            return false;\r\n        }\r\n\r\n        const parentType = this.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableType ||\r\n            parentType === EInstructionTypes.k_ComplexType ||\r\n            parentType === EInstructionTypes.k_SystemType) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    isConstant(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Cbuffer) || this.type.isUniform();\r\n    }\r\n    \r\n    toCode(): string {\r\n        var code = '';        \r\n        code = this.type.toCode();\r\n        code += ' ' + this.id.toCode();\r\n\r\n        if (this.type.isNotBaseArray()) {\r\n            var iLength: number = this.type.length;\r\n            code += '[' + iLength + ']';\r\n        }\r\n\r\n        if (!isNull(this.initExpr) &&\r\n            // !SystemScope.isSamplerType(this.type) && // TODO: is it correct check?\r\n            !this.type.isUniform()) {\r\n            code += '=' + this.initExpr.toCode();\r\n        }\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { assert, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { expression, instruction, types } from \"@lib/fx/analisys/helpers\";\r\nimport { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction, ILiteralInstruction, IScope, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IVariableUsage } from '@lib/idl/IInstruction';\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IVariableTypeInstructionSettings extends IInstructionSettings {\r\n    type: ITypeInstruction;\r\n    usages?: IVariableUsage[];\r\n    arrayIndex?: IExprInstruction;\r\n    padding?: number;\r\n\r\n    readable?: boolean;\r\n    writable?: boolean;\r\n}\r\n\r\nexport class VariableTypeInstruction extends Instruction implements IVariableTypeInstruction {\r\n    protected _subType: ITypeInstruction;\r\n    protected _usageList: IVariableUsage[];\r\n\r\n    /** overrites for defautl read/write tests (for internal usage) */\r\n    protected _isWritable: boolean;\r\n    protected _isReadable: boolean;\r\n\r\n    protected _arrayIndexExpr: IExprInstruction;\r\n    protected _arrayElementType: IVariableTypeInstruction;\r\n    protected _padding: number;\r\n    protected _aligment: number;\r\n\r\n    constructor({ type, usages = [], arrayIndex = null, writable = true, readable = true, padding = instruction.UNDEFINE_PADDING, ...settings }: IVariableTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_VariableType, ...settings });\r\n\r\n        type = Instruction.$withNoParent(type);\r\n        this._usageList = [];\r\n\r\n        let instrType = type.instructionType;\r\n        if (instrType === EInstructionTypes.k_ProxyType ||\r\n            instrType === EInstructionTypes.k_SystemType ||\r\n            instrType === EInstructionTypes.k_ComplexType) {\r\n            this._subType = type;\r\n        }\r\n        else {\r\n            let varType = <IVariableTypeInstruction>type;\r\n            // TODO: review this code\r\n            if (!varType.isNotBaseArray()) {\r\n                this._subType = varType.subType;\r\n                varType.usages.forEach(usage => this.addUsage(usage))\r\n            }\r\n            else {\r\n                this._subType = type;\r\n            }\r\n        }\r\n\r\n        assert(isDefAndNotNull(this._subType));\r\n        assert(isDefAndNotNull(this._usageList));\r\n\r\n        this._isWritable = writable;\r\n        this._isReadable = readable;\r\n\r\n        this._arrayIndexExpr = null;\r\n        this._arrayElementType = null;\r\n        this._padding = padding;\r\n        this._aligment = 1;\r\n\r\n        if (arrayIndex) {\r\n            // todo: add support for v[][10]\r\n            // todo: move elements construction to analyzer, don't make it implicitly\r\n            this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ readable, writable, scope: this.scope, type: this.subType, usages: this._usageList }), this);\r\n            this._arrayIndexExpr = Instruction.$withParent(arrayIndex, this);\r\n        } \r\n        // todo: array element type must be constructed with proper usages and read/write flags!\r\n        // else if (this.isArray()) {\r\n        //     this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ readable, writable, scope: this.scope, type: type.arrayElementType, usages: this._usageList }), this);\r\n        // }\r\n\r\n        usages.forEach(usage => this.addUsage(usage));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.baseType.name;\r\n    }\r\n\r\n\r\n    get writable(): boolean {\r\n        if (!this._isWritable) {\r\n            return false;\r\n        }\r\n\r\n        if (/*(this.isArray() && !this.isBase()) || */this.isUniform()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isConst()) {\r\n            return false;\r\n        }\r\n\r\n        // check for usages.includes('in') ?\r\n\r\n        return this.subType.writable;\r\n    }\r\n\r\n\r\n    get readable(): boolean {\r\n        if (!this._isReadable) {\r\n            return false;\r\n        }\r\n\r\n        if (this.usages.includes(\"out\")) {\r\n            return false;\r\n        }\r\n\r\n        return this.subType.readable;\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return this.subType.methods;\r\n    }\r\n\r\n\r\n    get aligment(): number {\r\n        return this._aligment;\r\n    }\r\n\r\n    // TODO: move to helpers\r\n    get size(): number {\r\n        if (!isNull(this._arrayElementType)) {\r\n            const size = types.alignSize(this._arrayElementType.size, this.aligment);\r\n            const length = this.length;\r\n            if (length === instruction.UNDEFINE_LENGTH || size === instruction.UNDEFINE_SIZE) {\r\n                return instruction.UNDEFINE_SIZE;\r\n            }\r\n            return size * length;\r\n        }\r\n        // return type.alignSize(this.subType.size, this.aligment);\r\n        return this.subType.size;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this.subType.baseType;\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        if (!this.isNotBaseArray()) { // not a user defined array like arr[10]\r\n            // for ex. if type is float3x4 then length is 3\r\n            return this.subType.length;\r\n        }\r\n\r\n        // IP: arrays like float[]?\r\n        if (this.isNotBaseArray() && isNull(this._arrayElementType)) {\r\n            return this.subType.length;\r\n        }\r\n\r\n        // arrays like float[10]\r\n        const expr = this._arrayIndexExpr;\r\n        if (instruction.isLiteral(expr)) {\r\n            return Number((<ILiteralInstruction<number>>expr).value);\r\n        }\r\n\r\n        // arrays like float[N];\r\n        const len = expression.evalConst(expr);\r\n        return len < 0 ? instruction.UNDEFINE_LENGTH: len;\r\n    }\r\n\r\n\r\n    get padding(): number {\r\n        return this._padding;\r\n    }\r\n\r\n\r\n    get arrayElementType(): IVariableTypeInstruction {\r\n        if (!this.isArray()) {\r\n            return null;\r\n        }\r\n\r\n        // todo: fix this.subType.arrayElementType!\r\n        return this._arrayElementType || <IVariableTypeInstruction>this.subType.arrayElementType;\r\n    }\r\n\r\n\r\n    get usages(): IVariableUsage[] {\r\n        let usages =  [ ...this._usageList ];\r\n        let subType = this.subType;\r\n        while (subType && subType.instructionType === EInstructionTypes.k_VariableType) {\r\n            const vtype = <IVariableTypeInstruction>subType;\r\n            // todo: remove duplicates\r\n            usages = [ ...usages, ...vtype.usages ];\r\n            subType = vtype.subType;\r\n        }\r\n\r\n        return usages;\r\n    }\r\n\r\n\r\n    get subType(): ITypeInstruction {\r\n        return this._subType;\r\n    }\r\n\r\n\r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.subType.fields;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        // TODO: fix this condition\r\n        return this.name || this.subType.toString() || types.hash(this);\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code: string = \"\";\r\n        if (!isNull(this._usageList)) {\r\n            for (let i: number = 0; i < this._usageList.length; i++) {\r\n                code += this._usageList[i] + \" \";\r\n            }\r\n        }\r\n\r\n        code += this.subType.toCode();\r\n        return code;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        return this.subType.toDeclString();\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return !isNull(this._arrayElementType) || this.subType.isArray();\r\n    }\r\n\r\n\r\n    // Returns true if the type is user defined array.\r\n    // like an ordinary array: int a[5]\r\n    // not a base array like: float4/int3 etc.\r\n    isNotBaseArray(): boolean {\r\n        return !isNull(this._arrayElementType) || this.subType.isNotBaseArray();\r\n    }\r\n\r\n\r\n    isComplex(): boolean {\r\n        return this.subType.isComplex();\r\n    }\r\n\r\n\r\n    isUniform(): boolean {\r\n        return this.usages.includes(\"uniform\");\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.usages.includes(\"const\");\r\n    }\r\n\r\n\r\n    isUnsigned(): boolean {\r\n        return this.usages.includes(\"unsigned\");\r\n    }\r\n\r\n\r\n    isStatic(): boolean {\r\n        return this.usages.includes(\"static\");\r\n    }\r\n\r\n\r\n    $overwritePadding(padding: number, aligment: number) {\r\n        this._padding = padding;\r\n        this._aligment = aligment;\r\n    }\r\n    \r\n\r\n    private addUsage(usage: IVariableUsage): void {\r\n        if (!this.usages.includes(usage)) {\r\n            this._usageList.push(usage);\r\n        }\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return this.subType.hasFieldWithSematics(semantic);\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return this.subType.hasAllUniqueSemantics();\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return this.subType.hasFieldWithoutSemantics();\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        // TODO: propogate usages? atleast readable/writable\r\n        return this.subType.getField(fieldName);\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return this.subType.getMethod(methodName, args);\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        // TODO: propogate usages?\r\n        return this.subType.getFieldBySemantics(semantic);\r\n    }\r\n\r\n\r\n    /**\r\n     * Helpers\r\n     */\r\n\r\n    // TODO: move to type.ts\r\n    /** @deprecated */\r\n    static wrap(type: ITypeInstruction, scope: IScope): IVariableTypeInstruction {\r\n        return new VariableTypeInstruction({ type, scope });\r\n    }\r\n\r\n    // TODO: move to type.ts\r\n    /** @deprecated */\r\n    static wrapAsConst(type: ITypeInstruction, scope: IScope): IVariableTypeInstruction {\r\n        return new VariableTypeInstruction({ type, scope, writable: false, usages: ['const'] });\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IStmtInstruction, IWhileStmtInstruction, IDoWhileOperator } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\n\r\n\r\nexport interface IWhileStmtInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    body: IStmtInstruction;\r\n    operator: IDoWhileOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent while(expr) stmt\r\n * ( while || do_while) ExprInstruction StmtInstruction\r\n */\r\nexport class WhileStmtInstruction extends StmtInstruction implements IWhileStmtInstruction {\r\n    protected _operator: IDoWhileOperator;\r\n    protected _cond: IExprInstruction;\r\n    protected _body: IStmtInstruction;\r\n\r\n    \r\n    constructor({ cond, body, operator, ...settings }: IWhileStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_WhileStmt, ...settings });\r\n        \r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._body = Instruction.$withParent(body, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get cond(): IExprInstruction {\r\n        return this.cond;\r\n    }\r\n\r\n\r\n    get body(): IStmtInstruction {\r\n        return this._body;\r\n    }\r\n\r\n\r\n    get operator(): IDoWhileOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n        if (this.operator === \"while\") {\r\n            code += \"while(\";\r\n            code += this.cond.toCode();\r\n            code += \")\";\r\n            code += this.body.toCode();\r\n        }\r\n        else {\r\n            code += \"do\";\r\n            code += this.body.toCode();\r\n            code += \"while(\";\r\n            code += this.cond.toCode();\r\n            code += \");\";\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction, IPassInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IDrawStmtInstruction, IPartFxInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { IInstructionSettings } from \"../Instruction\";\r\nimport { StmtInstruction } from \"../StmtInstruction\";\r\n\r\nexport interface IDrawInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    args: IExprInstruction[];\r\n}\r\n\r\n\r\nexport class DrawInstruction extends StmtInstruction implements IDrawStmtInstruction {\r\n    readonly name: string;\r\n    readonly args: IExprInstruction[];\r\n    \r\n    constructor({ name, args, ...settings }: IDrawInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_DrawStmt, ...settings });\r\n        this.name = name;\r\n        this.args = args;\r\n    }    \r\n\r\n    toCode(): string {\r\n        return `draw ${this.name};`;\r\n    }\r\n}\r\n","import { EInstructionTypes, ETechniqueType, IStructDeclInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ICompileExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IPartFxInstruction, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\nimport { T_VOID } from \"@lib/fx/analisys/SystemScope\";\r\n\r\nimport { ITechniqueInstructionSettings, TechniqueInstruction } from \"@lib/fx/analisys/instructions/TechniqueInstruction\";\r\nimport { types } from \"@lib/fx/analisys/helpers\"\r\n\r\n// prohibition of explicitly indicating the type of technique\r\nexport interface IPartFxInstructionSettings extends Omit<ITechniqueInstructionSettings<IPartFxPassInstruction>, \"techniqueType\"> {\r\n    spawnRoutine: ICompileExprInstruction;\r\n    initRoutine: ICompileExprInstruction;\r\n    updateRoutine: ICompileExprInstruction;\r\n    particle: ITypeInstruction;\r\n    capacity?: number;\r\n}\r\n\r\n// var s: IPartFxInstructionSettings;\r\n// s.te\r\n\r\nexport class PartFxInstruction extends TechniqueInstruction<IPartFxPassInstruction> implements IPartFxInstruction {\r\n    readonly spawnRoutine: ICompileExprInstruction;\r\n    readonly initRoutine: ICompileExprInstruction;\r\n    readonly updateRoutine: ICompileExprInstruction;\r\n    readonly particle: ITypeInstruction;\r\n    readonly capacity: number;\r\n\r\n    constructor({ spawnRoutine, initRoutine, updateRoutine, particle, capacity = -1, ...settings }: IPartFxInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PartFxDecl, techniqueType: ETechniqueType.k_PartFx, ...settings });\r\n\r\n        this.spawnRoutine = spawnRoutine;\r\n        this.initRoutine = initRoutine;\r\n        this.updateRoutine = updateRoutine;\r\n        this.particle = particle;\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    isValid() {\r\n        if (!this.spawnRoutine) {\r\n            console.error(`no spawn routine found`);\r\n            return false;\r\n        }\r\n\r\n        if (!types.equals(this.spawnRoutine.function.def.returnType, T_VOID)) {\r\n            if (!this.initRoutine) {\r\n                console.error(`init routine must be defined if regular spawner is used`);\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!this.updateRoutine) {\r\n            console.error(`no update routine found`);\r\n            return false;\r\n        }\r\n\r\n        const particleCheck = !!this.particle;\r\n        const passCheck = this.passes && this.passes.filter((pass: IPartFxPassInstruction) => pass.isValid()).length > 0;\r\n        return particleCheck && passCheck;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { IPassInstructionSettings, PassInstruction } from \"@lib/fx/analisys/instructions/PassInstruction\";\r\nimport { EInstructionTypes, ICompileExprInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { EPassDrawMode, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nexport interface IPartFxPassInstructionSettings extends IPassInstructionSettings {\r\n    sorting?: boolean;\r\n    prerenderRoutine: ICompileExprInstruction;\r\n    geometry: string;\r\n    instanceCount?: number;\r\n    drawMode?: EPassDrawMode;\r\n}\r\n\r\n\r\nexport class PartFxPassInstruction extends PassInstruction implements IPartFxPassInstruction {\r\n    readonly sorting: boolean;\r\n    readonly prerenderRoutine: ICompileExprInstruction;\r\n    readonly geometry: string;\r\n    readonly instanceCount: number;\r\n    readonly drawMode: EPassDrawMode;\r\n\r\n    constructor({ sorting = false, instanceCount = 1, drawMode = EPassDrawMode.k_Auto, prerenderRoutine, geometry, ...settings }: IPartFxPassInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PartFxPass, ...settings });\r\n        \r\n        this.sorting = sorting;\r\n        this.prerenderRoutine = prerenderRoutine;\r\n        this.geometry = geometry;\r\n        this.instanceCount = instanceCount;\r\n        this.drawMode = drawMode;\r\n    }\r\n\r\n    get particleInstance(): ITypeInstruction {\r\n        if (isNull(this.prerenderRoutine)) {\r\n            return null;\r\n        }\r\n\r\n        return this.prerenderRoutine.function.def.params[1].type.subType;\r\n    }\r\n\r\n    isValid(): boolean {\r\n        return !!this.particleInstance && !!this.prerenderRoutine;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IPartFxInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { IInstructionSettings } from \"../Instruction\";\r\nimport { StmtInstruction } from \"../StmtInstruction\";\r\n\r\nexport interface ISpawnInstructionSettings extends IInstructionSettings {\r\n    count: IExprInstruction;\r\n    args: IExprInstruction[];\r\n    name: string;\r\n}\r\n\r\n\r\nexport class SpawnInstruction extends StmtInstruction implements ISpawnStmtInstruction {\r\n    readonly count: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n    readonly name: string;\r\n    \r\n    // private _fx: IPartFxInstruction = null;\r\n    // private _init: IFunctionDeclInstruction = null;\r\n\r\n    constructor({ count, name, args, ...settings }: ISpawnInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SpawnStmt, ...settings });\r\n\r\n        this.count = count;\r\n        this.args = args;\r\n        this.name = name;\r\n    }    \r\n\r\n    \r\n    // get fx(): IPartFxInstruction {\r\n    //     return this._fx;\r\n    // }\r\n\r\n\r\n    // get init(): IFunctionDeclInstruction {\r\n    //     return this._init;\r\n    // }\r\n\r\n\r\n    toCode(): string {\r\n        return `spawn(${this.count}) ${this.name}(${this.args.map(arg => arg.toCode()).join(', ')});`;\r\n    }\r\n\r\n    // // delayed resolve of the spawn instructions\r\n    // $resolve(fx: IPartFxInstruction, init: IFunctionDeclInstruction): void {\r\n    //     this._fx = fx;\r\n    //     this._init = init;\r\n    // }\r\n}\r\n","import { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\n\r\nclass AppendStructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('AppendStructuredBuffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                const type = new VariableTypeInstruction({ type: args[0], scope });\r\n                const id = new IdInstruction({ scope, name: 'Append' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            const returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            const id = new IdInstruction({ scope, name: 'Append' });\r\n            const def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            const func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\n\r\nexport default AppendStructuredBufferTemplate;\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass BufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('Buffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        if (!isBase(args[0])) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\nexport default BufferTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types, instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass RWBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('RWBuffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        if (!isBase(args[0])) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\n\r\nexport default RWBufferTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\n\r\nclass RWStructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('RWStructuredBuffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'IncrementCounter' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'DecrementCounter' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\n\r\nexport default RWStructuredBufferTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types, instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass RWTexture1DTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(RWTexture1DTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'RWTexture1D';\r\n}\r\n\r\n\r\nexport default RWTexture1DTemplate;\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass RWTexture2DTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(RWTexture2DTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, });\r\n    }\r\n\r\n    static TYPE_NAME = 'RWTexture2D';\r\n}\r\n\r\n\r\nexport default RWTexture2DTemplate;\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\n\r\nclass StructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('StructuredBuffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\nexport default StructuredBufferTemplate;\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass Texture2DArrayTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(Texture2DArrayTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float3\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'dx' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'dy' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'SampleGrad' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'Texture2DArray';\r\n}\r\n\r\nexport default Texture2DArrayTemplate;\r\n\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass Texture2DTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(Texture2DTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'Sample' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            const rtName = `${type.isArray() ? type.arrayElementType.name : type.name}4`;\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(rtName), scope });\r\n            let id = new IdInstruction({ scope, name: 'Gather' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f1 = scope.findType(\"float\");\r\n                const type = new VariableTypeInstruction({ type: f1, scope });\r\n                const id = new IdInstruction({ scope, name: 'lod' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'SampleLevel' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'dx' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'dy' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'SampleGrad' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'mipLevel' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'width' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'height' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param2 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param2);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'GetDimensions' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let int3 = scope.findType(\"int3\");\r\n                const type = new VariableTypeInstruction({ type: int3, scope });\r\n                const id = new IdInstruction({ scope, name: 'location' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: elementType, scope });\r\n            let id = new IdInstruction({ scope, name: 'Load' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'Texture2D';\r\n}\r\n\r\nexport default Texture2DTemplate;\r\n\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass Texture3DTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(Texture3DTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float3\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'Sample' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'Texture3D';\r\n}\r\n\r\n\r\nexport default Texture3DTemplate;\r\n\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass TextureCubeArrayTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(TextureCubeArrayTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'TextureCubeArray';\r\n}\r\n\r\n\r\nexport default TextureCubeArrayTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types, instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass TextureCubeTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(TextureCubeTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float3\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'Sample' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float3\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'lod' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'SampleLevel' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'TextureCube';\r\n}\r\n\r\nexport default TextureCubeTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { parseUintLiteral } from \"@lib/fx/analisys/system/utils\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\n\r\nclass TriMeshTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('TriMesh');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'vertCount' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'faceCount' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'GetDimensions' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'vert' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: elementType, scope });\r\n            let id = new IdInstruction({ scope, name: 'LoadVertex' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'face' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint3\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'LoadFace' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'face' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            {\r\n                const { base, signed, heximal, exp } = parseUintLiteral(\"6u\");\r\n                const arrayIndex = new IntInstruction({ scope, base, exp, signed, heximal });\r\n\r\n                const uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, arrayIndex, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'adjacency' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param2 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param2);\r\n            }\r\n\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'LoadGSAdjacency' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'face' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            {\r\n                const { base, signed, heximal, exp } = parseUintLiteral(\"3u\");\r\n                const arrayIndex = new IntInstruction({ scope, base, exp, signed, heximal });\r\n\r\n                const uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, arrayIndex, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'adjacency' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param2 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param2);\r\n            }\r\n\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'LoadFaceAdjacency' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\n\r\nexport default TriMeshTemplate;\r\n\r\n","import { IScope, ITypeInstruction, ITypeTemplate } from \"@lib/idl/IInstruction\";\r\n\r\nclass TypeTemplate implements ITypeTemplate {\r\n    readonly name: string;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        return null;\r\n    }\r\n\r\n    typeName(args?: ITypeInstruction[]): string {\r\n        if (args && args.length > 0) {\r\n            return `${this.name}<${args.map(arg => arg.name).join(', ')}>`;\r\n        }\r\n        return this.name;\r\n    }\r\n}\r\n\r\nexport default TypeTemplate;\r\n","import { IScope } from \"@lib/idl/IInstruction\";\r\nimport { generateSystemFunction, TEMPLATE_TYPE, USAGE_CONTROL_FLOW, USAGE_PS } from \"./utils\";\r\n\r\n\r\n// TODO: rework system function templates for better readability\r\nexport function addSystemFunctions(scope: IScope): void {\r\n    // todo: rework setup of system functions according with microsoft docs.\r\n    generateSystemFunction(scope, \"dot\", \"float\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul\r\n    // TODO: add support for int|uint|bool based vectors \r\n    generateSystemFunction(scope, \"mul\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"int\"]);\r\n    generateSystemFunction(scope, \"mul\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\", \"float2x2\", \"float3x3\", \"float4x4\"]);\r\n    generateSystemFunction(scope, \"mul\", TEMPLATE_TYPE, [\"float\", TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\", \"float2x2\", \"float3x3\", \"float4x4\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float4\", [\"float4\", TEMPLATE_TYPE], [\"float4x4\", \"float4x3\", \"float4x2\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float3\", [\"float3\", TEMPLATE_TYPE], [\"float3x4\", \"float3x3\", \"float3x2\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float2\", [\"float2\", TEMPLATE_TYPE], [\"float2x4\", \"float2x3\", \"float2x2\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float4\", [TEMPLATE_TYPE, \"float4\"], [\"float4x4\", \"float3x4\", \"float2x4\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float3\", [TEMPLATE_TYPE, \"float3\"], [\"float4x3\", \"float3x3\", \"float2x3\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float2\", [TEMPLATE_TYPE, \"float2\"], [\"float4x2\", \"float3x2\", \"float2x2\"]);\r\n\r\n    /**\r\n     * scalar = int|uint|float\r\n     * vector = vector<int|uint|float, n>, n = 2,3,4\r\n     * matrix = matrix<scalar, rows, columns>, r = 2,3,4, c = 2,3,4\r\n     * \r\n     * scalar mul(scalar, scalar)\r\n     * vector mul(scalar, vector)\r\n     * vector mul(vector, scalar)\r\n     * vector mul(vector, vector)\r\n     * matrix mul(scalar, matrix)\r\n     * matrix mul(matrix, scalar)\r\n     * vector mul(vector, matrix)\r\n     * vector mul(matrix, vector)\r\n     * matrix mul(matrix, matrix)\r\n     */\r\n\r\n    generateSystemFunction(scope, \"mod\", \"float\", [\"float\", \"float\"], null);\r\n    generateSystemFunction(scope, \"floor\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"round\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"ceil\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(scope, \"fract\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"abs\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"abs\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    generateSystemFunction(scope, \"sign\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"sign\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    generateSystemFunction(scope, \"normalize\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"length\", \"float\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"cross\", \"float3\", [\"float3\", \"float3\"], null);\r\n    generateSystemFunction(scope, \"reflect\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    \r\n    generateSystemFunction(scope, \"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    generateSystemFunction(scope, \"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    generateSystemFunction(scope, \"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"fmod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"ldexp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"reversebits\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"uint\"]);\r\n    \r\n\r\n    generateSystemFunction(scope, \"clamp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"clamp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\", \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"pow\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"mod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"mod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"exp\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"exp2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"log\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"log2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"inversesqrt\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"sqrt\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    // generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n    // generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n    /** @deprecated (SM4) */\r\n    generateSystemFunction(scope, \"not\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(scope, \"distance\", \"float\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"lessThan\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"lessThan\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"lessThan\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"lessThanEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"lessThanEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"lessThanEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"equal\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"equal\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"equal\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n    generateSystemFunction(scope, \"equal\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(scope, \"notEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"notEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"notEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n    generateSystemFunction(scope, \"notEqual\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(scope, \"greaterThan\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"greaterThan\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"greaterThan\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"greaterThanEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"greaterThanEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"greaterThanEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"radians\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"degrees\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"sin\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"cos\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"sincos\", \"void\", [TEMPLATE_TYPE, `out ${TEMPLATE_TYPE}`, `out ${TEMPLATE_TYPE}`], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"tan\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"asin\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"acos\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"atan\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"atan\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"atan2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"atan2\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(scope, \"tex2D\", \"float4\", [\"sampler\", \"float2\"], null);\r\n    // generateSystemFunction(scope, \"tex2D\", \"float4\", [\"sampler2D\", \"float2\"], null);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler\", \"float3\"], null);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler2D\", \"float3\"], null);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler\", \"float4\"], null);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler2D\", \"float4\"], null);\r\n    // generateSystemFunction(scope, \"texCUBE\", \"float4\", [\"sampler\", \"float3\"], null);\r\n    // generateSystemFunction(scope, \"texCUBE\", \"float4\", [\"samplerCUBE\", \"float3\"], null);\r\n\r\n    // generateSystemFunction(scope, \"tex2D\", \"float4\", [\"sampler\", \"float2\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2D\", \"float4\", [\"sampler2D\", \"float2\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler2D\", \"float3\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler\", \"float4\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler2D\", \"float4\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"texCUBE\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"texCUBE\", \"float4\", [\"samplerCUBE\", \"float3\", \"float\"], null, false, true);\r\n\r\n    // generateSystemFunction(scope, \"tex2DLod\", \"float4\", [\"sampler\", \"float2\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DLod\", \"float4\", [\"sampler2D\", \"float2\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DProjLod\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DProjLod\", \"float4\", [\"sampler2D\", \"float3\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DProjLod\", \"float4\", [\"sampler\", \"float4\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DProjLod\", \"float4\", [\"sampler2D\", \"float4\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"texCUBELod\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"texCUBELod\", \"float4\", [\"samplerCUBE\", \"float3\", \"float\"], null, true, false);\r\n\r\n    //OES_standard_derivatives\r\n\r\n    generateSystemFunction(scope, \"dFdx\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"dFdy\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"width\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"fwidth\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(scope, \"smoothstep\", \"float3\", [\"float3\", \"float3\", \"float3\"], null);\r\n\r\n    generateSystemFunction(scope, \"smoothstep\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"smoothstep\", TEMPLATE_TYPE, [\"float\", \"float\", TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"step\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"clip\", \"void\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"], USAGE_PS);\r\n\r\n    generateSystemFunction(scope, \"frac\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"lerp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"lerp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"saturate\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"asfloat\", \"float\", [TEMPLATE_TYPE], [\"float\", \"int\", \"bool\", \"uint\"]);\r\n    generateSystemFunction(scope, \"asfloat\", \"float2\", [TEMPLATE_TYPE], [\"float2\", \"int2\", \"bool2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"asfloat\", \"float3\", [TEMPLATE_TYPE], [\"float3\", \"int3\", \"bool3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"asfloat\", \"float4\", [TEMPLATE_TYPE], [\"float4\", \"int4\", \"bool4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"asint\", \"int\", [TEMPLATE_TYPE], [\"float\", \"int\", \"bool\", \"uint\"]);\r\n    generateSystemFunction(scope, \"asint\", \"int2\", [TEMPLATE_TYPE], [\"float2\", \"int2\", \"bool2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"asint\", \"int3\", [TEMPLATE_TYPE], [\"float3\", \"int3\", \"bool3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"asint\", \"int4\", [TEMPLATE_TYPE], [\"float4\", \"int4\", \"bool4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"asuint\", \"uint\", [TEMPLATE_TYPE], [\"float\", \"int\", \"bool\", \"uint\"]);\r\n    generateSystemFunction(scope, \"asuint\", \"uint2\", [TEMPLATE_TYPE], [\"float2\", \"int2\", \"bool2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"asuint\", \"uint3\", [TEMPLATE_TYPE], [\"float3\", \"int3\", \"bool3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"asuint\", \"uint4\", [TEMPLATE_TYPE], [\"float4\", \"int4\", \"bool4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"InterlockedAdd\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\"]);\r\n    // generateSystemFunction(scope, \"InterlockedAdd\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\"]);\r\n\r\n    generateSystemFunction(scope, \"f16tof32\", \"float\", [\"uint\"], null);\r\n    generateSystemFunction(scope, \"f32tof16\", \"uint\", [\"float\"], null);\r\n\r\n    generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"int\", \"uint\", \"float\", \"bool\"]);\r\n    generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"int2\", \"uint2\", \"float2\", \"bool2\", \"float2x2\"]);\r\n    generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"int3\", \"uint3\", \"float3\", \"bool3\", \"float3x3\"]);\r\n    generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"int4\", \"uint4\", \"float4\", \"bool4\", \"float4x4\"]);\r\n\r\n    generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"int\", \"uint\", \"float\", \"bool\"]);\r\n    generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"int2\", \"uint2\", \"float2\", \"bool2\", \"float2x2\"]);\r\n    generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"int3\", \"uint3\", \"float3\", \"bool3\", \"float3x3\"]);\r\n    generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"int4\", \"uint4\", \"float4\", \"bool4\", \"float4x4\"]);\r\n\r\n    // DX12\r\n\r\n    generateSystemFunction(scope, \"WaveGetLaneIndex\", \"uint\", [], [\"void\"]);\r\n    generateSystemFunction(scope, \"WaveActiveBallot\", \"uint4\", [TEMPLATE_TYPE], [\"bool\"]);\r\n\r\n    // control flow\r\n    generateSystemFunction(scope, \"SetVertexShader\", \"void\", [TEMPLATE_TYPE], [\"VertexShader\"], USAGE_CONTROL_FLOW);\r\n    generateSystemFunction(scope, \"SetPixelShader\", \"void\", [TEMPLATE_TYPE], [\"PixelShader\"], USAGE_CONTROL_FLOW);\r\n    generateSystemFunction(scope, \"SetGeometryShader\", \"void\", [TEMPLATE_TYPE], [\"GeometryShader\"], USAGE_CONTROL_FLOW);\r\n    generateSystemFunction(scope, \"SetDepthStencilState\", \"void\", [TEMPLATE_TYPE, \"int\"], [\"DepthStencilState\"], USAGE_CONTROL_FLOW);\r\n    generateSystemFunction(scope, \"SetBlendState\", \"void\", [TEMPLATE_TYPE], [\"BlendState\"], USAGE_CONTROL_FLOW);                        // todo: use correct arguments\r\n    generateSystemFunction(scope, \"SetRasterizerState\", \"void\", [TEMPLATE_TYPE], [\"RasterizerState\"], USAGE_CONTROL_FLOW);              // todo: use correct arguments\r\n}\r\n","import { IScope } from \"@lib/idl/IInstruction\";\r\nimport AppendStructuredBufferTemplate from \"./AppendStructuredBufferTemplate\";\r\nimport BufferTemplate from \"./BufferTemplate\";\r\nimport RWBufferTemplate from \"./RWBufferTemplate\";\r\nimport RWStructuredBufferTemplate from \"./RWStructuredBufferTemplate\";\r\nimport RWTexture1DTemplate from \"./RWTexture1DTemplate\";\r\nimport RWTexture2DTemplate from \"./RWTexture2DTemplate\";\r\nimport StructuredBufferTemplate from \"./StructuredBufferTemplate\";\r\nimport Texture2DArrayTemplate from \"./Texture2DArrayTemplate\";\r\nimport Texture2DTemplate from \"./Texture2DTemplate\";\r\nimport Texture3DTemplate from \"./Texture3DTemplate\";\r\nimport TextureCubeArrayTemplate from \"./TextureCubeArrayTemplate\";\r\nimport TextureCubeTemplate from \"./TextureCubeTemplate\";\r\nimport TriMeshTemplate from \"./TriMeshTemplate\";\r\nimport { generateSystemType } from \"./utils\";\r\n\r\n\r\nexport function addSystemTypeBuiltin(scope: IScope) {\r\n    generateSystemType(scope, \"SamplerState\", 4);\r\n    generateSystemType(scope, \"SamplerComparisonState\", 4);\r\n    generateSystemType(scope, \"DepthStencilState\", 4);\r\n    generateSystemType(scope, \"BlendState\", 4);\r\n    generateSystemType(scope, \"RasterizerState\", 4);\r\n\r\n    generateSystemType(scope, \"VertexShader\", 4);\r\n    generateSystemType(scope, \"PixelShader\", 4);\r\n    generateSystemType(scope, \"ComputeShader\", 4);\r\n    generateSystemType(scope, \"GeometryShader\", 4);\r\n    generateSystemType(scope, \"HullShader\", 4);\r\n    generateSystemType(scope, \"DomainShader\", 4);\r\n\r\n    // generateSystemType(scope, \"texture\");\r\n    // generateSystemType(scope, \"sampler\");\r\n    // generateSystemType(scope, \"sampler2D\");\r\n    // generateSystemType(scope, \"samplerCUBE\");\r\n\r\n    scope.addTypeTemplate(new BufferTemplate);\r\n    scope.addTypeTemplate(new RWBufferTemplate);\r\n    scope.addTypeTemplate(new RWStructuredBufferTemplate);\r\n    scope.addTypeTemplate(new AppendStructuredBufferTemplate);\r\n    scope.addTypeTemplate(new StructuredBufferTemplate);\r\n\r\n    scope.addTypeTemplate(new TriMeshTemplate);\r\n\r\n    scope.addTypeTemplate(new RWTexture1DTemplate);\r\n    scope.addTypeTemplate(new RWTexture2DTemplate);\r\n    // TODO: RWTexture3D\r\n\r\n    // TODO: Texture1D\r\n    scope.addTypeTemplate(new Texture2DTemplate);\r\n    scope.addTypeTemplate(new Texture3DTemplate);\r\n    scope.addTypeTemplate(new TextureCubeTemplate);\r\n    // TODO: Texture1DArray\r\n    scope.addTypeTemplate(new Texture2DArrayTemplate);\r\n    // TODO: Texture3DArray\r\n    scope.addTypeTemplate(new TextureCubeArrayTemplate);\r\n\r\n    // produce default Texture2D type\r\n    const templateTexture2D = scope.findTypeTemplate(Texture2DTemplate.TYPE_NAME);\r\n    const typeTexture2D = templateTexture2D.produceType(scope, []);\r\n    scope.addType(typeTexture2D);\r\n\r\n    // produce default TextureCube type\r\n    const templateTextureCube = scope.findTypeTemplate(TextureCubeTemplate.TYPE_NAME);\r\n    const typeTextureCube = templateTextureCube.produceType(scope, []);\r\n    scope.addType(typeTextureCube);\r\n\r\n    // produce default Texture3D type\r\n    const templateTexture3D = scope.findTypeTemplate(Texture3DTemplate.TYPE_NAME);\r\n    const typeTexture3D = templateTexture3D.produceType(scope, []);\r\n    scope.addType(typeTexture3D);\r\n\r\n    // produce default Texture2DArray type\r\n    const templateTexture2DArray = scope.findTypeTemplate(Texture2DArrayTemplate.TYPE_NAME);\r\n    const typeTexture2DArray = templateTexture2DArray.produceType(scope, []);\r\n    scope.addType(typeTexture2DArray);\r\n\r\n    // produce default TextureCubeArray type\r\n    const templateTextureCubeArray = scope.findTypeTemplate(TextureCubeArrayTemplate.TYPE_NAME);\r\n    const typeTextureCubeArray = templateTextureCubeArray.produceType(scope, []);\r\n    scope.addType(typeTextureCubeArray);\r\n\r\n    // produce default RWTexture1D type\r\n    const templateRWTexture1D = scope.findTypeTemplate(RWTexture1DTemplate.TYPE_NAME);\r\n    const typeRWTexture1D = templateRWTexture1D.produceType(scope, []);\r\n    scope.addType(typeRWTexture1D);\r\n\r\n    // produce default RWTexture2D type\r\n    const templateRWTexture2D = scope.findTypeTemplate(RWTexture2DTemplate.TYPE_NAME);\r\n    const typeRWTexture2D = templateRWTexture2D.produceType(scope, []);\r\n    scope.addType(typeRWTexture2D);\r\n}\r\n","import { IScope } from \"@lib/idl/IInstruction\";\r\nimport { getSystemType, generateSystemType } from \"./utils\";\r\n\r\nexport function addSystemTypeMatrix(scope: IScope): void {\r\n    let float2 = getSystemType(scope, \"float2\");\r\n    let float3 = getSystemType(scope, \"float3\");\r\n    let float4 = getSystemType(scope, \"float4\");\r\n\r\n    let int2 = getSystemType(scope, \"int2\");\r\n    let int3 = getSystemType(scope, \"int3\");\r\n    let int4 = getSystemType(scope, \"int4\");\r\n\r\n    let uint2 = getSystemType(scope, \"uint2\");\r\n    let uint3 = getSystemType(scope, \"uint3\");\r\n    let uint4 = getSystemType(scope, \"uint4\");\r\n\r\n    let bool2 = getSystemType(scope, \"bool2\");\r\n    let bool3 = getSystemType(scope, \"bool3\");\r\n    let bool4 = getSystemType(scope, \"bool4\");\r\n\r\n    generateSystemType(scope, \"float2x2\", -1, float2, 2);\r\n    generateSystemType(scope, \"float2x3\", -1, float3, 2);\r\n    generateSystemType(scope, \"float2x4\", -1, float4, 2);\r\n\r\n    generateSystemType(scope, \"float3x2\", -1, float2, 3);\r\n    generateSystemType(scope, \"float3x3\", -1, float3, 3);\r\n    generateSystemType(scope, \"float3x4\", -1, float4, 3);\r\n\r\n    generateSystemType(scope, \"float4x2\", -1, float2, 4);\r\n    generateSystemType(scope, \"float4x3\", -1, float3, 4);\r\n    generateSystemType(scope, \"float4x4\", -1, float4, 4);\r\n\r\n    generateSystemType(scope, \"int2x2\", -1, int2, 2);\r\n    generateSystemType(scope, \"int2x3\", -1, int3, 2);\r\n    generateSystemType(scope, \"int2x4\", -1, int4, 2);\r\n\r\n    generateSystemType(scope, \"int3x2\", -1, int2, 3);\r\n    generateSystemType(scope, \"int3x3\", -1, int3, 3);\r\n    generateSystemType(scope, \"int3x4\", -1, int4, 3);\r\n\r\n    generateSystemType(scope, \"int4x2\", -1, int2, 4);\r\n    generateSystemType(scope, \"int4x3\", -1, int3, 4);\r\n    generateSystemType(scope, \"int4x4\", -1, int4, 4);\r\n\r\n    generateSystemType(scope, \"bool2x2\", -1, bool2, 2);\r\n    generateSystemType(scope, \"bool2x3\", -1, bool3, 2);\r\n    generateSystemType(scope, \"bool2x4\", -1, bool4, 2);\r\n\r\n    generateSystemType(scope, \"bool3x2\", -1, bool2, 3);\r\n    generateSystemType(scope, \"bool3x3\", -1, bool3, 3);\r\n    generateSystemType(scope, \"bool3x4\", -1, bool4, 3);\r\n\r\n    generateSystemType(scope, \"bool4x2\", -1, bool2, 4);\r\n    generateSystemType(scope, \"bool4x3\", -1, bool3, 4);\r\n    generateSystemType(scope, \"bool4x4\", -1, bool4, 4);\r\n}\r\n\r\n","import { IScope } from \"@lib/idl/IInstruction\";\r\nimport { defineTypeAlias, generateSystemType, USE_STRICT_HALF_TYPE } from \"./utils\";\r\n\r\nexport function addSystemTypeScalar(scope: IScope) {\r\n    generateSystemType(scope, \"void\", 0);\r\n    generateSystemType(scope, \"int\", 4);\r\n    generateSystemType(scope, \"uint\", 4);\r\n    generateSystemType(scope, \"bool\", 4);\r\n    generateSystemType(scope, \"float\", 4);\r\n    generateSystemType(scope, \"string\", 4/* pointer to string */);\r\n    generateSystemType(scope, \"null_t\", 4/* pointer */);\r\n\r\n    // TODO: use dedicated type for half\r\n    defineTypeAlias(scope, \"float\", \"half\");\r\n    console.assert(USE_STRICT_HALF_TYPE === false);\r\n}\r\n\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { types } from '@lib/fx/analisys/helpers';\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { CodeContext, CodeEmitter } from \"@lib/fx/translators/CodeEmitter\";\r\nimport { EAnalyzerErrors } from \"@lib/idl/EAnalyzerErrors\";\r\nimport {\r\n    EInstructionTypes, IAttributeInstruction, ICbufferInstruction, IFunctionDeclInstruction, IFunctionDefInstruction,\r\n    IRegister, IScope, ITypeInstruction, IVariableDeclInstruction, IVariableUsage\r\n} from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { AttributeInstruction } from \"../instructions/AttributeInstruction\";\r\nimport { FunctionDefInstruction } from \"../instructions/FunctionDefInstruction\";\r\nimport { SystemFunctionInstruction } from \"../instructions/SystemFunctionInstruction\";\r\n\r\nexport const USE_STRICT_HALF_TYPE = false;\r\nexport const TEMPLATE_TYPE = \"template\";\r\n\r\nexport function parseUintLiteral(value: string) {\r\n    const match = value.match(/^((0x[a-fA-F0-9]{1,8}?|[0-9]+)(e([+-]?[0-9]+))?)([ulUL]*)$/);\r\n    assert(match, `cannot parse uint literal: ${value}`);\r\n\r\n    const signed = match[5].toLowerCase().indexOf('u') === -1;\r\n    const exp = Number(match[4] || '0');\r\n    const base = Number(match[2]);\r\n    assert(!Number.isNaN(base));\r\n\r\n    const heximal = value[1] === 'x';\r\n\r\n    return { signed, exp, base, heximal };\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nexport function getSystemType(scope: IScope, typeName: string): SystemTypeInstruction {\r\n    //boolean, string, float and others\r\n    let type = <SystemTypeInstruction>scope.findType(typeName);\r\n    assert(!type || (type.instructionType === EInstructionTypes.k_SystemType));\r\n    return type;\r\n}\r\n\r\n\r\nexport function generateSystemType(scope: IScope, name: string, size?: number, elementType?: ITypeInstruction,\r\n    length?: number, fields?: IVariableDeclInstruction[], methods?: IFunctionDeclInstruction[]): SystemTypeInstruction;\r\nexport function generateSystemType(scope: IScope, ...args: any[]): SystemTypeInstruction {\r\n    let name: string;\r\n    let size: number;\r\n    let elementType: ITypeInstruction;\r\n    let length: number;\r\n    let fields: IVariableDeclInstruction[];\r\n    let methods: IFunctionDeclInstruction[];\r\n\r\n    [name, size, elementType, length, fields, methods] = args;\r\n\r\n    if (getSystemType(scope, name)) {\r\n        console.error(`type already exists: ${name}`);\r\n        return null;\r\n    }\r\n\r\n    const type = new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    scope.addType(type);\r\n\r\n    return type;\r\n}\r\n\r\nexport function defineTypeAlias(scope: IScope, typeName: string, aliasName: string) {\r\n    scope.addTypeAlias(typeName, aliasName);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport function addFieldsToVectorFromSuffixObject(scope: IScope, fields: IVariableDeclInstruction[], suffixMap: IMap<boolean>, baseType: string) {\r\n    for (let suffix in suffixMap) {\r\n        const fieldTypeName = baseType + ((suffix.length > 1) ? suffix.length.toString() : \"\");\r\n        const fieldBaseType = getSystemType(scope, fieldTypeName);\r\n\r\n        assert(fieldBaseType);\r\n\r\n        const fieldId = new IdInstruction({ scope, name: suffix });\r\n        const fieldType = new VariableTypeInstruction({ scope, type: fieldBaseType, writable: suffixMap[suffix] })\r\n\r\n        fields.push(new VariableDeclInstruction({ scope, id: fieldId, type: fieldType }));\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function generateSuffixLiterals(literals: string, output: IMap<boolean> = {}, depth: number = 0): IMap<boolean> {\r\n    if (depth >= /*literals.length*/4) {\r\n        return output;\r\n    }\r\n\r\n    if (depth === 0) {\r\n        for (let i = 0; i < literals.length; i++) {\r\n            output[literals[i]] = true;\r\n        }\r\n\r\n        depth = 1;\r\n    }\r\n\r\n    const outputKeys = Object.keys(output);\r\n\r\n    for (let i = 0; i < literals.length; i++) {\r\n        for (let j = 0; j < outputKeys.length; j++) {\r\n            if (outputKeys[j].indexOf(literals[i]) !== -1) {\r\n                output[outputKeys[j] + literals[i]] = false;\r\n            }\r\n            else {\r\n                output[outputKeys[j] + literals[i]] = (output[outputKeys[j]] === false) ? false : true;\r\n            }\r\n        }\r\n    }\r\n\r\n    depth++;\r\n\r\n    return generateSuffixLiterals(literals, output, depth);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport function isTemplate(typename: string): boolean {\r\n    return typename.split(' ').slice(-1)[0] === TEMPLATE_TYPE;\r\n}\r\n\r\nexport function parseType(scope: IScope, typename: string, typevalue: string = null) {\r\n    assert(typevalue !== TEMPLATE_TYPE);\r\n    const usagesType = (typevalue ? typename.replace(TEMPLATE_TYPE, typevalue) : typename).split(' ');\r\n    const hash = usagesType.slice(-1)[0];\r\n    const type = getSystemType(scope, hash);\r\n    const usages = <IVariableUsage[]>usagesType.slice(0, -1);\r\n\r\n    assert(type !== null);\r\n    usages.forEach(usage => assert(['in', 'out', 'inout'].indexOf(usage) !== -1));\r\n\r\n    return { type, usages, hash };\r\n}\r\n\r\ntype ITypeDesc = ReturnType<typeof parseType>;\r\n\r\n\r\nconst systemFunctionHashMap: IMap<boolean> = {};\r\n\r\nfunction _emitException(message: string) {\r\n    throw new Error(message);\r\n}\r\n\r\n// todo: rewrite it!\r\nfunction _error(code: number, info = {}): void {\r\n    _emitException(EAnalyzerErrors[code]);\r\n}\r\n\r\n\r\nexport const USAGE_VS = 0x01;\r\nexport const USAGE_PS = 0x02;\r\nexport const USAGE_GS = 0x04;\r\nexport const USAGE_CS = 0x08;\r\nexport const USAGE_HS = 0x10;\r\nexport const USAGE_DS = 0x20;\r\nexport const USAGE_CONTROL_FLOW = 0x100;\r\n\r\nfunction generateSystemFunctionInstance(scope: IScope, retType: ITypeDesc, name: string, paramTypes: ITypeDesc[], usage: number) {\r\n    const paramList = paramTypes.map((typeDesc, n) => {\r\n        return new VariableDeclInstruction({\r\n            type: new VariableTypeInstruction({\r\n                type: typeDesc.type,\r\n                usages: typeDesc.usages,\r\n                scope\r\n            }),\r\n            id: new IdInstruction({ name: `p${n}`, scope }),\r\n            scope\r\n        });\r\n    });\r\n\r\n    const returnType = new VariableTypeInstruction({\r\n        type: retType.type,\r\n        usages: retType.usages,\r\n        scope\r\n    });\r\n\r\n    const pixel = !!(usage & USAGE_PS);\r\n    const vertex = !!(usage & USAGE_VS);\r\n    const extern = !!(usage & USAGE_CONTROL_FLOW);\r\n    const attrs: IAttributeInstruction[] = [];\r\n    if (extern) {\r\n        attrs.push(new AttributeInstruction({ scope, name: 'extern' }));\r\n    }\r\n\r\n    const id = new IdInstruction({ scope, name });\r\n    const def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n    const func = new SystemFunctionInstruction({ scope, def, pixel, vertex, attrs });\r\n\r\n    scope.addFunction(func);\r\n}\r\n\r\n\r\n/**\r\n * Exampler:\r\n *  generateSystemFunction(\"dot\", \"dot($1,$2)\",   \"float\",    [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n *                         ^^^^^  ^^^^^^^^^^^^    ^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n *                         name   translationExpr returnType  argsTypes                       templateTypes\r\n */\r\nexport function generateSystemFunction(\r\n    scope: IScope,\r\n    name: string,\r\n    returnTypeName: string,\r\n    paramTypeNames: string[],\r\n    templateTypes: string[], usage: number = USAGE_VS | USAGE_PS): void {\r\n\r\n    if (!isNull(templateTypes)) {\r\n        for (let i = 0; i < templateTypes.length; i++) {\r\n            let funcHash = name + \"(\";\r\n            let returnType = parseType(scope, returnTypeName, templateTypes[i]);\r\n            let paramTypes = <ITypeDesc[]>[];\r\n\r\n            for (let j = 0; j < paramTypeNames.length; j++) {\r\n                const typeDesc = parseType(scope, paramTypeNames[j], templateTypes[i]);\r\n                paramTypes.push(typeDesc);\r\n                funcHash += typeDesc.hash + \",\";\r\n            }\r\n\r\n            funcHash += \")\";\r\n\r\n            if (systemFunctionHashMap[funcHash]) {\r\n                _error(EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });\r\n            }\r\n\r\n            generateSystemFunctionInstance(scope, returnType, name, paramTypes, usage);\r\n            systemFunctionHashMap[funcHash] = true;\r\n        }\r\n    }\r\n    else {\r\n        if (isTemplate(returnTypeName)) {\r\n            _emitException(\"Bad return type(TEMPLATE_TYPE) for system function '\" + name + \"'.\");\r\n        }\r\n\r\n        let funcHash = name + \"(\";\r\n        let returnType = parseType(scope, returnTypeName);\r\n        let paramTypes = <ITypeDesc[]>[];\r\n\r\n        for (let i = 0; i < paramTypeNames.length; i++) {\r\n            if (isTemplate(paramTypeNames[i])) {\r\n                _emitException(\"Bad argument type(TEMPLATE_TYPE) for system function '\" + name + \"'.\");\r\n            }\r\n            else {\r\n                const typeDesc = parseType(scope, paramTypeNames[i]);\r\n                paramTypes.push(typeDesc);\r\n                funcHash += typeDesc.hash + \",\";\r\n            }\r\n        }\r\n\r\n        funcHash += \")\";\r\n\r\n        if (systemFunctionHashMap[funcHash]) {\r\n            _error(EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });\r\n        }\r\n\r\n        generateSystemFunctionInstance(scope, returnType, name, paramTypes, usage);\r\n        systemFunctionHashMap[funcHash] = true;\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport const SCALAR_TYPES = [\r\n    'bool',\r\n    'int',\r\n    'uint',\r\n    'half',\r\n    'float'\r\n];\r\n\r\n\r\nexport const INT_TYPES = [\r\n    'int', 'uint'\r\n];\r\n\r\nexport const FLOAT_TYPES = [\r\n    'float'\r\n];\r\n\r\nexport const INT_BASED_TYPES = [\r\n    'int',\r\n    'int2', 'int3', 'int4',\r\n    'int2x2', 'int2x3', 'int2x4',\r\n    'int3x2', 'int3x3', 'int3x4',\r\n    'int4x2', 'int4x3', 'int4x4',\r\n];\r\n\r\n\r\nexport const UINT_BASED_TYPES = [\r\n    'uint',\r\n    'uint2', 'uint3', 'uint4',\r\n    'uint2x2', 'uint2x3', 'uint2x4',\r\n    'uint3x2', 'uint3x3', 'uint3x4',\r\n    'uint4x2', 'uint4x3', 'uint4x4',\r\n];\r\n\r\n\r\nexport const HALF_BASED_TYPES = [\r\n    'half',\r\n    'half2', 'half3', 'half4',\r\n    'half2x2', 'half2x3', 'half2x4',\r\n    'half3x2', 'half3x3', 'half3x4',\r\n    'half4x2', 'half4x3', 'half4x4',\r\n];\r\n\r\n\r\nexport const FLOAT_BASED_TYPES = [\r\n    'float',\r\n    'float2', 'float3', 'float4',\r\n    'float2x2', 'float2x3', 'float2x4',\r\n    'float3x2', 'float3x3', 'float3x4',\r\n    'float4x2', 'float4x3', 'float4x4',\r\n];\r\n\r\n\r\nexport const BOOL_BASED_TYPES = [\r\n    'bool',\r\n    'bool2', 'bool3', 'bool4',\r\n    'bool2x2', 'bool2x3', 'bool2x4',\r\n    'bool3x2', 'bool3x3', 'bool3x4',\r\n    'bool4x2', 'bool4x3', 'bool4x4',\r\n];\r\n\r\n\r\nexport const VECTOR_TYPES = [\r\n    'bool2', 'bool3', 'bool4',\r\n    'int2', 'int3', 'int4',\r\n    'uint2', 'uint3', 'uint4',\r\n    'half2', 'half3', 'half4',\r\n    'float2', 'float3', 'float4'\r\n];\r\n\r\n\r\nexport const MATRIX_TYPES = [\r\n    'bool2x2', 'bool2x3', 'bool2x4', 'bool3x2', 'bool3x3', 'bool3x4', 'bool4x2', 'bool4x3', 'bool4x4',\r\n    'int2x2', 'int2x3', 'int2x4', 'int3x2', 'int3x3', 'int3x4', 'int4x2', 'int4x3', 'int4x4',\r\n    'uint2x2', 'uint2x3', 'uint2x4', 'uint3x2', 'uint3x3', 'uint3x4', 'uint4x2', 'uint4x3', 'uint4x4',\r\n    'half2x2', 'half2x3', 'half2x4', 'half3x2', 'half3x3', 'half3x4', 'half4x2', 'half4x3', 'half4x4',\r\n    'float2x2', 'float2x3', 'float2x4', 'float3x2', 'float3x3', 'float3x4', 'float4x2', 'float4x3', 'float4x4',\r\n];\r\n\r\nexport const BASE_TYPES = [\r\n    ...SCALAR_TYPES, ...VECTOR_TYPES, ...MATRIX_TYPES\r\n]\r\n\r\nexport const UAV_TYPES = [\r\n    'RWTexture1D',\r\n    'RWTexture2D',\r\n    'RWTexture3D',\r\n    'RWBuffer',\r\n    'RWStructuredBuffer',\r\n    'AppendStructuredBuffer'\r\n];\r\n\r\nexport const TEXTURE_TYPES = [\r\n    'Texture1D',\r\n    'Texture2D',\r\n    'Texture3D',\r\n    'TextureCube',\r\n    'Texture2DArray',\r\n    'TextureCubeArray',\r\n    'RWTexture1D',\r\n    'RWTexture2D',\r\n    'RWTexture3D',\r\n];\r\n\r\nexport const BUFFER_TYPES = [\r\n    'Buffer',\r\n    'RWBuffer',\r\n    'RWStructuredBuffer',\r\n    'AppendStructuredBuffer',\r\n    'StructuredBuffer'\r\n];\r\n\r\nexport const SAMPLER_TYPES = [\r\n    'SamplerState',\r\n    'SamplerComparisonState'\r\n];\r\n\r\nexport const BLEND_STATE = 'BlendState';\r\nexport const DEPTH_STENCIL_STATE = 'DepthStencilState';\r\nexport const RASTERIZER_STATE = 'RasterizerState';\r\n\r\nexport const SHADER_TYPES = [\r\n    'VertexShader',\r\n    'PixelShader',\r\n    'GeometryShader',\r\n    'HullShader',\r\n    'DomainShader',\r\n    'ComputeShader'\r\n];\r\n\r\nconst skipTemplate = (name: string) => name.match(/([\\w][\\w\\d]+)(<[\\w][\\w\\d]+>)?/)[1];\r\n// note: arrays like \"Texture2D[5]\" also return true in this checks (!)\r\nexport const isUAV = (type: ITypeInstruction) => UAV_TYPES.includes(skipTemplate(type.name));\r\nexport const isTexture = (type: ITypeInstruction) => TEXTURE_TYPES.includes(skipTemplate(type.name));\r\nexport const isBuffer = (type: ITypeInstruction) => BUFFER_TYPES.includes(skipTemplate(type.name));\r\n\r\n// note: arrays like \"BlendState[5]\" also return true in this checks (!)\r\nexport const isSamplerState = (type: ITypeInstruction) => SAMPLER_TYPES.includes(type.name);\r\nexport const isBlendState = (type: ITypeInstruction) => [BLEND_STATE].includes(type.name);\r\nexport const isDepthStencilState = (type: ITypeInstruction) => [DEPTH_STENCIL_STATE].includes(type.name);\r\nexport const isRasterizerState = (type: ITypeInstruction) => [RASTERIZER_STATE].includes(type.name);\r\n\r\n// note: arrays like \"BlendState[5]\" also return true in this checks (!)\r\nexport const isPipelineState = (type: ITypeInstruction) => [\r\n    BLEND_STATE,\r\n    DEPTH_STENCIL_STATE,\r\n    RASTERIZER_STATE\r\n].includes(type.name);\r\n\r\nexport const isShaderType = (type: ITypeInstruction) => SHADER_TYPES.includes(types.signature(type));\r\n\r\n// note: arrays like \"float4[4]\" return false in this checks (!)\r\nexport const isBase = (type: ITypeInstruction) => BASE_TYPES.includes(types.signature(type));\r\nexport const isVectorType = (type: ITypeInstruction) => VECTOR_TYPES.includes(types.signature(type));\r\nexport const isMatrixType = (type: ITypeInstruction) => MATRIX_TYPES.includes(types.signature(type));\r\nexport const isScalarType = (type: ITypeInstruction) => SCALAR_TYPES.includes(types.signature(type));\r\nexport const isIntegerType = (type: ITypeInstruction) => INT_TYPES.includes(types.signature(type));\r\nexport const isFloatType = (type: ITypeInstruction) => FLOAT_TYPES.includes(types.signature(type));\r\nexport const isIntBasedType = (type: ITypeInstruction) => INT_BASED_TYPES.includes(types.signature(type));\r\nexport const isUintBasedType = (type: ITypeInstruction) => UINT_BASED_TYPES.includes(types.signature(type));\r\nexport const isBoolBasedType = (type: ITypeInstruction) => BOOL_BASED_TYPES.includes(types.signature(type));\r\nexport const isHalfBasedType = (type: ITypeInstruction) => HALF_BASED_TYPES.includes(types.signature(type));\r\nexport const isFloatBasedType = (type: ITypeInstruction) => FLOAT_BASED_TYPES.includes(types.signature(type));\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nexport function resolveRegister(decl: IVariableDeclInstruction | ICbufferInstruction): IRegister {\r\n    let type = null;\r\n    let index = -1;\r\n\r\n    const semantic = decl.semantic;\r\n    if (semantic) {\r\n        const match = semantic.match(/^register\\(([utbs]{1})([\\d]+)\\)$/);\r\n        if (match) {\r\n            type = match[1];\r\n            index = Number(match[2]);\r\n        }\r\n    }\r\n\r\n    if (isUAV(decl.type)) {\r\n        assert(type === null || type === 'u');\r\n        type = 'u';\r\n    }\r\n\r\n    if (isTexture(decl.type)) {\r\n        assert(type === null || type === 't');\r\n        type = 't';\r\n    }\r\n\r\n    if (isSamplerState(decl.type)) {\r\n        assert(type === null || type === 's');\r\n        type = 's';\r\n    }\r\n\r\n    if (decl.instructionType === EInstructionTypes.k_CbufferDecl) {\r\n        assert(type === null || type === 'b');\r\n        type = 'b';\r\n    }\r\n\r\n    // TODO: buffers\r\n\r\n    return { type, index };\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////\r\n\r\n\r\nfunction alignL(content: string, len: number) {\r\n    let diff = Math.max(0, len - content.length);\r\n    return `${Array(diff).fill(' ').join('')}${content}`;\r\n}\r\n\r\n\r\nfunction alignR(content: string, len: number) {\r\n    let diff = Math.max(0, len - content.length);\r\n    return `${content}${Array(diff).fill(' ').join('')}`;\r\n}\r\n\r\nclass Emitter<ContextT extends CodeContext> extends CodeEmitter<ContextT> {\r\n    emitFunctionDefinition(ctx: ContextT, def: IFunctionDefInstruction, attrs: IAttributeInstruction[]): void {\r\n        const { typeName } = this.resolveType(ctx, def.returnType);\r\n        // this.emitKeyword(alignL(typeName, 10));\r\n        // this.emitKeyword(alignR(def.name, 16));\r\n        attrs?.forEach(attr => this.emitLine(`[${attr.name}]`));\r\n        this.emitKeyword(typeName);\r\n        this.emitKeyword(def.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitParams(ctx, def.params);\r\n        this.emitChar(')');\r\n    }\r\n}\r\n\r\nexport function debugPrint(scope: IScope) {\r\n\r\n    const ctx = new CodeContext;\r\n    const emitter = new Emitter({ omitEmptyParams: true });\r\n\r\n    const { functions, types, typeTemplates } = scope;\r\n\r\n    emitter.begin();\r\n    for (let name in types) {\r\n        const type = types[name];\r\n        emitter.emitLine(`// ${type.name};`);\r\n    }\r\n    emitter.end();\r\n\r\n    emitter.begin();\r\n    for (let name in typeTemplates) {\r\n        const tpl = typeTemplates[name];\r\n        emitter.emitLine(`// ${tpl.name};`);\r\n    }\r\n    emitter.end();\r\n\r\n    emitter.begin();\r\n    for (let name in functions) {\r\n        const overloads = functions[name];\r\n\r\n        for (const fn of overloads) {\r\n            emitter.emitFunctionDefinition(ctx, fn.def, fn.attrs);\r\n            emitter.emitChar(';');\r\n            emitter.emitNewline();\r\n        }\r\n\r\n        emitter.emitNewline();\r\n    }\r\n    emitter.end();\r\n    return emitter.toString();\r\n}\r\n","import { IScope, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { addFieldsToVectorFromSuffixObject, defineTypeAlias, generateSuffixLiterals, generateSystemType, getSystemType, USE_STRICT_HALF_TYPE } from \"./utils\";\r\n\r\nexport function addSystemTypeVector(scope: IScope): void {\r\n    const XYSuffix = generateSuffixLiterals(\"xy\");\r\n    const XYZSuffix = generateSuffixLiterals(\"xyz\");\r\n    const XYZWSuffix = generateSuffixLiterals(\"xyzw\");\r\n\r\n    const RGSuffix = generateSuffixLiterals(\"rg\");\r\n    const RGBSuffix = generateSuffixLiterals(\"rgb\");\r\n    const RGBASuffix = generateSuffixLiterals(\"rgba\");\r\n\r\n    const STSuffix = generateSuffixLiterals(\"st\");\r\n    const STPSuffix = generateSuffixLiterals(\"stp\");\r\n    const STPQSuffix = generateSuffixLiterals(\"stpq\");\r\n\r\n\r\n    let float = getSystemType(scope, \"float\");\r\n    let half = getSystemType(scope, \"half\");\r\n    let int = getSystemType(scope, \"int\");\r\n    let uint = getSystemType(scope, \"uint\");\r\n    let bool = getSystemType(scope, \"bool\");\r\n\r\n    let float2 = generateSystemType(scope, \"float2\", -1, float, 2);\r\n    let float3 = generateSystemType(scope, \"float3\", -1, float, 3);\r\n    let float4 = generateSystemType(scope, \"float4\", -1, float, 4);\r\n\r\n    if (!USE_STRICT_HALF_TYPE) {\r\n        defineTypeAlias(scope, 'float2', 'half2');\r\n        defineTypeAlias(scope, 'float3', 'half3');\r\n        defineTypeAlias(scope, 'float4', 'half4');\r\n    }\r\n\r\n    let int2 = generateSystemType(scope, \"int2\", -1, int, 2);\r\n    let int3 = generateSystemType(scope, \"int3\", -1, int, 3);\r\n    let int4 = generateSystemType(scope, \"int4\", -1, int, 4);\r\n\r\n    let uint2 = generateSystemType(scope, \"uint2\", -1, uint, 2);\r\n    let uint3 = generateSystemType(scope, \"uint3\", -1, uint, 3);\r\n    let uint4 = generateSystemType(scope, \"uint4\", -1, uint, 4);\r\n\r\n    let bool2 = generateSystemType(scope, \"bool2\", -1, bool, 2);\r\n    let bool3 = generateSystemType(scope, \"bool3\", -1, bool, 3);\r\n    let bool4 = generateSystemType(scope, \"bool4\", -1, bool, 4);\r\n\r\n    {\r\n        let suf2f: IVariableDeclInstruction[] = [];\r\n        // program.push(EScopeType.k_Struct);\r\n        addFieldsToVectorFromSuffixObject(scope, suf2f, XYSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2f, RGSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2f, STSuffix, \"float\");\r\n        // program.pop();\r\n        suf2f.forEach(field => float2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3f: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf3f, XYZSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3f, RGBSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3f, STPSuffix, \"float\");\r\n        suf3f.forEach(field => float3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4f: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf4f, XYZWSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4f, RGBASuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4f, STPQSuffix, \"float\");\r\n        suf4f.forEach(field => float4.addField(field));\r\n    }\r\n\r\n    if (USE_STRICT_HALF_TYPE) {\r\n        let half2 = generateSystemType(scope, \"half2\", -1, half, 2);\r\n        let half3 = generateSystemType(scope, \"half3\", -1, half, 3);\r\n        let half4 = generateSystemType(scope, \"half4\", -1, half, 4);\r\n\r\n        {\r\n            let suf2f: IVariableDeclInstruction[] = [];\r\n            // program.push(EScopeType.k_Struct);\r\n            addFieldsToVectorFromSuffixObject(scope, suf2f, XYSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf2f, RGSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf2f, STSuffix, \"half\");\r\n            // program.pop();\r\n            suf2f.forEach(field => half2.addField(field));\r\n        }\r\n\r\n        {\r\n            let suf3f: IVariableDeclInstruction[] = [];\r\n            addFieldsToVectorFromSuffixObject(scope, suf3f, XYZSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf3f, RGBSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf3f, STPSuffix, \"half\");\r\n            suf3f.forEach(field => half3.addField(field));\r\n        }\r\n\r\n        {\r\n            let suf4f: IVariableDeclInstruction[] = [];\r\n            addFieldsToVectorFromSuffixObject(scope, suf4f, XYZWSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf4f, RGBASuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf4f, STPQSuffix, \"half\");\r\n            suf4f.forEach(field => half4.addField(field));\r\n        }\r\n    }\r\n\r\n    {\r\n        let suf2i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf2i, XYSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2i, RGSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2i, STSuffix, \"int\");\r\n        suf2i.forEach(field => int2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf3i, XYZSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3i, RGBSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3i, STPSuffix, \"int\");\r\n        suf3i.forEach(field => int3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf4i, XYZWSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4i, RGBASuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4i, STPQSuffix, \"int\");\r\n        suf4i.forEach(field => int4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf2ui, XYSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2ui, RGSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2ui, STSuffix, \"uint\");\r\n        suf2ui.forEach(field => uint2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf3ui, XYZSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3ui, RGBSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3ui, STPSuffix, \"uint\");\r\n        suf3ui.forEach(field => uint3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf4ui, XYZWSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4ui, RGBASuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4ui, STPQSuffix, \"uint\");\r\n        suf4ui.forEach(field => uint4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf2b, XYSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2b, RGSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2b, STSuffix, \"bool\");\r\n        suf2b.forEach(field => bool2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf3b, XYZSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3b, RGBSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3b, STPSuffix, \"bool\");\r\n        suf3b.forEach(field => bool3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf4b, XYZWSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4b, RGBASuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4b, STPQSuffix, \"bool\");\r\n        suf4b.forEach(field => bool4.addField(field));\r\n    }\r\n}\r\n","import * as Bytecode from \"@lib/fx/bytecode/Bytecode\";\r\nimport { typeAstToTypeLayout } from \"@lib/fx/bytecode/VM/native\";\r\nimport { createSLASTDocument } from \"@lib/fx/SLASTDocument\";\r\nimport { createSLDocument } from \"@lib/fx/SLDocument\";\r\nimport { createTextDocument } from \"@lib/fx/TextDocument\";\r\nimport { CodeConvolutionContext, CodeConvolutionEmitter } from \"@lib/fx/translators/CodeConvolutionEmitter\";\r\nimport { FxTranslator, FxTranslatorContext, ICSShaderReflectionEx, IFxContextExOptions, IPartFxPassReflection, IPartFxReflection, IPassReflection, IPreset, IUIControl } from \"@lib/fx/translators/FxTranslator\";\r\nimport { GLSLContext, GLSLEmitter } from \"@lib/fx/translators/GlslEmitter\";\r\nimport { EInstructionTypes, ITechniqueInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { EPassDrawMode, IPartFxInstruction } from \"@lib/idl/part/IPartFx\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\nimport { ConvolutionPackEx, encodeControlValue, encodePropertyValue, controlValueFromString, propertyValueFromString } from \"./utils\";\r\n\r\nimport { CBBundleT } from \"@lib/idl/bundles/auto/cbbundle\";\r\nimport { BufferBundleT } from \"@lib/idl/bundles/auto/fx/buffer-bundle\";\r\nimport { BundleT } from \"@lib/idl/bundles/auto/fx/bundle\";\r\nimport { BundleContent } from \"@lib/idl/bundles/auto/fx/bundle-content\";\r\nimport { BundleMetaT } from \"@lib/idl/bundles/auto/fx/bundle-meta\";\r\nimport { BundleSignatureT } from \"@lib/idl/bundles/auto/fx/bundle-signature\";\r\nimport { EPartSimRoutines } from \"@lib/idl/bundles/auto/fx/epart-sim-routines\";\r\nimport { GLSLAttributeT } from \"@lib/idl/bundles/auto/fx/glslattribute\";\r\nimport { MatBundleT } from \"@lib/idl/bundles/auto/fx/mat-bundle\";\r\nimport { MatRenderPassT } from \"@lib/idl/bundles/auto/fx/mat-render-pass\";\r\nimport { PartBundleT } from \"@lib/idl/bundles/auto/fx/part-bundle\";\r\nimport { PartRenderPassT } from \"@lib/idl/bundles/auto/fx/part-render-pass\";\r\nimport { PresetT } from \"@lib/idl/bundles/auto/fx/preset\";\r\nimport { PresetEntryT } from \"@lib/idl/bundles/auto/fx/preset-entry\";\r\nimport { RenderStateT } from \"@lib/idl/bundles/auto/fx/render-state\";\r\nimport { RoutineBundle } from \"@lib/idl/bundles/auto/fx/routine-bundle\";\r\nimport { RoutineBytecodeBundleT } from \"@lib/idl/bundles/auto/fx/routine-bytecode-bundle\";\r\nimport { RoutineBytecodeBundleResourcesT } from \"@lib/idl/bundles/auto/fx/routine-bytecode-bundle-resources\";\r\nimport { RoutineGLSLSourceBundleT } from \"@lib/idl/bundles/auto/fx/routine-glslsource-bundle\";\r\nimport { RoutineHLSLSourceBundleT } from \"@lib/idl/bundles/auto/fx/routine-hlslsource-bundle\";\r\nimport { RoutineShaderBundleT } from \"@lib/idl/bundles/auto/fx/routine-shader-bundle\";\r\nimport { RoutineSourceBundle } from \"@lib/idl/bundles/auto/fx/routine-source-bundle\";\r\nimport { Technique11BundleT } from \"@lib/idl/bundles/auto/fx/technique11bundle\";\r\nimport { TextureBundleT } from \"@lib/idl/bundles/auto/fx/texture-bundle\";\r\nimport { TrimeshBundleT } from \"@lib/idl/bundles/auto/fx/trimesh-bundle\";\r\nimport { UAVBundleT } from \"@lib/idl/bundles/auto/fx/uavbundle\";\r\nimport { UIControlT } from \"@lib/idl/bundles/auto/fx/uicontrol\";\r\nimport { ViewTypePropertyT } from \"@lib/idl/bundles/auto/fx/view-type-property\";\r\nimport { TypeFieldT } from \"@lib/idl/bundles/auto/type-field\";\r\nimport { TypeLayoutT } from \"@lib/idl/bundles/auto/type-layout\";\r\nimport * as flatbuffers from \"flatbuffers\";\r\n\r\n\r\n\r\nexport const PACKED = true;\r\n\r\n\r\n// global defines from webpack's config;\r\n/// <reference path=\"../../webpack.d.ts\" />\r\nfunction createFxBundleSignature(): BundleSignatureT {\r\n    return new BundleSignatureT(MODE, VERSION, COMMITHASH, BRANCH, TIMESTAMP);\r\n}\r\n\r\n\r\nfunction createFxBundle(name: string, type: BundleContent, data: PartBundleT | MatBundleT | Technique11BundleT, meta = new BundleMetaT, controls?: UIControlT[], presets?: PresetT[]): BundleT {\r\n    const signature = createFxBundleSignature();\r\n    return new BundleT(name, signature, meta, type, data, controls, presets);\r\n}\r\n\r\n\r\nfunction createPartFxRenderPass(slDocument: ISLDocument, reflection: IPartFxPassReflection, opts: BundleOptions = {}): PartRenderPassT {\r\n    const scope = slDocument.root.scope;\r\n    const { geometry, sorting, instanceCount, CSParticlesPrerenderRoutine, drawMode } = reflection;\r\n    const prerender = drawMode == EPassDrawMode.k_Auto\r\n        ? createFxRoutineBytecodeBundle(slDocument, CSParticlesPrerenderRoutine)\r\n        : createFxRoutineNoBytecodeBundle(); // fill dummy routine for backward compartibility\r\n    // create GLSL attribute based instance layout\r\n    const partType = scope.findType(reflection.instance);\r\n    const instance = createFxTypeLayout(partType);\r\n    const vertex = createFxRoutineVsShaderBundle(slDocument, reflection.instance, reflection.VSParticleShader, opts);\r\n    const pixel = createFxRoutinePsShaderBundle(slDocument, reflection.PSParticleShader, opts);\r\n    const routineTypes = [RoutineBundle.RoutineBytecodeBundle, RoutineBundle.RoutineShaderBundle, RoutineBundle.RoutineShaderBundle];\r\n    const routines = [prerender, vertex, pixel]; // must be aligned with EPartRenderRoutines\r\n    const instanceType = scope.findType(reflection.instance);\r\n    const stride = instanceType.size >> 2;\r\n    const renderStates = Object.keys(reflection.renderStates).map(key => new RenderStateT(Number(key), Number(reflection.renderStates[key])));\r\n    return new PartRenderPassT(routineTypes, routines, geometry, sorting, instanceCount, stride, instance, renderStates);\r\n}\r\n\r\n\r\n\r\nfunction createMatFxRenderPass(slDocument: ISLDocument, reflection: IPassReflection, opts: BundleOptions = {}, convPack: ConvolutionPackEx = {}): MatRenderPassT {\r\n    const scope = slDocument.root.scope;\r\n    const vs = createFxRoutineVsShaderBundle(slDocument, reflection.instance, reflection.VSParticleShader, opts, convPack);\r\n    const ps = createFxRoutinePsShaderBundle(slDocument, reflection.PSParticleShader, opts, convPack);\r\n    const routineTypes = [RoutineBundle.RoutineShaderBundle, RoutineBundle.RoutineShaderBundle];\r\n    const routines = [vs, ps]; // must be aligned with EMatRenderRoutines\r\n    const vertexType = scope.findType(reflection.instance);\r\n    const instance = createFxTypeLayout(vertexType);\r\n    const instanceType = scope.findType(reflection.instance);\r\n    const stride = instanceType.size >> 2;\r\n    const renderStates = Object.keys(reflection.renderStates).map(key => new RenderStateT(Number(key), Number(reflection.renderStates[key])));\r\n    return new MatRenderPassT(routineTypes, routines, instance, stride, renderStates);\r\n}\r\n\r\n\r\nfunction createFxTypeLayout(type: ITypeInstruction): TypeLayoutT {\r\n    return typeAstToTypeLayout(type);\r\n}\r\n\r\n\r\nfunction createFxRoutineNoBytecodeBundle(): RoutineBytecodeBundleT {\r\n    return new RoutineBytecodeBundleT();\r\n}\r\n\r\n\r\nfunction createFxRoutineBytecodeBundle(slDocument: ISLDocument, reflection: ICSShaderReflectionEx): RoutineBytecodeBundleT {\r\n    const entry = reflection.name;\r\n    const numthreads = [...reflection.numthreads];\r\n    const bcDocument = Bytecode.translate(slDocument, entry);\r\n\r\n    if (bcDocument.diagnosticReport.errors) {\r\n        // const content = CodeEmitter.translateDocument(slDocument);\r\n        // const step = (y, x) => x > y ? 1 : 0;\r\n        // const pad = (x) => Array(step(x, 1000) + step(x, 100) + step(x, 10)).fill(' ').join('') + x;\r\n        // console.log(content.split('\\n').map((line, i) => `${pad(i + 1)}. ${line}`).join('\\n'));\r\n        console.error(Diagnostics.stringify(bcDocument.diagnosticReport));\r\n        alert('could not generate bytecode, see console log for details');\r\n    }\r\n\r\n    const code = bcDocument.program?.code;\r\n\r\n    if (!code) {\r\n        return new RoutineBytecodeBundleT();\r\n    }\r\n\r\n    const uavs = reflection.uavs.map(({ name, register: slot, elementType }) => {\r\n        const typeInstr = slDocument.root.scope.findType(elementType);\r\n        const stride = typeInstr.size; // in bytes\r\n        const type = createFxTypeLayout(typeInstr);\r\n        return new UAVBundleT(name, slot, stride, type);\r\n    });\r\n    const buffers = reflection.buffers.map(({ name, register: slot, elementType }) => {\r\n        const typeInstr = slDocument.root.scope.findType(elementType);\r\n        const stride = typeInstr.size; // in bytes\r\n        const type = createFxTypeLayout(typeInstr);\r\n        return new BufferBundleT(name, slot, stride, type);\r\n    });\r\n    const textures = reflection.textures.map(({ name, register: slot, elementType }) => {\r\n        const typeInstr = slDocument.root.scope.findType(elementType);\r\n        const stride = typeInstr.size; // in bytes\r\n        const type = createFxTypeLayout(typeInstr);\r\n        return new TextureBundleT(name, slot, stride, type);\r\n    });\r\n\r\n    const trimeshes = reflection.trimeshes.map(({ name, vertexCountUName, faceCountUName, verticesName, facesName, indicesAdjName, faceAdjName }) => {\r\n        return new TrimeshBundleT(name, vertexCountUName, faceCountUName, verticesName, facesName, indicesAdjName, faceAdjName);\r\n    });\r\n    return new RoutineBytecodeBundleT(Array.from(code), new RoutineBytecodeBundleResourcesT(uavs, buffers, textures, trimeshes), numthreads);\r\n}\r\n\r\n\r\n// function createFxPass11BytecodeBundle(pass11: IPass11Instruction): Pass11BytecodeBundleT {\r\n\r\n//     // todo: translate pass\r\n//     return new Pass11BytecodeBundleT();\r\n// }\r\n\r\n\r\nfunction createFxRoutineVsGLSLBundle(slDocument: ISLDocument, interpolatorsType: string, entryName: string, { name }: BundleOptions = {}): RoutineGLSLSourceBundleT {\r\n    const scope = slDocument.root.scope;\r\n    const fn = scope.findFunction(entryName, null);\r\n\r\n    if (!fn) {\r\n        return new RoutineGLSLSourceBundleT();\r\n    }\r\n\r\n    const partType = scope.findType(interpolatorsType);\r\n    const instance = createFxTypeLayout(partType);\r\n\r\n    const attrsGLSL = instance.fields.map(field => {\r\n        let size = field.size >> 2;\r\n        let offset = field.padding >> 2;\r\n        let attrName = GLSLEmitter.$declToAttributeName(partType.getField(<string>field.name));\r\n        return new GLSLAttributeT(size, offset, attrName);\r\n    });\r\n\r\n    const ctx = new GLSLContext({ mode: 'vs' });\r\n    const codeGLSL = GLSLEmitter.translate(fn, ctx); // raw hlsl\r\n\r\n    const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {\r\n        const fields = scope.findCbuffer(name).type.fields.map(f => new TypeFieldT(createFxTypeLayout(f.type), f.name, f.semantic, f.type.size, f.type.padding));\r\n        return new CBBundleT(name, register, size, fields);\r\n    });\r\n\r\n    return new RoutineGLSLSourceBundleT(codeGLSL, attrsGLSL, cbuffers);\r\n}\r\n\r\n\r\nfunction createFxRoutineVsHLSLBundle(slDocument: ISLDocument, entryName: string, { name }: BundleOptions = {}, { textDocument, slastDocument }: ConvolutionPackEx = {}): RoutineHLSLSourceBundleT {\r\n    const scope = slDocument.root.scope;\r\n    const fn = scope.findFunction(entryName, null);\r\n\r\n    if (!fn) {\r\n        return new RoutineHLSLSourceBundleT();\r\n    }\r\n    // set entry point name according with bundle name\r\n    const ctx = new CodeConvolutionContext({ textDocument, slastDocument, mode: 'vs', entryName: name });\r\n    const codeHLSL = CodeConvolutionEmitter.translate(fn, ctx); // raw hlsl\r\n\r\n    const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {\r\n        const fields = scope.findCbuffer(name).type.fields.map(f => new TypeFieldT(createFxTypeLayout(f.type), f.name, f.semantic, f.type.size, f.type.padding));\r\n        return new CBBundleT(name, register, size, fields);\r\n    });\r\n\r\n    return new RoutineHLSLSourceBundleT(codeHLSL, name, cbuffers);\r\n}\r\n\r\n\r\nfunction createFxRoutineVsShaderBundle(slDocument: ISLDocument, interpolatorsType: string, entryName: string, opts: BundleOptions = {}, convPack: ConvolutionPackEx = {}): RoutineShaderBundleT {\r\n    const shaderType = [];\r\n    const shaderBundles = [];\r\n\r\n    if (!opts.omitGLSL) {\r\n        shaderType.push(RoutineSourceBundle.RoutineGLSLSourceBundle);\r\n        shaderBundles.push(createFxRoutineVsGLSLBundle(slDocument, interpolatorsType, entryName, opts));\r\n    }\r\n\r\n    if (!opts.omitHLSL) {\r\n        shaderType.push(RoutineSourceBundle.RoutineHLSLSourceBundle);\r\n        shaderBundles.push(createFxRoutineVsHLSLBundle(slDocument, entryName, opts, convPack));\r\n    }\r\n\r\n    return new RoutineShaderBundleT(shaderType, shaderBundles);\r\n}\r\n\r\n\r\nfunction createFxRoutinePsGLSLBundle(slDocument: ISLDocument, entryName: string, { name }: BundleOptions = {}): RoutineGLSLSourceBundleT {\r\n    const scope = slDocument.root.scope;\r\n    const fn = scope.findFunction(entryName, null);\r\n\r\n    if (!fn) {\r\n        return new RoutineGLSLSourceBundleT();\r\n    }\r\n\r\n    // set entry point name according with bundle name\r\n    const ctx = new GLSLContext({ mode: 'ps' });\r\n    const codeGLSL = GLSLEmitter.translate(fn, ctx); // raw hlsl\r\n\r\n    const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {\r\n        const fields = scope.findCbuffer(name).type.fields.map(f => new TypeFieldT(createFxTypeLayout(f.type), f.name, f.semantic, f.type.size, f.type.padding));\r\n        return new CBBundleT(name, register, size, fields);\r\n    });\r\n\r\n    return new RoutineGLSLSourceBundleT(codeGLSL, [], cbuffers);\r\n}\r\n\r\n\r\nfunction createFxRoutinePsHLSLBundle(slDocument: ISLDocument, entryName: string, { name }: BundleOptions = {}, { textDocument, slastDocument }: ConvolutionPackEx = {}): RoutineHLSLSourceBundleT {\r\n    const scope = slDocument.root.scope;\r\n    const fn = scope.findFunction(entryName, null);\r\n\r\n    if (!fn) {\r\n        return new RoutineHLSLSourceBundleT();\r\n    }\r\n\r\n    // set entry point name according with bundle name\r\n    const ctx = new CodeConvolutionContext({ textDocument, slastDocument, mode: 'ps', entryName: name });\r\n    const codeHLSL = CodeConvolutionEmitter.translate(fn, ctx); // raw hlsl\r\n\r\n    const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {\r\n        const fields = scope.findCbuffer(name).type.fields.map(f => new TypeFieldT(createFxTypeLayout(f.type), f.name, f.semantic, f.type.size, f.type.padding));\r\n        return new CBBundleT(name, register, size, fields);\r\n    });\r\n\r\n    return new RoutineHLSLSourceBundleT(codeHLSL, name, cbuffers);\r\n}\r\n\r\n\r\nfunction createFxRoutinePsShaderBundle(slDocument: ISLDocument, entryName: string, opts: BundleOptions = {}, convPack: ConvolutionPackEx = {}): RoutineShaderBundleT {\r\n    const shaderType = [];\r\n    const shaderBundles = [];\r\n\r\n    if (!opts.omitGLSL) {\r\n        shaderType.push(RoutineSourceBundle.RoutineGLSLSourceBundle);\r\n        shaderBundles.push(createFxRoutinePsGLSLBundle(slDocument, entryName, opts));\r\n    }\r\n\r\n    if (!opts.omitHLSL) {\r\n        shaderType.push(RoutineSourceBundle.RoutineHLSLSourceBundle);\r\n        shaderBundles.push(createFxRoutinePsHLSLBundle(slDocument, entryName, opts, convPack));\r\n    }\r\n\r\n    return new RoutineShaderBundleT(shaderType, shaderBundles);\r\n}\r\n\r\n\r\n\r\nfunction createFxControls(controls: IUIControl[]): UIControlT[] {\r\n    return controls.map(ctrl => {\r\n        const props = ctrl.properties.map(prop => new ViewTypePropertyT(\r\n            prop.name, \r\n            propertyValueFromString(prop.type), \r\n            encodePropertyValue(prop.type, prop.value)\r\n        ));\r\n        return new UIControlT(\r\n            ctrl.name, \r\n            controlValueFromString(ctrl.type), \r\n            encodeControlValue(ctrl.type, ctrl.value), \r\n            props);\r\n    });\r\n}\r\n\r\n\r\nfunction createFxPresets(presets: IPreset[]): PresetT[] {\r\n    return presets.map(\r\n        ({ name, desc, data }) => new PresetT(\r\n            name,\r\n            desc,\r\n            data.map(({ name, type, value }) => new PresetEntryT(\r\n                name, \r\n                controlValueFromString(type), \r\n                encodeControlValue(type, value)\r\n            ))\r\n        )\r\n    );\r\n}\r\n\r\n\r\nexport interface BundleOptions {\r\n    packed?: boolean;\r\n    meta?: {\r\n        author: string;\r\n        source: string;\r\n    };\r\n    omitHLSL?: boolean;\r\n    omitGLSL?: boolean;\r\n    name?: string;\r\n\r\n    translator?: IFxContextExOptions;\r\n}\r\n\r\n\r\nfunction finalizeBundle(bundle: BundleT, opts: BundleOptions = {}): Uint8Array | BundleT {\r\n    // get unpacked version\r\n    // --------------------------------\r\n\r\n    let { packed = PACKED } = opts;\r\n\r\n    if (!packed)\r\n        return bundle;\r\n\r\n    // get packed version\r\n    // --------------------------------\r\n\r\n    let fbb = new flatbuffers.Builder();\r\n    let end = bundle.pack(fbb);\r\n    fbb.finish(end);\r\n\r\n    return fbb.asUint8Array();\r\n}\r\n\r\n\r\nasync function createPartFxBundle(fx: IPartFxInstruction, opts: BundleOptions = {}): Promise<Uint8Array | BundleT> {\r\n    const ctx = new FxTranslatorContext({ ...opts.translator });\r\n    const raw = FxTranslator.translate(fx, ctx); // raw hlsl\r\n\r\n    const reflection = ctx.techniques[0] as IPartFxReflection;\r\n    const { name, capacity } = reflection;\r\n\r\n    opts.name ||= name;\r\n\r\n    const textDocument = await createTextDocument('://raw', raw);\r\n    const slDocument = await createSLDocument(textDocument);\r\n    const scope = slDocument.root.scope;\r\n\r\n\r\n    if (slDocument.diagnosticReport.errors) {\r\n        console.error(Diagnostics.stringify(slDocument.diagnosticReport));\r\n        return null;\r\n    }\r\n\r\n    const particle = createFxTypeLayout(scope.findType(reflection.particle));\r\n    const routines = Array<RoutineShaderBundleT | RoutineBytecodeBundleT>(EPartSimRoutines.k_Last);\r\n    const routineTypes = Array<RoutineBundle>(EPartSimRoutines.k_Last);\r\n\r\n    routineTypes[EPartSimRoutines.k_Reset] = RoutineBundle.RoutineBytecodeBundle;\r\n    routines[EPartSimRoutines.k_Reset] = createFxRoutineBytecodeBundle(slDocument, reflection.CSParticlesResetRoutine);\r\n\r\n    routineTypes[EPartSimRoutines.k_Spawn] = RoutineBundle.RoutineBytecodeBundle;\r\n    routines[EPartSimRoutines.k_Spawn] = createFxRoutineBytecodeBundle(slDocument, reflection.CSParticlesSpawnRoutine);\r\n\r\n    routineTypes[EPartSimRoutines.k_Init] = RoutineBundle.RoutineBytecodeBundle;\r\n    routines[EPartSimRoutines.k_Init] = createFxRoutineBytecodeBundle(slDocument, reflection.CSParticlesInitRoutine);\r\n\r\n    routineTypes[EPartSimRoutines.k_Update] = RoutineBundle.RoutineBytecodeBundle;\r\n    routines[EPartSimRoutines.k_Update] = createFxRoutineBytecodeBundle(slDocument, reflection.CSParticlesUpdateRoutine);\r\n\r\n    const passes = reflection.passes.map(pass => createPartFxRenderPass(slDocument, pass, opts));\r\n    const part = new PartBundleT(capacity, routineTypes, routines, passes, particle);\r\n\r\n    const controls = createFxControls(reflection.controls);\r\n    const presets = createFxPresets(reflection.presets);\r\n\r\n    const { meta } = opts;\r\n    const bundle = createFxBundle(opts.name, BundleContent.PartBundle, part, new BundleMetaT(meta?.author, meta?.source), controls, presets);\r\n\r\n    return finalizeBundle(bundle, opts);\r\n}\r\n\r\n\r\n\r\n/** @deprecated */\r\nasync function createMatFxBundle(tech: ITechniqueInstruction, opts: BundleOptions = {}, convPack: ConvolutionPackEx = {}): Promise<Uint8Array | BundleT> {\r\n    const { includeResolver, defines } = convPack;\r\n    \r\n    const { textDocument, slastDocument } = convPack;\r\n    const ctx = new FxTranslatorContext({ ...opts.translator, textDocument, slastDocument });\r\n    const raw = FxTranslator.translate(tech, ctx);\r\n\r\n    const reflection = ctx.techniques[0];\r\n    const { name } = reflection;\r\n\r\n    opts.name ||= name;\r\n\r\n    const textDocument3 = await createTextDocument('file://foo.bar///mat.fx', raw);\r\n    const slastDocument3 = await createSLASTDocument(textDocument3, { includeResolver, defines });\r\n    const slDocument = await createSLDocument(slastDocument3);\r\n\r\n    if (slDocument.diagnosticReport.errors) {\r\n        console.error(Diagnostics.stringify(slDocument.diagnosticReport));\r\n        return null;\r\n    }\r\n\r\n    const passes = reflection.passes.map(pass => createMatFxRenderPass(slDocument, pass, opts, new ConvolutionPackEx(textDocument3, slastDocument3, includeResolver, defines)));\r\n    const mat = new MatBundleT(passes);\r\n\r\n    const controls = createFxControls(reflection.controls);\r\n    const presets = createFxPresets(reflection.presets);\r\n\r\n    const { meta } = opts;\r\n    const bundle = createFxBundle(opts.name, BundleContent.MatBundle, mat, new BundleMetaT(meta?.author, meta?.source), controls, presets);\r\n\r\n    return finalizeBundle(bundle, opts);\r\n}\r\n\r\n\r\nexport async function createBundle(fx: ITechniqueInstruction, options?: BundleOptions, convPack?: ConvolutionPackEx): Promise<Uint8Array | BundleT> {\r\n    switch (fx.instructionType) {\r\n        case EInstructionTypes.k_PartFxDecl:\r\n            return createPartFxBundle(<IPartFxInstruction>fx, options);\r\n        case EInstructionTypes.k_TechniqueDecl:\r\n            return createMatFxBundle(fx, options, convPack);\r\n    }\r\n    console.assert(false);\r\n    return null;\r\n}\r\n\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport * as Bytecode from \"@lib/fx/bytecode/Bytecode\";\r\nimport { typeAstToTypeLayout } from \"@lib/fx/bytecode/VM/native\";\r\nimport * as TSVM from \"@lib/fx/bytecode/VM/ts/bundle\";\r\nimport { createSLASTDocument } from \"@lib/fx/SLASTDocument\";\r\nimport { createSLDocument } from \"@lib/fx/SLDocument\";\r\nimport { createTextDocument } from \"@lib/fx/TextDocument\";\r\nimport { CodeConvolutionContext, CodeConvolutionEmitter } from \"@lib/fx/translators/CodeConvolutionEmitter\";\r\nimport { CodeContextMode } from \"@lib/fx/translators/CodeEmitter\";\r\nimport { FxTranslator, FxTranslatorContext, IFxContextExOptions, IUIControl } from \"@lib/fx/translators/FxTranslator\";\r\nimport { TypeFieldT } from \"@lib/idl/bundles/auto/type-field\";\r\nimport { EChunkType } from \"@lib/idl/bytecode\";\r\nimport { ITechnique11Instruction } from \"@lib/idl/IInstruction\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\nimport { isDef } from \"@lib/util/s3d/type\";\r\nimport { ConvolutionPackEx, encodeControlValue, encodePropertyValue, controlValueFromString, propertyValueFromString } from \"./utils\";\r\n\r\nimport * as flatbuffers from \"flatbuffers\";\r\n\r\nimport { CBBundleT } from \"@lib/idl/bundles/auto/cbbundle\";\r\nimport { BundleT } from \"@lib/idl/bundles/auto/fx/bundle\";\r\nimport { BundleContent } from \"@lib/idl/bundles/auto/fx/bundle-content\";\r\nimport { BundleMetaT } from \"@lib/idl/bundles/auto/fx/bundle-meta\";\r\nimport { BundleSignatureT } from \"@lib/idl/bundles/auto/fx/bundle-signature\";\r\nimport { PixelShaderT } from \"@lib/idl/bundles/auto/fx/pixel-shader\";\r\nimport { PresetT } from \"@lib/idl/bundles/auto/fx/preset\";\r\nimport { Shader } from \"@lib/idl/bundles/auto/fx/shader\";\r\nimport { Technique11BundleT } from \"@lib/idl/bundles/auto/fx/technique11bundle\";\r\nimport { Technique11RenderPassT } from \"@lib/idl/bundles/auto/fx/technique11render-pass\";\r\nimport { UIControlT } from \"@lib/idl/bundles/auto/fx/uicontrol\";\r\nimport { VertexShaderT } from \"@lib/idl/bundles/auto/fx/vertex-shader\";\r\nimport { ViewTypePropertyT } from \"@lib/idl/bundles/auto/fx/view-type-property\";\r\n\r\n/** Create flatbuffers controls from native translator description. */\r\nfunction createFxControls(controls: IUIControl[]): UIControlT[] {\r\n    return controls.map(ctrl => {\r\n        const props = ctrl.properties.map(prop => new ViewTypePropertyT(\r\n            prop.name, \r\n            propertyValueFromString(prop.type), \r\n            encodePropertyValue(prop.type, prop.value)\r\n        ));\r\n        return new UIControlT(\r\n            ctrl.name, \r\n            controlValueFromString(ctrl.type), \r\n            encodeControlValue(ctrl.type, ctrl.value), \r\n            props);\r\n    });\r\n}\r\n\r\n\r\nexport interface Bundle11Options {\r\n    packed?: boolean;\r\n    meta?: {\r\n        author: string;\r\n        source: string;\r\n    };\r\n    name?: string;\r\n    // deprecated?\r\n    translator?: IFxContextExOptions;\r\n}\r\n\r\n\r\n/// <reference path=\"../../webpack.d.ts\" />\r\nfunction createFxBundle(name: string, type: BundleContent, data: Technique11BundleT, meta = new BundleMetaT, controls?: UIControlT[], presets?: PresetT[]): BundleT {\r\n    const signature = new BundleSignatureT(MODE, VERSION, COMMITHASH, BRANCH, TIMESTAMP);\r\n    return new BundleT(name, signature, meta, type, data, controls, presets);\r\n}\r\n\r\n\r\nfunction finalizeBundle(bundle: BundleT, opts: Bundle11Options = {}): Uint8Array | BundleT {\r\n    // get unpacked version\r\n    // --------------------------------\r\n\r\n    let { packed = true } = opts;\r\n\r\n    if (!packed)\r\n        return bundle;\r\n\r\n    // get packed version\r\n    // --------------------------------\r\n\r\n    let fbb = new flatbuffers.Builder();\r\n    let end = bundle.pack(fbb);\r\n    fbb.finish(end);\r\n\r\n    return fbb.asUint8Array();\r\n}\r\n\r\n\r\n/**\r\n * Pipeline:\r\n *  1. Translate the whole technique to raw hlsl\r\n *     in order to unwrap fx types (like trimeshes)\r\n *     and collect autogen buffers (like controls, global & local uniforms).\r\n *  2. Iterate over pass code to find all used shaders to print raw per \r\n *     shader hlsl code with precise reflections (used cbuffers).\r\n *  3. Wrap with flatbuffers.\r\n */\r\nasync function createTechnique11Bundle(tech: ITechnique11Instruction, opts: Bundle11Options = {}, \r\n    convPack: ConvolutionPackEx = {}): Promise<Uint8Array | BundleT> {\r\n    const ctx = new FxTranslatorContext({ ...opts.translator, ...convPack });\r\n    const codeRaw =  FxTranslator.translate(tech, ctx);\r\n    const passes: Technique11RenderPassT[] = [];\r\n    for (const pass11 of tech.passes) {\r\n        const { program } = Bytecode.translate(pass11);\r\n        // depth, stencil, rasterizer and blend states are already serialized\r\n        // as part of code binary\r\n        const { code, cdl } = program;\r\n        const chunks = TSVM.decodeChunks(code);\r\n        const shaderChunk = chunks[EChunkType.k_Shaders];\r\n\r\n        const shaderTypes: Shader[] = [];\r\n        const shaders : (PixelShaderT | VertexShaderT)[] = [];\r\n\r\n        if (isDef(shaderChunk)) {\r\n            const descs = TSVM.decodeShadersChunk(shaderChunk);\r\n            for (const desc of descs) {\r\n                const { ver, args, name } = desc;\r\n                console.warn(`compile shader <${name}> -v ${ver}`, args);\r\n\r\n                // it's assumed that all the shaders places in the same scope for now\r\n                // (near the technique it'self in other words - not imported)\r\n                \r\n                {\r\n                    const scope = tech.scope;\r\n                    const entryFn = scope.findFunction(name, null);\r\n                    const params = entryFn.def.params;\r\n                    assert(args.every((_, i) => [ ...params ].reverse()[i].type.name === [ ...args ].reverse()[i].type), \r\n                        'entry function doesn\\'t match uniform arguments');\r\n                }\r\n\r\n                const mode = <CodeContextMode>ver.substring(0, 2);\r\n                assert(['vs', 'ps', 'gs'].includes(mode), `invalid mode: \"${mode}\"`);\r\n\r\n                // translate per shader in order to extract precise reflection\r\n                const textDocument = await createTextDocument(`file://${tech.name}///${name}.fx`, codeRaw);\r\n                const slastDocument = await createSLASTDocument(textDocument, convPack);\r\n                const slDocument = await createSLDocument(slastDocument);\r\n\r\n                const convPackSh = new ConvolutionPackEx(textDocument, slastDocument, \r\n                    convPack.includeResolver, convPack.defines);\r\n            \r\n                if (slDocument.diagnosticReport.errors) {\r\n                    console.error(Diagnostics.stringify(slDocument.diagnosticReport));\r\n                    return null;\r\n                }\r\n\r\n                const scope = slDocument.root.scope;\r\n                const entryFn = scope.findFunction(name, null);\r\n                const ctx = new CodeConvolutionContext({ ...convPackSh, mode, constants: args });\r\n                const sourceCode = CodeConvolutionEmitter.translate(entryFn, ctx);\r\n\r\n                const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {\r\n                    const { type } = scope.findCbuffer(name);\r\n                    const fields = type.fields.map(\r\n                        f => new TypeFieldT(\r\n                            typeAstToTypeLayout(f.type), \r\n                            f.name, \r\n                            f.semantic, \r\n                            f.type.size, \r\n                            f.type.padding\r\n                        )\r\n                    );\r\n                    return new CBBundleT(name, register, size, fields);\r\n                });\r\n\r\n                let shaderType: Shader;\r\n                let shader: VertexShaderT | PixelShaderT;\r\n                switch (mode) {\r\n                    case 'vs': \r\n                    let input = typeAstToTypeLayout(entryFn.def.params[0].type);\r\n                    shaderType = Shader.VertexShader;\r\n                    shader = new VertexShaderT(sourceCode, name, input, cbuffers);\r\n                    break;\r\n                    case 'ps':\r\n                    shaderType = Shader.PixelShader;\r\n                    shader = new PixelShaderT(sourceCode, name, cbuffers);\r\n                    break;\r\n                    default:\r\n                        assert(false, 'not implemeted');\r\n                }\r\n\r\n                shaderTypes.push(shaderType);\r\n                shaders.push(shader);\r\n            }\r\n        }\r\n\r\n        passes.push(new Technique11RenderPassT([ ...code ], shaderTypes, shaders));\r\n    };\r\n\r\n    ///////////////////////////////////\r\n\r\n    const { name } = tech;\r\n    opts.name ||= name;\r\n\r\n    const reflection = ctx.techniques11[0];\r\n    const controls = createFxControls(reflection.controls);\r\n\r\n    // todo: add presets support.\r\n    // const presets = ...\r\n\r\n    const tech11 = new Technique11BundleT(passes);\r\n\r\n    const { meta } = opts;\r\n    const bundle = createFxBundle(opts.name, BundleContent.Technique11Bundle, tech11, new BundleMetaT(meta?.author, meta?.source), controls);\r\n\r\n    return finalizeBundle(bundle, opts);\r\n}\r\n\r\n\r\nexport async function createBundle(fx: ITechnique11Instruction, options?: Bundle11Options, convPack?: ConvolutionPackEx): Promise<Uint8Array | BundleT> {\r\n    return createTechnique11Bundle(fx, options, convPack);\r\n}\r\n\r\n\r\n","import { IMap } from \"@lib/idl/IMap\";\r\nimport { Color, ControlValues, IPlaygroundControl, IPlaygroundControlsState, IPlaygroundPreset, IPlaygroundPresetEntry, Vector2, Vector3, Vector4 } from \"@sandbox/store/IStoreState\";\r\nimport { assert, isString } from \"@lib/common\";\r\nimport { ICodeConvolutionContextOptions } from \"@lib/fx/translators/CodeConvolutionEmitter\";\r\nimport { IKnownDefine } from \"@lib/parser/Preprocessor\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { ISLASTDocument } from \"@lib/idl/ISLASTDocument\";\r\nimport { IncludeResolver } from \"@lib/idl/parser/IParser\";\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\nimport { UintValueT } from \"@lib/idl/bundles/auto/fx/uint-value\";\r\nimport { IntValueT } from \"@lib/idl/bundles/auto/fx/int-value\";\r\nimport { FloatValueT } from \"@lib/idl/bundles/auto/fx/float-value\";\r\nimport { StringValueT } from \"@lib/idl/bundles/auto/fx/string-value\";\r\nimport { Float2ValueT } from \"@lib/idl/bundles/auto/fx/float2value\";\r\nimport { Float3ValueT } from \"@lib/idl/bundles/auto/fx/float3value\";\r\nimport { Float4ValueT } from \"@lib/idl/bundles/auto/fx/float4value\";\r\nimport { ControlValue } from \"@lib/idl/bundles/auto/fx/control-value\";\r\nimport { PropertyValue } from \"@lib/idl/bundles/auto/fx/property-value\";\r\nimport { ColorValueT } from \"@lib/idl/bundles/auto/fx/color-value\";\r\nimport { TextureValueT } from \"@lib/idl/bundles/auto/fx/texture-value\";\r\nimport { MeshValueT } from \"@lib/idl/bundles/auto/fx/mesh-value\";\r\nimport { UIControlT } from \"@lib/idl/bundles/auto/fx/uicontrol\";\r\nimport { PresetT } from \"@lib/idl/bundles/auto/fx/preset\";\r\nimport { Bundle, BundleT } from \"@lib/idl/bundles/auto/fx/bundle\";\r\n\r\nexport type PropertyValueType = number | string;\r\nexport type ControlValueType = boolean | number | Vector2 | Vector3 | Vector4 | Color | string;\r\nexport type PropertyValueT = UintValueT | IntValueT | FloatValueT | StringValueT;\r\nexport type ControlValueT = UintValueT | IntValueT | FloatValueT | Float2ValueT | Float3ValueT | Float4ValueT | ColorValueT | TextureValueT;\r\n\r\n// -----------------------------------------------------------------------------------------\r\n\r\n/** Get flatbuffers control value type from string constant. */\r\nexport function controlValueFromString(type: string) : ControlValue {\r\n    switch(type) {\r\n        case 'int': return ControlValue.IntValue;\r\n        case 'uint': return ControlValue.UintValue;\r\n        case 'float': return ControlValue.FloatValue;\r\n        case 'float2': return ControlValue.Float2Value;\r\n        case 'float3': return ControlValue.Float3Value;\r\n        case 'float4': return ControlValue.Float4Value;\r\n        case 'color': return ControlValue.ColorValue;\r\n        case 'texture2d': return ControlValue.TextureValue;\r\n        case 'mesh': return ControlValue.MeshValue;\r\n    }\r\n    assert(false, 'Unsupported control type');\r\n    return null;\r\n}\r\n\r\n\r\n/** Get flatbuffers property value type from string constant. */\r\nexport function propertyValueFromString(type: string) : PropertyValue {\r\n    switch(type) {\r\n        case 'int': return PropertyValue.IntValue;\r\n        case 'uint': return PropertyValue.UintValue;\r\n        case 'float': return PropertyValue.FloatValue;\r\n        case 'string': return PropertyValue.StringValue;\r\n    }\r\n    assert(false, 'Unsupported property type');\r\n    return null;\r\n}\r\n\r\n/** Encode native JS data to flatbuffers value. */\r\nexport function encodeControlValue(type: string, data: ControlValueType) : ControlValueT {\r\n    switch(type) {\r\n        case 'int': return new IntValueT(data as number);\r\n        case 'uint': return new UintValueT(data as number);\r\n        case 'float': return new FloatValueT(data as number);\r\n        case 'float2':\r\n            let v2 = data as Vector2;\r\n            return new Float2ValueT(v2.x, v2.y);\r\n        case 'float3':\r\n            let v3 = data as Vector3;\r\n            return new Float3ValueT(v3.x, v3.y, v3.z);\r\n        case 'float4':\r\n            let v4 = data as Vector4;\r\n            return new Float4ValueT(v4.x, v4.y, v4.z, v4.w);\r\n        case 'color':\r\n            let color = data as Color;\r\n            let r = Math.max(0, Math.min(255, color.r * 255));\r\n            let g = Math.max(0, Math.min(255, color.g * 255));\r\n            let b = Math.max(0, Math.min(255, color.b * 255));\r\n            let a = Math.max(0, Math.min(255, color.a * 255));\r\n            return new ColorValueT(r, g, b, a);\r\n        case 'texture2d':\r\n            return new TextureValueT(data as string);\r\n        case 'mesh':\r\n            return new MeshValueT(data as string);\r\n    }\r\n    assert(false, 'Unsupported control type');\r\n    return null;\r\n}\r\n\r\n\r\n/** Encode native JS data to flatbuffers value. */\r\nexport function encodePropertyValue(type: string, data: PropertyValueType) : PropertyValueT {\r\n    switch(type) {\r\n        case 'int': return new IntValueT(data as number);\r\n        case 'uint': return new UintValueT(data as number);\r\n        case 'float': return new FloatValueT(data as number);\r\n        case 'string': return new StringValueT(data as string);\r\n    }\r\n    assert(false, 'Unsupported property type');\r\n    return null;\r\n}\r\n\r\n\r\nexport function controlValueToString(type: ControlValue) : string {\r\n    switch(type) {\r\n        case ControlValue.IntValue: return 'int';\r\n        case ControlValue.UintValue: return 'uint';\r\n        case ControlValue.FloatValue: return 'float';\r\n        case ControlValue.Float2Value: return 'float2';\r\n        case ControlValue.Float3Value: return 'float3';\r\n        case ControlValue.Float4Value: return 'float4';\r\n        case ControlValue.ColorValue: return 'color';\r\n        case ControlValue.TextureValue: return 'texture2d';\r\n        case ControlValue.MeshValue: return 'mesh';\r\n    }\r\n    assert(false, 'Unsupported control value type');\r\n    return null;\r\n}\r\n\r\n\r\nexport function propertyValueToString(type: PropertyValue) : string {\r\n    switch(type) {\r\n        case PropertyValue.IntValue: return 'int';\r\n        case PropertyValue.UintValue: return 'uint';\r\n        case PropertyValue.FloatValue: return 'float';\r\n        case PropertyValue.StringValue: return 'string';\r\n    }\r\n    assert(false, 'Unsupported property value type');\r\n    return null;\r\n}\r\n\r\n\r\nexport function decodeControlValue(type: ControlValue, data: ControlValueT) : ControlValueType {\r\n    switch(type) {\r\n        case ControlValue.IntValue: return (data as IntValueT).value;\r\n        case ControlValue.UintValue: return (data as UintValueT).value;\r\n        case ControlValue.FloatValue: return (data as FloatValueT).value;\r\n        case ControlValue.Float2Value: \r\n            let v2 = data as Float2ValueT;\r\n            return {x: v2.x, y: v2.y} as Vector2;\r\n        case ControlValue.Float3Value:\r\n            let v3 = data as Float3ValueT;\r\n            return {x: v3.x, y: v3.y, z: v3.z} as Vector3;\r\n        case ControlValue.Float4Value:\r\n            let v4 = data as Float4ValueT;\r\n            return {x: v4.x, y: v4.y, z: v4.z, w: v4.w} as Vector4;\r\n        case ControlValue.ColorValue:\r\n            let color = data as ColorValueT;\r\n            return {r: color.r / 255, g: color.g / 255, b: color.b / 255, a: color.a / 255} as Color;\r\n        case ControlValue.TextureValue:\r\n            return (data as TextureValueT).value as string;\r\n        case ControlValue.MeshValue:\r\n            return (data as MeshValueT).value as string;\r\n    }\r\n    assert(false, 'Unsupported control value type');\r\n    return null;\r\n}\r\n\r\n\r\nexport function decodePropertyValue(type: PropertyValue, data: PropertyValueT) : PropertyValueType {\r\n    switch(type) {\r\n        case PropertyValue.IntValue: return (data as UintValueT).value;\r\n        case PropertyValue.UintValue: return (data as IntValueT).value;\r\n        case PropertyValue.FloatValue: return (data as FloatValueT).value;\r\n        case PropertyValue.StringValue: return (data as StringValueT).value as string;\r\n    }\r\n    assert(false, 'Unsupported property value type');\r\n    return null;\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------\r\n\r\n/** Decode flatbufers control descriptions to native, playground ready, description. */\r\nexport function decodeControls(controlsFx: UIControlT[]): IMap<IPlaygroundControl> {\r\n    let controls : IMap<IPlaygroundControl> = {};\r\n    controlsFx.forEach(controlFx => {\r\n        let properties : IMap<PropertyValueType> = {};\r\n        let controlName = controlFx.name as string;\r\n        // controlFx.values an array of the same types\r\n        // so valuesType contains the same values\r\n        let controlType = controlValueToString(controlFx.valueType);\r\n\r\n        controlFx.properties.forEach(propFx => {\r\n            const name = propFx.name as string;\r\n            const value = decodePropertyValue(propFx.valueType, propFx.value);\r\n            properties[name] = value;\r\n        });\r\n\r\n        controls[controlName] = { \r\n            name: controlName, \r\n            type: controlType,\r\n            properties: properties\r\n        };\r\n    });\r\n    return controls;\r\n}\r\n\r\n\r\n/** Decode flatbufers control values to native values. */\r\nexport function decodeValues(controls: UIControlT[]): ControlValues {\r\n    let values: ControlValues = {};\r\n    controls.forEach(ctrl => \r\n        values[ctrl.name as string] = decodeControlValue(ctrl.valueType, ctrl.value));\r\n    return values;\r\n}\r\n\r\n\r\n/** Decode flatbufers presets to native, playground ready, presets. */\r\nexport function decodePresets(presets: PresetT[]): IPlaygroundPreset[] {\r\n    // some kind of muddy and clumsy convert from flatbuffers to native TS :/\r\n    return presets.map(({ name, desc, data }): IPlaygroundPreset => \r\n        ({ \r\n            name: <string>name, \r\n            desc: <string>desc,\r\n            data: data.map(({ name, valueType, value }) => ({ \r\n                name: <string>name,\r\n                type: controlValueToString(valueType),\r\n                value: decodeControlValue(valueType, value)\r\n            } as IPlaygroundPresetEntry))\r\n        }));\r\n}\r\n\r\n\r\n\r\nfunction decodeBundle(data: Uint8Array | BundleT): BundleT {\r\n    let fx: BundleT = null;\r\n\r\n    // load from packed version, see PACKED in @lib/fx/bundles/Bundle.ts\r\n    if (data instanceof Uint8Array) {\r\n        fx = new BundleT();\r\n        Bundle.getRootAsBundle(new flatbuffers.ByteBuffer(data)).unpackTo(fx);\r\n    } else {\r\n        fx = <BundleT>data;\r\n    }\r\n\r\n    return fx;\r\n}\r\n\r\n\r\nexport function decodeBundleControls(data: Uint8Array | BundleT): IPlaygroundControlsState {\r\n    const fx = decodeBundle(data);\r\n    const controls = decodeControls(fx.controls);\r\n    const values = decodeValues(fx.controls);\r\n    const presets = decodePresets(fx.presets);\r\n    \r\n    return { controls, values, presets };\r\n}\r\n\r\n\r\nexport function encodePlaygroundControlsToString(controls: IPlaygroundControlsState): string {\r\n    let data = [];\r\n    for (let name in controls.values) {\r\n        const value = controls.values[name];\r\n        const elements = [];\r\n        const args = [];\r\n\r\n        switch (controls.controls[name].type) {\r\n            case 'int':\r\n            case 'uint':\r\n                args.push(Math.round(Number(value))); \r\n                break;\r\n            case 'float':\r\n                args.push(value); \r\n                break;\r\n            case 'float2':\r\n                let v2 = value as Vector2;\r\n                args.push(v2.x, v2.y); \r\n                break;\r\n            case 'float3':\r\n                let v3 = value as Vector3;\r\n                args.push(v3.x, v3.y, v3.z); \r\n                break;\r\n            case 'float4':\r\n                let v4 = value as Vector4;\r\n                args.push(v4.x, v4.y, v4.z, v4.w); \r\n                break;\r\n            case 'color':\r\n                let color = value as Color;\r\n                args.push(color.r, color.g, color.b, color.a);\r\n                break;\r\n        }\r\n        \r\n        data.push(`${name} = { ${args.join(', ')} }`);\r\n    }\r\n    return [...data, null].join(';\\n');\r\n    return \"\";\r\n}\r\n\r\n\r\nexport function cloneValue(type : string, value : ControlValueType) : ControlValueType {\r\n    switch(type) {\r\n        case 'int':\r\n        case 'uint':\r\n        case 'float':\r\n            return value;\r\n        case 'float2': return {...value as Vector2};\r\n        case 'float3': return {...value as Vector3};\r\n        case 'float4': return {...value as Vector4};\r\n        case 'color': return {...value as Color};\r\n        case 'texture2d': return value as string;\r\n    }\r\n    assert(false, 'Unsupported control type');\r\n    return null;\r\n}\r\n\r\n\r\nexport function colorToUint({ r, g, b, a }: Color) {\r\n    [r ,g, b, a] = [r, g, b, a].map(x => Math.max(0, Math.min(255, x * 255)));\r\n    return /*a << 24 | */b << 0 | g << 8 | r << 16;\r\n}\r\n\r\n\r\nexport function uintToColor(src: number, dst: Color) {\r\n    dst.r = ((src >> 16) & 0xff) / 255.0;\r\n    dst.g = ((src >> 8) & 0xff) / 255.0;\r\n    dst.b = ((src >> 0) & 0xff) / 255.0;\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------\r\n\r\n\r\nexport class ConvolutionPackEx implements ICodeConvolutionContextOptions {\r\n    defines?: IKnownDefine[];\r\n\r\n    constructor(\r\n        public textDocument?: ITextDocument,\r\n        public slastDocument?: ISLASTDocument,\r\n        public includeResolver?: IncludeResolver,\r\n        defines?: (string | IKnownDefine)[]) {\r\n        this.defines = defines?.map((name): IKnownDefine => isString(name) ? ({ name }) as IKnownDefine : name as IKnownDefine);\r\n    }\r\n}\r\n","import { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { expression, instruction, types, variable } from \"@lib/fx/analisys/helpers\";\r\nimport { DeclStmtInstruction } from \"@lib/fx/analisys/instructions/DeclStmtInstruction\";\r\nimport { ReturnStmtInstruction } from \"@lib/fx/analisys/instructions/ReturnStmtInstruction\";\r\nimport { EVariableUsageFlags } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { T_BOOL, T_FLOAT, T_INT, T_UINT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { createFXSLDocument } from \"@lib/fx/FXSLDocument\";\r\nimport { createTextDocument } from \"@lib/fx/TextDocument\";\r\nimport { EAddrType, EChunkType } from \"@lib/idl/bytecode\";\r\nimport { EOperation } from \"@lib/idl/bytecode/EOperations\";\r\nimport {\r\n    EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, ICompileShader11Instruction, IComplexExprInstruction,\r\n    IConditionalExprInstruction, IConstructorCallInstruction, IExprInstruction, IExprStmtInstruction, IForStmtInstruction,\r\n    IFunctionCallInstruction, IFunctionDeclInstruction, IIdExprInstruction, IIfStmtInstruction, IInitExprInstruction,\r\n    IInstruction, ILiteralInstruction, ILogicalExprInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction,\r\n    IPostfixPointInstruction, IRelationalExprInstruction, IStmtBlockInstruction, IUnaryExprInstruction, IVariableDeclInstruction\r\n} from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { DiagnosticException, Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { IFile } from \"@lib/idl/parser/IParser\";\r\nimport { i32ToU8Array } from \"./common\";\r\nimport { ContextBuilder, EErrors, IContext } from \"./Context\";\r\nimport { CDL } from \"./DebugLayout\";\r\nimport PromisedAddress from \"./PromisedAddress\";\r\nimport sizeof from \"./sizeof\";\r\n\r\nimport { TypeLayoutT } from \"@lib/idl/bundles/auto/type-layout\";\r\nimport { TypeFieldT } from \"@lib/idl/bundles/auto/type-field\";\r\n\r\n// [00 - 01) cbs\r\n// [01 - 17) inputs\r\n// [17 - 33) uavs\r\n// [33 - 64) srvs\r\n\r\nexport const CBUFFER0_REGISTER = 0;\r\nexport const INPUT0_REGISTER = 1;\r\nexport const UAV0_REGISTER = 17;\r\nexport const SRV0_REGISTER = 33;\r\n\r\nexport const SRV_TOTAL = 64 - SRV0_REGISTER;\r\nexport const UAV_TOTAL = SRV0_REGISTER - UAV0_REGISTER;\r\nexport const INPUT_TOTAL = UAV_TOTAL - INPUT0_REGISTER;\r\nexport const CBUFFER_TOTAL = INPUT0_REGISTER - CBUFFER0_REGISTER;\r\n\r\n\r\nconst UNRESOLVED_JUMP_LOCATION = -1;\r\n\r\ninterface ISubProgram {\r\n    code: Uint8Array;\r\n    cdl: CDL;\r\n}\r\n\r\nexport interface IBCDocument {\r\n    uri: IFile\r\n    diagnosticReport: IDiagnosticReport;\r\n    program: ISubProgram;\r\n}\r\n\r\nfunction writeString(u8data: Uint8Array, offset: number, value: string): number {\r\n    u8data.set(i32ToU8Array(value.length), offset);\r\n    offset += 4;\r\n\r\n    u8data.set(value.split('').map(c => c.charCodeAt(0)), offset);\r\n    offset += value.length;\r\n    return offset;\r\n}\r\n\r\nfunction writeInt(u8data: Uint8Array, offset: number, value: number): number {\r\n    u8data.set(i32ToU8Array(value), offset);\r\n    offset += 4;\r\n    return offset;\r\n}\r\n\r\nfunction writeTypeField(u8data: Uint8Array, offset: number, field: TypeFieldT): number {\r\n    offset = writeInt(u8data, offset, field.padding);\r\n    offset = writeInt(u8data, offset, field.size);\r\n    offset = writeString(u8data, offset, <string>field.semantic);\r\n    offset = writeString(u8data, offset, <string>field.name);\r\n    offset = writeTypeLayout(u8data, offset, field.type);\r\n    return offset;\r\n}\r\n\r\nfunction writeTypeLayout(u8data: Uint8Array, offset: number, layout: TypeLayoutT): number {\r\n    offset = writeInt(u8data, offset, layout.size);\r\n    offset = writeInt(u8data, offset, layout.length);\r\n    offset = writeString(u8data, offset, <string>layout.name);\r\n    offset = writeInt(u8data, offset, layout.fields.length);\r\n    for (let field of layout.fields) {\r\n        offset = writeTypeField(u8data, offset, field);\r\n    }\r\n    return offset;\r\n}\r\n\r\nfunction externsChunk(ctx: IContext): ArrayBuffer {\r\n    const { externs } = ctx;\r\n    const reflection = externs.dump();\r\n    \r\n    const sizeofTypeField = (field: TypeFieldT) => {\r\n        return 0 +\r\n            4 /* padding */ +\r\n            4 /* size */ +\r\n            4 /* semantic */ + field.semantic.length +\r\n            4 /* name */ + field.name.length +\r\n            sizeofTypeLayout(field.type);\r\n    }\r\n\r\n    const sizeofTypeLayout = (layout: TypeLayoutT) => {\r\n        return 0 +\r\n            4 /* size */ +\r\n            4 /* length */ +\r\n            4 /* sizeof(name) */ + layout.name.length +\r\n            4 /* fields.length */ + layout.fields.reduce((a, tl) => a + sizeofTypeField(tl), 0);\r\n    };\r\n\r\n\r\n    const byteLength = \r\n        4/* reflection.length */ +\r\n        reflection.reduce(\r\n            (s, { name, ret, params }) => s + \r\n            4 /* id */+ \r\n            4 /* sizeof(name) */ + name.length +\r\n            sizeofTypeLayout(ret) +\r\n            4 /* params.length */ + params.reduce((s, p) => s + sizeofTypeLayout(p), 0), 0);\r\n\r\n    const size = (byteLength + 4) >> 2;\r\n    const chunkHeader = [EChunkType.k_Externs, size];\r\n    const data = new Uint32Array(chunkHeader.length + size);\r\n    data.set(chunkHeader);\r\n\r\n    const u8data = new Uint8Array(data.buffer, 8/* int header type + int size */);\r\n    let written = writeInt(u8data, 0, reflection.length);\r\n    for (let i = 0; i < reflection.length; ++i) {\r\n        const { id, name, ret, params } = reflection[i];\r\n        written = writeInt(u8data, written, id);\r\n        written = writeString(u8data, written, name);\r\n        written = writeTypeLayout(u8data, written, ret);\r\n        written = writeInt(u8data, written, params.length);\r\n        for (let p of params) {\r\n            written = writeTypeLayout(u8data, written, p);\r\n        }\r\n    }\r\n    return data.buffer;\r\n}\r\n\r\n// TODO: rewrite with cleaner code\r\nfunction constLayoutChunk(ctx: IContext): ArrayBuffer {\r\n    const { constants } = ctx;\r\n    const reflection = constants.dump();\r\n    const byteLength =\r\n        4/* names.length */ +\r\n        reflection.map(entry =>\r\n            entry.name.length +\r\n            entry.type.length +\r\n            entry.semantic.length +\r\n            4 + /* sizeof(name.length) */\r\n            4 + /* sizeof(type.length) */\r\n            4 + /* sizeof(semantic.length) */\r\n            4 + /* sizeof(addr) */\r\n            4 + /* sizeof(size) */\r\n            4   /* sizeof(type.length) */\r\n        ).reduce((prev, curr) => prev + curr, 0);\r\n\r\n    const size = (byteLength + 4) >> 2;\r\n    const chunkHeader = [EChunkType.k_Layout, size];\r\n    const data = new Uint32Array(chunkHeader.length + size);\r\n    data.set(chunkHeader);\r\n\r\n    const u8data = new Uint8Array(data.buffer, 8/* int header type + int size */);\r\n    let written = writeInt(u8data, 0, reflection.length);\r\n    for (let i = 0; i < reflection.length; ++i) {\r\n        const { name, offset, type, size, semantic } = reflection[i];\r\n        written = writeString(u8data, written, name);\r\n        written = writeString(u8data, written, type);\r\n        written = writeString(u8data, written, semantic || '');\r\n        written = writeInt(u8data, written, offset);\r\n        written = writeInt(u8data, written, size);\r\n    }\r\n    // console.log('after write', u8data.length, 'bytes', written);\r\n    return data.buffer;\r\n}\r\n\r\nfunction constChunk(ctx: IContext): ArrayBuffer {\r\n    const { constants } = ctx;\r\n    const mem = constants.data;\r\n    const size = mem.byteLength >> 2;\r\n    const chunkHeader = [EChunkType.k_Constants, size];\r\n    assert((size << 2) == mem.byteLength);\r\n    const data = new Uint32Array(chunkHeader.length + size);\r\n    data.set(chunkHeader);\r\n    data.set(new Uint32Array(mem.byteArray.buffer, 0, mem.byteLength >> 2), chunkHeader.length);\r\n    return data.buffer;\r\n}\r\n\r\n\r\nfunction codeChunk(ctx: IContext): ArrayBuffer {\r\n    const { instructions } = ctx;\r\n    const chunkHeader = [EChunkType.k_Code, instructions.length];\r\n    const data = new Uint32Array(chunkHeader.length + instructions.length);\r\n    data.set(chunkHeader);\r\n    data.set(instructions.data, chunkHeader.length);\r\n    return data.buffer;\r\n}\r\n\r\nconst CHUNK_EMPTY = (new Uint8Array(0)).buffer;\r\n\r\nfunction shadersChunk(ctx: IContext): ArrayBuffer {\r\n    const { pipeline } = ctx;\r\n    const shaders = pipeline.dumpShaders();\r\n\r\n    if (shaders.length === 0) {\r\n        return CHUNK_EMPTY;\r\n    }\r\n\r\n    const byteLength =\r\n    4/* shaders.length */ +\r\n    shaders.map(({ shader: sh }) =>\r\n        sh.name.length +\r\n        sh.ver.length +\r\n        4 + /* sizeof(name.length) */\r\n        4 + /* sizeof(ver.length) */\r\n        4 + /* args.length */\r\n        sh.args.map(arg => \r\n            4 + /* sizeof(arg.type) */\r\n            arg.type.length + \r\n            4   /* constant value (number or bool) */\r\n        ).reduce((prev, curr) => prev + curr, 0)\r\n    ).reduce((prev, curr) => prev + curr, 0);\r\n\r\n    const size = (byteLength + 4) >> 2;\r\n    const chunkHeader = [EChunkType.k_Shaders, size];\r\n    const data = new Uint32Array(chunkHeader.length + size);\r\n    data.set(chunkHeader);\r\n\r\n    const u8data = new Uint8Array(data.buffer, 8/* int header type + int size */);\r\n    let written = writeInt(u8data, 0, shaders.length);\r\n    for (let i = 0; i < shaders.length; ++i) {\r\n        const { name, ver, args } = shaders[i].shader;\r\n        written = writeString(u8data, written, name);\r\n        written = writeString(u8data, written, ver);\r\n        written = writeInt(u8data, written, args.length);\r\n        for (let j = 0; j < args.length; ++j) {\r\n            written = writeString(u8data, written, args[j].type);\r\n            switch (args[j].type) {\r\n                case 'int':\r\n                case 'uint':\r\n                case 'bool':\r\n                    written = writeInt(u8data, written, +args[j].value);\r\n                    break;\r\n                default:\r\n                    assert(false, `unsupported constant type \"${args[j].type}\"`);\r\n                    written = writeInt(u8data, written, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    return data.buffer;\r\n}\r\n\r\n// depth stencil state\r\nfunction dssChunk(ctx: IContext): ArrayBuffer {\r\n    const { pipeline } = ctx;\r\n    const depthStencilStates = pipeline.dumpDepthStencilStates();\r\n\r\n    if (depthStencilStates.length === 0) {\r\n        return CHUNK_EMPTY;\r\n    }\r\n\r\n\r\n    const byteLength =\r\n    4/* depthStencilStates.length */ +\r\n    depthStencilStates.map(dss =>\r\n        4 + // DepthEnable\r\n        4 + // DepthWriteMask\r\n        4 + // DepthFunc\r\n        4 + // StencilEnable\r\n        4 + // StencilReadMask\r\n        4 + // StencilWriteMask\r\n        4 * 4 + // BackFace\r\n        4 * 4   // FrontFace\r\n    ).reduce((prev, curr) => prev + curr, 0);\r\n\r\n    const size = (byteLength + 4) >> 2;\r\n    const chunkHeader = [EChunkType.k_DepthStencilStates, size];\r\n    const data = new Uint32Array(chunkHeader.length + size);\r\n    data.set(chunkHeader);\r\n\r\n    const u8data = new Uint8Array(data.buffer, 8/* int header type + int size */);\r\n    let written = writeInt(u8data, 0, depthStencilStates.length);\r\n    for (let i = 0; i < depthStencilStates.length; ++i) {\r\n        const dss = depthStencilStates[i];\r\n        written = writeInt(u8data, written, +dss.DepthEnable);\r\n        written = writeInt(u8data, written, +dss.DepthWriteMask);\r\n        written = writeInt(u8data, written, +dss.DepthFunc);\r\n        written = writeInt(u8data, written, +dss.StencilEnable);\r\n        written = writeInt(u8data, written, +dss.StencilReadMask);\r\n        written = writeInt(u8data, written, +dss.StencilWriteMask);\r\n\r\n        written = writeInt(u8data, written, +dss.FrontFace.StencilFailOp);\r\n        written = writeInt(u8data, written, +dss.FrontFace.StencilDepthFailOp);\r\n        written = writeInt(u8data, written, +dss.FrontFace.StencilPassOp);\r\n        written = writeInt(u8data, written, +dss.FrontFace.StencilFunc);\r\n\r\n        written = writeInt(u8data, written, +dss.BackFace.StencilFailOp);\r\n        written = writeInt(u8data, written, +dss.BackFace.StencilDepthFailOp);\r\n        written = writeInt(u8data, written, +dss.BackFace.StencilPassOp);\r\n        written = writeInt(u8data, written, +dss.BackFace.StencilFunc);\r\n    }\r\n\r\n    return data.buffer;\r\n}\r\n\r\nfunction binary(ctx: IContext): Uint8Array {\r\n    const chunks = [\r\n        constLayoutChunk(ctx), \r\n        constChunk(ctx), \r\n        codeChunk(ctx), \r\n        externsChunk(ctx),\r\n        shadersChunk(ctx),\r\n        dssChunk(ctx)\r\n    ].map(ch => new Uint8Array(ch));\r\n    const byteLength = chunks.map(x => x.byteLength).reduce((a, b) => a + b);\r\n    let data = new Uint8Array(byteLength);\r\n    let offset = 0;\r\n    chunks.forEach(ch => {\r\n        data.set(ch, offset);\r\n        offset += ch.byteLength;\r\n    });\r\n    return data;\r\n}\r\n\r\n\r\n\r\nfunction translateProgram(ctx: IContext, fn: IFunctionDeclInstruction): ISubProgram {\r\n    const { constants, debug, alloca, push, pop, addr, imove, ref, icode, instructions } = ctx;\r\n\r\n    // NOTE: it does nothing at the momemt :/\r\n    debug.beginCompilationUnit('[todo]', fn.def.returnType);\r\n    // simulate function call()\r\n    const fdef = fn.def;\r\n    let ret = alloca(fdef.returnType.size);\r\n    push(fn, ret);\r\n\r\n    // TODO: use the same code as FunctionCall;\r\n    // loading of all non-inpt parameters to registers\r\n    for (let i = 0; i < fdef.params.length; ++i) {\r\n        const param = fdef.params[i];\r\n        if (param.type.usages.includes('out') || param.type.usages.includes('inout')) {\r\n            continue;\r\n        }\r\n\r\n        const inputIndex = variable.parameterIndex(param) + INPUT0_REGISTER;\r\n        const size = param.type.size;\r\n        const src = addr.loc({ type: EAddrType.k_Input, inputIndex, addr: 0, size });\r\n        const dest = alloca(size);\r\n        imove(dest, src);\r\n        debug.map(fdef); // FIXME: is it ok?\r\n        ref(param, dest);\r\n    }\r\n\r\n    translateUnknown(ctx, fn);\r\n    pop();\r\n\r\n    // always push ret as last instruction\r\n    const [op,] = instructions.back();\r\n    if (op != EOperation.k_Ret)\r\n        icode(EOperation.k_Ret);\r\n\r\n    debug.endCompilationUnit();\r\n\r\n    let code = binary(ctx);         // TODO: stay only binary view\r\n    let cdl = debug.dump();         // code debug layout;\r\n\r\n    return {\r\n        code,           // final binary pack\r\n        cdl             // same as PDB\r\n    };\r\n}\r\n\r\nfunction translateUnknown(ctx: IContext, instr: IInstruction): void {\r\n    const {\r\n        pc,\r\n        error,\r\n        critical,\r\n        constants,\r\n        pipeline,\r\n        externs,\r\n        uavs,\r\n        srvs,\r\n        alloca,\r\n        addr,\r\n        debug,\r\n        push,\r\n        pop,\r\n        open,\r\n        close,\r\n        deref,\r\n        ref,\r\n        icode,\r\n        imove,\r\n        iop4,\r\n        iop3,\r\n        iop2,\r\n        iop1,\r\n        iload,\r\n        iconst_i32,\r\n        iconst_f32,\r\n        ret,\r\n        depth,\r\n        instructions\r\n    } = ctx;\r\n\r\n\r\n    // NOTE: pc - number of written instructions\r\n    // NOTE: rc - number of occupied registers\r\n\r\n    const isEntryPoint = () => depth() === 1;\r\n\r\n    type ArithmeticOp = IArithmeticExprInstruction['operator'];\r\n\r\n    const intrinsics = {\r\n\r\n        /**\r\n         * Float based arithmetics\r\n         * vector [op] vector | vector [op] scalar | scalar [op] vector\r\n         */\r\n        arithf(opName: ArithmeticOp, dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            const size = Math.max(left.size, right.size);\r\n            const n = size / sizeof.f32();\r\n\r\n            // handle case: scalar * vector => scalar.xxxx * vector\r\n            if (left.size != right.size) {\r\n                if (left.size === sizeof.f32()) {\r\n                    left = addr.override(left, Array(n).fill(0));\r\n                } else if (right.size === sizeof.f32()) {\r\n                    right = addr.override(right, Array(n).fill(0));\r\n                } else {\r\n                    assert(false, 'vectors with differen length cannot be multipled');\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n            }\r\n\r\n            const opFloatMap = {\r\n                '+': EOperation.k_F32Add,\r\n                '-': EOperation.k_F32Sub,\r\n                '*': EOperation.k_F32Mul,\r\n                '/': EOperation.k_F32Div,\r\n                '%': EOperation.k_F32Mod\r\n            };\r\n\r\n            const op: EOperation = opFloatMap[opName];\r\n\r\n            if (!isDef(op)) {\r\n                // todo: emit correct source location\r\n                error(null, EErrors.k_UnsupportedArithmeticExpr, { tooltip: `operation: ${opName}` });\r\n                return PromisedAddress.INVALID;\r\n            }\r\n\r\n            iop3(op, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        // TODO: merhe with function above\r\n        arithi(opName: ArithmeticOp, dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            const size = Math.max(left.size, right.size);\r\n            const n = size / sizeof.f32();\r\n\r\n            // handle case: scalar * vector => scalar.xxxx * vector\r\n            if (left.size !== right.size) {\r\n                if (left.size === sizeof.f32()) {\r\n                    left = addr.override(left, Array(n).fill(0));\r\n                } else if (right.size === sizeof.f32()) {\r\n                    right = addr.override(right, Array(n).fill(0));\r\n                } else {\r\n                    assert(false, 'vectors with differen length cannot be multipled');\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n            }\r\n\r\n            const opIntMap = {\r\n                '+': EOperation.k_I32Add,\r\n                '-': EOperation.k_I32Sub,\r\n                '*': EOperation.k_I32Mul,\r\n                '/': EOperation.k_I32Div,\r\n                '%': EOperation.k_I32Mod\r\n            }\r\n\r\n            const op: EOperation = opIntMap[opName];\r\n\r\n            if (!isDef(op)) {\r\n                // todo: emit correct source location\r\n                error(null, EErrors.k_UnsupportedArithmeticExpr, { tooltip: `operation ${opName}` });\r\n                return PromisedAddress.INVALID;\r\n            }\r\n\r\n            iop3(op, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        mulf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('*', dest, left, right),\r\n        divf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('/', dest, left, right),\r\n        addf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('+', dest, left, right),\r\n        subf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('-', dest, left, right),\r\n        modf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('%', dest, left, right),\r\n\r\n        muli: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('*', dest, left, right),\r\n        divi: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('/', dest, left, right),\r\n        addi: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('+', dest, left, right),\r\n        subi: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('-', dest, left, right),\r\n        modi: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('%', dest, left, right),\r\n\r\n        dotf(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            let temp = alloca(Math.max(left.size, right.size));\r\n            let mlr = intrinsics.mulf(temp, left, right);\r\n            let n = mlr.size / sizeof.f32();\r\n\r\n            // copy first element of 'mlr' to dest\r\n            imove(dest, addr.shrink(mlr, sizeof.f32()));\r\n            for (let i = 1; i < n; ++i) {\r\n                let padding = i * sizeof.f32();\r\n                let size = sizeof.f32();\r\n                intrinsics.addf(dest, dest, addr.sub(mlr, padding, size));\r\n            }\r\n\r\n            return dest;\r\n        },\r\n\r\n        distancef(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            let temp = alloca(left.size);\r\n            intrinsics.subf(temp, left, right);\r\n            intrinsics.lengthf(dest, temp);\r\n            return dest;\r\n        },\r\n\r\n        /** dest = a + b * c */\r\n        madi(dest: PromisedAddress, a: PromisedAddress, b: PromisedAddress, c: PromisedAddress): PromisedAddress {\r\n            iop4(EOperation.k_I32Mad, dest, a, b, c);\r\n            return dest;\r\n        },\r\n\r\n        noti(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_I32Not, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        mini(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_I32Min, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        maxi(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_I32Max, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        fracf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Frac, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        floorf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Floor, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        ceilf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Ceil, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        sinf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Sin, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        cosf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Cos, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        absf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Abs, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        sqrtf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Sqrt, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        powf(dest: PromisedAddress, x: PromisedAddress, y: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_F32Pow, dest, x, y);\r\n            return dest;\r\n        },\r\n\r\n        minf(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_F32Min, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        // a = max(b, c);\r\n        maxf(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_F32Max, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        // ret step(y, x)\r\n        // (x >= y) ? 1 : 0\r\n        stepf(dest: PromisedAddress, y: PromisedAddress, x: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_F32GreaterThanEqual, dest, x, y);\r\n            return dest;\r\n        },\r\n\r\n        clampf(dest: PromisedAddress, x: PromisedAddress, min: PromisedAddress, max: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_F32Max, dest, x, min);\r\n            iop3(EOperation.k_F32Min, dest, dest, max);\r\n            return dest;\r\n        },\r\n\r\n        saturatef(dest: PromisedAddress, x: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_F32Max, dest, x, iconst_f32(0.0));\r\n            iop3(EOperation.k_F32Min, dest, dest, iconst_f32(1.0));\r\n            return dest;\r\n        },\r\n\r\n        lengthf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            intrinsics.dotf(dest, src, src);\r\n            intrinsics.sqrtf(dest, dest);\r\n            return dest;\r\n        },\r\n\r\n        normalizef(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            const len = alloca(sizeof.f32());\r\n            intrinsics.lengthf(len, src);\r\n            intrinsics.divf(dest, src, len);\r\n            return dest;\r\n        },\r\n\r\n        lerpf(dest: PromisedAddress, from: PromisedAddress, to: PromisedAddress, k: PromisedAddress): PromisedAddress {\r\n            assert(from.size === to.size);\r\n\r\n            const size = from.size;\r\n            const n = size / sizeof.f32();\r\n            const swizzle = Array(n).fill(0);\r\n\r\n            let one = iconst_f32(1.0);\r\n            // todo: fix bu with vectored koef.\r\n            let kInv: PromisedAddress;\r\n            if (k.size === sizeof.f32()) {\r\n                kInv = intrinsics.subf(one, one, k);\r\n            } else {\r\n                assert(k.size === from.size);\r\n                one = addr.override(one, swizzle);\r\n                kInv = intrinsics.subf(alloca(dest.size), one, k);\r\n            }\r\n\r\n            let temp = alloca(size);\r\n\r\n            intrinsics.mulf(temp, to, k);\r\n            intrinsics.mulf(dest, from, kInv);\r\n            intrinsics.addf(dest, dest, temp);\r\n\r\n            return dest;\r\n        },\r\n\r\n        // hlsl supports float3 x float3 only\r\n        cross(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) {\r\n            // .x = (m.y * n.z - m.z * n.y)\r\n            // .y = (m.z * n.x - m.x * n.z)\r\n            // .z = (m.x * n.y - m.y * n.x)\r\n            let f32 = sizeof.f32();\r\n\r\n            let t1 = alloca(f32);\r\n            let t2 = alloca(f32);\r\n            let temp = alloca(f32 * 3);\r\n\r\n            let mx = addr.sub(left, 0 * f32, f32);\r\n            let my = addr.sub(left, 1 * f32, f32);\r\n            let mz = addr.sub(left, 2 * f32, f32);\r\n\r\n            let nx = addr.sub(right, 0 * f32, f32);\r\n            let ny = addr.sub(right, 1 * f32, f32);\r\n            let nz = addr.sub(right, 2 * f32, f32);\r\n\r\n            let tx = addr.sub(temp, 0 * f32, f32);\r\n            let ty = addr.sub(temp, 1 * f32, f32);\r\n            let tz = addr.sub(temp, 2 * f32, f32);\r\n\r\n            intrinsics.mulf(t1, my, nz);\r\n            intrinsics.mulf(t2, mz, ny);\r\n            intrinsics.subf(tx, t1, t2); // .x\r\n\r\n            intrinsics.mulf(t1, mz, nx);\r\n            intrinsics.mulf(t2, mx, nz);\r\n            intrinsics.subf(ty, t1, t2); // .y\r\n\r\n            intrinsics.mulf(t1, mx, ny);\r\n            intrinsics.mulf(t2, my, nx);\r\n            intrinsics.subf(tz, t1, t2); // .z\r\n\r\n            imove(dest, temp);\r\n            return dest;\r\n        }\r\n    }\r\n\r\n    // handle global variables like: const float VALUE = 10;\r\n    // as hidden uniform constants\r\n    function canBePlacedInUniforms(decl: IVariableDeclInstruction): boolean {\r\n        // Suitable:\r\n        //  uniform float4x4 viewMatrix;\r\n        //  float4 color = float4(1, 1, 1, 1);\r\n        //  const float scale = 1;\r\n        // Not suitable:\r\n        //  const float;            // <= not uniform and doesn't have proper default value\r\n        //  RTTexture2D dynamicTex; // <= uav\r\n        //  Texture2D albedo;\r\n        const isUniform = decl.type.isUniform();\r\n        const isCbufferField = (decl.usageFlags & EVariableUsageFlags.k_Cbuffer) != 0;\r\n        const isConstant = decl.initExpr && decl.initExpr.isConst();\r\n        const isPipelineState = SystemScope.isPipelineState(decl.type);\r\n        \r\n        return decl.isGlobal() && (isUniform || isCbufferField || isConstant) && !isPipelineState;\r\n    }\r\n\r\n\r\n    function resolveAddressType(decl: IVariableDeclInstruction): EAddrType {\r\n        if (decl.isParameter()) {\r\n            if (decl.type.usages.includes('out') || decl.type.usages.includes('inout')) {\r\n                // entry point function can refer to input memory, for ex. vertex shader\r\n                return isEntryPoint() ? EAddrType.k_Input : EAddrType.k_Registers;\r\n            }\r\n        }\r\n\r\n        if (decl.isGlobal()) {\r\n            // uniforms are placed in input 0/CBV0\r\n            if (canBePlacedInUniforms(decl)) {\r\n                return EAddrType.k_Input;\r\n            }\r\n\r\n            if (SystemScope.isUAV(decl.type)) {\r\n                return EAddrType.k_Input;\r\n            }\r\n\r\n            if (SystemScope.isBuffer(decl.type)) {\r\n                return EAddrType.k_Input;\r\n            }\r\n\r\n            if (SystemScope.isTexture(decl.type)) {\r\n                return EAddrType.k_Input;\r\n            }\r\n\r\n            if (SystemScope.isPipelineState(decl.type)) {\r\n                // all states are presented as integers\r\n                return EAddrType.k_PipelineStates;\r\n            }\r\n\r\n            critical(decl.sourceNode, EErrors.k_AddressCannotBeResolved, {\r\n                tooltip: `could not resolve address type for '${decl.toCode()}'`\r\n            });\r\n        }\r\n\r\n        assert(decl.isLocal());\r\n        return EAddrType.k_Registers;\r\n    }\r\n\r\n    const POSTFIX_COMPONENT_MAP = {\r\n        'r': 0, 'x': 0, 's': 0,\r\n        'g': 1, 'y': 1, 't': 1,\r\n        'b': 2, 'z': 2, 'p': 2,\r\n        'a': 3, 'w': 3, 'q': 3\r\n    };\r\n\r\n    const checkPostfixNameForSwizzling = (postfixName: string) =>\r\n        postfixName\r\n            .split('')\r\n            .map(c => POSTFIX_COMPONENT_MAP[c])\r\n            .map(i => i >= 0 && i < 4)\r\n            .reduce((accum, val) => accum && val);\r\n\r\n    // xxwy => [0, 0, 3, 1]\r\n    const swizzlePatternFromName = (postfixName: string) =>\r\n        postfixName.split('').map(c => POSTFIX_COMPONENT_MAP[c]);\r\n\r\n    // const swizzlePatternFromPadding = (padding: number, size: number) => {\r\n    //     assert(padding % sizeof.i32() === 0);\r\n    //     assert(size % sizeof.i32() === 0);\r\n\r\n    //     return [...Array(size / sizeof.i32()).keys()].map(i => i + padding / sizeof.i32());\r\n    // };\r\n\r\n    function preloadArguments(call: IFunctionCallInstruction, forceLoad: boolean): PromisedAddress[] {\r\n        const fdecl = call.decl as IFunctionDeclInstruction;\r\n        const fdef = fdecl.def;\r\n        const args: PromisedAddress[] = [];\r\n        for (let i = 0; i < fdef.params.length; ++i) {\r\n            const arg = call.args[i];\r\n            let argAddr = raddr(arg);\r\n            if (argAddr.type !== EAddrType.k_Registers && forceLoad) {\r\n                argAddr = iload(argAddr);\r\n            }\r\n            args.push(argAddr);\r\n        }\r\n        return args;\r\n    }\r\n\r\n    function iextern(call: IFunctionCallInstruction): PromisedAddress {\r\n        const fdecl = call.decl as IFunctionDeclInstruction;\r\n        const fdef = fdecl.def;\r\n        // const retType = fdef.returnType;\r\n\r\n        // todo: do not preload all the arguemnts?\r\n        // const args = preloadArguments(call, true);\r\n\r\n        const dataSize = fdef.returnType.size + fdef.params.reduce((partialSum, param) => partialSum + param.type.size, 0);\r\n        assert(dataSize >= 0 && dataSize <= 256);\r\n\r\n        // calling convention layout\r\n        // dest | is needed\r\n        // arguments | if needed\r\n        const ccLayout = alloca(dataSize);\r\n\r\n        let ccParamAddr = addr.sub(ccLayout, fdef.returnType.size);\r\n        assert(fdef.params.length == call.args.length);\r\n        for (let i = 0; i < fdef.params.length; ++i) {\r\n            const arg = call.args[i];\r\n            const param = fdef.params[i];\r\n            const type = param.type;\r\n\r\n            assert(arg.type.size === param.type.size);\r\n            assert((arg.type.size % 4) == 0);\r\n\r\n            const argAddr = raddr(arg);\r\n            imove(addr.sub(ccParamAddr, 0, type.size), argAddr);\r\n            \r\n            if (i !== fdef.params.length - 1) // if to avoid zero sized address scalculation\r\n                ccParamAddr = addr.sub(ccParamAddr, type.size);\r\n        }\r\n\r\n        const iExtern = externs.add(fdef);\r\n        icode(EOperation.k_I32ExternCall, iExtern, ccLayout);\r\n        return addr.sub(ccLayout, 0, fdef.returnType.size);\r\n    }\r\n\r\n    function iintrinsic(call: IFunctionCallInstruction): PromisedAddress {\r\n        const fdecl = call.decl as IFunctionDeclInstruction;\r\n        const fdef = fdecl.def;\r\n        const retType = fdef.returnType;\r\n\r\n        const dest = alloca(retType.size);\r\n\r\n        let forceLoadArgumentsToRegisters: boolean;\r\n\r\n        switch (fdecl.name) {\r\n            case 'InterlockedAdd':\r\n                // expected InterlockedAdd(UAV pointer [uint/int], any [uint/int], any [uint/int])\r\n                forceLoadArgumentsToRegisters = false;\r\n                break;\r\n            default:\r\n                forceLoadArgumentsToRegisters = true;\r\n        }\r\n\r\n\r\n        const args = preloadArguments(call, forceLoadArgumentsToRegisters);\r\n\r\n\r\n        switch (fdecl.name) {\r\n            case 'asuint':\r\n            case 'asfloat':\r\n            case 'asint':\r\n                // NOTE: nothing todo\r\n                return args[0];\r\n            case 'mul':\r\n                return intrinsics.mulf(dest, args[0], args[1]);\r\n            case 'dot':\r\n                return intrinsics.dotf(dest, args[0], args[1]);\r\n            case 'frac':\r\n                return intrinsics.fracf(dest, args[0]);\r\n            case 'sin':\r\n                return intrinsics.sinf(dest, args[0]);\r\n            case 'cos':\r\n                return intrinsics.cosf(dest, args[0]);\r\n            case 'abs':\r\n                return intrinsics.absf(dest, args[0]);\r\n            case 'sqrt':\r\n                return intrinsics.sqrtf(dest, args[0]);\r\n            case 'pow':\r\n                return intrinsics.powf(dest, args[0], args[1]);\r\n            case 'normalize':\r\n                return intrinsics.normalizef(dest, args[0]);\r\n            case 'length':\r\n                return intrinsics.lengthf(dest, args[0]);\r\n            case 'floor':\r\n                return intrinsics.floorf(dest, args[0]);\r\n            case 'ceil':\r\n                return intrinsics.ceilf(dest, args[0]);\r\n            case 'distance':\r\n                return intrinsics.distancef(dest, args[0], args[1]);\r\n            case 'min':\r\n                // TODO: separate INT/FLOAT intrisics\r\n                if (SystemScope.isFloatBasedType(fdef.params[0].type)) {\r\n                    return intrinsics.minf(dest, args[0], args[1]);\r\n                }\r\n                assert(SystemScope.isIntBasedType(fdef.params[0].type) || SystemScope.isUintBasedType(fdef.params[1].type));\r\n                // handle INT/UINT params as int intrinsic\r\n                return intrinsics.mini(dest, args[0], args[1]);\r\n            case 'max':\r\n                // TODO: separate INT/FLOAT intrisics\r\n                if (SystemScope.isFloatBasedType(fdef.params[0].type)) {\r\n                    return intrinsics.maxf(dest, args[0], args[1]);\r\n                }\r\n                assert(SystemScope.isIntBasedType(fdef.params[0].type) || SystemScope.isUintBasedType(fdef.params[0].type));\r\n                // handle INT/UINT params as int intrinsic\r\n                return intrinsics.maxi(dest, args[0], args[1]);\r\n            case 'step':\r\n                assert(SystemScope.isFloatBasedType(fdef.params[0].type));\r\n                return intrinsics.stepf(dest, args[0], args[1]);\r\n            case 'clamp':\r\n                assert(SystemScope.isFloatBasedType(fdef.params[0].type));\r\n                return intrinsics.clampf(dest, args[0], args[1], args[2]);\r\n            case 'saturate':\r\n                assert(SystemScope.isFloatBasedType(fdef.params[0].type));\r\n                return intrinsics.saturatef(dest, args[0]);\r\n            case 'lerp':\r\n                return intrinsics.lerpf(dest, args[0], args[1], args[2]);\r\n            case 'cross':\r\n                return intrinsics.cross(dest, args[0], args[1]);\r\n            case 'mod':\r\n                // TODO: separate INT/FLOAT intrisics\r\n                if (SystemScope.isFloatBasedType(fdef.params[0].type)) {\r\n                    return intrinsics.modf(dest, args[0], args[1]);\r\n                }\r\n                assert(SystemScope.isIntBasedType(fdef.params[0].type) || SystemScope.isUintBasedType(fdef.params[0].type));\r\n                // handle INT/UINT params as int intrinsic\r\n                return intrinsics.modi(dest, args[0], args[1]);\r\n\r\n            case 'InterlockedAdd':\r\n                {\r\n                    assert(fdef.params.length === 3);\r\n\r\n                    assert(args[0].type === EAddrType.k_PointerInput, 'destination must be UAV address');\r\n                    assert(args[0].size === sizeof.i32(), 'only int/uint values are supported');\r\n\r\n                    if (args[1].type !== EAddrType.k_Registers) {\r\n                        args[1] = iload(args[1]);\r\n                    }\r\n\r\n                    let originalAddr = args[2];\r\n                    if (args[2].type !== EAddrType.k_Registers) {\r\n                        originalAddr = alloca(sizeof.i32());\r\n                    }\r\n\r\n                    imove(originalAddr, args[0]);\r\n\r\n                    const changedAddr = intrinsics.addi(alloca(sizeof.i32()), originalAddr, args[1]);\r\n                    imove(args[0], changedAddr);\r\n\r\n                    if (args[2] !== originalAddr) {\r\n                        imove(args[2], originalAddr);\r\n                    }\r\n\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n\r\n            //\r\n            // UAVs\r\n            //\r\n\r\n            /** @returns: The post-decremented counter value. */\r\n            case 'DecrementCounter':\r\n                {\r\n                    const uav = call.callee;\r\n                    const uavAddr = raddr(uav);\r\n                    const uavCounterAddr = addr.shrink(uavAddr, sizeof.i32());\r\n                    const valueAddr = iload(uavCounterAddr);\r\n                    const nextValueAddr = intrinsics.addi(alloca(sizeof.i32()), valueAddr, iconst_i32(-1));\r\n                    imove(uavCounterAddr, nextValueAddr);\r\n                    return nextValueAddr;\r\n                }\r\n            /** @returns: The pre-incremented counter value. */\r\n            case 'IncrementCounter':\r\n                {\r\n                    const uav = call.callee;\r\n                    const uavAddr = raddr(uav);\r\n                    const uavCounterAddr = addr.shrink(uavAddr, sizeof.i32());\r\n                    const valueAddr = iload(uavCounterAddr);\r\n                    const nextValueAddr = intrinsics.addi(alloca(sizeof.i32()), valueAddr, iconst_i32(+1));\r\n                    imove(uavCounterAddr, nextValueAddr);\r\n                    return valueAddr;\r\n                }\r\n            case 'Append':\r\n                {\r\n                    const { callee: uav, args } = call;\r\n                    const uavAddr = raddr(uav);\r\n                    const uavCounterAddr = addr.shrink(uavAddr, sizeof.i32());\r\n\r\n                    assert(args.length === 1);\r\n                    const srcAddr = raddr(args[0]);\r\n                    const valueAddr = iload(uavCounterAddr);\r\n\r\n                    const arrayElementSize = args[0].type.size;\r\n\r\n                    const uavDataAddr = addr.sub(uavAddr, sizeof.i32());\r\n                    const elementPointer = addr.subPointer(uavDataAddr, valueAddr, arrayElementSize);\r\n\r\n                    imove(elementPointer, srcAddr);\r\n\r\n                    // TODO: replace with intrinsics.inc();\r\n                    intrinsics.addi(valueAddr, valueAddr, iconst_i32(1));\r\n                    imove(uavCounterAddr, valueAddr);\r\n\r\n                    return elementPointer;\r\n                }\r\n\r\n            //\r\n            // Textures\r\n            //\r\n\r\n            case 'GetDimensions':\r\n                {\r\n                    const { callee: tex } = call;\r\n                    const texAddr = raddr(tex);\r\n\r\n                    // GetDimensions(w, h) only supported\r\n                    assert(tex.type.name.includes('Texture2D'));\r\n                    assert(args.length === 3);\r\n\r\n                    const w = addr.sub(texAddr, 0, sizeof.i32());\r\n                    const h = addr.sub(texAddr, sizeof.i32(), sizeof.i32());\r\n                    // NOTE: always returns size of zero mip (!)\r\n                    // const mip = args[0];\r\n                    const wout = args[1];\r\n                    const hout = args[2];\r\n\r\n                    imove(wout, w);\r\n                    imove(hout, h);\r\n\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n\r\n            case 'Load':\r\n                {\r\n                    const { callee } = call;\r\n                    const tex = raddr(callee);\r\n\r\n                    // Load(int3) only supported\r\n                    assert(callee.type.name.includes('Texture2D'));\r\n                    assert(args.length === 1);\r\n\r\n                    let uvs = args[0];\r\n                    if (uvs.type !== EAddrType.k_Registers) {\r\n                        uvs = iload(uvs);\r\n                    }\r\n\r\n                    //const u = addr.sub(uvs, 0, sizeof.i32());\r\n                    // descriptor size if 64 bytes\r\n                    // width  | 4 byte\r\n                    // height | 4 byte\r\n                    // format | 4 byte\r\n                    // unused | 52 bytes\r\n\r\n                    //const v = addr.sub(uvs, sizeof.i32(), sizeof.i32());\r\n                    //const w = addr.sub(tex, 0, sizeof.i32());\r\n                    // const h = addr.sub(texAddr, sizeof.i32(), sizeof.i32());\r\n\r\n                    // const valueAddr = alloca(sizeof.i32());\r\n                    // intrinsics.madi(valueAddr, u, w, v);\r\n\r\n                    // const texelSize = callee.type.arrayElementType.size;\r\n                    const dest = alloca(sizeof.f32() * 4);\r\n                    icode(EOperation.k_I32TextureLoad, dest, tex.inputIndex, uvs);\r\n                    // const elementPointer = addr.subPointer(dest, valueAddr, texelSize);\r\n                    // return elementPointer;\r\n                    return dest;\r\n                }\r\n        }\r\n\r\n        error(call.sourceNode, EErrors.k_UnsupportedIntrinsic, { name: call.decl.name });\r\n        return PromisedAddress.INVALID;\r\n    }\r\n\r\n\r\n    /** resolve address => returns address of temprary result of expression */\r\n    function raddr(expr: IExprInstruction): PromisedAddress {\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_InitExpr:\r\n                {\r\n                    const init = expr as IInitExprInstruction;\r\n\r\n                    if (init.isArray()) {\r\n                        // todo: add support\r\n                        error(expr.sourceNode, EErrors.k_UnsupportedExprType, { tooltip: 'arrays are not yet supported' });\r\n                        return PromisedAddress.INVALID;\r\n                    }\r\n\r\n                    let arg = init.args[0];\r\n                    return raddr(arg);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_BoolExpr:\r\n                {\r\n                    const i32 = (expr as ILiteralInstruction<boolean>).value ? 1 : 0;\r\n                    return iconst_i32(i32);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_IntExpr:\r\n                {\r\n                    const i32 = (expr as ILiteralInstruction<number>).value;\r\n                    return iconst_i32(i32);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_FloatExpr:\r\n                {\r\n                    const f32 = (expr as ILiteralInstruction<number>).value;\r\n                    return iconst_f32(f32);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_StringExpr:\r\n                {\r\n                    // remove quotes\r\n                    const cstr = (expr as ILiteralInstruction<string>).value?.slice(1, -1);\r\n                    assert(cstr.length > 0);\r\n                    // input0, size = 4/* cstr.length */ + sizeof(cstr)\r\n                    const constAddr = constants.derefCString(cstr);\r\n                    return iconst_i32(constAddr.addr); // write to register addr of string in constant buffer 0. \r\n                }\r\n                break;\r\n            case EInstructionTypes.k_NullExpr:\r\n                {\r\n                    // it's assumed that all the types which can be converted \r\n                    // to NULL are pointers, so we can replace its address with 4 bytes\r\n                    // value.\r\n                    return iconst_i32(0);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_IdExpr:\r\n                {\r\n                    let id = (expr as IIdExprInstruction);\r\n                    assert(id.decl === expression.unwind(id));\r\n\r\n                    const size = id.decl.type.size;\r\n                    const decl = expression.unwind(id);\r\n                    const addrType = resolveAddressType(decl);\r\n\r\n                    switch (addrType) {\r\n                        case EAddrType.k_Registers:\r\n                            {\r\n                                return deref(id.decl);\r\n                            }\r\n                        case EAddrType.k_Input:\r\n                            {\r\n                                // CBUFFER0_REGISTER input is always being used for hidden constant buffer (uniform constants)\r\n                                if (canBePlacedInUniforms(decl)) {\r\n                                    return constants.deref(decl);\r\n                                }\r\n\r\n                                if (SystemScope.isUAV(decl.type)) {\r\n                                    return uavs.deref(decl);\r\n                                }\r\n\r\n                                if (SystemScope.isBuffer(decl.type)) {\r\n                                    return srvs.deref(decl);\r\n                                }\r\n\r\n                                if (SystemScope.isTexture(decl.type)) {\r\n                                    return srvs.deref(decl);\r\n                                }\r\n\r\n                                // implies that each parameter is loaded from its stream, so \r\n                                // the offset is always zero. \r\n                                // Otherwise use 'variable.getParameterOffset(decl);'\r\n                                // in order to determ correct offset between parameters\r\n                                const offset = 0;\r\n                                const src = offset;\r\n                                const inputIndex = variable.parameterIndex(decl) + INPUT0_REGISTER;\r\n                                assert(variable.parameterIndex(decl) < INPUT_TOTAL);\r\n                                return addr.loc({ inputIndex, addr: src, size, type: addrType });\r\n                            }\r\n                        case EAddrType.k_PipelineStates:\r\n                            {\r\n                                // Resolve as registers (!)\r\n\r\n                                // deref:\r\n                                //  DepthStencilState\r\n                                //  RasterizerState\r\n                                //  BlendState\r\n                                const id = pipeline.deref(decl);\r\n                                return iconst_i32(id);\r\n                            }\r\n                    }\r\n\r\n                    critical(id.sourceNode, EErrors.k_UnsupportedAddressType, { tooltip: `type: ${addrType}` });\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return raddr((expr as IComplexExprInstruction).expr);\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                {\r\n                    const arithExpr = expr as IArithmeticExprInstruction;\r\n                    const dest = alloca(arithExpr.type.size);\r\n\r\n                    const opName = arithExpr.operator;\r\n                    const left = arithExpr.left;\r\n                    const right = arithExpr.right;\r\n\r\n                    assert(SystemScope.isScalarType(left.type) || SystemScope.isVectorType(left.type));\r\n                    assert(SystemScope.isScalarType(right.type) || SystemScope.isVectorType(right.type));\r\n\r\n                    let leftAddr = raddr(left);\r\n                    if (leftAddr.type !== EAddrType.k_Registers) {\r\n                        leftAddr = iload(leftAddr);\r\n                        debug.map(left);\r\n                    }\r\n\r\n                    let rightAddr = raddr(right);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(right);\r\n                    }\r\n\r\n                    if (SystemScope.isFloatBasedType(left.type)) {\r\n                        assert(SystemScope.isFloatBasedType(right.type));\r\n                        intrinsics.arithf(opName, dest, leftAddr, rightAddr);\r\n                    } else if (SystemScope.isIntBasedType(left.type) || SystemScope.isUintBasedType(left.type)) {\r\n                        assert(SystemScope.isIntBasedType(right.type) || SystemScope.isUintBasedType(right.type));\r\n                        intrinsics.arithi(opName, dest, leftAddr, rightAddr);\r\n                    } else {\r\n                        assert(false);\r\n                        return PromisedAddress.INVALID;\r\n                    }\r\n\r\n                    debug.map(arithExpr);\r\n                    return dest;\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                {\r\n                    const assigment = expr as IAssignmentExprInstruction;\r\n                    const size = assigment.type.size;\r\n                    assert(size % sizeof.i32() === 0);\r\n\r\n\r\n                    // left address can be both from the registers and in the external memory\r\n                    const leftAddr = raddr(assigment.left);\r\n\r\n                    assert(instruction.isExpression(assigment.right), EInstructionTypes[assigment.right.instructionType]);\r\n                    // right address always from the registers\r\n                    let rightAddr = raddr(<IExprInstruction>assigment.right);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(assigment.right);\r\n                    }\r\n\r\n                    const floatBased = SystemScope.isFloatBasedType(expr.type);\r\n\r\n                    switch (assigment.operator) {\r\n                        case '=':\r\n                            imove(leftAddr, rightAddr);\r\n                            break;\r\n                        case '+=':\r\n                            floatBased\r\n                                ? intrinsics.addf(leftAddr, leftAddr, rightAddr)\r\n                                : intrinsics.addi(leftAddr, leftAddr, rightAddr);\r\n                            break;\r\n                        case '-=':\r\n                            floatBased\r\n                                ? intrinsics.subf(leftAddr, leftAddr, rightAddr)\r\n                                : intrinsics.subi(leftAddr, leftAddr, rightAddr);\r\n                            break;\r\n                        case '*=':\r\n                            floatBased\r\n                                ? intrinsics.mulf(leftAddr, leftAddr, rightAddr)\r\n                                : intrinsics.muli(leftAddr, leftAddr, rightAddr);\r\n                            break;\r\n                        case '/=':\r\n                            floatBased\r\n                                ? intrinsics.divf(leftAddr, leftAddr, rightAddr)\r\n                                : intrinsics.divi(leftAddr, leftAddr, rightAddr);\r\n                            break;\r\n                        default:\r\n                            error(null, EErrors.k_UnsupportedAssigmentOperator, { tooltip: `operator: ${assigment.operator}` });\r\n                    }\r\n\r\n                    debug.map(assigment);\r\n                    // breakpoint right after assingment\r\n                    debug.ns();\r\n                    return leftAddr;\r\n                }\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n                {\r\n                    const postfix = expr as IPostfixArithmeticInstruction;\r\n                    const operand = postfix.expr;\r\n                    const op = postfix.operator;\r\n                    const size = postfix.type.size;\r\n\r\n                    let src = raddr(operand);\r\n                    if (src.type !== EAddrType.k_Registers) {\r\n                        src = iload(src);\r\n                    }\r\n\r\n                    if (SystemScope.isIntBasedType(operand.type)) {\r\n                        switch (op) {\r\n                            case '++':\r\n                                {\r\n                                    const dest = imove(alloca(size), src);\r\n                                    intrinsics.arithi('+', src, src, iconst_i32(1));\r\n                                    debug.map(postfix);\r\n                                    return dest;\r\n                                }\r\n                            case '--':\r\n                                {\r\n                                    const dest = imove(alloca(size), src);\r\n                                    intrinsics.arithi('-', src, src, iconst_i32(1));\r\n                                    debug.map(postfix);\r\n                                    return dest;\r\n                                }\r\n                            // fall to unsupported warning\r\n                        }\r\n                    } else {\r\n                        switch (op) {\r\n                            case '++':\r\n                                {\r\n                                    const dest = imove(alloca(size), src);\r\n                                    intrinsics.arithf('+', src, src, iconst_f32(1));\r\n                                    debug.map(postfix);\r\n                                    return dest;\r\n                                }\r\n                            case '--':\r\n                                {\r\n                                    const dest = imove(alloca(size), src);\r\n                                    intrinsics.arithf('-', src, src, iconst_f32(1));\r\n                                    debug.map(postfix);\r\n                                    return dest;\r\n                                }\r\n                            // fall to unsupported warning\r\n                        }\r\n                    }\r\n\r\n                    error(postfix.sourceNode, EErrors.k_UnsupportedUnaryExpression, {\r\n                        tooltip: `unsupported type of unary expression found: '${op}'(${postfix.toCode()})`\r\n                    });\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                {\r\n                    const unary = expr as IUnaryExprInstruction;\r\n                    const operand = unary.expr;\r\n                    const op = unary.operator;\r\n                    const size = unary.type.size;\r\n\r\n                    let src = raddr(operand);\r\n                    if (src.type !== EAddrType.k_Registers) {\r\n                        src = iload(src);\r\n                    }\r\n\r\n                    if (SystemScope.isBoolBasedType(operand.type)) {\r\n                        if (op === '!') {\r\n                            const dest = intrinsics.noti(alloca(size), src);\r\n                            debug.map(unary);\r\n                            return dest;\r\n                        }\r\n                    }\r\n\r\n                    if (SystemScope.isIntBasedType(operand.type)) {\r\n                        switch (op) {\r\n                            case '-':\r\n                                {\r\n                                    const dest = intrinsics.arithi('*', alloca(size), src, iconst_i32(-1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            case '+':\r\n                                // nothing todo\r\n                                return src;\r\n                            case '++':\r\n                                {\r\n                                    const dest = intrinsics.arithi('+', src, src, iconst_i32(1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            case '--':\r\n                                {\r\n                                    const dest = intrinsics.arithi('-', src, src, iconst_i32(1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            // fall to unsupported warning\r\n                        }\r\n                    } else {\r\n                        switch (op) {\r\n                            case '-':\r\n                                {\r\n                                    const dest = intrinsics.arithf('*', alloca(size), src, iconst_f32(-1.0));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            case '++':\r\n                                {\r\n                                    const dest = intrinsics.arithf('+', src, src, iconst_f32(1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            case '--':\r\n                                {\r\n                                    const dest = intrinsics.arithf('-', src, src, iconst_f32(1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            // fall to unsupported warning\r\n                        }\r\n                    }\r\n                    error(unary.sourceNode, EErrors.k_UnsupportedUnaryExpression, {\r\n                        tooltip: `unsupported type of unary expression found: '${op}'(${unary.toCode()})`\r\n                    });\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n            case EInstructionTypes.k_LogicalExpr:\r\n                {\r\n                    const logicExpr = expr as ILogicalExprInstruction;\r\n\r\n                    const opMap = {\r\n                        '||': EOperation.k_I32LogicalOr,\r\n                        '&&': EOperation.k_I32LogicalAnd\r\n                    };\r\n\r\n                    let op: EOperation = opMap[logicExpr.operator];;\r\n\r\n                    const { left, right } = logicExpr;\r\n\r\n                    let leftAddr = raddr(left);\r\n                    if (leftAddr.type !== EAddrType.k_Registers) {\r\n                        leftAddr = iload(leftAddr);\r\n                        debug.map(left);\r\n                    }\r\n\r\n                    let rightAddr = raddr(right);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(right);\r\n                    }\r\n\r\n                    const size = logicExpr.type.size;\r\n                    const dest = alloca(size);\r\n                    iop3(op, dest, leftAddr, rightAddr);\r\n                    debug.map(logicExpr);\r\n\r\n                    return addr.loc({ addr: dest, size });\r\n                }\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                {\r\n                    const relExpr = expr as IRelationalExprInstruction;\r\n\r\n                    const opUintMap = {\r\n                        '<': EOperation.k_U32LessThan,          //lt\r\n                        '>=': EOperation.k_U32GreaterThanEqual, // ge\r\n                        '==': EOperation.k_I32Equal,            // << compare with I32 operator\r\n                        '!=': EOperation.k_I32NotEqual          // << compare with I32 operator\r\n                    }\r\n\r\n                    const opIntMap = {\r\n                        '<': EOperation.k_I32LessThan,          //lt\r\n                        '>=': EOperation.k_I32GreaterThanEqual, // ge\r\n                        '==': EOperation.k_I32Equal,            // eq\r\n                        '!=': EOperation.k_I32NotEqual          // ne\r\n                    };\r\n\r\n                    const opFloatMap = {\r\n                        '<': EOperation.k_F32LessThan,          // lt\r\n                        '>=': EOperation.k_F32GreaterThanEqual, // ge\r\n                        '==': EOperation.k_I32Equal,            // << compare with I32 operator\r\n                        '!=': EOperation.k_I32NotEqual          // << compare with I32 operator\r\n                    };\r\n\r\n                    let op: EOperation;\r\n                    let { left, right } = relExpr;\r\n                    let operator = relExpr.operator;\r\n\r\n                    // (left > right) => (right < left)\r\n                    if (operator === '>') {\r\n                        operator = '<';\r\n                        [right, left] = [left, right];\r\n                    }\r\n\r\n                    // (left <= right) => (right >= left)\r\n                    if (operator === '<=') {\r\n                        operator = '>=';\r\n                        [right, left] = [left, right];\r\n                    }\r\n\r\n\r\n                    if (types.equals(left.type, T_INT)) {\r\n                        op = opIntMap[operator];\r\n\r\n                        // print warning if right type is UINT;\r\n                        if (!types.equals(right.type, T_INT) && !types.equals(right.type, T_UINT)) {\r\n                            error(expr.sourceNode, EErrors.k_UnsupportedRelationalExpr, {});\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (types.equals(left.type, T_UINT)) {\r\n                        op = opUintMap[operator];\r\n\r\n                        // print warning if right type is INT;\r\n                        if (!types.equals(right.type, T_UINT) && !types.equals(right.type, T_INT)) {\r\n                            error(expr.sourceNode, EErrors.k_UnsupportedRelationalExpr, {});\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (types.equals(left.type, T_FLOAT)) {\r\n                        op = opFloatMap[operator];\r\n\r\n                        if (!types.equals(right.type, T_FLOAT)) {\r\n                            error(expr.sourceNode, EErrors.k_UnsupportedRelationalExpr, {});\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (types.equals(left.type, T_BOOL)) {\r\n                        op = opIntMap[operator];\r\n                        if (!types.equals(right.type, T_BOOL)) {\r\n                            error(expr.sourceNode, EErrors.k_UnsupportedRelationalExpr, {});\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    }\r\n\r\n                    if (!op) {\r\n                        error(expr.sourceNode, EErrors.k_UnsupportedRelationalExpr, {});\r\n                        return PromisedAddress.INVALID;\r\n                    }\r\n\r\n                    let leftAddr = raddr(left);\r\n                    if (leftAddr.type !== EAddrType.k_Registers) {\r\n                        leftAddr = iload(leftAddr);\r\n                        debug.map(left);\r\n                    }\r\n\r\n                    let rightAddr = raddr(right);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(right);\r\n                    }\r\n\r\n                    const size = relExpr.type.size;\r\n                    const dest = alloca(size);\r\n                    iop3(op, dest, leftAddr, rightAddr);\r\n                    debug.map(relExpr);\r\n\r\n                    return addr.loc({ addr: dest, size });\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_CastExpr:\r\n                {\r\n                    const castExpr = expr as ICastExprInstruction;\r\n\r\n                    if (castExpr.isUseless()) {\r\n                        console.warn(`Useless cast found: ${castExpr.toCode()}`);\r\n                        return raddr(castExpr.expr);\r\n                    }\r\n\r\n                    const srcType = castExpr.expr.type;\r\n                    const dstType = castExpr.type;\r\n\r\n                    let op: EOperation;\r\n\r\n                    // TODO: add support for vectors\r\n\r\n                    if (types.equals(dstType, T_BOOL)) {\r\n                        const size = castExpr.type.size;\r\n                        const dest = alloca(size);\r\n                        let exprAddr = raddr(castExpr.expr);\r\n                        if (exprAddr.type !== EAddrType.k_Registers) {\r\n                            exprAddr = iload(exprAddr);\r\n                        }\r\n\r\n                        iop3(EOperation.k_I32NotEqual, dest, exprAddr, iconst_i32(0));\r\n                        debug.map(castExpr);\r\n                        return addr.loc({ addr: dest, size });\r\n                    }\r\n\r\n\r\n                    if (types.equals(srcType, T_FLOAT)) {\r\n                        if (types.equals(dstType, T_INT)) {\r\n                            op = EOperation.k_F32ToI32;\r\n                        } else if (types.equals(dstType, T_UINT)) {\r\n                            op = EOperation.k_F32ToU32;\r\n                        } else {\r\n                            error(castExpr.sourceNode, EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (types.equals(srcType, T_INT)) {\r\n                        if (types.equals(dstType, T_FLOAT)) {\r\n                            op = EOperation.k_I32ToF32;\r\n                        } else if (types.equals(dstType, T_UINT)) {\r\n                            // useless conversion\r\n                            return raddr(castExpr.expr);\r\n                        } else {\r\n                            error(castExpr.sourceNode, EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (types.equals(srcType, T_UINT)) {\r\n                        if (types.equals(dstType, T_FLOAT)) {\r\n                            op = EOperation.k_U32ToF32;\r\n                        } else if (types.equals(dstType, T_INT)) {\r\n                            // useless conversion\r\n                            return raddr(castExpr.expr);\r\n                        } else {\r\n                            error(castExpr.sourceNode, EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    }\r\n\r\n                    const size = castExpr.type.size;\r\n                    const dest = alloca(size);\r\n                    let exprAddr = raddr(castExpr.expr);\r\n                    if (exprAddr.type !== EAddrType.k_Registers) {\r\n                        exprAddr = iload(exprAddr);\r\n                    }\r\n                    iop2(op, dest, exprAddr);\r\n                    debug.map(castExpr);\r\n                    return addr.loc({ addr: dest, size });\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                {\r\n                    const postfixIndex = expr as IPostfixIndexInstruction;\r\n                    // element[index]\r\n                    const { element, index } = postfixIndex;\r\n\r\n                    assert(types.equals(index.type, T_INT) || types.equals(index.type, T_UINT));\r\n                    assert(!isNull(element.type.arrayElementType));\r\n\r\n                    if (/*index.isConstExpr()*/false) {\r\n                        // TODO: implement constexpr branch\r\n                    } else {\r\n                        let elementAddr = raddr(element);\r\n                        // NOTE: element can be not loaded yet\r\n                        //       we don't want to load all the array (all 'element' object)\r\n\r\n                        if (SystemScope.isUAV(element.type)) {\r\n                            // some UAVs can have hidden counter at the beginning of the data\r\n                            // in such cases we need to step forward before fetching the data\r\n                            elementAddr = addr.sub(elementAddr, sizeof.i32());\r\n                        }\r\n\r\n                        // sizeof(element[i])\r\n                        let arrayElementSize = element.type.arrayElementType.size;\r\n                        assert(arrayElementSize % sizeof.i32() === 0, `all sizes must be multiple of ${sizeof.i32()}`);\r\n\r\n                        // index => index of element in the array (element)\r\n                        let indexAddr = raddr(index);\r\n                        // NOTE: index can be unresolved yet\r\n\r\n                        const dest = addr.subPointer(elementAddr, indexAddr, arrayElementSize);\r\n                        debug.map(postfixIndex);\r\n                        return dest;\r\n                    }\r\n\r\n                    return PromisedAddress.INVALID; // << FIXME\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                {\r\n                    const point = expr as IPostfixPointInstruction;\r\n                    const { element, postfix } = point;\r\n                    const elementAddr = raddr(element);\r\n\r\n                    let { size, padding } = postfix.type;\r\n                    let swizzle: number[] = null;\r\n\r\n                    // Does expression have dynamic indexing?\r\n                    // TODO: rename isConstExpr() method to something more suitable\r\n                    if (point.isConstExpr()) {\r\n\r\n                        // handle such types like float2, float3, int2, int3 etc.\r\n                        // all system types except matrix and samplers support swizzling\r\n                        const isSwizzlingSupported = SystemScope.isVectorType(element.type) ||\r\n                            SystemScope.isScalarType(element.type);\r\n\r\n                        if (isSwizzlingSupported) {\r\n                            assert(checkPostfixNameForSwizzling(postfix.name));\r\n                            swizzle = swizzlePatternFromName(postfix.name);\r\n\r\n                            assert(padding === instruction.UNDEFINE_PADDING, 'padding of swizzled components must be undefined');\r\n\r\n                            // If loading not allowed then we are inside the recursive call to calculate the final address\r\n                            // so in this case we just have to return address with padding added to it.\r\n                            return addr.override(elementAddr, swizzle);\r\n                        } else {\r\n                            return addr.sub(elementAddr, padding, size);\r\n                        }\r\n                    }\r\n\r\n                    critical(expr.sourceNode, EErrors.k_NotImplemented, {});\r\n\r\n                    // todo: add support for move_reg_ptr, move_ptr_ptr, move_ptr_reg\r\n                    return elementAddr;\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                {\r\n                    const call = expr as IFunctionCallInstruction;\r\n                    const fdecl = call.decl;\r\n                    const fdef = fdecl.def;\r\n                    const retType = fdef.returnType;\r\n\r\n                    // todo: use more precise check\r\n                    // note: system functions also can present externs, for ex: SetVertexShader()\r\n                    if (fdecl.attrs.find(({ name }) => name === 'extern')) {\r\n                        debug.ns();\r\n                        const dest = iextern(call);\r\n                        debug.map(call);\r\n                        return dest;\r\n                    }\r\n\r\n\r\n                    if (fdecl.instructionType === EInstructionTypes.k_SystemFunctionDecl) {\r\n                        // breakpoint before intrinsic call\r\n                        // TODO: is it's breakpoint really usefull?\r\n                        debug.ns();\r\n                        const dest = iintrinsic(call);\r\n                        debug.map(call);\r\n                        return dest;\r\n                    }\r\n\r\n                    const ret = alloca(retType.size);\r\n\r\n                    const params = fdef.params;\r\n                    const args = params\r\n                        .map((param, i) => i < call.args.length ? call.args[i] : param.initExpr);\r\n                    const paramSources = args\r\n                        .map(arg => raddr(arg))\r\n                        .map(arg => arg.type === EAddrType.k_Registers ? arg : iload(arg));\r\n\r\n                    push(fdecl, ret);\r\n\r\n                    for (let i = 0; i < fdef.params.length; ++i) {\r\n                        const src = paramSources[i];\r\n\r\n                        // by default all parameters are interpreted as 'in'\r\n                        if (params[i].type.usages.includes('out') || params[i].type.usages.includes('inout')) {\r\n                            ref(params[i], src);\r\n                        } else {\r\n                            // todo: handle expressions like \"float4 v = 5.0;\"\r\n                            const size = params[i].type.size;\r\n                            const dest = alloca(size);\r\n\r\n                            imove(dest, src);\r\n                            debug.map(args[i]);\r\n\r\n                            ref(params[i], dest);\r\n                        }\r\n                    }\r\n\r\n                    translateUnknown(ctx, fdecl);\r\n                    pop();\r\n\r\n                    return ret;\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_ConditionalExpr:\r\n                {\r\n                    const { condition, left, right } = expr as IConditionalExprInstruction;\r\n                    assert(types.equals(left.type, right.type));\r\n\r\n                    let size = left.type.size;\r\n                    let dest = alloca(size);\r\n                    let condAddr = raddr(condition);\r\n                    assert(condAddr.size === sizeof.bool());\r\n\r\n                    if (condAddr.type !== EAddrType.k_Registers) {\r\n                        condAddr = iload(condAddr);\r\n                        debug.map(condition);\r\n                    }\r\n\r\n                    iop1(EOperation.k_JumpIf, condAddr);\r\n\r\n                    let unresolvedJump = pc();\r\n                    icode(EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);\r\n\r\n                    let leftAddr = raddr(left as IExprInstruction);\r\n                    if (leftAddr.type !== EAddrType.k_Registers) {\r\n                        leftAddr = iload(leftAddr);\r\n                        debug.map(left);\r\n                    }\r\n                    imove(dest, leftAddr);\r\n                    debug.map(left);\r\n\r\n                    // jump co contrary or out of if\r\n                    let jumpTo = pc() + 1;\r\n                    instructions.replace(unresolvedJump, EOperation.k_Jump, [jumpTo]);\r\n\r\n                    unresolvedJump = pc();\r\n                    icode(EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);\r\n\r\n                    let rightAddr = raddr(right as IExprInstruction);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(right);\r\n                    }\r\n                    imove(dest, rightAddr);\r\n                    debug.map(right);\r\n\r\n                    // jump to skip contrary\r\n                    jumpTo = pc();\r\n                    instructions.replace(unresolvedJump, EOperation.k_Jump, [jumpTo]);\r\n                    return addr.loc({ addr: dest, size });\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                {\r\n                    const ctorCall = expr as IConstructorCallInstruction;\r\n                    // todo: add correct constructor call support for builtin type at the level of analyzer\r\n                    const type = ctorCall.type;\r\n                    const args = (ctorCall.args as IExprInstruction[]);\r\n\r\n                    const size = type.size;\r\n                    const dest = alloca(size);\r\n\r\n                    switch (type.name) {\r\n                        case 'float':\r\n                        case 'float1':\r\n                        case 'float2':\r\n                        case 'float3':\r\n                        case 'float4':\r\n                        case 'int':\r\n                        case 'int1':\r\n                        case 'int2':\r\n                        case 'int3':\r\n                        case 'int4':\r\n                        case 'uint':\r\n                        case 'uint1':\r\n                        case 'uint2':\r\n                        case 'uint3':\r\n                        case 'uint4':\r\n                        case 'bool':\r\n                        case 'bool2':\r\n                        case 'bool3':\r\n                        case 'bool4':\r\n\r\n                            switch (args.length) {\r\n                                case 1:\r\n                                    // TODO: convert float to int if necessary\r\n                                    // handling for the case single same type argument and multiple floats\r\n                                    assert(instruction.isExpression(args[0]), EInstructionTypes[args[0].instructionType]);\r\n                                    let src = raddr(args[0]);\r\n\r\n                                    if (src.type !== EAddrType.k_Registers) {\r\n                                        src = iload(src);\r\n                                        debug.map(args[0]);\r\n                                    }\r\n\r\n                                    // convert arguments from float to int and back\r\n                                    if (SystemScope.isFloatBasedType(args[0].type) !== SystemScope.isFloatBasedType(type)) {\r\n                                        const op = SystemScope.isFloatBasedType(type) ? EOperation.k_I32ToF32 : EOperation.k_F32ToI32;\r\n                                        // expected:\r\n                                        //  float4(10), float3(10u), float3(true);\r\n                                        //  float2(int2(10, 10)) etc.\r\n                                        assert(args[0].type.size === sizeof.i32() || args[0].type.size === expr.type.size);\r\n\r\n                                        // don't change initial location?\r\n                                        let temp = alloca(src.size);\r\n                                        iop2(op, temp, src);\r\n                                        src = temp;\r\n                                    }\r\n\r\n                                    const elementSize = SystemScope.isFloatBasedType(type) ? sizeof.f32() : sizeof.i32();\r\n\r\n                                    // FIXME: use 'length' property\r\n                                    let length = type.size / elementSize;\r\n                                    let swizzle = null;\r\n                                    if (src.size === elementSize) {\r\n                                        swizzle = [...Array(length).fill(0)];\r\n                                        src = addr.override(src, swizzle);\r\n                                    } else {\r\n                                        swizzle = [...Array(length).keys()];\r\n                                        src = addr.override(src, swizzle);\r\n                                    }\r\n\r\n\r\n                                    imove(dest, src);\r\n                                    debug.map(ctorCall);\r\n                                    break;\r\n                                default:\r\n                                    let padding = 0;\r\n                                    for (let i = 0; i < args.length; ++i) {\r\n                                        assert(instruction.isExpression(args[i]), EInstructionTypes[args[i].instructionType]);\r\n                                        let src = raddr(args[i]);\r\n\r\n                                        if (src.type !== EAddrType.k_Registers) {\r\n                                            src = iload(src);\r\n                                            debug.map(args[i]);\r\n                                        }\r\n\r\n\r\n                                        // convert arguments from float to int and back\r\n                                        if (SystemScope.isFloatBasedType(args[i].type) !== SystemScope.isFloatBasedType(type)) {\r\n                                            const op = SystemScope.isFloatBasedType(type) ? EOperation.k_I32ToF32 : EOperation.k_F32ToI32;\r\n                                            assert(args[i].type.size === sizeof.i32()); // <= expected float4(10) or float3(10u) or float3(true);\r\n\r\n                                            // don't change initial location?\r\n                                            let temp = alloca(src.size);\r\n                                            iop2(op, temp, src);\r\n                                            src = temp;\r\n                                        }\r\n\r\n                                        imove(addr.sub(dest, padding, src.size), src);\r\n                                        padding += args[i].type.size;\r\n                                    }\r\n                                    debug.map(ctorCall);\r\n                                    break;\r\n\r\n                            }\r\n                            return addr.loc({ addr: dest, size });\r\n                        default:\r\n                    }\r\n                    console.warn(`Unknown constructor found: ${ctorCall.toCode()}`);\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n                break;\r\n                case EInstructionTypes.k_CompileShader11Expr:\r\n                {\r\n                    // see builtin.ts for details, all the types of shaders: \r\n                    // VertexShader, PixelShader etc. are presented as integers. \r\n                    const sh11 = expr as ICompileShader11Instruction;\r\n                    const id = pipeline.derefShader11(sh11);\r\n                    return iconst_i32(id);\r\n                }\r\n                break;\r\n            default:\r\n                console.warn(`Unknown expression found: ${expr.instructionName} (${expr.toCode()})`);\r\n                return PromisedAddress.INVALID;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    // \r\n    // Handle all instruction types\r\n    //\r\n\r\n    function translate(instr: IInstruction) {\r\n        if (isNull(instr)) {\r\n            return;\r\n        }\r\n\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_VariableDecl:\r\n                {\r\n                    let decl = instr as IVariableDeclInstruction;\r\n\r\n                    if (isNull(decl.initExpr)) {\r\n                        // There is no initial value, but allocation should be done anyway\r\n                        // in order to assign register for this variable.\r\n                        ref(decl, alloca(decl.type.size));\r\n                        return;\r\n                    }\r\n\r\n                    /*\r\n                    0: int a = 1;           | 0x00: load %a   #1        | NS 0\r\n                    1: int b = 2;           | 0x01: load %b   #2        | NS 1\r\n                    2: int c = a + b * 10;  | 0x02: load %t0  #10       |\r\n                                            | 0x03: mul  $t1  %b %t0    |\r\n                                            | 0x02: add  %c   %a %t1    | NS 2\r\n                    3: return c;            | 0x03: move %rax %c        | NS 3\r\n                                            | 0x04: ret                 |\r\n                                            |\r\n                    */\r\n\r\n                    let dest = raddr(decl.initExpr);\r\n                    if (dest.type !== EAddrType.k_Registers) {\r\n                        //breakpoint before variable initialization\r\n                        debug.ns();\r\n                        dest = iload(dest);\r\n                        debug.map(decl.initExpr);\r\n                        // breakpoint right after variable initialization\r\n                        debug.ns();\r\n                    }\r\n\r\n                    ref(decl, dest);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_DeclStmt:\r\n                {\r\n                    let stmt = instr as DeclStmtInstruction;\r\n                    stmt.declList.forEach(translate);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_IfStmt:\r\n                {\r\n                    // [out of if code]\r\n                    //  jif:\r\n                    // jump: 'jump to end of if'    ---+\r\n                    // ....                            |\r\n                    // ....                            |\r\n                    // ....                            |\r\n                    // [out of if code]             <--+\r\n\r\n                    // [out of if code]\r\n                    //  jif:\r\n                    // jump: 'jump to contrary'     ---+\r\n                    // ....                            |\r\n                    // ....                            |\r\n                    // jump:  'jump to skip contraty'  |  ---+\r\n                    // ....                         <--+     |\r\n                    // ....                                  |\r\n                    // [out of if code]                   <--+ \r\n\r\n\r\n\r\n\r\n                    let ifStmt = instr as IIfStmtInstruction;\r\n                    let { cond, conseq, contrary } = ifStmt;\r\n\r\n                    let condAddr = raddr(cond);\r\n                    assert(condAddr.size === sizeof.bool());\r\n\r\n                    if (condAddr.type !== EAddrType.k_Registers) {\r\n                        condAddr = iload(condAddr);\r\n                    }\r\n\r\n                    iop1(EOperation.k_JumpIf, condAddr);\r\n\r\n                    let unresolvedJump = pc();\r\n                    icode(EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);\r\n                    translate(conseq);\r\n                    // jump co contrary or out of if\r\n                    let jumpTo = pc() + (contrary ? 1 : 0);\r\n                    instructions.replace(unresolvedJump, EOperation.k_Jump, [jumpTo]);\r\n\r\n                    if (contrary) {\r\n                        unresolvedJump = pc();\r\n                        icode(EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);\r\n                        translate(contrary);\r\n                        // jump to skip contrary\r\n                        jumpTo = pc();\r\n                        instructions.replace(unresolvedJump, EOperation.k_Jump, [jumpTo]);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_ReturnStmt:\r\n                {\r\n                    let retStmt = instr as ReturnStmtInstruction;\r\n                    const expr = retStmt.expr;\r\n                    if (!isNull(expr)) {\r\n                        let src = raddr(expr);\r\n\r\n                        if (src.type !== EAddrType.k_Registers) {\r\n                            src = iload(src);\r\n                            debug.map(expr);\r\n                        }\r\n\r\n                        const dest = ret();\r\n\r\n                        assert(src.size === ret().size);\r\n                        imove(dest, src);\r\n                        debug.map(expr);\r\n                    }\r\n                    // breakpoint before leaving function\r\n                    debug.ns();\r\n                    icode(EOperation.k_Ret);\r\n                    debug.map(retStmt);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_StmtBlock:\r\n                {\r\n                    open(); // open block\r\n                    let block = instr as IStmtBlockInstruction;\r\n                    for (let stmt of block.stmtList) {\r\n                        translate(stmt);\r\n                    }\r\n                    close(); // close block\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_FunctionDecl:\r\n                {\r\n                    let func = instr as IFunctionDeclInstruction;\r\n\r\n                    if (!func.impl) {\r\n                        // resolve function's implementation\r\n                        func = func.scope.findFunctionInScope(func);\r\n                    }\r\n                    \r\n                    let def = func.def; // todo: handle all arguments!!\r\n                    let impl = func.impl;\r\n                    translate(impl);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_ExprStmt:\r\n                {\r\n                    let stmt = instr as IExprStmtInstruction;\r\n                    raddr(stmt.expr);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_ForStmt:\r\n                {\r\n                    const loop = instr as IForStmtInstruction;\r\n                    const { init, cond, step, body } = loop;\r\n\r\n                    open(); // open block\r\n\r\n                    // TODO: make the code more readable\r\n                    if (instruction.isExpression(init)) {\r\n                        // translate as expression\r\n                        raddr(init as IExprInstruction);\r\n                    } else {\r\n                        // translate as varaible declaration\r\n                        translate(init as IVariableDeclInstruction);\r\n                    }\r\n\r\n                    assert(types.equals(cond.type, T_BOOL));\r\n                    // before cond:\r\n                    let beforeCondPc = pc();\r\n                    let condAddr = raddr(cond);\r\n                    assert(condAddr.size === sizeof.bool());\r\n\r\n                    if (condAddr.type !== EAddrType.k_Registers) {\r\n                        condAddr = iload(condAddr);\r\n                    }\r\n\r\n                    // TOOD: add support for break statement.\r\n\r\n                    iop1(EOperation.k_JumpIf, condAddr);\r\n                    let unresolvedJump = pc();\r\n                    icode(EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);\r\n\r\n                    translate(body);\r\n\r\n                    // step:\r\n                    raddr(step);\r\n                    // goto to before condition\r\n                    icode(EOperation.k_Jump, beforeCondPc);\r\n\r\n                    // out of loop:\r\n                    let outofLoopPc = pc();\r\n                    // resolve jump in case of invalid condition => go to out of loop\r\n                    instructions.replace(unresolvedJump, EOperation.k_Jump, [outofLoopPc]);\r\n\r\n                    close(); // close block\r\n\r\n                    return;\r\n                }\r\n            default:\r\n                console.warn(`Unknown statement found: ${instr.instructionName} (${instr.toCode()})`);\r\n        }\r\n    }\r\n\r\n    translate(instr);\r\n}\r\n\r\n\r\nconst hex2 = (v: number) => `0x${v.toString(16).padStart(2, '0')}`;\r\nconst hex4 = (v: number) => `0x${v.toString(16).padStart(4, '0')}`;\r\n// const reg = (v: number) => REG_NAMES[v] || `[${hex2(v >>> 0)}]`;    // register address;\r\n// const addr = (v: number) => `%${hex4(v >>> 0)}%`;                   // global memory address;\r\n\r\n/// <reference path=\"./webpack.d.ts\" />\r\nexport function translate(fn: IFunctionDeclInstruction): IBCDocument;\r\nexport function translate(slDocument: ISLDocument, entryName: string): IBCDocument;\r\nexport function translate(a, b?): IBCDocument {\r\n    let uri: IFile;\r\n    let entryFunc: IFunctionDeclInstruction;\r\n\r\n    switch(arguments.length) {\r\n        case 2:\r\n            {\r\n                let [ slDocument, entryName ] = arguments;\r\n                entryFunc = slDocument.root.scope.findFunction(entryName, null);\r\n                uri = slDocument.uri;\r\n            }\r\n            break;\r\n        case 1:\r\n            {\r\n                [ entryFunc ] = arguments;\r\n                assert(entryFunc);\r\n                uri = entryFunc.sourceNode?.loc?.start.file;\r\n            }\r\n            break;\r\n        default:\r\n            assert(false);\r\n    }\r\n\r\n    const ctx = ContextBuilder(uri);\r\n    let program: ISubProgram = null;\r\n    if (!PRODUCTION) {\r\n        console.time('[translate program]');\r\n    }\r\n    try {\r\n        if (!isDefAndNotNull(entryFunc)) {\r\n            ctx.critical(entryFunc.sourceNode, EErrors.k_EntryPointNotFound, {});\r\n        }\r\n        program = translateProgram(ctx, entryFunc);\r\n    } catch (e) {\r\n        if (!(e instanceof DiagnosticException)) {\r\n            throw e;\r\n        }\r\n    }\r\n    if (!PRODUCTION) {\r\n        console.timeEnd('[translate program]');\r\n        // console.log(`${entryFunc.def.name} translated as ${res.code.byteLength} bytes`);\r\n    }\r\n    const diagnosticReport = ctx.diag.resolve();\r\n    return { uri, diagnosticReport, program };\r\n}\r\n\r\nexport async function translateExpression(expr: string, context?: ISLDocument): Promise<IBCDocument> {\r\n    const uri = `://expression`;\r\n    const anonymousFuncName = `anonymous`;\r\n    const source = `auto ${anonymousFuncName}() { return (${expr}); }`;\r\n    const textDocument = await createTextDocument(uri, source);\r\n    const documentEx = await createFXSLDocument(textDocument, undefined, context);\r\n    if (!documentEx.diagnosticReport.errors) {\r\n        return translate(documentEx, anonymousFuncName);\r\n    }\r\n    console.error(Diagnostics.stringify(documentEx.diagnosticReport));\r\n    return null;\r\n}\r\n\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { BoolInstruction } from \"@lib/fx/analisys/instructions/BoolInstruction\";\r\nimport { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { T_BOOL, T_FLOAT, T_FLOAT2, T_FLOAT3, T_FLOAT4, T_INT, T_INT2, T_INT3, T_INT4, T_UINT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { IConstant, EAddrType } from \"@lib/idl/bytecode\";\r\nimport { EInstructionTypes, IInitExprInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { FloatInstruction } from \"../analisys/instructions/FloatInstruction\";\r\nimport { CBUFFER0_REGISTER } from \"./Bytecode\";\r\nimport { i32ToU8Array } from \"./common\";\r\nimport PromisedAddress from \"./PromisedAddress\";\r\n\r\nexport class ConstantPoolMemory {\r\n    byteArray: Uint8Array;\r\n    byteLength: number;\r\n\r\n    constructor() {\r\n        this.byteArray = new Uint8Array(4);\r\n        this.byteLength = 0;\r\n    }\r\n\r\n    get byteCapacity(): number {\r\n        return this.byteArray.byteLength;\r\n    }\r\n\r\n    /** Check capacity and make realloc if needed. */\r\n    private check(byteSize: number) {\r\n        let expected = this.byteLength + byteSize;\r\n        if (expected <= this.byteCapacity) {\r\n            return;\r\n        }\r\n        var oldBuffer = this.byteArray;\r\n        var newBuffer = new Uint8Array(Math.max(expected, this.byteCapacity * 2));\r\n        newBuffer.set(oldBuffer);\r\n\r\n        this.byteArray = newBuffer;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param size Size in bytes.\r\n     */\r\n    addUniform(size: number, name: string, defaultValue: Uint8Array = null) {\r\n        this.check(size);\r\n        if (defaultValue) {\r\n            this.byteArray.set(defaultValue, this.byteLength);\r\n        }\r\n        this.byteLength += size;\r\n    }\r\n}\r\n\r\n\r\nexport class ConstanPool {\r\n    protected _data: ConstantPoolMemory = new ConstantPoolMemory;\r\n    protected _knownConstants: IConstant[] = [];\r\n\r\n    deref(decl: IVariableDeclInstruction): PromisedAddress {\r\n        assert(decl.isGlobal() && (decl.type.isUniform() || decl.isConstant()));\r\n        const { name, semantic, initExpr, type: { size } } = decl;\r\n\r\n        let reflection = this._knownConstants.find(c => c.name === name);\r\n        if (!reflection) {\r\n            let addr = null;\r\n            let defaultValue = null;\r\n            if (!isNull(initExpr)) {\r\n                if (decl.type.isNotBaseArray()) {\r\n                    // todo: add support\r\n                    assert(false, 'arrays are not yet supported (!)');\r\n                } else {\r\n                    switch (initExpr.type.name) {\r\n                        case T_FLOAT.name:\r\n                            defaultValue = new Float32Array([ (initExpr as FloatInstruction).value ]);\r\n                            break;\r\n                        case T_UINT.name:\r\n                            defaultValue = new Uint32Array([ (initExpr as IntInstruction).value ]);\r\n                            break;\r\n                        case T_BOOL.name:\r\n                            const value = (initExpr as BoolInstruction).value;\r\n                            defaultValue = new Int32Array([ value ? 1 : 0 ]);\r\n                            break;\r\n                        case T_INT.name:\r\n                            defaultValue = new Int32Array([ (initExpr as IntInstruction).value ]);\r\n                            break;\r\n                        case T_FLOAT2.name:\r\n                        case T_FLOAT3.name:\r\n                        case T_FLOAT4.name:\r\n                            assert(initExpr.instructionType === EInstructionTypes.k_InitExpr);\r\n                            defaultValue = new Float32Array((<IInitExprInstruction>initExpr).args.map(arg => (arg as FloatInstruction).value));\r\n                            break;\r\n                        case T_INT2.name:\r\n                        case T_INT3.name:\r\n                        case T_INT4.name:\r\n                            assert(initExpr.instructionType === EInstructionTypes.k_InitExpr);\r\n                            defaultValue = new Int32Array((<IInitExprInstruction>initExpr).args.map(arg => (arg as IntInstruction).value));\r\n                            break;\r\n                        default:\r\n                            assert(false, 'unsupported');\r\n                            return PromisedAddress.INVALID;\r\n                    }\r\n                }\r\n            }\r\n            addr = this.addUniform(size, `${name}${semantic? `:${semantic}`: '' }`, defaultValue);\r\n            const { addr: offset } = addr;\r\n            const type = decl.type.name; // TODO: use signature?\r\n\r\n            reflection = {\r\n                name,\r\n                semantic,\r\n                offset,\r\n                size,\r\n                type\r\n            };\r\n\r\n            this._knownConstants.push(reflection);\r\n        }\r\n\r\n        // NOTE: we return copy because adress will be loaded\r\n        return new PromisedAddress({\r\n            type: EAddrType.k_Input,\r\n            inputIndex: CBUFFER0_REGISTER,\r\n            addr: reflection.offset,\r\n            size\r\n        });\r\n    }\r\n\r\n    // todo: merge with general deref\r\n    derefCString(value: string): PromisedAddress {\r\n        const align4 = (x: number) => ((x + 3) >> 2) << 2;\r\n\r\n        let name = `\"${value}\"`;\r\n        let size = align4(4 /* sizeof(value) */ + value.length + 1 /* trailing zero */);\r\n        let reflection = this._knownConstants.find(c => c.name === name);\r\n        let semantic = \"\";\r\n\r\n        if (!reflection) {\r\n            let u8Data = new Uint8Array(size);\r\n            u8Data.set([...i32ToU8Array(value.length), ...value.split('').map(c => c.charCodeAt(0)), 0]);\r\n\r\n            let addr = this.addUniform(size, `\"${value}\"`, u8Data);\r\n            const { addr: offset } = addr;\r\n            const type = `string`;\r\n\r\n            reflection = {\r\n                name,\r\n                offset,\r\n                size,\r\n                type,\r\n                semantic\r\n            };\r\n\r\n            this._knownConstants.push(reflection);\r\n        }\r\n\r\n        return new PromisedAddress({\r\n            type: EAddrType.k_Input,\r\n            inputIndex: CBUFFER0_REGISTER,\r\n            addr: reflection.offset,\r\n            size\r\n        });\r\n    }\r\n\r\n\r\n    private addUniform(size: number, desc: string, defaultValue: ArrayBufferView = null): PromisedAddress {\r\n        const addr = this._data.byteLength;\r\n        this._data.addUniform(size, desc, \r\n            defaultValue ? new Uint8Array(defaultValue.buffer, defaultValue.byteOffset, defaultValue.byteLength) : null);\r\n\r\n        return new PromisedAddress({\r\n            type: EAddrType.k_Input,\r\n            inputIndex: CBUFFER0_REGISTER,\r\n            addr,\r\n            size\r\n        });\r\n    }\r\n\r\n    get data(): ConstantPoolMemory {\r\n        return this._data;\r\n    }\r\n\r\n    get size(): number {\r\n        return this._data.byteLength;\r\n    }\r\n\r\n    dump(): IConstant[] {\r\n        return this._knownConstants;\r\n    }\r\n}\r\n\r\n\r\nexport default ConstanPool;\r\n","import { assert, isDef, isDefAndNotNull, MakeOptional } from \"@lib/common\";\r\nimport { EAddrType } from \"@lib/idl/bytecode\";\r\nimport { EOperation } from \"@lib/idl/bytecode/EOperations\";\r\nimport { EDiagnosticCategory } from \"@lib/idl/IDiagnostics\";\r\nimport { IFunctionDeclInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IFile, IParseNode, IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { f32Asi32, sname } from \"./common\";\r\nimport ConstanPool from \"./ConstantPool\";\r\nimport debugLayout from './DebugLayout';\r\nimport InstructionList from \"./InstructionList\";\r\nimport PromisedAddress, { IAddrDesc } from \"./PromisedAddress\";\r\nimport sizeof from \"./sizeof\";\r\nimport SymbolTable from \"./SymbolTable\";\r\nimport { SRVPool } from \"./SRVPool\";\r\nimport { UAVPool } from \"./UAVPool\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { Externs } from \"./Externs\";\r\nimport { PipelineStates } from \"./PipelineStates\";\r\n\r\nexport enum EErrors {\r\n    k_UnsupportedConstantType,\r\n    k_UnsupportedExprType,\r\n    k_UnsupoortedTypeConversion,\r\n    k_UnsupportedArithmeticExpr,\r\n    k_UnsupportedRelationalExpr,\r\n    k_UnsupportedIntrinsic,\r\n    k_UnsupportedUnaryExpression,\r\n    k_UnsupportedAssigmentOperator,\r\n    k_UnsupportedAddressType,\r\n    k_AddressCannotBeResolved,\r\n    k_EntryPointNotFound,\r\n\r\n    k_NotImplemented\r\n}\r\n\r\nexport enum EWarnings {\r\n\r\n}\r\n\r\ninterface IDiagDesc {\r\n    file: IFile;\r\n    loc: IRange;\r\n    info: any; // TODO: fixme\r\n}\r\n\r\nexport class TranslatorDiagnostics extends Diagnostics<IDiagDesc> {\r\n    constructor() {\r\n        super(\"Translator Diagnostics\", 'T');\r\n    }\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IDiagDesc): string {\r\n        return '[unknown]';  // FIXME: return correct filename\r\n    }\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IDiagDesc): IRange {\r\n        return { start: { line: 0, column: 0, file: null }, end: { line: 0, column: 0, file: null } }; // todo: fixme\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        // TODO: fill all errors.\r\n        // TODO: add support for warnings\r\n        return {};\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: any): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EErrors[code]}:${loc?.start.line}:${loc?.start.column}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function ContextBuilder(uri: IFile = null) {\r\n    console.assert(uri, 'no debug info?!');\r\n    \r\n    // occupied registers count \r\n    // same as stack pointer; \r\n    // counter grows forward;\r\n    let rc: number = 0;\r\n\r\n    // stack of functions and logical blocks for ex: braces.\r\n    const stack: {\r\n        scopes: {\r\n            // symbol table containing local variables of the function including parameters\r\n            symbols: SymbolTable<PromisedAddress>;\r\n            // registers count at the moment of block's entry\r\n            rc: number;\r\n        }[];\r\n\r\n        // program counter's value before the function's start \r\n        pc: number; // << NOTE: currently is unsed\r\n\r\n        fn: IFunctionDeclInstruction;\r\n        // address of register where return call should save its value\r\n        ret: PromisedAddress;\r\n        // addresses of function return instructions to be resolved\r\n        retRequests: number[];\r\n    }[] = [];\r\n\r\n\r\n    const instructions = new InstructionList;\r\n    const constants = new ConstanPool;\r\n    const pipeline = new PipelineStates;\r\n    const uavs = new UAVPool;\r\n    const srvs = new SRVPool;\r\n    const externs = new Externs;\r\n\r\n    const diag = new TranslatorDiagnostics; // todo: remove it?\r\n\r\n    //\r\n    // copied from analyzer.\r\n    // ====================\r\n    //\r\n\r\n    type IErrorInfo = IMap<any>;\r\n    // type IWarningInfo = IMap<any>;\r\n\r\n    const resolveNodeSourceLocation = (sourceNode: IParseNode): IRange => {\r\n        if (!isDefAndNotNull(sourceNode)) return null;\r\n        if (isDef(sourceNode.loc)) return sourceNode.loc;\r\n        return resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);\r\n    }\r\n\r\n    const error = (sourceNode: IParseNode, code: number, info: IErrorInfo = {}) => {\r\n        const loc = resolveNodeSourceLocation(sourceNode);\r\n        const file = uri;\r\n        diag.error(code, { file, loc, info });\r\n    }\r\n\r\n    const critical = (sourceNode: IParseNode, code: number, info: IErrorInfo = {}) => {\r\n        const loc = resolveNodeSourceLocation(sourceNode);\r\n        const file = uri;\r\n        diag.critical(code, { file, loc, info });\r\n    }\r\n\r\n    //\r\n    // ====================\r\n    //\r\n\r\n    /** @returns Description of the top of the callstack */\r\n    const top = () => stack[stack.length - 1];\r\n    const depth = () => stack.length;\r\n    const ret = () => top().ret;\r\n    const pc = () => instructions.pc;\r\n\r\n    const debug = debugLayout(pc);\r\n\r\n    /* (assuming that all registers for all types are placed in the same memory) */\r\n    function alloca(size: number): PromisedAddress {\r\n        if (size === 0) {\r\n            return PromisedAddress.INVALID;\r\n        }\r\n\r\n        const dest = Addr.loc({ type: EAddrType.k_Registers, addr: rc, size });\r\n        rc += size;\r\n        return dest;\r\n    }\r\n\r\n\r\n    /** insert code */\r\n    function icode(code: EOperation, ...args: Array<number | PromisedAddress>): void {\r\n        if (code === EOperation.k_Ret) {\r\n            // add the instruction address to the description of the\r\n            // function on the top of the colstack; when the code\r\n            // generation for this function is completed, all return\r\n            // instructions must receive the correct addresses for\r\n            // jumping to the end of the function\r\n            addReturn();\r\n        }\r\n\r\n        // add this instruction to debug layout;\r\n        debug.step();\r\n        instructions.add(code, args.map(Number));\r\n    }\r\n\r\n    /**\r\n     * Apply per component operation between two register-based adresses\r\n     * op(a[i])\r\n     */\r\n    function iop1(op: EOperation, dest: PromisedAddress): void {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        for (let i = 0; i < dest.length; ++i) {\r\n            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply per component operation between two register-based adresses\r\n     * a[i] = op(b[i])\r\n     */\r\n    function iop2(op: EOperation, dest: PromisedAddress, a: PromisedAddress): void {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        assert(a.type === EAddrType.k_Registers);\r\n\r\n        assert(dest.length === a.length);\r\n\r\n        for (let i = 0; i < dest.length; ++i) {\r\n            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                a.addr + (a.swizzle ? a.swizzle[i] : i) * sizeof.i32());\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Apply per component operation between two register-based adresses\r\n     * dest[i] = op(a[i], b[i])\r\n     */\r\n    function iop3(op: EOperation, dest: PromisedAddress, a: PromisedAddress, b: PromisedAddress): void {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        assert(a.type === EAddrType.k_Registers);\r\n        assert(b.type === EAddrType.k_Registers);\r\n\r\n        assert(dest.length === a.length);\r\n        assert(dest.length === b.length);\r\n\r\n        for (let i = 0; i < dest.length; ++i) {\r\n            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                a.addr + (a.swizzle ? a.swizzle[i] : i) * sizeof.i32(),\r\n                b.addr + (b.swizzle ? b.swizzle[i] : i) * sizeof.i32());\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Apply per component operation between two register-based adresses\r\n     * dest[i] = op(a[i], b[i], c[i])\r\n     */\r\n    function iop4(op: EOperation, dest: PromisedAddress, a: PromisedAddress, b: PromisedAddress, c: PromisedAddress): void {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        assert(a.type === EAddrType.k_Registers);\r\n        assert(b.type === EAddrType.k_Registers);\r\n        assert(c.type === EAddrType.k_Registers);\r\n\r\n\r\n        assert(dest.length === a.length);\r\n        assert(dest.length === b.length);\r\n        assert(dest.length === c.length);\r\n\r\n        for (let i = 0; i < dest.length; ++i) {\r\n            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                a.addr + (a.swizzle ? a.swizzle[i] : i) * sizeof.i32(),\r\n                b.addr + (b.swizzle ? b.swizzle[i] : i) * sizeof.i32(),\r\n                c.addr + (c.swizzle ? c.swizzle[i] : i) * sizeof.i32());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write something to this location/address\r\n     * @param src Source address.\r\n     * @param size Size of the source location.\r\n     */\r\n    function imove(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n        assert(src.length === dest.length,\r\n            `source size is ${src.size} and less then the requested size ${dest.size}.`);\r\n\r\n        switch (dest.type) {\r\n            case EAddrType.k_Registers:\r\n                {\r\n                    switch (src.type) {\r\n                        case EAddrType.k_Registers:\r\n                            assert(dest.type === EAddrType.k_Registers);\r\n                            for (let i = 0; i < dest.length; ++i) {\r\n                                icode(EOperation.k_I32LoadRegister,\r\n                                    dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                                    src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                            }\r\n                            break;\r\n                        case EAddrType.k_Input:\r\n                            assert(dest.type === EAddrType.k_Registers);\r\n                            for (let i = 0; i < dest.length; ++i) {\r\n                                icode(EOperation.k_I32LoadInput, src.inputIndex,\r\n                                    dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                                    src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                            }\r\n                            break;\r\n                        case EAddrType.k_PointerRegisters:\r\n                            assert(dest.type === EAddrType.k_Registers);\r\n                            for (let i = 0; i < dest.length; ++i) {\r\n                                icode(EOperation.k_I32LoadRegistersPointer,\r\n                                    // destination register\r\n                                    dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                                    // source pointer\r\n                                    src.addr,\r\n                                    // pointer offset\r\n                                    (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                            }\r\n                            break;\r\n                        case EAddrType.k_PointerInput:\r\n                            assert(dest.type === EAddrType.k_Registers);\r\n                            for (let i = 0; i < dest.length; ++i) {\r\n                                icode(EOperation.k_I32LoadInputPointer,\r\n                                    src.inputIndex,\r\n                                    // destination register\r\n                                    dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                                    // source pointer\r\n                                    src.addr,\r\n                                    // pointer offset\r\n                                    (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                            }\r\n                            break;\r\n                        default:\r\n                            assert(false, 'unsupported memory type found.');\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case EAddrType.k_Input:\r\n                assert(src.type === EAddrType.k_Registers);\r\n                for (let i = 0; i < dest.length; ++i) {\r\n                    icode(EOperation.k_I32StoreInput, dest.inputIndex,\r\n                        dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                        src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                }\r\n                break;\r\n            case EAddrType.k_PointerInput:\r\n                assert(src.type === EAddrType.k_Registers);\r\n                for (let i = 0; i < dest.length; ++i) {\r\n                    icode(EOperation.k_I32StoreInputPointer, dest.inputIndex,\r\n                        // destination pointer\r\n                        dest.addr,\r\n                        // source register\r\n                        src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32(),\r\n                        // destination offset\r\n                        (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32());\r\n                }\r\n                break;\r\n            case EAddrType.k_PointerRegisters:\r\n                assert(src.type === EAddrType.k_Registers);\r\n                for (let i = 0; i < dest.length; ++i) {\r\n                    icode(EOperation.k_I32StoreRegisterPointer,\r\n                        // destination pointer\r\n                        dest.addr,\r\n                        // source register\r\n                        src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32(),\r\n                        // destination offset\r\n                        (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32());\r\n                }\r\n                break;\r\n            default:\r\n                assert(false, 'unsupported memory type found.');\r\n        }\r\n\r\n        return dest;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Resolve/move this address/region to registers\r\n     */\r\n    function iload(src: PromisedAddress): PromisedAddress {\r\n        assert(src.type !== EAddrType.k_Registers);\r\n        return imove(alloca(src.size), src);\r\n    }\r\n\r\n\r\n    const I32_HINT = 0;\r\n    const F32_HINT = 1;\r\n    // hint: 0 -> i32, 1 -> f32 (hints for bytecode viewer only)\r\n    function iset(dest: PromisedAddress, i32: number, i32Hint: 0 | 1): PromisedAddress {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        icode(EOperation.k_I32SetConst, dest.addr + (dest.swizzle ? dest.swizzle[0] : 0) * sizeof.i32(), i32, i32Hint);\r\n        return dest;\r\n    }\r\n\r\n\r\n    function iconst_i32(i32: number): PromisedAddress {\r\n        return iset(alloca(sizeof.i32()), i32, I32_HINT);\r\n    }\r\n\r\n    function iconst_f32(f32: number): PromisedAddress {\r\n        return iset(alloca(sizeof.f32()), f32Asi32(f32), F32_HINT);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add referene of the local variable.\r\n     * @param decl Variable declaration.\r\n     * @param src Register number.\r\n     */\r\n    function ref(decl: IVariableDeclInstruction, src: PromisedAddress): void {\r\n        const name = sname.var(decl);\r\n        assert(src.type === EAddrType.k_Registers);\r\n\r\n        const scopes = top().scopes;\r\n        const symbols = scopes[scopes.length - 1].symbols;\r\n        assert(!isDef(symbols[name]));\r\n        symbols[name] = src;\r\n    }\r\n\r\n\r\n    /**\r\n     * @returns Register address of variable/constant or REG_INVALID.\r\n     * @param decl\r\n     */\r\n    function deref(decl: IVariableDeclInstruction): PromisedAddress {\r\n        const name = sname.var(decl);\r\n        // is zero register available?\r\n        for (let iFn = stack.length - 1; iFn >= 0; --iFn) {\r\n            const scopes = stack[iFn].scopes;\r\n            for (let iScope = scopes.length - 1; iScope >= 0; --iScope) {\r\n                const symbols = scopes[iScope].symbols;\r\n                if (isDef(symbols[name])) {\r\n                    return symbols[name];\r\n                }\r\n            }\r\n        }\r\n        assert(false, `cannot dereference varaible ${name} (${decl.toCode()})`);\r\n        return PromisedAddress.INVALID;\r\n    }\r\n\r\n\r\n    /** @returns Address of the return value. */\r\n    function push(fn: IFunctionDeclInstruction, ret: PromisedAddress): void {\r\n        const pc = instructions.pc;\r\n        const retRequests = [];\r\n        const scopes = [];\r\n        stack.push({ fn, scopes, ret, pc, retRequests });\r\n        open();\r\n    }\r\n\r\n\r\n    function pop(): void {\r\n        // check that there are no non-closed blocks left inside the function\r\n        assert(top().scopes.length === 1);\r\n        close();\r\n\r\n        const entry = stack.pop();\r\n\r\n        const entryPoint = stack.length === 0;\r\n        // updating all return adresses to correct values\r\n        if (!entryPoint) {\r\n            entry.retRequests.forEach(pc => instructions.replace(pc, EOperation.k_Jump, [instructions.pc]));\r\n            //                                                                          ^^^^^^^^^^^^^^^^^\r\n            //                                                     instruction immediately after function\r\n        }\r\n    }\r\n\r\n    /** Open new block */\r\n    function open() {\r\n        const symbols = new SymbolTable<PromisedAddress>();\r\n        top().scopes.push({ symbols, rc });\r\n    }\r\n\r\n\r\n    /** CLose last block */\r\n    function close() {\r\n        const scope = top().scopes.pop();\r\n        rc = scope.rc;\r\n    }\r\n\r\n\r\n    // next operation will be 'k_Ret'\r\n    function addReturn() {\r\n        top()?.retRequests.push(pc());\r\n    }\r\n\r\n    const Addr = {\r\n        loc({ type = EAddrType.k_Registers, addr, inputIndex, size, swizzle }: MakeOptional<IAddrDesc>) {\r\n            return new PromisedAddress({ type, addr, inputIndex, size, swizzle });\r\n        },\r\n\r\n        // override layout\r\n        override(src: PromisedAddress, swizzle: number[]): PromisedAddress {\r\n\r\n            let offset = 0;\r\n            let size = 0;\r\n\r\n            swizzle = swizzle.map(i => src.swizzle ? src.swizzle[i] : i);\r\n\r\n\r\n            // NOTE: \r\n            // All this optimizations are need only for debug purposes.\r\n            \r\n            if (!src.isPointer()) {\r\n                // removment of the unary swizzles\r\n                if (swizzle.length === 1) {\r\n                    offset = swizzle[0] * sizeof.i32();\r\n                    size = sizeof.i32();\r\n                    swizzle = null;\r\n                    return new PromisedAddress({ ...src, addr: src.addr + offset, size, swizzle });\r\n                }\r\n\r\n\r\n                const ordered = [ ...swizzle ].sort((a, b) => a - b);\r\n                \r\n                // removment of the gap\r\n                // example: v.zw => (&v + 2).xy\r\n                if (ordered[0] !== 0) {\r\n                    offset = ordered[0] * sizeof.i32();\r\n                    swizzle = swizzle.map(si => si - ordered[0]);\r\n                }\r\n                \r\n                // removment of the useless swizzles\r\n                // example: v.xy => v\r\n                const useless = swizzle.every((si, i) => si === i);\r\n                if (useless) {\r\n                    size = swizzle.length * sizeof.i32();\r\n                    swizzle = null;\r\n                }\r\n            }\r\n\r\n            return new PromisedAddress({ ...src, addr: src.addr + offset, size, swizzle });\r\n        },\r\n\r\n\r\n        subPointer(src: PromisedAddress, indexAddr: PromisedAddress, arrayElementSize: number) {\r\n            const { type, addr, size, inputIndex, swizzle } = src;\r\n\r\n            if (indexAddr.type !== EAddrType.k_Registers) {\r\n                indexAddr = iload(indexAddr);\r\n            }\r\n\r\n            //\r\n            // no swizzling (pointers & non-pointers)\r\n            //\r\n\r\n            if (!swizzle) {\r\n\r\n                // convert byte offset to register index (cause VM uses registers not byte offsets)\r\n                const sizeAddr = iconst_i32(arrayElementSize >> 2);\r\n\r\n                // convert byte offset to register index\r\n                const baseAddr =  !src.isPointer() ? iconst_i32(addr >> 2) : addr;\r\n                const pointerType = !src.isPointer() ? PromisedAddress.castToPointer(type) : type;\r\n\r\n                const pointerAddr = alloca(sizeof.addr());        // addr <=> i32\r\n                icode(EOperation.k_I32Mad, pointerAddr, baseAddr, indexAddr, sizeAddr);\r\n\r\n\r\n                return new PromisedAddress({ type: pointerType, addr: pointerAddr, size: arrayElementSize, inputIndex });\r\n            }\r\n\r\n            //\r\n            // swizzling (pointers & non-pointers)\r\n            //\r\n\r\n            assert(arrayElementSize === sizeof.i32());\r\n\r\n            assert(swizzle.length <= 4);\r\n\r\n            const swBaseRegister = rc;\r\n            swizzle.forEach(si => iconst_i32(si));\r\n            // ----- sw base rigister\r\n            // [z]\r\n            // [x]\r\n            // [y]\r\n            // -----\r\n\r\n            const swAddr = iconst_i32(swBaseRegister >> 2);\r\n\r\n            // swAddr ==> [ sw base rigister ]\r\n\r\n            icode(EOperation.k_I32Add, swAddr, swAddr, indexAddr);\r\n\r\n            // swAddr ==> [ sw base rigister + offset ]\r\n\r\n            // pointer to value of the swizzle for given offset\r\n            const offsetPointer = new PromisedAddress({ type: EAddrType.k_PointerRegisters, addr: swAddr, size: sizeof.i32() });\r\n\r\n            const pointerAddr = iload(offsetPointer);\r\n            // destAddr ==> [ swizzles[offset] ]\r\n\r\n            const baseAddr = !src.isPointer()? iconst_i32(addr >> 2) : addr;\r\n            const pointerType = !src.isPointer() ? PromisedAddress.castToPointer(type) : type;\r\n\r\n            // add given swizzle to base pointer (all pointers already aligned in registers, so 'mad' isn't not needed here)\r\n            icode(EOperation.k_I32Add, pointerAddr, baseAddr, pointerAddr);\r\n\r\n            return new PromisedAddress({ type: pointerType, addr: pointerAddr, size: arrayElementSize, inputIndex });\r\n        },\r\n\r\n\r\n        sub(src: PromisedAddress, offset: number, range?: number): PromisedAddress {\r\n            const { type, addr, size, inputIndex, swizzle } = src;\r\n\r\n            range = range || (size - offset);\r\n\r\n            assert(range % sizeof.i32() === 0);\r\n            assert(offset % sizeof.i32() === 0);\r\n            assert(size >= offset + range);\r\n\r\n            if (src.isPointer()) {\r\n                if (!swizzle) {\r\n                    if (offset !== 0) {\r\n                        // calc the summ of the original addr and given offset\r\n                        const newAddr = alloca(sizeof.addr());\r\n                        const offsetAddr = iconst_i32(offset >> 2);\r\n                        icode(EOperation.k_I32Add, newAddr, addr, offsetAddr);\r\n                        return new PromisedAddress({ type, addr: newAddr, size: range, inputIndex });\r\n                    }\r\n                    // nothing todo, just shrink the size\r\n                    return new PromisedAddress({ type, addr, size: range, inputIndex });\r\n                }\r\n\r\n                // offsets from the swizzled pointers are unsupported\r\n                // ex: uav[i].xyz.field\r\n                //                ^^^^^\r\n                //                there are not such case can be! \r\n                \r\n                assert(false, 'unsupported branch');\r\n                return PromisedAddress.INVALID;\r\n            }\r\n\r\n            // just shift the address\r\n            if (!swizzle) {\r\n                return new PromisedAddress({ type, addr: addr + offset, size: range, inputIndex });\r\n            }\r\n\r\n            // implicitly move padding inside swizzles\r\n            const ordered = [...Array(range / sizeof.i32()).keys()].map(i => i + offset / sizeof.i32());\r\n            return Addr.override(src, ordered);\r\n        },\r\n\r\n        shrink(src: PromisedAddress, size: number): PromisedAddress {\r\n            return Addr.sub(src, 0, size);\r\n        }\r\n    }\r\n\r\n    const addr = Addr;\r\n\r\n    return {\r\n        pc,\r\n        addr,\r\n        instructions,\r\n        debug,\r\n        deref,\r\n        ref,\r\n        alloca,\r\n        icode,\r\n        imove,\r\n        iload,\r\n        iconst_i32,\r\n        iconst_f32,\r\n        iop4,\r\n        iop3,\r\n        iop2,\r\n        iop1,\r\n        push,\r\n        pop,\r\n        open,\r\n        close,\r\n        ret,\r\n        constants,\r\n        pipeline,\r\n        externs,\r\n        uavs,\r\n        srvs,\r\n        depth,\r\n        diag,\r\n        error,\r\n        critical\r\n    };\r\n}\r\n\r\nexport type IContext = ReturnType<typeof ContextBuilder>;\r\n","import { assert, isDef } from \"@lib/common\";\r\nimport { IFunctionDeclInstruction, IInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport DistinctColor from \"@lib/util/DistinctColor\";\r\nimport { isDefAndNotNull } from \"@lib/util/s3d/type\";\r\nimport { isNull } from \"util\";\r\n\r\nenum EDebugLineFlags {\r\n    k_NewStatement = 0x01\r\n};\r\n\r\nexport class DebugLineRecord {\r\n    pc: number;      // instruction addr;\r\n    file?: number;\r\n    line?: number;\r\n    column?: number; \r\n    flags: number;  // bitflags like: NS PE etc.\r\n    color?: number; // debug color, for easier code <=> asm matching\r\n}\r\n\r\n// process counter;\r\ntype PC = () => number;\r\n\r\nfunction debugLine(pc: PC) {\r\n    const files: string[] = [];\r\n    const layout: DebugLineRecord[] = [];\r\n\r\n    const lastRecord = () => layout[layout.length -1] || null;\r\n\r\n    // mark last record as 'new statement';\r\n    function ns() {\r\n        let rec = lastRecord();\r\n        // TOOD: allow breakpoints in case of no instructions have already beed added\r\n        if (rec) {\r\n            rec.flags |= EDebugLineFlags.k_NewStatement;\r\n        }\r\n    }\r\n\r\n    // add last instruction to record table;\r\n    function step() {\r\n        layout.push({ pc: pc(), flags: 0 })\r\n    }\r\n\r\n    // add filename to source files table and return index;\r\n    function fileToIndex(file: string) {\r\n        let idx = files.indexOf(file);\r\n        if (idx == -1) {\r\n            idx = files.length;\r\n            files.push(file);\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    function map(inst: IInstruction) {\r\n        const loc = (inst && inst.sourceNode && inst.sourceNode.loc) || null;\r\n        if (isNull(loc)) {\r\n            return;\r\n        }\r\n        \r\n        const pos = loc.start;\r\n        const rec = lastRecord();\r\n\r\n        if (rec) {\r\n            rec.line = pos.line || 0;\r\n            rec.column = pos.column || 0;\r\n            rec.file = fileToIndex(`${pos.file}`);\r\n        }\r\n    }\r\n\r\n\r\n    function dump() {\r\n        let line = undefined;\r\n        let color = new DistinctColor;\r\n        let cache = {};\r\n        for (let i = layout.length - 1; i >= 0; i--) {\r\n            let entry = layout[i];\r\n\r\n            if (line != entry.line) color.pickNext();\r\n            line = isDef(entry.line) ? entry.line : line;\r\n            entry.line = line;\r\n            cache[line] = isDef(cache[line])? cache[line] : color.value();\r\n            entry.color = cache[line];\r\n        }\r\n        return { files, layout };\r\n    }\r\n\r\n    return {\r\n        ns,         // mark last record as 'new statement';\r\n        step,       // add last instruction(pc) to record table;\r\n        map,        // specify last record source location\r\n\r\n        dump\r\n    }\r\n}\r\n\r\nenum ETagType {\r\n    k_CompilationUnit,\r\n    k_SubProgram\r\n}\r\n\r\ninterface ITag {\r\n    tagType: ETagType;\r\n    children?: ITag[];\r\n}\r\n\r\ninterface ICompilationUnit extends ITag {\r\n    name: string; // path to file originally compiled;\r\n    lowPc: number;\r\n    highPc: number;\r\n}\r\n\r\ninterface ISubProgram extends ITag {\r\n    name: string;       // function name;\r\n    type: number;       // tag addr;\r\n    lowPc: number;\r\n    highPc: number;\r\n    declFile: string;   // file\r\n    declLine: number;\r\n}\r\n\r\nfunction debugInfo(pc: PC) {\r\n\r\n    let unitLayout: ITypeInstruction;\r\n\r\n    function locate(decl: IVariableDeclInstruction, reg: number) {\r\n\r\n    }\r\n\r\n    function beginCompilationUnit(name: string = null, layout: ITypeInstruction): void {\r\n        unitLayout = layout;\r\n    }\r\n    function endCompilationUnit(): void {};\r\n\r\n    function beginSubProgram(func: IFunctionDeclInstruction): void {}\r\n    function endSubProgram(): void {}\r\n\r\n    function dump() {\r\n        return {\r\n            layout: unitLayout\r\n        };\r\n    }\r\n\r\n    return {\r\n        beginCompilationUnit,\r\n        endCompilationUnit,\r\n        beginSubProgram,\r\n        endSubProgram,\r\n\r\n        locate,\r\n\r\n        dump\r\n    }\r\n}\r\n\r\n\r\n\r\nexport interface CDL {\r\n    line: ReturnType<ReturnType<typeof debugLine>['dump']>; // << descriptoption for each line\r\n    info: ReturnType<ReturnType<typeof debugInfo>['dump']>; // << empty for now\r\n}\r\n\r\nexport function debug (pc: PC) {\r\n    const line = debugLine(pc);\r\n    const info = debugInfo(pc);\r\n   \r\n    function dump(): CDL {\r\n        return {\r\n            line: line.dump(),\r\n            info: info.dump()\r\n        }\r\n    }\r\n\r\n    // const { ns } = line;\r\n    // const { beginCompilationUnit, endCompilationUnit, beginSubProgram, endSubProgram } = info;\r\n    return { ...line, ...info, dump }; // todo: export only required;\r\n}\r\n\r\ntype Color = number;\r\n\r\n/**\r\n * Code Debug Layout View.\r\n */\r\nexport function cdlview(cdlRaw: CDL) {\r\n    if (!isDefAndNotNull(cdlRaw)) {\r\n        return null;\r\n    }\r\n\r\n    const { line, info } = cdlRaw;\r\n\r\n    /**\r\n     * @param pc Number of instruction.\r\n     */\r\n    function resolveFileLocation(pc: number) {\r\n        let rec = line.layout[pc];\r\n        assert(rec.pc == pc);\r\n        return {\r\n            file: isDef(rec.file) ? line.files[rec.file]: null,\r\n            line: rec.line,\r\n            column: rec.column\r\n        };\r\n    }\r\n\r\n    /** \r\n     * @returns Valid breakpoint position from arbitrary line.\r\n     */\r\n    function resolveBreakpointLocation(ln: number): number {\r\n        // todo: optimize it;\r\n        let rec = line.layout.find(r => r.line >= ln && (r.flags & EDebugLineFlags.k_NewStatement) != 0);\r\n        return (rec && rec.line) || -1;\r\n    }\r\n\r\n\r\n    function resolvePcColor(pc: number): Color {\r\n        return line.layout[pc] ? line.layout[pc].color : 0xffffff;\r\n    }\r\n\r\n    function resolveLineColor(ln: number, file: string): number {        \r\n        let rec = line.layout.find(r => r.line === ln && r.file === line.files.indexOf(file));\r\n        return rec ? rec.color : -1;\r\n    }\r\n    \r\n\r\n    return {\r\n        resolveFileLocation,\r\n        resolveBreakpointLocation,\r\n        resolvePcColor,\r\n        resolveLineColor\r\n    }\r\n}\r\n\r\nexport default debug;\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { IExtern } from \"@lib/idl/bytecode\";\r\nimport { IFunctionDefInstruction } from \"@lib/idl/IInstruction\";\r\nimport { typeAstToTypeLayout } from \"./VM/native\";\r\n\r\n\r\nexport class Externs {\r\n    funcs: IFunctionDefInstruction[] = [];\r\n\r\n    add(fdef: IFunctionDefInstruction): number {\r\n        let id = this.funcs.indexOf(fdef);\r\n        if (id === -1) {\r\n            id = this.funcs.length;\r\n            this.funcs.push(fdef);\r\n        }\r\n        assert(this.funcs[id].instructionID === fdef.instructionID);\r\n        return id;\r\n    }\r\n\r\n    dump(): IExtern[] {\r\n        return this.funcs.map((fdef, id) => {\r\n            const ret = typeAstToTypeLayout(fdef.returnType);\r\n            const params = fdef.params.map(({ type }) => typeAstToTypeLayout(type));\r\n            const name = fdef.name;\r\n            return { id, name, ret, params };\r\n        });\r\n    }\r\n}\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { EOperation } from \"@lib/idl/bytecode/EOperations\";\r\n\r\n// todo: use more compact format than 4 x int32\r\n\r\nclass InstructionList {\r\n    private _data: Uint32Array;\r\n    private _length: number;\r\n\r\n    constructor() {\r\n        this._data = new Uint32Array(8);\r\n        this._length = 0;\r\n    }\r\n\r\n\r\n    get capacity(): number {\r\n        return this._data.length;\r\n    }\r\n\r\n\r\n    get data(): Uint32Array {\r\n        return this._data.subarray(0, this._length);\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n\r\n    get pc(): number {\r\n        return this.length / InstructionList.STRIDE;\r\n    }\r\n\r\n\r\n    // convert bytes adresses to register numbers\r\n    // validate number of arguments\r\n    // premultiply jump counters with instructions stride\r\n    static prepareInstruction(op: EOperation, args: number[]) {\r\n\r\n        // NOTE: keep order as it is done in the VM.ts\r\n        switch (op) {\r\n            case EOperation.k_I32SetConst:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                // args[1] => constant itself\r\n                // args[2] => hint about what type lies in the constant\r\n                break;\r\n            case EOperation.k_I32LoadRegister:\r\n                assert(args.length == 2);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                break;\r\n            case EOperation.k_I32LoadRegistersPointer:\r\n            case EOperation.k_I32StoreRegisterPointer:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2; // byte offset => register offset\r\n                break;\r\n            case EOperation.k_I32LoadInput:\r\n            case EOperation.k_I32StoreInput:\r\n                assert(args.length == 3);\r\n                // args[0] => input index    \r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                break;\r\n            case EOperation.k_I32LoadInputPointer:\r\n            case EOperation.k_I32StoreInputPointer:\r\n                assert(args.length == 4);\r\n                // args[0] => input index\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                args[3] >>= 2; // byte offset => register offset\r\n                break;\r\n            case EOperation.k_I32TextureLoad:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;  // float4 sized destination address\r\n                args[1];        // is input index of texture\r\n                args[2] >>= 2;  // address of arguments\r\n                break;    \r\n            case EOperation.k_I32ExternCall:\r\n                assert(args.length == 2);\r\n                args[0];              // id of external routine\r\n                args[1] >>= 2;        // cc layout\r\n                break;  \r\n            case EOperation.k_I32Not:\r\n                assert(args.length == 2);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_I32Add:\r\n            case EOperation.k_I32Sub:\r\n            case EOperation.k_I32Mul:\r\n            case EOperation.k_I32Div:\r\n            case EOperation.k_I32Mod:\r\n            case EOperation.k_F32Add:\r\n            case EOperation.k_F32Sub:\r\n            case EOperation.k_F32Mul:\r\n            case EOperation.k_F32Div:\r\n            case EOperation.k_F32Mod:\r\n\r\n            case EOperation.k_U32LessThan:\r\n            case EOperation.k_U32GreaterThanEqual:\r\n            case EOperation.k_I32LessThan:\r\n            case EOperation.k_I32GreaterThanEqual:\r\n            case EOperation.k_I32Equal:\r\n            case EOperation.k_I32NotEqual:\r\n            case EOperation.k_F32LessThan:\r\n            case EOperation.k_F32GreaterThanEqual:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_I32Mad:\r\n                assert(args.length == 4);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                args[3] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_I32LogicalOr:\r\n            case EOperation.k_I32LogicalAnd:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_F32Frac:\r\n            case EOperation.k_F32Floor:\r\n            case EOperation.k_F32Ceil:\r\n            case EOperation.k_F32Sin:\r\n            case EOperation.k_F32Cos:\r\n            case EOperation.k_F32Abs:\r\n            case EOperation.k_F32Sqrt:\r\n                assert(args.length == 2);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_I32Min:\r\n            case EOperation.k_I32Max:\r\n            case EOperation.k_F32Max:\r\n            case EOperation.k_F32Min:\r\n            case EOperation.k_F32Pow:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_F32ToI32:\r\n            case EOperation.k_I32ToF32:\r\n            case EOperation.k_F32ToU32:\r\n            case EOperation.k_U32ToF32:\r\n                assert(args.length == 2);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_Jump:\r\n                assert(args.length === 1);\r\n                // don't multiply jump in order to facilitate the operation of the VM\r\n                // see bundle.cpp/bundle.ts for more details.\r\n                args[0] *= 1; // InstructionList.STRIDE;\r\n                break;\r\n            case EOperation.k_JumpIf:\r\n                assert(args.length === 1);\r\n                args[0] >>= 2;\r\n                break;\r\n            case EOperation.k_Ret:\r\n                // nothing todo\r\n                break;\r\n            default:\r\n                assert(false, `unknown operation found: ${op} (${EOperation[op]})`);\r\n        }\r\n    }\r\n\r\n\r\n    add(op: EOperation, args: number[]) {\r\n        assert(args.length <= 4);\r\n        this.check(InstructionList.STRIDE);\r\n\r\n        InstructionList.prepareInstruction(op, args);\r\n\r\n        this.push(op);\r\n        args.forEach((v) => this.push(v));\r\n        this._length += 4 - args.length;\r\n    }\r\n\r\n    /**\r\n     * Replace specified instruction with new one;\r\n     * @param pc number of instruction to be replaced\r\n     * @param op new operation\r\n     * @param args new arguments\r\n     */\r\n    replace(pc: number, op: EOperation, args: number[]) {\r\n        assert(pc < this.pc);\r\n        assert(args.length <= 4);\r\n\r\n        const pc5 = pc * InstructionList.STRIDE; // stride is 5\r\n\r\n        // FIXME: remove this assert\r\n        assert(this.data[pc5] === EOperation.k_Ret || this.data[pc5] === EOperation.k_Jump,\r\n            `expected ${EOperation.k_Ret}/${EOperation.k_Jump}, but given is ${this.data[pc5]} for pc = ${pc}`);\r\n\r\n        InstructionList.prepareInstruction(op, args);\r\n\r\n        // replace op\r\n        this.data[pc5] = op;\r\n        // replace arguments\r\n        args.forEach((v, i) => { this.data[pc5 + 1 + i] = v; });\r\n    }\r\n\r\n    // [ op, a, b, c, d ]\r\n    back() {\r\n        return this.data.slice(-InstructionList.STRIDE);\r\n    }\r\n\r\n    private push(val: number) {\r\n        assert(this.capacity - this._length >= 1);\r\n        this._data[this._length++] = val;\r\n    }\r\n\r\n\r\n    private check(count: number) {\r\n        let expected = this._length + count;\r\n        if (expected <= this.capacity) {\r\n            return;\r\n        }\r\n\r\n        var oldData = this._data;\r\n        var newData = new Uint32Array(Math.max(expected, this.capacity * 2));\r\n        newData.set(oldData);\r\n\r\n        this._data = newData;\r\n    }\r\n\r\n    static STRIDE: number = 5;\r\n}\r\n\r\nexport default InstructionList;","import { assert, isDef } from \"@lib/common\";\r\nimport { expression } from \"@lib/fx/analisys/helpers\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { IShader } from \"@lib/idl/bytecode\";\r\nimport { EComparisonFunc, EDepthWriteMask, EStencilOp, IDepthStencilState } from \"@lib/idl/bytecode\";\r\nimport { EInstructionTypes, ICompileShader11Instruction, IStateBlockInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nfunction hash(csh: ICompileShader11Instruction): string {\r\n    return `${csh.ver}-${csh.func.name}.${csh.func.instructionID}-${csh.args.map(a => expression.evalConst(a)).join(':')}`;\r\n}\r\n\r\n///////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////\r\n\r\nexport function createDepthStencilState(): IDepthStencilState {\r\n    return {\r\n        DepthEnable: true,\r\n        DepthWriteMask: EDepthWriteMask.k_All,\r\n        DepthFunc: EComparisonFunc.k_Less,\r\n        StencilEnable: false,\r\n        StencilReadMask: 0xff,\r\n        StencilWriteMask: 0xff,\r\n        FrontFace: {\r\n            StencilFailOp: EStencilOp.k_Keep,\r\n            StencilDepthFailOp: EStencilOp.k_Keep,\r\n            StencilPassOp: EStencilOp.k_Keep,\r\n            StencilFunc: EComparisonFunc.k_Always\r\n        },\r\n        BackFace: {\r\n            StencilFailOp: EStencilOp.k_Keep,\r\n            StencilDepthFailOp: EStencilOp.k_Keep,\r\n            StencilPassOp: EStencilOp.k_Keep,\r\n            StencilFunc: EComparisonFunc.k_Always\r\n        }\r\n    };\r\n}\r\n\r\n///////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////\r\n\r\nconst camelToSnakeCase = str => str?.length > 1 \r\n    ? (str[0] + str.substring(1).replace(/[A-Z]/g, letter => `_${letter}`)).toLowerCase()\r\n    : str;\r\n\r\nfunction evalPropEnum(props: Object, key: string, enumObj: Object, defaultVal: number): number {\r\n    if (!isDef(props[key])) {\r\n        return defaultVal;\r\n    }\r\n\r\n    const knownKeys = Object.keys(enumObj);\r\n    const keyIndex = knownKeys.map(k => camelToSnakeCase(k.substring(2)).toUpperCase()).indexOf(props[key].toUpperCase());\r\n    assert(keyIndex !== -1);\r\n\r\n    if (keyIndex == -1) {\r\n        return defaultVal;\r\n    }\r\n\r\n    const keyName = knownKeys[keyIndex];\r\n    const enumVal = enumObj[keyName];\r\n    \r\n    return enumVal;\r\n}\r\n\r\nfunction evalPropBool(props: Object, key: string, defaultVal: boolean) {\r\n    enum EBool { k_False, k_True }\r\n    return !!evalPropEnum(props, key, EBool, +defaultVal);\r\n}\r\n\r\nfunction evalNumber(props: Object, key: string, defaultVal: number) {\r\n    if (!isDef(props[key])) {\r\n        return defaultVal;\r\n    }\r\n\r\n    return Number(props[key]);\r\n}\r\n\r\n///////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////\r\n\r\ninterface IDepthStencilStateEntry {\r\n    name: string;\r\n    state: IDepthStencilState;\r\n}\r\n\r\ninterface IShaderEntry {\r\n    id: number;\r\n    shader: IShader;\r\n}\r\n\r\nexport class PipelineStates {\r\n    protected _knownShaders: IMap<IShaderEntry> = {};\r\n    protected _knownDepthStencilStates: IDepthStencilStateEntry[] = [];\r\n\r\n\r\n    dumpShaders(): IShaderEntry[] {\r\n        return Object.values(this._knownShaders).sort((a, b) => a.id - b.id);\r\n    }\r\n\r\n\r\n    dumpDepthStencilStates(): IDepthStencilState[] {\r\n        return this._knownDepthStencilStates.map(entry => entry.state);\r\n    }\r\n\r\n\r\n    derefShader11(csh: ICompileShader11Instruction): number {\r\n        const { func, ver } = csh;\r\n        const { name } = func;\r\n        const key = hash(csh);\r\n        const shaders = this._knownShaders;\r\n\r\n        if (shaders[key]) {\r\n            return shaders[key].id;\r\n        }\r\n\r\n        const id = Object.keys(shaders).length + 1; // '0' is reserved id for NULL shaders\r\n        // todo: add support for complex constants/expressions like float4(1,2,3,4), complex types etc.\r\n        const args = csh.args.map(arg => ({ type: arg.type.name, value: expression.evalConst(arg) }));\r\n        shaders[key] = { id, shader: { name, ver, args } };\r\n        return id;\r\n    }\r\n\r\n\r\n    deref(decl: IVariableDeclInstruction): number {\r\n        if (SystemScope.isDepthStencilState(decl.type)) {\r\n            return this.derefDethStencilState(decl);\r\n        }\r\n\r\n        if (SystemScope.isBlendState(decl.type)) {\r\n            console.assert(false, 'blend state is not yet supported');\r\n            return this.derefBlendState(decl);\r\n        }\r\n\r\n        if (SystemScope.isRasterizerState(decl.type)) {\r\n            console.assert(false, 'raserizer state is not yet supported');\r\n            return this.derefRasterizerState(decl);\r\n        }\r\n        \r\n        assert(false, `unknown pipeline state \"${decl.type.name}\" found`);\r\n        return -1;\r\n    }\r\n\r\n\r\n    protected derefDethStencilState(decl: IVariableDeclInstruction): number {\r\n        assert(!decl.type.isNotBaseArray(), 'DSS arrays are not yet unsupported (!)');\r\n        assert(decl.isGlobal());\r\n\r\n        const { name, type, initExpr } = decl;\r\n        const entries = this._knownDepthStencilStates;\r\n        const entryIndex = entries.findIndex(s => s.name === name);\r\n\r\n        if (entryIndex !== -1) {\r\n            return entryIndex;\r\n        }\r\n\r\n        const state = createDepthStencilState();\r\n        const id = entries.length;\r\n        entries.push({ name, state });\r\n\r\n        if (initExpr) {\r\n            assert(initExpr.instructionType === EInstructionTypes.k_StateBlockExpr);\r\n            const props = (initExpr as IStateBlockInstruction).props;\r\n            \r\n            state.DepthEnable = evalPropBool(props, 'DepthEnable', state.DepthEnable);\r\n            state.DepthWriteMask = evalPropEnum(props, 'DepthWriteMask', EDepthWriteMask, state.DepthWriteMask);\r\n            state.DepthFunc = evalPropEnum(props, 'DepthFunc', EComparisonFunc, state.DepthFunc);\r\n\r\n            state.StencilEnable = evalPropBool(props, 'StencilEnable', state.StencilEnable);\r\n            state.StencilReadMask = evalNumber(props, 'StencilReadMask', state.StencilReadMask);\r\n            state.StencilWriteMask = evalNumber(props, 'StencilWriteMask', state.StencilWriteMask);\r\n\r\n            state.FrontFace.StencilFailOp = evalPropEnum(props, 'FrontFaceStencilFailOp', EStencilOp, state.FrontFace.StencilFailOp);\r\n            state.FrontFace.StencilDepthFailOp = evalPropEnum(props, 'FrontFaceStencilDepthFailOp', EStencilOp, state.FrontFace.StencilDepthFailOp);\r\n            state.FrontFace.StencilPassOp = evalPropEnum(props, 'FrontFaceStencilPassOp', EStencilOp, state.FrontFace.StencilPassOp);\r\n            state.FrontFace.StencilFunc = evalPropEnum(props, 'FrontFaceStencilFunc', EComparisonFunc, state.FrontFace.StencilFunc);\r\n\r\n            state.BackFace.StencilFailOp = evalPropEnum(props, 'BackFaceStencilFailOp', EStencilOp, state.BackFace.StencilFailOp);\r\n            state.BackFace.StencilDepthFailOp = evalPropEnum(props, 'BackFaceStencilDepthFailOp', EStencilOp, state.BackFace.StencilDepthFailOp);\r\n            state.BackFace.StencilPassOp = evalPropEnum(props, 'BackFaceStencilPassOp', EStencilOp, state.BackFace.StencilPassOp);\r\n            state.BackFace.StencilFunc = evalPropEnum(props, 'BackFaceStencilFunc', EComparisonFunc, state.BackFace.StencilFunc);\r\n        }\r\n        \r\n        return id;\r\n    }\r\n\r\n\r\n    protected derefBlendState(decl: IVariableDeclInstruction): number {\r\n        return 0;\r\n    }\r\n\r\n    \r\n    protected derefRasterizerState(decl: IVariableDeclInstruction): number {\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\nexport default PipelineStates;\r\n","import { assert } from \"@lib/common\";\r\nimport { EAddrType } from \"@lib/idl/bytecode\";\r\n\r\nimport { REG_INVALID } from \"./common\";\r\nimport sizeof from \"./sizeof\";\r\n\r\nexport interface IAddrDesc {\r\n    type: EAddrType;\r\n    addr: number | PromisedAddress;\r\n    size?: number;\r\n    swizzle?: number[];\r\n    inputIndex?: number;\r\n}\r\n\r\n\r\nexport interface IAddrOverride {\r\n    size?: number;\r\n    swizzle?: number[];\r\n}\r\n\r\n\r\nclass PromisedAddress {\r\n    type: EAddrType;\r\n    addr: number;\r\n    size: number;\r\n    inputIndex: number;\r\n    swizzle: number[];\r\n\r\n\r\n    constructor({ type, addr, size = 0, inputIndex = -1, swizzle = null }: IAddrDesc) {\r\n        this.type = type;\r\n        this.addr = Number(addr);\r\n        this.inputIndex = inputIndex;\r\n\r\n        assert(!swizzle || !size || swizzle.length * sizeof.i32() === size, 'size and swizzling are not compatible');\r\n        if (swizzle) {\r\n            assert(swizzle.length > 1, 'unary swizzles must be removed in favor of offsetted adress');\r\n            assert(swizzle.length <= 4, 'only xyzw/rgba swizzles are supported');\r\n\r\n            size = swizzle.length * sizeof.i32();\r\n        }\r\n\r\n        this.size = size;\r\n        this.swizzle = swizzle;\r\n\r\n        assert(addr === REG_INVALID || size > 0, 'invalid address size found');\r\n        assert(size % sizeof.i32() === 0, 'invalid address alignment found');\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        return this.size / sizeof.i32();\r\n    }\r\n\r\n\r\n    valueOf(): number {\r\n         // guard of implicit loading\r\n        if (this.type != EAddrType.k_Registers) {\r\n            assert(false, `address has implicitly moved to ${EAddrType[EAddrType.k_Registers]} from ${EAddrType[this.type]}`);\r\n            return REG_INVALID;\r\n        }\r\n\r\n        return this.addr;\r\n    }\r\n\r\n\r\n    isPointer(): boolean {\r\n        return this.type >= EAddrType.k_PointerRegisters;\r\n    }\r\n\r\n    isInput(): boolean {\r\n        return this.type == EAddrType.k_Input || this.type == EAddrType.k_PointerInput;\r\n    }\r\n\r\n\r\n    toNumber() {\r\n        return this.addr;\r\n    }\r\n\r\n\r\n    toString() {\r\n        const { type, inputIndex, addr, swizzle, size } = this;\r\n        const isPointer = this.isPointer();\r\n        const isInput = this.isInput();\r\n        \r\n        return `${EAddrType[type]} [${isPointer ? '%' : isInput ? '' : 'r'}${addr / 4} ${isInput ? `input(${inputIndex})` : ``}, ${size} bytes, [${(swizzle || []).join(', ')}]]`;\r\n    }\r\n\r\n    // non-pointer address type => pointer\r\n    static castToPointer(type: EAddrType): EAddrType {\r\n        assert(type < EAddrType.k_PointerRegisters);\r\n        return (type + EAddrType.k_PointerRegisters);\r\n    }\r\n\r\n\r\n    static INVALID = new PromisedAddress({ type: EAddrType.k_Registers, addr: REG_INVALID, size: 0 });\r\n}\r\n\r\nexport default PromisedAddress;\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { variable, types } from \"@lib/fx/analisys/helpers\";\r\nimport { EAddrType } from \"@lib/idl/bytecode\";\r\nimport { IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\n\r\nimport { SRV_TOTAL, SRV0_REGISTER } from \"./Bytecode\";\r\nimport PromisedAddress from \"./PromisedAddress\";\r\n\r\nexport class SRVPool {\r\n    private _knownSRVs: IVariableDeclInstruction[];\r\n\r\n    constructor() {\r\n        this._knownSRVs = Array(SRV_TOTAL).fill(null);\r\n    }\r\n\r\n    deref(decl: IVariableDeclInstruction): PromisedAddress {\r\n        const knownSRVs = this._knownSRVs;\r\n\r\n        assert(!decl.type.isNotBaseArray());\r\n        assert(SystemScope.isBuffer(decl.type) || SystemScope.isTexture(decl.type));\r\n\r\n        let { index, type } = SystemScope.resolveRegister(decl);\r\n        assert(type === 't');\r\n\r\n        const knownIndex = knownSRVs.indexOf(decl);\r\n        assert(knownIndex === -1 || knownIndex === index);\r\n\r\n        if (index === -1) {\r\n            index = knownSRVs.findIndex(decl => isNull(decl));\r\n            assert(index !== -1, `uav limit is reached (uav total: ${SRV_TOTAL})`);\r\n            knownSRVs[index] = decl;\r\n        }\r\n\r\n        knownSRVs[index] = decl;\r\n\r\n        assert(index !== -1);\r\n        assert(index < SRV_TOTAL);\r\n\r\n        const inputIndex = SRV0_REGISTER + index;\r\n        const addr = 0;\r\n        // NOTE: UAV's size is unknown in advance\r\n        // so we use maximum aligned int as possible\r\n        return new PromisedAddress({ type: EAddrType.k_Input, addr, size: 1 << 30, inputIndex });\r\n    }\r\n}","/**\r\n * A simplified symbol table containing the correspondence of unique \r\n * hashes of symbols and their addresses in registers.\r\n * The table is global and does not depend on the stack of functions, \r\n * because hashes are built on the basis of identifiers of instructions \r\n * unique to each function and context.\r\n */\r\nclass SymbolTable<SYMBOL_T>  {\r\n    [key: string]: SYMBOL_T;\r\n\r\n    *[Symbol.iterator]() {\r\n        for (let i in this) {\r\n            yield this[i];\r\n        }\r\n    }\r\n}\r\n\r\nexport default SymbolTable;\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { variable, types } from \"@lib/fx/analisys/helpers\";\r\nimport { EAddrType } from \"@lib/idl/bytecode\";\r\nimport { IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { UAV_TOTAL, UAV0_REGISTER } from \"./Bytecode\";\r\nimport PromisedAddress from \"./PromisedAddress\";\r\n\r\nexport class UAVPool {\r\n    private _knownUAVs: IVariableDeclInstruction[];\r\n\r\n    constructor() {\r\n        this._knownUAVs = Array(UAV_TOTAL).fill(null);\r\n    }\r\n\r\n    deref(decl: IVariableDeclInstruction): PromisedAddress {\r\n        const knownUAVs = this._knownUAVs;\r\n\r\n        assert(!decl.type.isNotBaseArray());\r\n        assert(SystemScope.isUAV(decl.type));\r\n\r\n        let { index, type } = SystemScope.resolveRegister(decl);\r\n        assert(type === 'u');\r\n\r\n        const knownIndex = knownUAVs.indexOf(decl);\r\n        assert(knownIndex === -1 || knownIndex === index);\r\n\r\n        if (index === -1) {\r\n            index = knownUAVs.findIndex(decl => isNull(decl));\r\n            assert(index !== -1, `uav limit is reached (uav total: ${UAV_TOTAL})`);\r\n            knownUAVs[index] = decl;\r\n        }\r\n\r\n        knownUAVs[index] = decl;\r\n\r\n        assert(index !== -1);\r\n        assert(index < UAV_TOTAL);\r\n\r\n        const inputIndex = UAV0_REGISTER + index;\r\n        const addr = 0;\r\n        // NOTE: UAV's size is unknown in advance\r\n        // so we use maximum aligned int as possible\r\n        return new PromisedAddress({ type: EAddrType.k_Input, addr, size: 1 << 30, inputIndex });\r\n    }\r\n}","///////////////////////////////////\r\n///////////////////////////////////\r\n///////////////////////////////////\r\n\r\nfunction transferU8ToHeap(module: EmscriptenModule, u8Array: Uint8Array): WASMMemory {\r\n    const heap = module._malloc(u8Array.length * u8Array.BYTES_PER_ELEMENT);\r\n    const size = u8Array.length >> 2;\r\n    module.HEAPU8.set(u8Array, heap);\r\n    return { heap, size };\r\n}\r\n\r\n\r\nfunction freeHeap(module: EmscriptenModule, { heap }: WASMMemory) {\r\n    module._free(heap);\r\n}\r\n\r\n///////////////////////////////////\r\n///////////////////////////////////\r\n///////////////////////////////////\r\n\r\nimport loadBundleWASM from './module.cpp';\r\nimport * as Bytecode from '@lib/idl/bytecode';\r\n\r\ntype IBundle = Bytecode.IBundle;\r\n\r\nconst BundleModule = await loadBundleWASM();\r\nconst WASMBundle = BundleModule?.Bundle;\r\n\r\nexport function make(name: string, code: Uint8Array): IBundle {\r\n    let bundleWasm: IBundle = null;\r\n    let mem = transferU8ToHeap(BundleModule, code);\r\n    try {\r\n        bundleWasm = new BundleModule.Bundle(name, mem);\r\n    } catch(e) {\r\n        // console.error(e);\r\n    } finally {\r\n        BundleModule._free(mem.heap);\r\n    }\r\n\r\n    return bundleWasm;\r\n}\r\n\r\n\r\ninterface WASMMemory extends Bytecode.IMemory {\r\n    heap: number; // in bytes \r\n    size: number; // in uint32 (byteSize = 4 x size)\r\n}\r\n\r\n\r\nexport function memoryToU8Array(input: Bytecode.IMemory) {\r\n    const { heap, size } = input as WASMMemory;\r\n    return BundleModule.HEAPU8.subarray(heap, (heap + (size << 2)));\r\n}\r\n\r\n\r\nexport function memoryToI32Array(input: Bytecode.IMemory): Int32Array {\r\n    const { heap, size } = <WASMMemory>input;\r\n    console.assert(heap % 4 == 0, \"unsupported heap address!\");\r\n    return BundleModule.HEAP32.subarray(heap >> 2, ((heap >> 2) + size));\r\n}\r\n\r\n\r\nexport function memoryToF32Array(input: Bytecode.IMemory): Float32Array {\r\n    const { heap, size } = <WASMMemory>input;\r\n    console.assert(heap % 4 == 0, \"unsupported heap address!\");\r\n    return BundleModule.HEAPF32.subarray(heap >> 2, ((heap >> 2) + size));\r\n}\r\n\r\n\r\nexport function createUAV(name: string, elementSize: number, length: number, register: number) {\r\n    return WASMBundle.createUAV(name, elementSize, length, register);\r\n}\r\n\r\n\r\nexport function destroyUAV(uav: Bytecode.IUAV) {\r\n    WASMBundle.destroyUAV(uav);\r\n}\r\n\r\n\r\nexport function copyViewToMemory(input: ArrayBufferView): Bytecode.IMemory {\r\n    return transferU8ToHeap(BundleModule, new Uint8Array(input.buffer, input.byteOffset, input.byteLength));\r\n}\r\n\r\n\r\nexport function releaseMemory(mem: Bytecode.IMemory) {\r\n    freeHeap(BundleModule, <WASMMemory>mem);\r\n}\r\n\r\n\r\n// cleanup shared registers memory\r\nexport function debugResetRegisters() {\r\n    // unsupported\r\n}\r\n","import { isDef, isNull, isString } from \"@lib/common\";\r\nimport * as Bytecode from '@lib/fx/bytecode';\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { asNativeViaCDL } from \"./native\";\r\n\r\nimport * as WASMBundle from \"./cpp/bridge\";\r\nimport * as TSBundle from \"./ts/bridge\";\r\nimport { IBundle, IMemory, IUAV } from \"@lib/idl/bytecode\";\r\n\r\nexport { asNative, asNativeRaw, asNativeViaAST, asNativeViaCDL } from './native';\r\n\r\n/////////////////////////////////////////////////////////////////////\r\n/// Common API\r\n/////////////////////////////////////////////////////////////////////\r\n\r\n/// <reference path=\"./webpack.d.ts\" />\r\n\r\n// check shell.js for more details\r\n// electron hack to support option --disable-wasm\r\nconst forceNoWasm = () => (new URLSearchParams(window.location.search)).get('disable-wasm') === 'true';\r\n\r\nlet useWASM = WASM && !forceNoWasm();\r\n\r\nfunction VMBundle() {\r\n    return (useWASM ? WASMBundle : TSBundle);\r\n}\r\n\r\n\r\nexport function isWASM() {\r\n    return useWASM;\r\n}\r\n\r\n\r\nexport function switchRuntime(runtime?: 'wasm' | 'js') {\r\n    useWASM = isDef(runtime) ? runtime === 'wasm' : !useWASM;\r\n    console.log(`%c VM runtime has been switched to \"${(useWASM ? \"WASM\" : \"JS\")}\".`, 'font-weight: bold; background: #6f0000; color: #fff');\r\n}\r\n\r\n\r\nexport function make(debugName: string, code: number[] | Uint8Array): IBundle {\r\n    return VMBundle().make(debugName, new Uint8Array(code));\r\n}\r\n\r\n/**\r\n * Interpret memory as typed array.\r\n * NOTE: no copying occurs (!)\r\n * @returns Same data interpreted as typed array. \r\n */\r\nexport function memoryToU8Array(input: IMemory): Uint8Array {\r\n    return VMBundle().memoryToU8Array(input);\r\n}\r\n\r\n/**\r\n * Interpret memory as typed array.\r\n * NOTE: no copying occurs (!)\r\n * @returns Same data interpreted as typed array. \r\n */\r\nexport function memoryToI32Array(input: IMemory): Int32Array {\r\n    return VMBundle().memoryToI32Array(input);\r\n}\r\n\r\n/**\r\n * Interpret memory as typed array.\r\n * NOTE: no copying occurs (!)\r\n * @returns Same data interpreted as typed array. \r\n */\r\nexport function memoryToF32Array(input: IMemory): Float32Array {\r\n    return VMBundle().memoryToF32Array(input);\r\n}\r\n\r\n/**\r\n * NOTE: copy view to NEW memory (!)\r\n * @returns New array containing input data.\r\n */\r\nexport function copyViewToMemory(input: ArrayBufferView): IMemory {\r\n    return VMBundle().copyViewToMemory(input);\r\n}\r\n\r\n\r\nexport function releaseMemory(mem: IMemory) {\r\n    VMBundle().releaseMemory(mem);\r\n}\r\n\r\n\r\nexport function createUAV(name: string, elementSize: number, length: number, register: number) {\r\n    return VMBundle().createUAV(name, elementSize, length, register);\r\n}\r\n\r\n\r\nexport function destroyUAV(uav: IUAV) {\r\n    VMBundle().destroyUAV(uav);\r\n}\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////\r\n\r\nfunction debugResetRegisters() {\r\n    VMBundle().debugResetRegisters();\r\n}\r\n\r\ndeclare const MODE: string;\r\n\r\n// TODO: use bundle inside\r\n/** @deprecated */\r\nexport async function evaluate(code: Uint8Array): Promise<any>;\r\n/** @deprecated */\r\nexport async function evaluate(expr: string, document: ISLDocument): Promise<any>;\r\n/** @deprecated */\r\nexport async function evaluate(param: string | Uint8Array, param2?: ISLDocument): Promise<any> {\r\n    if (MODE === 'development') {\r\n        debugResetRegisters();\r\n    }\r\n\r\n    let code: Uint8Array;\r\n    if (isString(arguments[0])) {\r\n        const expr = <string>arguments[0];\r\n        const slDocument = <ISLDocument>arguments[1];\r\n        const { program } = await Bytecode.translateExpression(expr, slDocument);\r\n        if (isNull(program)) {\r\n            return null;\r\n        }\r\n        const { code, cdl } = program;\r\n        const bundle = make(\"[evaluate]\", code);\r\n        return asNativeViaCDL(bundle.play(), cdl);\r\n    } else {\r\n        code = arguments[0];\r\n    }\r\n\r\n    const bundle = make(\"[evaluate]\", code);\r\n    return bundle.play();\r\n}\r\n\r\n\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { f32Asi32, i32ToU8Array, u8ArrayAsF32, u8ArrayAsI32 } from \"@lib/fx/bytecode/common\";\r\nimport { CDL } from \"@lib/fx/bytecode/DebugLayout\";\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\nimport * as Bundle from \"@lib/idl/bytecode\";\r\nimport { EInstructionTypes, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IBCDocument } from \"@lib/fx/bytecode/Bytecode\";\r\n\r\nimport { TypeLayoutT } from \"@lib/idl/bundles/auto/type-layout\";\r\nimport { TypeFieldT } from \"@lib/idl/bundles/auto/type-field\";\r\n\r\nfunction asNativeVector<T>(elementDecoder: (u8: Uint8Array) => T, value: Uint8Array, length: number, stride = 4): T[] {\r\n    const vector = [];\r\n    for (let i = 0; i < length; ++i) {\r\n        vector.push(elementDecoder(value.subarray(stride * i, stride * i + stride)));\r\n    }\r\n    return vector;\r\n}\r\n\r\nfunction fromNativeVector<T extends Array<any>>(elementDecoder: (val: T[0]) => Uint8Array, arr: T): Uint8Array {\r\n    let byteLength = arr.reduce((s, val) => s + elementDecoder(val).byteLength, 0);\r\n    let u8Array = new Uint8Array(byteLength);\r\n    let offset = 0;\r\n    for (let val of arr) {\r\n        let u8 = elementDecoder(val);\r\n        u8Array.set(u8, offset);\r\n        offset += u8.byteLength;\r\n    }\r\n    return u8Array;\r\n}\r\n\r\nconst asInt = u8ArrayAsI32;\r\nconst asUint = u8a => (asInt(u8a) >>> 0);\r\nconst asFloat = u8ArrayAsF32;\r\nconst asBool = u8a => asInt(u8a) !== 0;\r\n\r\nconst fromInt = i32 => new Uint8Array(i32ToU8Array(i32));\r\nconst fromUint = u32 => new Uint8Array(i32ToU8Array(u32));\r\nconst fromFloat = f32 => new Uint8Array(i32ToU8Array(f32Asi32(f32)));\r\nconst fromBool = b32 => new Uint8Array(i32ToU8Array(+(b32)));\r\n\r\nfunction typeLayoutArrayToBaseType({ fields, length, name, size }: TypeLayoutT): TypeLayoutT\r\n{\r\n    return new TypeLayoutT(fields, undefined, name, size);\r\n}\r\n\r\nexport function typeAstToTypeLayout(type: ITypeInstruction): TypeLayoutT\r\n{\r\n    const isNotComplexOrSystem = (type: ITypeInstruction) => !type.isComplex() ||\r\n        type.instructionType == EInstructionTypes.k_SystemType;\r\n\r\n    let name = type.name;\r\n    let size = type.size;\r\n    let fields: TypeFieldT[] = undefined;\r\n    let length = -1;\r\n\r\n    if (type.isNotBaseArray())\r\n    {\r\n        length = type.length;\r\n        \r\n        const elementType = typeAstToTypeLayout(type.arrayElementType);\r\n        fields = elementType.fields;\r\n    }\r\n    else if (!isNotComplexOrSystem(type))\r\n    {\r\n        fields = type.fields.map(({ name, type, semantic }) => new TypeFieldT( typeAstToTypeLayout(type), name, semantic, type.size, type.padding ));\r\n    }\r\n\r\n    return new TypeLayoutT( fields, length, <string>name, size );\r\n}\r\n\r\nexport function fromNativeRaw<T>(data: T, layout: TypeLayoutT): Uint8Array {\r\n    switch (layout.name) {\r\n        case 'bool':\r\n            return fromBool(data);\r\n        case 'int':\r\n            return fromInt(data);\r\n        case 'float':\r\n            return fromFloat(data);\r\n        case 'uint':\r\n            return fromUint(data);\r\n        case 'uint2':\r\n        case 'uint3':\r\n        case 'uint4':\r\n            return fromNativeVector(fromUint, data as any);\r\n        case 'int2':\r\n        case 'int3':\r\n        case 'int4':\r\n            return fromNativeVector(fromInt, data as any);\r\n        case 'float2':\r\n        case 'float3':\r\n        case 'float4':\r\n            return fromNativeVector(fromFloat, data as any);\r\n    }\r\n\r\n    // parse as array\r\n    if (layout.length && layout.length >= 0) {\r\n        const elementType = typeLayoutArrayToBaseType(layout);\r\n        return fromNativeVector(val => fromNativeRaw(val, elementType), data as any);\r\n    }\r\n\r\n    // parse as structure\r\n    if (layout.fields) {\r\n        let byteLength = layout.fields.reduce((s, field) => {\r\n            const { padding, size, type, name } = field;\r\n            return Math.max(s, padding + size);\r\n        }, 0);\r\n        \r\n        let complex = new Uint8Array(byteLength);\r\n        layout.fields.forEach(field => {\r\n            const { padding, size, type, name } = field;\r\n            const u8 = fromNativeRaw(data[<string>name], type);\r\n            complex.set(u8, padding);\r\n        });\r\n        return complex;\r\n    }\r\n\r\n    assert(false, `not implemented`, layout);\r\n    return null;\r\n}\r\n\r\nexport function asNative(result: Bundle.IMemory, layout: TypeLayoutT)\r\n{\r\n    return asNativeRaw(VM.memoryToU8Array(result), layout);\r\n}\r\n\r\nexport function asNativeRaw(result: Uint8Array, layout: TypeLayoutT): any {\r\n    switch (layout.name) {\r\n        case 'bool':\r\n            return asBool(result);\r\n        case 'int':\r\n            return asInt(result);\r\n        case 'float':\r\n            return asFloat(result);\r\n        case 'uint':\r\n            return asUint(result);\r\n        case 'uint2':\r\n        case 'uint3':\r\n        case 'uint4':\r\n            return asNativeVector(asUint, result, layout.size / 4, 4);\r\n        case 'int2':\r\n        case 'int3':\r\n        case 'int4':\r\n            return asNativeVector(asInt, result, layout.size / 4, 4);\r\n        case 'float2':\r\n        case 'float3':\r\n        case 'float4':\r\n            return asNativeVector(asFloat, result, layout.size / 4, 4);\r\n    }\r\n\r\n    // parse as array\r\n    if (layout.length && layout.length >= 0) {\r\n        const elementType = typeLayoutArrayToBaseType(layout);\r\n        return asNativeVector(u8a => asNativeRaw(u8a, elementType), result, layout.length, elementType.size);\r\n    }\r\n\r\n    // parse as structure\r\n    if (layout.fields) {\r\n        let complex = {};\r\n        layout.fields.forEach(field => {\r\n            const { padding, size, type } = field;\r\n            complex[<string>field.name] = asNativeRaw(result.subarray(padding, padding + size), type);\r\n        });\r\n        return complex;\r\n    }\r\n\r\n    assert(false, `not implemented`, layout);\r\n    return null;\r\n}\r\n\r\nexport function asNativeViaAST(result: Uint8Array, type: ITypeInstruction): any {\r\n    return asNativeRaw(result, typeAstToTypeLayout(type));\r\n}\r\n\r\nexport function asNativeViaCDL(result: Uint8Array, cdl: CDL): any {\r\n    return asNativeRaw(result, typeAstToTypeLayout(cdl.info.layout));\r\n}\r\n\r\nexport function asNativeFunction(bcDocument: IBCDocument): Function\r\n{\r\n    const { code, cdl } = bcDocument.program;\r\n    const bundle = VM.make(`[as-native-function]`, code);\r\n    return (...args: any[]) => {\r\n        assert(!args || args.length === 0, 'arguments not supported');\r\n        return asNativeViaCDL(bundle.play(), cdl);\r\n    };\r\n}","import * as Bytecode from '@lib/idl/bytecode';\r\nimport { asBundleMemory, fromBundleMemory, TSBundle } from '@lib/fx/bytecode/VM/ts/bundle';\r\n\r\nexport function make(name: string, code: Uint8Array): Bytecode.IBundle {\r\n    return new TSBundle(name, code);\r\n}\r\n\r\n\r\nexport function memoryToU8Array(input: Bytecode.IMemory): Uint8Array {\r\n    const buffer = fromBundleMemory(input);\r\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n}\r\n\r\n\r\nexport function memoryToF32Array(input: Bytecode.IMemory): Float32Array {\r\n    const buffer = fromBundleMemory(input);\r\n    return new Float32Array(buffer.buffer, buffer.byteOffset, buffer.length);\r\n}\r\n\r\n\r\nexport function memoryToI32Array(input: Bytecode.IMemory): Int32Array {\r\n    return fromBundleMemory(input);\r\n}\r\n\r\n\r\nfunction copy(src: ArrayBufferView): ArrayBufferView {\r\n    const dst = new Uint8Array(src.byteLength);\r\n    dst.set(new Uint8Array(src.buffer, src.byteOffset, src.byteLength));\r\n    return dst;\r\n}\r\n\r\n\r\nexport function copyViewToMemory(input: ArrayBufferView): Bytecode.IMemory {\r\n    return asBundleMemory(copy(input));\r\n}\r\n\r\n\r\nexport function releaseMemory(mem: Bytecode.IMemory) {\r\n    // noting todo, memory is just usual typed view\r\n}\r\n\r\n\r\nexport function createUAV(name: string, elementSize: number, length: number, register: number) {\r\n    return TSBundle.createUAV(name, elementSize, length, register);\r\n}\r\n\r\n\r\nexport function destroyUAV(uav: Bytecode.IUAV) {\r\n    // nothing todo\r\n}\r\n\r\n// cleanup shared registers memory\r\nexport function debugResetRegisters() {\r\n    TSBundle.resetRegisters();\r\n}\r\n\r\n\r\n","import { assert, isDef, isDefAndNotNull } from \"@lib/common\";\r\nimport * as Bytecode from '@lib/fx/bytecode/Bytecode';\r\nimport { CBUFFER0_REGISTER, CBUFFER_TOTAL, SRV0_REGISTER, SRV_TOTAL, UAV0_REGISTER, UAV_TOTAL } from \"@lib/fx/bytecode/Bytecode\";\r\nimport { u8ArrayToI32 } from \"@lib/fx/bytecode/common\";\r\nimport InstructionList from \"@lib/fx/bytecode/InstructionList\";\r\nimport sizeof from \"@lib/fx/bytecode/sizeof\";\r\nimport { asNativeRaw, fromNativeRaw } from \"@lib/fx/bytecode/VM/native\";\r\nimport * as Bundle from \"@lib/idl/bytecode\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { TypeLayoutT } from \"@lib/idl/bundles/auto/type-layout\";\r\nimport { TypeFieldT } from \"@lib/idl/bundles/auto/type-field\";\r\n\r\n\r\nlet { EChunkType, EOperation } = Bundle;\r\n\r\ninterface TSBundleMemory extends Bundle.IMemory\r\n{\r\n    buffer: Int32Array;\r\n}\r\n\r\nexport function asBundleMemory(data: ArrayBufferView): TSBundleMemory\r\n{\r\n    const buffer = data instanceof Int32Array \r\n        ? data \r\n        : new Int32Array(data.buffer, data.byteOffset, data.byteLength >> 2);\r\n    return { buffer };\r\n}\r\n\r\nexport function fromBundleMemory(mem: Bundle.IMemory)\r\n{\r\n    return (<TSBundleMemory>mem).buffer;\r\n}\r\n\r\n\r\nfunction slotToShaderLikeRegister(slot: number) {\r\n    if (slot >= CBUFFER0_REGISTER && slot - CBUFFER0_REGISTER < CBUFFER_TOTAL) \r\n        return `b${slot - CBUFFER0_REGISTER}`;\r\n    if (slot >= SRV0_REGISTER && slot - SRV0_REGISTER < SRV_TOTAL) \r\n        return `t${slot - SRV0_REGISTER}`;\r\n    if (slot >= UAV0_REGISTER && slot - UAV0_REGISTER < UAV_TOTAL) \r\n        return `u${slot - UAV0_REGISTER}`;\r\n    return `[ invalid slot | ${slot} ]`;\r\n}\r\n\r\n\r\nfunction exposeInvalidInputError(iinput: Int32Array[], slot: number) {\r\n    const reg = slotToShaderLikeRegister(slot);\r\n    if (isDefAndNotNull(iinput[slot])) return `resource usage out of range, register: ${reg}`;\r\n    return `missing resource is found, register: ${reg}`;\r\n}\r\n\r\n\r\nexport class TSBundle implements Bundle.IBundle\r\n{\r\n    private instructions: Uint32Array;\r\n    private inputs: Int32Array[];\r\n    private layout: Bundle.IConstant[];\r\n    private depthStencilStates: Bundle.IDepthStencilState[];\r\n    private shaders: Bundle.IShader[];\r\n    private externs: Bundle.IExtern[];\r\n    private ncalls: Function[];         // native calls\r\n\r\n    private static $regs = new ArrayBuffer(512 * 16);\r\n    private static iregs = new Int32Array(TSBundle.$regs);\r\n    private static fregs = new Float32Array(TSBundle.$regs);\r\n    private static regs = new Uint8Array(TSBundle.$regs);\r\n\r\n    private static Gid = new Int32Array([0, 0, 0]);     // uint3 Gid: SV_GroupID    \r\n    private static Gi = new Int32Array([0]);            // uint GI: SV_GroupIndex\r\n    private static GTid = new Int32Array([0, 0, 0]);    // uint3 GTid: SV_GroupThreadID\r\n    private static DTid = new Int32Array([0, 0, 0]);    // uint3 DTid: SV_DispatchThreadID\r\n\r\n    constructor(public debugName: string, data: Uint8Array)\r\n    {\r\n        this.load(data);\r\n    }\r\n\r\n    private load(code: Uint8Array) {\r\n        const chunks = decodeChunks(code);\r\n    \r\n        const codeChunk = chunks[EChunkType.k_Code];\r\n        assert(isDefAndNotNull(codeChunk) && isDefAndNotNull(chunks[EChunkType.k_Constants]));\r\n\r\n        const constants = decodeConstChunk(chunks[EChunkType.k_Constants]);\r\n        this.instructions = decodeCodeChunk(codeChunk);\r\n        this.layout = decodeLayoutChunk(chunks[EChunkType.k_Layout]);\r\n        this.depthStencilStates = decodeDepthStencilStates(chunks[EChunkType.k_DepthStencilStates]);\r\n        this.shaders = decodeShadersChunk(chunks[EChunkType.k_Shaders]);\r\n        this.externs = decodeExternsChunk(chunks[EChunkType.k_Externs]);\r\n        this.inputs = Array<Int32Array>(64).fill(null);\r\n        this.inputs[CBUFFER0_REGISTER] = new Int32Array(constants.buffer, constants.byteOffset, constants.length >> 2);\r\n\r\n        const undefFn = (extern: Bundle.IExtern) => (a, b, c, d, e, f) => { \r\n            console.error(`[native call <${extern.name}> was not provided]`, [a, b, c, d, e, f].filter(x => isDef(x))); \r\n        };\r\n\r\n        const traceFn = (a, b, c, d, e, f, g, h, i, j, k) => { \r\n            console.log(...[a, b, c, d, e, f, g, h, i, j, k].filter(x => isDef(x))); \r\n        };\r\n\r\n        this.ncalls = Array<Function>(this.externs.length).fill(null).map(\r\n            (fn, id) => (this.externs[id].name === 'trace' ? traceFn : undefFn(this.externs[id]))\r\n        );\r\n    }\r\n\r\n    private asNative(u8: Uint8Array, layout: TypeLayoutT): any {\r\n        switch (layout.name) {\r\n            // IP: experimental way to resolve string (useful for debug purposes like trace())\r\n            case 'string': {\r\n                let byteOffset = u8ArrayToI32(u8);\r\n                let i32a = this.inputs[CBUFFER0_REGISTER];\r\n                let len = i32a[byteOffset >> 2];\r\n                let u8a = new Uint8Array(i32a.buffer, i32a.byteOffset + byteOffset + 4, len);\r\n                return String.fromCharCode(...u8a);\r\n            }\r\n            case 'DepthStencilState': {\r\n                let id = u8ArrayToI32(u8);\r\n                return this.depthStencilStates[id];\r\n            }\r\n            case 'VertexShader':\r\n            case 'PixelShader': \r\n            case 'GeometryShader': {\r\n                let id = u8ArrayToI32(u8);\r\n                if (id == 0) // NULL was passed as shader\r\n                    return null;\r\n                return this.shaders[id - 1];\r\n            }\r\n        }\r\n        return asNativeRaw(u8, layout);\r\n    }\r\n    \r\n\r\n    play(): Uint8Array {\r\n        const ilist = this.instructions;\r\n        const iregs = TSBundle.iregs;\r\n        const fregs = TSBundle.fregs;\r\n        const regs = TSBundle.regs;\r\n        const iinput = this.inputs;\r\n\r\n        let i5 = 0;                      // current instruction;\r\n        end:\r\n        while (1) {\r\n            let op = ilist[i5];\r\n            let a = ilist[i5 + 1];\r\n            let b = ilist[i5 + 2];\r\n            let c = ilist[i5 + 3];\r\n            let d = ilist[i5 + 4];\r\n            \r\n            switch (op) {\r\n                // registers\r\n                case EOperation.k_I32SetConst:\r\n                    // assert(iregs.length > a, `[iregs.length > a] where iregs.length = ${iregs.length}, a = ${a}`);\r\n                    iregs[a] = b;\r\n                    break;\r\n                case EOperation.k_I32LoadRegister:\r\n                    // assert(iregs.length > b, `[iregs.length > b] where iregs.length = ${iregs.length}, b = ${b}`);\r\n                    // assert(iregs.length > a, `[iregs.length > a] where iregs.length = ${iregs.length}, a = ${a}`);\r\n                    iregs[a] = iregs[b];\r\n                    break;\r\n                // inputs\r\n                case EOperation.k_I32LoadInput:\r\n                    // assert(iinput[a], exposeInvalidInputError(iinput, a));\r\n                    // assert(iinput[a].length > c);\r\n                    // assert(iregs.length > b);\r\n                    iregs[b] = iinput[a][c];\r\n                    break;\r\n                case EOperation.k_I32StoreInput:\r\n                    // assert(iinput[a], exposeInvalidInputError(iinput, a));    \r\n                    // assert(iinput[a].length > b);\r\n                    // assert(iregs.length > c);\r\n                    iinput[a][b] = iregs[c];\r\n                    break;\r\n                // registers pointers    \r\n                // a => dest\r\n                // b => source pointer\r\n                // c => offset\r\n                case EOperation.k_I32LoadRegistersPointer:\r\n                    // assert(iregs.length > (iregs[b] + c), `[iregs.length > (iregs[b] + c)] where iregs.length = ${iregs.length}, iregs[b] = ${iregs[b]}, b = ${b}, c = ${c}`);\r\n                    // assert(iregs.length > a);\r\n                    iregs[a] = iregs[iregs[b] + c];\r\n                    break;\r\n                case EOperation.k_I32StoreRegisterPointer:\r\n                    // assert(iregs.length > (iregs[a] + c));\r\n                    // assert(iregs.length > b);\r\n                    iregs[iregs[a] + c] = iregs[b];\r\n                    break;\r\n                // input pointers\r\n                // a => input index\r\n                // b => dest\r\n                // c => source pointer\r\n                // d => offset\r\n                case EOperation.k_I32LoadInputPointer:\r\n                    // assert(iinput[a], exposeInvalidInputError(iinput, a));  \r\n                    // assert(iinput[a].length > (iregs[c] + d));\r\n                    // assert(iregs.length > b);\r\n                    iregs[b] = iinput[a][iregs[c] + d];\r\n                    break;\r\n                case EOperation.k_I32StoreInputPointer:\r\n                    // assert(iinput[a], exposeInvalidInputError(iinput, a));  \r\n                    // assert(iinput[a].length > (iregs[b] + d));\r\n                    // assert(iregs.length > c);\r\n                    iinput[a][iregs[b] + d] = iregs[c];\r\n                    break;\r\n                \r\n                case EOperation.k_I32TextureLoad:\r\n                    // a - destination  (always float4)\r\n                    // b - texture      (input index)\r\n                    // c - arguments    (int3 uv)\r\n                    {\r\n                        const layout = iinput[b];\r\n                        const u = iregs[c];\r\n                        const v = iregs[c + 1];\r\n                        const w = layout[0];\r\n                        const h = layout[1];\r\n                        // assert(u >= 0 && u < w, `u(${u}) is out of borders [0, ${w})`);\r\n                        // assert(v >= 0 && v < h, `u(${v}) is out of borders [0, ${h})`);\r\n                        // const fmt = layout[2];\r\n                        const texel = layout.subarray(/*desc(64) >> 2*/16)[w * v + u] >>> 0; // todo: use unsigned inputs\r\n                        const iR = (texel) & 0xFF;\r\n                        const iG = (texel >> 8) & 0xFF;\r\n                        const iB = (texel >> 16) & 0xFF;\r\n                        const iA = (texel >> 24) & 0xFF;\r\n                        fregs.set([ iR / 255.0, iG / 255.0, iB / 255.0, iA / 255.0 ], a);\r\n                    }\r\n                    break;\r\n                \r\n                case EOperation.k_I32ExternCall:\r\n                    {\r\n                        const id = a;\r\n                        const { params, ret } = this.externs[id];\r\n                        const retOffset = (b << 2);\r\n                        // todo: support out arguments\r\n                        let paramOffset = retOffset + ret.size;\r\n                        let args = new Array(params.length);\r\n                        for (let i = 0; i < params.length; ++ i) {\r\n                            let p = params[i];\r\n                            let u8 = regs.subarray(paramOffset, paramOffset + p.size);\r\n                            args[i] = this.asNative(u8, p);\r\n                            paramOffset += p.size;\r\n                            assert(p.size % 4 === 0);\r\n                        }\r\n                        const res = this.ncalls[a].apply(null, args);\r\n                        if (ret.size) {\r\n                            regs.set(fromNativeRaw(res, ret), retOffset);\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                //\r\n                // Arithmetic operations\r\n                //\r\n\r\n                case EOperation.k_I32Add:\r\n                    iregs[a] = iregs[b] + iregs[c];\r\n                    break;\r\n                case EOperation.k_I32Sub:\r\n                    iregs[a] = iregs[b] - iregs[c];\r\n                    break;\r\n                case EOperation.k_I32Mul:\r\n                    iregs[a] = iregs[b] * iregs[c];\r\n                    break;\r\n                case EOperation.k_I32Div:\r\n                    iregs[a] = iregs[b] / iregs[c];\r\n                    break;\r\n                case EOperation.k_I32Mod:\r\n                    iregs[a] = iregs[b] % iregs[c];\r\n                    break;\r\n\r\n                case EOperation.k_I32Mad:\r\n                    iregs[a] = iregs[b] + iregs[c] * iregs[d];\r\n                    break;\r\n                \r\n                case EOperation.k_I32Min:\r\n                    iregs[a] = Math.min(iregs[b], iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32Max:\r\n                    iregs[a] = Math.max(iregs[b], iregs[c]);\r\n                    break;\r\n\r\n                case EOperation.k_F32Add:\r\n                    fregs[a] = fregs[b] + fregs[c];\r\n                    break;\r\n                case EOperation.k_F32Sub:\r\n                    fregs[a] = fregs[b] - fregs[c];\r\n                    break;\r\n                case EOperation.k_F32Mul:\r\n                    fregs[a] = fregs[b] * fregs[c];\r\n                    break;\r\n                case EOperation.k_F32Div:\r\n                    fregs[a] = fregs[b] / fregs[c];\r\n                    break;\r\n                case EOperation.k_F32Mod:\r\n                    fregs[a] = fregs[b] % fregs[c];\r\n                    break;\r\n\r\n\r\n                //\r\n                // Relational operations\r\n                //\r\n\r\n                case EOperation.k_U32LessThan:\r\n                    iregs[a] = +((iregs[b] >>> 0) < (iregs[c] >>> 0));\r\n                    break;\r\n                case EOperation.k_U32GreaterThanEqual:\r\n                    iregs[a] = +((iregs[b] >>> 0) >= (iregs[c] >>> 0));\r\n                    break;\r\n                case EOperation.k_I32LessThan:\r\n                    iregs[a] = +(iregs[b] < iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32GreaterThanEqual:\r\n                    iregs[a] = +(iregs[b] >= iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32Equal:\r\n                    iregs[a] = +(iregs[b] === iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32NotEqual:\r\n                    iregs[a] = +(iregs[b] !== iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32Not:\r\n                    iregs[a] = +(!iregs[b]);\r\n                    break;\r\n\r\n                case EOperation.k_F32LessThan:\r\n                    fregs[a] = +(fregs[b] < fregs[c]);\r\n                    break;\r\n                case EOperation.k_F32GreaterThanEqual:\r\n                    fregs[a] = +(fregs[b] >= fregs[c]);\r\n                    break;\r\n\r\n                //\r\n                // Logical operations\r\n                //\r\n\r\n\r\n                case EOperation.k_I32LogicalOr:\r\n                    iregs[a] = +(iregs[b] || iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32LogicalAnd:\r\n                    iregs[a] = +(iregs[b] && iregs[c]);\r\n                    break;\r\n\r\n                //\r\n                // intrinsics\r\n                //\r\n\r\n                case EOperation.k_F32Frac:\r\n                    // same as frac() in HLSL\r\n                    fregs[a] = fregs[b] - Math.floor(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Floor:\r\n                    fregs[a] = Math.floor(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Ceil:\r\n                    fregs[a] = Math.ceil(fregs[b]);\r\n                    break;\r\n\r\n                case EOperation.k_F32Sin:\r\n                    fregs[a] = Math.sin(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Cos:\r\n                    fregs[a] = Math.cos(fregs[b]);\r\n                    break;\r\n\r\n                case EOperation.k_F32Abs:\r\n                    fregs[a] = Math.abs(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Sqrt:\r\n                    fregs[a] = Math.sqrt(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Max:\r\n                    fregs[a] = Math.max(fregs[b], fregs[c]);\r\n                    break;\r\n                case EOperation.k_F32Min:\r\n                    fregs[a] = Math.min(fregs[b], fregs[c]);\r\n                    break;\r\n                case EOperation.k_F32Pow:\r\n                    fregs[a] = Math.pow(fregs[b], fregs[c]);\r\n                    break;\r\n\r\n                //\r\n                // Cast\r\n                //\r\n\r\n\r\n                case EOperation.k_U32ToF32:\r\n                    fregs[a] = iregs[b] >>> 0;\r\n                    break;\r\n                case EOperation.k_I32ToF32:\r\n                    fregs[a] = iregs[b];\r\n                    break;\r\n                case EOperation.k_F32ToU32: // TODO: remove it?\r\n                case EOperation.k_F32ToI32:\r\n                    iregs[a] = Math.trunc(fregs[b]);\r\n                    break;\r\n\r\n                //\r\n                // Flow controls\r\n                //\r\n                case EOperation.k_JumpIf:\r\n                    i5 = iregs[a] !== 0\r\n                        ? i5 + InstructionList.STRIDE /* skip one instruction */\r\n                        : i5;                         /* do nothing (cause next instruction must always be Jump) */\r\n                    break;\r\n                case EOperation.k_Jump:\r\n                    // TODO: don't use multiplication here\r\n                    i5 = a * InstructionList.STRIDE;\r\n                    continue;\r\n                case EOperation.k_Ret:\r\n                    {\r\n                        break end;\r\n                    }\r\n                    break;\r\n                default:\r\n                    console.error(`${this.debugName} | unknown operation found: ${op}`);\r\n            }\r\n            i5 += InstructionList.STRIDE;\r\n        }\r\n\r\n        return TSBundle.regs;\r\n    }\r\n\r\n\r\n\r\n\r\n    dispatch(numgroups: Bundle.INumgroups, numthreads: Bundle.INumthreads) {\r\n        const { x: nGroupX, y: nGroupY, z: nGroupZ } = numgroups;\r\n        const { x: nThreadX, y: nThreadY, z: nThreadZ } = numthreads;\r\n\r\n        // TODO: get order from bundle\r\n        const SV_GroupID = Bytecode.INPUT0_REGISTER + 0;\r\n        const SV_GroupIndex = Bytecode.INPUT0_REGISTER + 1;\r\n        const SV_GroupThreadID = Bytecode.INPUT0_REGISTER + 2;\r\n        const SV_DispatchThreadID = Bytecode.INPUT0_REGISTER + 3;\r\n\r\n        this.inputs[SV_GroupID] = TSBundle.Gid;\r\n        this.inputs[SV_GroupIndex] = TSBundle.Gi;\r\n        this.inputs[SV_GroupThreadID] = TSBundle.GTid;\r\n        this.inputs[SV_DispatchThreadID] = TSBundle.DTid;\r\n\r\n        for (let iGroupZ = 0; iGroupZ < nGroupZ; ++iGroupZ) {\r\n            for (let iGroupY = 0; iGroupY < nGroupY; ++iGroupY) {\r\n                for (let iGroupX = 0; iGroupX < nGroupX; ++iGroupX) {\r\n                    TSBundle.Gid[0] = iGroupX;\r\n                    TSBundle.Gid[1] = iGroupY;\r\n                    TSBundle.Gid[2] = iGroupZ;\r\n\r\n                    for (let iThreadZ = 0; iThreadZ < nThreadZ; ++iThreadZ) {\r\n                        for (let iThreadY = 0; iThreadY < nThreadY; ++iThreadY) {\r\n                            for (let iThreadX = 0; iThreadX < nThreadX; ++iThreadX) {\r\n                                TSBundle.GTid[0] = iThreadX;\r\n                                TSBundle.GTid[1] = iThreadY;\r\n                                TSBundle.GTid[2] = iThreadZ;\r\n\r\n                                TSBundle.DTid[0] = iGroupX * nThreadX + iThreadX;\r\n                                TSBundle.DTid[1] = iGroupY * nThreadY + iThreadY;\r\n                                TSBundle.DTid[2] = iGroupZ * nThreadZ + iThreadZ;\r\n\r\n                                TSBundle.Gi[0] = iThreadZ * nThreadX * nThreadY + iThreadY * nThreadX + iThreadX;\r\n\r\n                                this.play();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    setInput(slot: number, input: TSBundleMemory): void {\r\n        this.inputs[slot] = input.buffer;\r\n    }\r\n\r\n    getInput(slot: number): TSBundleMemory {\r\n        return asBundleMemory(this.inputs[slot]);\r\n    }\r\n\r\n\r\n    setConstant(name: string, value: Uint8Array): boolean {\r\n        const layout = this.layout;\r\n        const reflection = layout.find(entry => entry.name === name);\r\n        const constants = this.inputs[CBUFFER0_REGISTER];\r\n    \r\n        if (!reflection) {\r\n            return false;\r\n        }\r\n    \r\n        const dst = new DataView(constants.buffer, constants.byteOffset + reflection.offset);\r\n        const src = new DataView(value.buffer, value.byteOffset);\r\n    \r\n        // TODO: validate layout / constant type in memory / size\r\n        switch (reflection.type) {\r\n            case 'float':\r\n                dst.setFloat32(0, src.getFloat32(0, true), true);\r\n                break;\r\n            case 'int':\r\n                dst.setInt32(0, src.getInt32(0, true), true);\r\n                break;\r\n            case 'uint':\r\n                dst.setUint32(0, src.getUint32(0, true), true);\r\n                break;\r\n            case 'float2':\r\n                dst.setFloat32(0, src.getFloat32(0, true), true);\r\n                dst.setFloat32(4, src.getFloat32(4, true), true);\r\n                break;\r\n            case 'float3':\r\n                dst.setFloat32(0, src.getFloat32(0, true), true);\r\n                dst.setFloat32(4, src.getFloat32(4, true), true);\r\n                dst.setFloat32(8, src.getFloat32(8, true), true);\r\n                break;\r\n            case 'float4':\r\n                dst.setFloat32(0, src.getFloat32(0, true), true);\r\n                dst.setFloat32(4, src.getFloat32(4, true), true);\r\n                dst.setFloat32(8, src.getFloat32(8, true), true);\r\n                dst.setFloat32(12, src.getFloat32(12, true), true);\r\n                break;\r\n            default:\r\n                assert(false, 'unsupported');\r\n        }\r\n    \r\n        return true;\r\n    }\r\n\r\n    getLayout(): Bundle.IConstant[] {\r\n        return this.layout;\r\n    }\r\n\r\n    getExterns(): Bundle.IExtern[] {\r\n        return this.externs;\r\n    }\r\n\r\n    setExtern(id: number, extern: Function): void {\r\n        this.ncalls[id] = extern;\r\n    }\r\n\r\n    static resetRegisters()\r\n    {\r\n        TSBundle.regs.fill(0);\r\n    }\r\n\r\n    static createUAV(name: string, elementSize: number, length: number, register: number): Bundle.IUAV {\r\n        const counterSize = sizeof.i32();\r\n        const size = counterSize + length * elementSize; // in bytes\r\n        assert(size % sizeof.i32() === 0);\r\n    \r\n        const index = Bytecode.UAV0_REGISTER + register;\r\n    \r\n        const memory = asBundleMemory(new Int32Array(size >> 2));\r\n        const data = asBundleMemory(memory.buffer.subarray(counterSize >> 2));\r\n        \r\n        const counter = memory.buffer.subarray(0, 1);\r\n    \r\n        counter[0] = 0; // reset counter\r\n    \r\n        return {\r\n            name,\r\n            // byte length of a single element\r\n            elementSize,\r\n            // number of elements\r\n            length, \r\n            // register specified in the shader\r\n            register,\r\n    \r\n            // [ elements ]\r\n            data,\r\n    \r\n            // raw data [ counter, ...elements ]\r\n            buffer: memory,\r\n            // input index for VM\r\n            index\r\n        };\r\n    }\r\n}\r\n\r\ntype Chunk = Uint8Array;\r\ntype ChunkMap = IMap<Chunk>;\r\n\r\nexport function decodeChunks(code: Uint8Array, chunks?: ChunkMap): ChunkMap {\r\n    if (!isDefAndNotNull(chunks)) {\r\n        chunks = {};\r\n    }\r\n\r\n    const view = new DataView(code.buffer, code.byteOffset, code.byteLength);\r\n    const type = view.getUint32(0, true);\r\n    const byteLength = view.getUint32(4, true) << 2;\r\n    let content: Uint8Array = null;\r\n    try {\r\n        content = new Uint8Array(code.buffer, code.byteOffset + 8, byteLength);\r\n    } catch (e)\r\n    {\r\n        console.log(e);\r\n    }\r\n\r\n    chunks[type] = content;\r\n\r\n    const nextChunkOffset = content.byteOffset + content.byteLength;\r\n    if (nextChunkOffset < code.buffer.byteLength) {\r\n        decodeChunks(new Uint8Array(content.buffer, nextChunkOffset), chunks);\r\n    }\r\n\r\n    return chunks;\r\n}\r\n\r\n\r\nexport function decodeCodeChunk(codeChunk: Uint8Array): Uint32Array {\r\n    return new Uint32Array(codeChunk.buffer, codeChunk.byteOffset, codeChunk.byteLength >> 2);\r\n}\r\n\r\n\r\nexport function decodeConstChunk(constChunk: Uint8Array): Uint8Array {\r\n    return constChunk;\r\n}\r\n\r\n\r\n// TODO: rewrite with cleaner code\r\nexport function decodeLayoutChunk(layoutChunk: Uint8Array): Bundle.IConstant[] {\r\n    let readed = 0;\r\n    let count = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n    readed += 4;\r\n\r\n    let layout: Bundle.IConstant[] = [];\r\n    for (let i = 0; i < count; ++i) {\r\n        const nameLength = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const name = String.fromCharCode(...layoutChunk.subarray(readed, readed + nameLength));\r\n        readed += nameLength;\r\n\r\n        const typeLength = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const type = String.fromCharCode(...layoutChunk.subarray(readed, readed + typeLength));\r\n        readed += typeLength;\r\n\r\n        const semanticLength = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const semantic = String.fromCharCode(...layoutChunk.subarray(readed, readed + semanticLength));\r\n        readed += semanticLength;\r\n\r\n        const offset = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const size = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        \r\n        layout.push({ name, type, offset, size, semantic });\r\n    }\r\n    return layout;\r\n}\r\n\r\nexport function decodeShadersChunk(shadersChunk: Uint8Array): Bundle.IShader[] {\r\n    if (!shadersChunk) {\r\n        return null;\r\n    }\r\n\r\n    let readed = 0;\r\n    let shadersCount = u8ArrayToI32(shadersChunk.subarray(readed, readed + 4));\r\n    readed += 4;\r\n\r\n    let shaders: Bundle.IShader[] = [];\r\n    for (let i = 0; i < shadersCount; ++i) {\r\n        const nameLength = u8ArrayToI32(shadersChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const name = String.fromCharCode(...shadersChunk.subarray(readed, readed + nameLength));\r\n        readed += nameLength;\r\n\r\n        const verLength = u8ArrayToI32(shadersChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const ver = String.fromCharCode(...shadersChunk.subarray(readed, readed + verLength));\r\n        readed += verLength;\r\n\r\n        const argsCount = u8ArrayToI32(shadersChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const args = [];\r\n        for (let j = 0; j < argsCount; ++j) {\r\n            const typeLength = u8ArrayToI32(shadersChunk.subarray(readed, readed + 4));\r\n            readed += 4;\r\n            const type = String.fromCharCode(...shadersChunk.subarray(readed, readed + typeLength));\r\n            readed += typeLength;\r\n\r\n            let value;\r\n            switch (type) {\r\n                case 'int':\r\n                case 'uint':\r\n                    value = u8ArrayToI32(shadersChunk.subarray(readed, readed + 4));\r\n                    readed += 4;\r\n                    break;\r\n                case 'bool':\r\n                    value = !!u8ArrayToI32(shadersChunk.subarray(readed, readed + 4));\r\n                    readed += 4;\r\n                    break;\r\n                default:\r\n                    assert(false, `unsupported constant type \"${type}\"`);\r\n            }\r\n\r\n            args.push({ type, value });\r\n        }\r\n\r\n        shaders.push({ name, ver, args })\r\n    }\r\n    return shaders;\r\n}\r\n\r\n\r\nexport function decodeDepthStencilStates(dssChunk: Uint8Array): Bundle.IDepthStencilState[] {\r\n    if (!dssChunk) {\r\n        return null;\r\n    }\r\n\r\n    let readed = 0;\r\n    let shadersCount = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n    readed += 4;\r\n\r\n    let states: Bundle.IDepthStencilState[] = [];\r\n    for (let i = 0; i < shadersCount; ++i) {\r\n        const DepthEnable = !!u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const DepthWriteMask = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const DepthFunc = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const StencilEnable = !!u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const StencilReadMask = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const StencilWriteMask = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n\r\n        const FrontFaceStencilFailOp = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const FrontFaceStencilDepthFailOp = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const FrontFaceStencilPassOp = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const FrontFaceStencilFunc = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n\r\n        const BackFaceStencilFailOp = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const BackFaceStencilDepthFailOp = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const BackFaceStencilPassOp = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const BackFaceStencilFunc = u8ArrayToI32(dssChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n\r\n        states.push({ \r\n            DepthEnable,\r\n            DepthWriteMask,\r\n            DepthFunc,\r\n            StencilEnable,\r\n            StencilReadMask,\r\n            StencilWriteMask,\r\n            FrontFace: {\r\n                StencilFailOp: FrontFaceStencilFailOp,\r\n                StencilDepthFailOp: FrontFaceStencilDepthFailOp,\r\n                StencilPassOp: FrontFaceStencilPassOp,\r\n                StencilFunc: FrontFaceStencilFunc\r\n            },\r\n            BackFace: {\r\n                StencilFailOp: BackFaceStencilFailOp,\r\n                StencilDepthFailOp: BackFaceStencilDepthFailOp,\r\n                StencilPassOp: BackFaceStencilPassOp,\r\n                StencilFunc: BackFaceStencilFunc\r\n            },\r\n         });\r\n    }\r\n    return states;\r\n}\r\n\r\n\r\nfunction decodeTypeField(data: Uint8Array, field: TypeFieldT): number {\r\n    let readed = 0;\r\n    field.padding = u8ArrayToI32(data.subarray(readed, readed + 4));\r\n    readed += 4;\r\n    field.size = u8ArrayToI32(data.subarray(readed, readed + 4));\r\n    readed += 4;\r\n\r\n    const semanticLength = u8ArrayToI32(data.subarray(readed, readed + 4));\r\n    readed += 4;\r\n    field.semantic = String.fromCharCode(...data.subarray(readed, readed + semanticLength));\r\n    readed += semanticLength;\r\n\r\n    const nameLength = u8ArrayToI32(data.subarray(readed, readed + 4));\r\n    readed += 4;\r\n    field.name = String.fromCharCode(...data.subarray(readed, readed + nameLength));\r\n    readed += nameLength;\r\n\r\n    let type: TypeLayoutT = {} as any;\r\n    readed += decodeTypeLayout(data.subarray(readed), type);\r\n    field.type = type;\r\n\r\n    return readed;\r\n}\r\n\r\nfunction decodeTypeLayout(data: Uint8Array, layout: TypeLayoutT): number {\r\n    let readed = 0;\r\n    layout.size = u8ArrayToI32(data.subarray(readed, readed + 4));\r\n    readed += 4;\r\n    layout.length = u8ArrayToI32(data.subarray(readed, readed + 4));\r\n    readed += 4;\r\n\r\n    const nameLength = u8ArrayToI32(data.subarray(readed, readed + 4));\r\n    readed += 4;\r\n    layout.name = String.fromCharCode(...data.subarray(readed, readed + nameLength));\r\n    readed += nameLength;\r\n\r\n    let count = u8ArrayToI32(data.subarray(readed, readed + 4));\r\n    readed += 4;\r\n\r\n    for (let i = 0; i < count; ++ i) {\r\n        let fiedl: TypeFieldT = {} as any;\r\n        readed += decodeTypeField(data.subarray(readed), fiedl);\r\n        layout.fields ||= [];\r\n        layout.fields.push(fiedl);\r\n    }\r\n\r\n    return readed;\r\n}\r\n\r\nexport function decodeExternsChunk(externsChunk: Uint8Array): Bundle.IExtern[] {\r\n    let readed = 0;\r\n    let externCount = u8ArrayToI32(externsChunk.subarray(readed, readed + 4));\r\n    readed += 4;\r\n\r\n    let externs: Bundle.IExtern[] = [];\r\n    for (let i = 0; i < externCount; ++i) {\r\n        const id = u8ArrayToI32(externsChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n\r\n        const nameLength = u8ArrayToI32(externsChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const name = String.fromCharCode(...externsChunk.subarray(readed, readed + nameLength));\r\n        readed += nameLength;\r\n\r\n        const ret: TypeLayoutT = {} as any; // hack\r\n        readed += decodeTypeLayout(externsChunk.subarray(readed), ret);\r\n\r\n        let paramCount = u8ArrayToI32(externsChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n\r\n        const params: TypeLayoutT[] = [];\r\n        for (let j = 0; j < paramCount; ++j) {\r\n            const param: TypeLayoutT = {} as any; // hack\r\n            readed += decodeTypeLayout(externsChunk.subarray(readed), param);\r\n            params.push(param);\r\n        }\r\n\r\n        externs.push({ id, name, ret, params });\r\n    }\r\n    return externs;\r\n}\r\n","import { IFunctionDeclInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport const REG_INVALID = (-1 >>> 0);\r\nexport const DEFAULT_ENTRY_POINT_NAME = 'main';\r\n\r\n// symbol name id generation;\r\nexport const sname = {\r\n    i32: (i32: number) => `%i32:${i32}`,\r\n    f32: (f32: number) => `%f32:${f32}`,\r\n    var: (vdecl: IVariableDeclInstruction) => `${vdecl.name}:${vdecl.instructionID}`,\r\n    fun: (fdecl: IFunctionDeclInstruction) => `${fdecl.name}:${fdecl.instructionID}`,\r\n\r\n    // addr: (addr: number) => sname.i32(addr)\r\n};\r\n\r\n// aux functions for packing routines\r\nexport const i32ToU8Array = (i32: number) => Array(4).fill(0).map((u8, i, self) => (i32 >> (i) * 8) & (0xff));\r\nexport const u8ArrayToI32 = (arr: Uint8Array | Array<number>) => (arr as number[]).reduce((acc, cv, i, self) => acc | (cv << (i) * 8), 0);\r\n\r\n// Uint8Array => Int32Array conversion\r\nexport const u8ArrayAsI32 = (arr: Uint8Array) => ((arr[0]) | (arr[1] << 8) | (arr[2] << 16) | (arr[3] << 24));\r\nexport const u8ArrayAsF32 = (arr: Uint8Array) => new Float32Array(arr.buffer, arr.byteOffset)[0];\r\n\r\n\r\nconst ab = new ArrayBuffer(4);\r\nconst f32a = new Float32Array(ab);\r\nconst i32a = new Int32Array(ab);\r\nconst u32a = new Uint32Array(ab);\r\nexport function f32Asi32(f32: number): number {\r\n    f32a[0] = f32;\r\n    return i32a[0];\r\n}\r\n\r\nexport function i32Asf32(i32: number): number {\r\n    i32a[0] = i32;\r\n    return f32a[0];\r\n}\r\n\r\nexport function u32Asf32(u32: number): number {\r\n    u32a[0] = u32;\r\n    return f32a[0];\r\n}\r\n\r\n\r\nexport function i32Asu32(i32: number): number {\r\n    i32a[0] = i32;\r\n    return u32a[0];\r\n}\r\n\r\n\r\nexport function u32Asi32(u32: number): number {\r\n    u32a[0] = u32;\r\n    return i32a[0];\r\n}\r\n","export { translate, translateExpression } from \"./Bytecode\"\r\nexport { DEFAULT_ENTRY_POINT_NAME, REG_INVALID } from \"./common\"\r\nexport { cdlview } from \"./DebugLayout\"\r\n","const sizeof = {\r\n    u32: () => 4,\r\n    i32: () => 4,\r\n    f32: () => 4,\r\n    bool: () => sizeof.i32(),\r\n    addr: () => sizeof.i32()\r\n};\r\n\r\n\r\nexport default sizeof;","import { IEmitter, ITextureDesc, ITexture, ITrimeshDesc, ITrimesh } from '@lib/idl/emitter/IEmitter';\r\nimport loadWASM from './module.cpp';\r\nimport * as Bytecode from '@lib/idl/bytecode';\r\nimport { ITechnique } from '@lib/idl/ITechnique';\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\nimport { Bundle, BundleT } from '@lib/idl/bundles/auto/fx/bundle';\r\nimport { BundleContent } from '@lib/idl/bundles/auto/fx/bundle-content';\r\n\r\ninterface WASMMemory extends Bytecode.IMemory {\r\n    heap: number; // in bytes \r\n    size: number; // in uint32 (byteSize = 4 x size)\r\n}\r\n\r\nconst Module = await loadWASM();\r\n\r\nconst isEmitter = tech => tech?.getType() === 'emitter';\r\nconst isMat = tech => tech?.getType() === 'material';\r\n\r\n/**\r\n * Allocate new heap memory. (!)\r\n */\r\nfunction transferU8ToHeap(module: EmscriptenModule, view: ArrayBufferView): WASMMemory {\r\n    const u8Array = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\r\n    const heap = module._malloc(u8Array.length * u8Array.BYTES_PER_ELEMENT);\r\n    const size = u8Array.length >> 2;\r\n    module.HEAPU8.set(u8Array, heap);\r\n    return { heap, size };\r\n}\r\n\r\n\r\nfunction freeHeap(module: EmscriptenModule, { heap }: WASMMemory) {\r\n    module._free(heap);\r\n}\r\n\r\n\r\nfunction createFromBundle(content: Uint8Array): ITechnique {\r\n    let pipelineWasm = null;\r\n    let mem = transferU8ToHeap(Module, content);\r\n    try {\r\n        pipelineWasm = Module.createFromBundle(mem);\r\n    } finally {\r\n        Module._free(mem.heap);\r\n    }\r\n\r\n    return pipelineWasm;\r\n}\r\n\r\n\r\nexport function destroyTechnique(tech: ITechnique) {\r\n    if (isEmitter(tech)) {\r\n        Module.destroyEmitter(<IEmitter>tech);\r\n    }\r\n}\r\n\r\nfunction decodeBundleData(data: Uint8Array | BundleT): BundleT {\r\n    // load from packed version, see PACKED in @lib/fx/bundles/Bundle.ts\r\n    if (data instanceof Uint8Array) {\r\n        let fx = new BundleT();\r\n        let buf = new flatbuffers.ByteBuffer(data);\r\n        Bundle.getRootAsBundle(buf).unpackTo(fx);\r\n        return fx;\r\n    }\r\n\r\n    return <BundleT>data;\r\n}\r\n\r\nfunction decodeBundleType(data: Uint8Array | BundleT): BundleContent {\r\n    // load from packed version, see PACKED in @lib/fx/bundles/Bundle.ts\r\n    if (data instanceof Uint8Array) {\r\n        let buf = new flatbuffers.ByteBuffer(data);\r\n        return Bundle.getRootAsBundle(buf).contentType();\r\n    }\r\n\r\n    return (<BundleT>data).contentType;\r\n}\r\n\r\nexport function createTechnique(data: Uint8Array | BundleT): ITechnique {\r\n    console.assert(data instanceof Uint8Array, \"only packed bundle are supported\");\r\n\r\n    const type = decodeBundleType(data);\r\n\r\n    if (type === BundleContent.PartBundle) {\r\n        // ! cpp module supports only particles bundles for now !\r\n        const tech = createFromBundle(<Uint8Array>data);\r\n        (<IEmitter>tech).reset();\r\n        return tech;\r\n    }\r\n\r\n    // fixme: remove dummy code\r\n    return { getName() { return <string>decodeBundleData(data).name }, getType() { return 'material' }, getPassCount() { return 0 }, getPass(i) { return null }, };\r\n}\r\n\r\n\r\nexport function copyTechnique(dst: ITechnique, src: ITechnique): boolean {\r\n    if (isEmitter(dst) && isEmitter(src)) {\r\n        return Module.copyEmitter(<IEmitter>dst, <IEmitter>src);\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function createTexture(desc: ITextureDesc, initData: ArrayBufferView): ITexture {\r\n    let textureWasm = null;\r\n    let mem = transferU8ToHeap(Module, initData);\r\n    try {\r\n        textureWasm = Module.createTexture(desc, mem);\r\n    } finally {\r\n        Module._free(mem.heap);\r\n    }\r\n\r\n    return textureWasm;\r\n}\r\n\r\n\r\nexport function destroyTexture(texture: ITexture) {\r\n    if (texture) {\r\n        try {\r\n            Module.destroyTexture(texture);\r\n        } finally {};\r\n    }\r\n}\r\n\r\n\r\nexport function createTrimesh(desc: ITrimeshDesc, \r\n    vertices: ArrayBufferView, faces: ArrayBufferView, \r\n    indicesAdj: ArrayBufferView, facesAdj: ArrayBufferView): ITrimesh {\r\n    let trimeshWasm = null;\r\n    let vertMem = transferU8ToHeap(Module, vertices);\r\n    let faceMem = transferU8ToHeap(Module, faces);\r\n    let indMem = transferU8ToHeap(Module, indicesAdj);\r\n    let adjMem = transferU8ToHeap(Module, facesAdj);\r\n    try {\r\n        trimeshWasm = Module.createTrimesh(desc, vertMem, faceMem, indMem, adjMem);\r\n    } finally {\r\n        Module._free(vertMem.heap);\r\n        Module._free(faceMem.heap);\r\n        Module._free(indMem.heap);\r\n    }\r\n    return trimeshWasm;\r\n}\r\n\r\n\r\nexport function destroyTrimesh(mesh: ITrimesh) {\r\n    if (mesh) {\r\n        try {\r\n            Module.destroyTrimesh(mesh);\r\n        } finally {};\r\n    }\r\n}\r\n\r\n//\r\n//\r\n//\r\n\r\nexport function memoryToU8Array(input: Bytecode.IMemory) {\r\n    const { heap, size } = input as WASMMemory;\r\n    return Module.HEAPU8.subarray(heap, (heap + (size << 2)));\r\n}\r\n\r\n\r\nexport function memoryToI32Array(input: Bytecode.IMemory): Int32Array {\r\n    const { heap, size } = <WASMMemory>input;\r\n    console.assert(heap % 4 == 0, \"unsupported heap address!\");\r\n    return Module.HEAP32.subarray(heap >> 2, ((heap >> 2) + size));\r\n}\r\n\r\n\r\nexport function memoryToF32Array(input: Bytecode.IMemory): Float32Array {\r\n    const { heap, size } = <WASMMemory>input;\r\n    console.assert(heap % 4 == 0, \"unsupported heap address!\");\r\n    return Module.HEAPF32.subarray(heap >> 2, ((heap >> 2) + size));\r\n}\r\n\r\n\r\n/**\r\n * NOTE: copy view to NEW memory (!)\r\n * @returns New array containing input data.\r\n */\r\nexport function copyViewToMemory(input: ArrayBufferView): Bytecode.IMemory {\r\n    return transferU8ToHeap(Module, new Uint8Array(input.buffer, input.byteOffset, input.byteLength));\r\n}\r\n\r\n\r\nexport function releaseMemory(mem: Bytecode.IMemory) {\r\n    freeHeap(Module, <WASMMemory>mem);\r\n}\r\n","import * as Bytecode from '@lib/idl/bytecode';\r\n\r\nimport * as WASMPipe from \"./cpp/bridge\";\r\nimport * as TSPipe from \"./ts/bridge\";\r\nimport { isDef } from '@lib/common';\r\nimport { ITechnique } from '@lib/idl/ITechnique';\r\n\r\n/// <reference path=\"./webpack.d.ts\" />\r\n\r\n// check shell.js for more details\r\n// electron hack to support option --disable-wasm\r\nconst forceNoWasm = () => (new URLSearchParams(window.location.search)).get('disable-wasm') === 'true';\r\nlet useWASM = WASM && !forceNoWasm();\r\n\r\nfunction Pipe() {\r\n    return useWASM ? WASMPipe : TSPipe;\r\n}\r\n\r\nexport function isWASM() {\r\n    return useWASM;\r\n}\r\n\r\nexport function switchRuntime(runtime?: 'wasm' | 'js') {\r\n    useWASM = isDef(runtime) ? runtime === 'wasm' : !useWASM;\r\n    console.log(`%c Technique runtime has been switched to \"${(useWASM ? \"WASM\" : \"JS\")}\".`, 'font-weight: bold; background: #6f0000; color: #fff');\r\n}\r\n\r\n// hack\r\nimport * as flatbuffers from 'flatbuffers';\r\nimport { ITexture, ITextureDesc, ITrimesh, ITrimeshDesc } from '@lib/idl/emitter/IEmitter';\r\nimport { Bundle, BundleT } from '@lib/idl/bundles/auto/fx/bundle';\r\nimport { BundleContent } from '@lib/idl/bundles/auto/fx/bundle-content';\r\n\r\nfunction HACK_GetBundleType(data: Uint8Array | BundleT): BundleContent {\r\n        if (data instanceof Uint8Array) {\r\n            let buf = new flatbuffers.ByteBuffer(data);\r\n            return Bundle.getRootAsBundle(buf).contentType();\r\n        }\r\n        return (<BundleT>data).contentType;\r\n}\r\n\r\n// end of hack\r\n\r\nexport function createTechnique(data: Uint8Array | BundleT): ITechnique {\r\n    // hack:\r\n    // cpp module doesn't support material/technique11 bundles\r\n    // so redirect them to TS only solution\r\n    if (isWASM()) {\r\n        if (HACK_GetBundleType(data) === BundleContent.MatBundle || HACK_GetBundleType(data) === BundleContent.Technique11Bundle) {\r\n            console.warn(`${BundleContent[HACK_GetBundleType(data)]} bundle was created using TS module while WASM is on.`);\r\n            return TSPipe.createTechnique(data);\r\n        }\r\n    }\r\n    // end of hack\r\n\r\n    return Pipe().createTechnique(data);\r\n}\r\n\r\n\r\nexport function destroyTechnique(tech: ITechnique): void {\r\n    Pipe().destroyTechnique(tech);\r\n}\r\n\r\n\r\nexport function copyTechnique(dst: ITechnique, src: ITechnique): boolean {\r\n    return Pipe().copyTechnique(dst, src);\r\n}\r\n\r\n\r\nexport function createTexture(desc: ITextureDesc, initData: ArrayBufferView): ITexture {\r\n    return Pipe().createTexture(desc, initData);\r\n}\r\n\r\nexport function destroyTexture(texture: ITexture) {\r\n    Pipe().destroyTexture(texture);\r\n}\r\n\r\nexport function createTrimesh(desc: ITrimeshDesc, vertices: ArrayBufferView, \r\n    faces: ArrayBufferView, indicesAdj: ArrayBufferView, facesAdj: ArrayBufferView): ITrimesh {\r\n    return Pipe().createTrimesh(desc, vertices, faces, indicesAdj, facesAdj);\r\n}\r\n\r\n\r\nexport function destroyTrimesh(mesh: ITrimesh) {\r\n    Pipe().destroyTrimesh(mesh);\r\n}\r\n\r\n\r\n//\r\n//\r\n//\r\n\r\nexport function memoryToU8Array(input: Bytecode.IMemory): Uint8Array {\r\n    return Pipe().memoryToU8Array(input);\r\n}\r\n\r\n\r\nexport function memoryToI32Array(input: Bytecode.IMemory): Int32Array {\r\n    return Pipe().memoryToI32Array(input);\r\n}\r\n\r\n\r\nexport function memoryToF32Array(input: Bytecode.IMemory): Float32Array {\r\n    return Pipe().memoryToF32Array(input);\r\n}\r\n\r\n/**\r\n * NOTE: copy view to NEW memory if WASM bundle is used (!)\r\n * @returns New array containing input data.\r\n */\r\nexport function copyViewToMemory(input: ArrayBufferView): Bytecode.IMemory {\r\n    return Pipe().copyViewToMemory(input);\r\n}\r\n\r\nexport function releaseMemory(mem: Bytecode.IMemory) {\r\n    Pipe().releaseMemory(mem);\r\n}","import { asBundleMemory, fromBundleMemory } from '@lib/fx/bytecode/VM/ts/bundle';\r\nimport * as Bytecode from '@lib/idl/bytecode';\r\nimport { ITexture, ITextureDesc, ITrimesh, ITrimeshDesc } from '@lib/idl/emitter/IEmitter';\r\nimport { ITechnique } from '@lib/idl/ITechnique';\r\nimport * as flatbuffers from 'flatbuffers';\r\nimport { copyTsEmitter, createTsEmitter, createTsTexture, createTsTrimesh, destroyTsEmitter, destroyTsTexture, destroyTsTrimesh } from './emitter';\r\nimport { copyTsMaterial, createTsMaterial, destroyTsMaterial } from './mat';\r\nimport { copyTsTechnique11, createTsTechnique11, destroyTsTechnique11 } from './technique11';\r\nimport { assert } from '@lib/common';\r\n\r\nimport { Bundle, BundleT } from '@lib/idl/bundles/auto/fx/bundle';\r\nimport { BundleContent } from '@lib/idl/bundles/auto/fx/bundle-content';\r\n\r\n\r\nfunction decodeBundleData(data: Uint8Array | BundleT): BundleT {\r\n    // load from packed version, see PACKED in @lib/fx/bundles/Bundle.ts\r\n    if (data instanceof Uint8Array) {\r\n        let fx = new BundleT();\r\n        let buf = new flatbuffers.ByteBuffer(data);\r\n        Bundle.getRootAsBundle(buf).unpackTo(fx);\r\n        return fx;\r\n    }\r\n\r\n    return <BundleT>data;\r\n}\r\n\r\n\r\n\r\nexport function createTexture(desc: ITextureDesc, initData: ArrayBufferView): ITexture {\r\n    return createTsTexture(desc, initData);\r\n}\r\n\r\n\r\nexport function destroyTexture(texture: ITexture) {\r\n    destroyTsTexture(texture);\r\n}\r\n\r\n\r\nexport function createTrimesh(desc: ITrimeshDesc, \r\n    vertices: ArrayBufferView, faces: ArrayBufferView, indicesAdj: ArrayBufferView, facesAdj: ArrayBufferView): ITrimesh {\r\n    return createTsTrimesh(desc, vertices, faces, indicesAdj, facesAdj);\r\n}\r\n\r\n\r\nexport function destroyTrimesh(mesh: ITrimesh) {\r\n    destroyTsTrimesh(mesh);\r\n}\r\n\r\n//\r\n//\r\n//\r\n\r\n\r\nexport function createTechnique(data: Uint8Array | BundleT): ITechnique {\r\n    const bundle = decodeBundleData(data);\r\n\r\n    if (bundle.contentType === BundleContent.PartBundle) {\r\n        const emitter = createTsEmitter(bundle);\r\n        emitter.reset();\r\n        return emitter;\r\n    }\r\n\r\n    if (bundle.contentType === BundleContent.MatBundle) {\r\n        return createTsMaterial(bundle);\r\n    }\r\n\r\n    if (bundle.contentType === BundleContent.Technique11Bundle) {\r\n        return createTsTechnique11(bundle);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n\r\nexport function destroyTechnique(tech: ITechnique): void {\r\n    switch (tech?.getType()) {\r\n        case 'emitter': return destroyTsEmitter(tech); // partFx\r\n        case 'material': return destroyTsMaterial(tech); // basically it's technique9\r\n        case 'technique11': return destroyTsTechnique11(tech);\r\n    }\r\n}\r\n\r\n\r\nexport function copyTechnique(dst: ITechnique, src: ITechnique): boolean {\r\n    assert(dst.getType() === src.getType());\r\n    switch (dst.getType()) {\r\n        case 'emitter': return copyTsEmitter(dst, src);         // partFx\r\n        case 'material': return copyTsMaterial(dst, src);       // basically it's technique9\r\n        case 'technique11': return copyTsTechnique11(dst, src);\r\n    }\r\n    console.assert(false);\r\n    return false;\r\n}\r\n\r\n\r\n//\r\n//\r\n//\r\n\r\nexport function memoryToU8Array(input: Bytecode.IMemory): Uint8Array {\r\n    const buffer = fromBundleMemory(input);\r\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n}\r\n\r\n\r\nexport function memoryToF32Array(input: Bytecode.IMemory): Float32Array {\r\n    const buffer = fromBundleMemory(input);\r\n    return new Float32Array(buffer.buffer, buffer.byteOffset, buffer.length);\r\n}\r\n\r\n\r\nexport function memoryToI32Array(input: Bytecode.IMemory): Int32Array {\r\n    return fromBundleMemory(input);\r\n}\r\n\r\nfunction copy(src: ArrayBufferView): ArrayBufferView  {\r\n    const dst = new Uint8Array(src.byteLength);\r\n    dst.set(new Uint8Array(src.buffer, src.byteOffset, src.byteLength));\r\n    return dst;\r\n}\r\n\r\nexport function copyViewToMemory(input: ArrayBufferView): Bytecode.IMemory {\r\n    return asBundleMemory(copy(input));\r\n}\r\n\r\n\r\nexport function releaseMemory(mem: Bytecode.IMemory) {\r\n    console.error('NOT IMPLEMENTED!!!');\r\n}\r\n\r\n","import { assert, verbose } from '@lib/common';\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\nimport { asBundleMemory } from '@lib/fx/bytecode/VM/ts/bundle';\r\nimport { FxTranslator } from '@lib/fx/translators/FxTranslator';\r\nimport * as Bytecode from \"@lib/idl/bytecode\";\r\nimport { IEmitter } from '@lib/idl/emitter';\r\nimport { Uniforms } from '@lib/idl/Uniforms';\r\nimport { ITechnique } from '@lib/idl/ITechnique';\r\n\r\nimport { SRV0_REGISTER } from '@lib/fx/bytecode/Bytecode';\r\nimport { IParticleDebugViewer, ITexture, ITextureDesc, ITrimesh, ITrimeshDesc } from '@lib/idl/emitter/IEmitter';\r\nimport { EUsage, IConstantBuffer } from '@lib/idl/ITechnique9';\r\nimport { IMap } from '@lib/idl/IMap';\r\n\r\nimport { UAVBundleT } from '@lib/idl/bundles/auto/fx/uavbundle';\r\nimport { TypeLayoutT } from '@lib/idl/bundles/auto/type-layout';\r\nimport { RoutineBytecodeBundleT } from '@lib/idl/bundles/auto/fx/routine-bytecode-bundle';\r\nimport { EPartSimRoutines } from '@lib/idl/bundles/auto/fx/epart-sim-routines';\r\nimport { BundleT } from '@lib/idl/bundles/auto/fx/bundle';\r\nimport { PartBundleT } from '@lib/idl/bundles/auto/fx/part-bundle';\r\nimport { RoutineShaderBundleT } from '@lib/idl/bundles/auto/fx/routine-shader-bundle';\r\nimport { EPartRenderRoutines } from '@lib/idl/bundles/auto/fx/epart-render-routines';\r\nimport { RoutineGLSLSourceBundleT } from '@lib/idl/bundles/auto/fx/routine-glslsource-bundle';\r\nimport { RoutineSourceBundle } from '@lib/idl/bundles/auto/fx/routine-source-bundle';\r\n\r\ntype IMemory = Bytecode.IMemory;\r\ntype IUAVResource = ReturnType<typeof VM.createUAV>;\r\n\r\ninterface TSTrimesh extends ITrimesh {\r\n    vertCount: number;\r\n    faceCount: number;\r\n\r\n    vertices: IMemory;\r\n    faces: IMemory;\r\n    indicesAdj: IMemory;\r\n    faceAdj: IMemory;\r\n}\r\n\r\ninterface TSTexture extends ITexture {\r\n    layout: IMemory;\r\n}\r\n\r\nfunction createUAVEx(bundle: UAVBundleT, capacity: number): IUAVResource {\r\n    const uav = VM.createUAV(<string>bundle.name, bundle.stride, capacity, bundle.slot);\r\n    // console.log(`UAV '${uav.name}' (counter value: ${UAV.readCounter(uav)}, size: ${uav.length}) has been created.`);\r\n    return uav;\r\n}\r\n\r\n// tslint:disable-next-line:max-line-length\r\n// !attention! updtae shared list if needed\r\nfunction createUAVsEx(bundles: UAVBundleT[], capacity: number, sharedUAVs: IUAVResource[] = []): IUAVResource[] {\r\n    return bundles.map(uavBundle => {\r\n        const sharedUAV = sharedUAVs.find(uav => uav.name === uavBundle.name);\r\n        if (sharedUAV) return sharedUAV;\r\n        const uav = createUAVEx(uavBundle, capacity);\r\n        sharedUAVs.push(uav);\r\n        return uav;\r\n    });\r\n}\r\n\r\nconst CTEMP_U8 = new Uint8Array(8);\r\nconst CTEMP_DV = new DataView(CTEMP_U8.buffer);\r\n\r\n\r\n\r\nfunction createParticleDebugViewer(\r\n    layout: TypeLayoutT,\r\n    capacity: number,\r\n    uavDeadIndices: Bytecode.IUAV,\r\n    uavStates: Bytecode.IUAV,\r\n    uavParticles: Bytecode.IUAV\r\n): IParticleDebugViewer {\r\n\r\n    const dataU8 = new Uint8Array(layout.size * capacity);\r\n    const dataIds = new Array(capacity);\r\n\r\n    function dump() {\r\n        const npart = getParticleCount();\r\n\r\n        // verbose(`particles total: ${npart} ( ${UAV.readCounter(uavDeadIndices)}/${capacity} )`);\r\n\r\n        const uavStatesI32 = VM.memoryToI32Array(uavStates.data);\r\n        const uavParticlesU8 = VM.memoryToU8Array(uavParticles.data);\r\n\r\n        let iCopy = 0;\r\n        uavStatesI32.forEach((alive, iPart) => {\r\n            if (alive) {\r\n                const src = new Uint8Array(uavParticlesU8.buffer, uavParticlesU8.byteOffset + iPart * layout.size, layout.size);\r\n                const dst = new Uint8Array(dataU8.buffer, dataU8.byteOffset + iCopy * layout.size, layout.size);\r\n                dst.set(src);\r\n                dataIds[iCopy] = iPart;\r\n                iCopy ++;\r\n            }\r\n        });\r\n    }\r\n\r\n    const getParticleCount = () => capacity - UAV.readCounter(uavDeadIndices);\r\n    const isDumpReady = () => true;\r\n    // const getLayout = () => layout;\r\n\r\n    function readParticleJSON(iPart: number): Object {\r\n        const src = new Uint8Array(dataU8.buffer, dataU8.byteOffset + iPart * layout.size, layout.size);\r\n        return VM.asNativeRaw(src, layout);\r\n    }\r\n\r\n    function readParticlesJSON(): Array<Object> {\r\n        let dst = [];\r\n        for (let i = 0; i < getParticleCount(); ++ i) {\r\n            dst.push({ ...readParticleJSON(i), [`#id`]: dataIds[i] } );\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    return {\r\n        dump,\r\n        isDumpReady,\r\n        getParticleCount,\r\n        readParticleJSON,\r\n        readParticlesJSON\r\n    };\r\n}\r\n\r\n\r\nfunction setupFxRoutineBytecodeBundle(debugName: string, routineBundle: RoutineBytecodeBundleT, capacity: number, sharedUAVs: IUAVResource[]) {\r\n    const codeLength = routineBundle.code.length;\r\n    if (codeLength == 0) {\r\n        // it's dummy bundle\r\n        return null;\r\n    }\r\n\r\n    const vmBundle = VM.make(debugName, routineBundle.code);\r\n    const uavs = createUAVsEx(routineBundle.resources.uavs, capacity, sharedUAVs);\r\n    const numthreads = routineBundle.numthreads;\r\n\r\n    uavs.forEach(uav => { vmBundle.setInput(uav.index, uav.buffer); });\r\n\r\n    const { buffers, textures, trimeshes } = routineBundle.resources;\r\n\r\n    function setConstant(name: string, value: Uint8Array) {\r\n        vmBundle.setConstant(name, value);\r\n    }\r\n\r\n    function setInt32Constant(name: string, value: number) {\r\n        CTEMP_DV.setInt32(0, value, true);\r\n        setConstant(name, CTEMP_U8);\r\n    }\r\n\r\n    function setUint32Constant(name: string, value: number) {\r\n        CTEMP_DV.setUint32(0, value, true);\r\n        setConstant(name, CTEMP_U8);\r\n    }\r\n\r\n    function setConstants(constants: Uniforms) {\r\n        Object.keys(constants)\r\n            .forEach(name => setConstant(name, constants[name]));\r\n    }\r\n\r\n\r\n    function setBuffer(name, data: IMemory) {\r\n        const buf = buffers.find(buf => buf.name === name);\r\n        if (!buf) return;\r\n\r\n        vmBundle.setInput(buf.slot + SRV0_REGISTER, data);\r\n    }\r\n\r\n\r\n    // content consist of Float32Array(...f3 pos, f3 normal, f2 uv)\r\n    function setTrimesh(name: string, trimesh: ITrimesh) {\r\n        const { vertCount, faceCount, vertices, faces, indicesAdj, faceAdj } = <TSTrimesh>trimesh;\r\n\r\n        const mesh = trimeshes.find(mesh => mesh.name === name);\r\n        if (!mesh) return;\r\n\r\n        setBuffer(mesh.verticesName, vertices);\r\n        setBuffer(mesh.facesName, faces);\r\n        setBuffer(mesh.gsAdjecencyName, indicesAdj);\r\n        setBuffer(mesh.faceAdjacencyName, faceAdj);\r\n\r\n        setUint32Constant(<string>mesh.vertexCountUName, vertCount);\r\n        setUint32Constant(<string>mesh.faceCountUName, faceCount);\r\n    }\r\n\r\n    function setTexture(name: string, tex: ITexture) {\r\n        const { layout } = <TSTexture>tex;\r\n        const texture = textures.find(tex => tex.name === name);\r\n        if (!texture) return;\r\n        vmBundle.setInput(texture.slot + SRV0_REGISTER, layout);\r\n    }\r\n\r\n    assert(numthreads[0] >= 1 && numthreads[1] === 1 && numthreads[2] === 1);\r\n\r\n    function run(numgroups: number) {\r\n        vmBundle.dispatch({ x: numgroups, y: 1, z: 1 }, { x: numthreads[0], y: numthreads[1], z: numthreads[2] });\r\n    }\r\n\r\n    return {\r\n        uavs,\r\n        bundle: vmBundle,\r\n        run,\r\n        setConstants,\r\n        setInt32Constant,\r\n        setUint32Constant,\r\n\r\n        setTrimesh,\r\n        setTexture,\r\n\r\n        groupsizex: numthreads[0]\r\n    };\r\n}\r\n\r\n\r\nconst UAV = {\r\n    overwriteCounter(uav: Bytecode.IUAV, value: number) {\r\n        VM.memoryToI32Array(uav.buffer)[0] = value;\r\n    },\r\n\r\n    readCounter(uav: Bytecode.IUAV): number {\r\n        return VM.memoryToI32Array(uav.buffer)[0];\r\n    },\r\n\r\n    readElement({ data, elementSize }: Bytecode.IUAV, iElement: number): Uint8Array {\r\n        const u8a = VM.memoryToU8Array(data);\r\n        return new Uint8Array(u8a.buffer, u8a.byteOffset + iElement * elementSize, elementSize);\r\n    },\r\n\r\n    minidump(uav: Bytecode.IUAV): void {\r\n        const { name, length, elementSize, register, data } = uav;\r\n        // std::cout << \"--------------------------------------\" << std::endl;\r\n        console.log(` uav ${name}[${length}x${elementSize}:r${register}:cnt(${UAV.readCounter(uav)})]`);\r\n\r\n        const u8a = VM.memoryToU8Array(data);\r\n        let n = Math.min(64, length * elementSize);\r\n        let sout = '';\r\n        for (let i = 0; i < n; ++i) {\r\n            sout += `${u8a[i].toString(16)} `;\r\n        }\r\n        sout += '...';\r\n        console.log(sout);\r\n        // std::cout << \"--------------------------------------\" << std::endl;\r\n    }\r\n};\r\n\r\n\r\n\r\n// tslint:disable-next-line:max-func-body-length\r\nfunction createEmiterFromBundle(bundle: BundleT, uavResources: IUAVResource[]): IEmitter {\r\n    const { name, content } = bundle;\r\n    const { capacity, particle, simulationRoutines, renderPasses } = content as PartBundleT;\r\n\r\n    const resetBundle = setupFxRoutineBytecodeBundle(`${name}/reset`, <RoutineBytecodeBundleT>simulationRoutines[EPartSimRoutines.k_Reset], capacity, uavResources);\r\n    const initBundle = setupFxRoutineBytecodeBundle(`${name}/init`, <RoutineBytecodeBundleT>simulationRoutines[EPartSimRoutines.k_Init], capacity, uavResources);\r\n    const updateBundle = setupFxRoutineBytecodeBundle(`${name}/update`, <RoutineBytecodeBundleT>simulationRoutines[EPartSimRoutines.k_Update], capacity, uavResources);\r\n    const spawnBundle = setupFxRoutineBytecodeBundle(`${name}/spawn`, <RoutineBytecodeBundleT>simulationRoutines[EPartSimRoutines.k_Spawn], 4, uavResources);\r\n\r\n    const uavDeadIndices = uavResources.find(uav => uav.name === FxTranslator.UAV_DEAD_INDICES);\r\n    const uavParticles = uavResources.find(uav => uav.name === FxTranslator.UAV_PARTICLES);\r\n    const uavStates = uavResources.find(uav => uav.name === FxTranslator.UAV_STATES);\r\n    const uavInitArguments = uavResources.find(uav => uav.name === FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS);\r\n    const uavCreationRequests = uavResources.find(uav => uav.name === FxTranslator.UAV_CREATION_REQUESTS);\r\n    const uavSpawnEmitter = uavResources.find(uav => uav.name === FxTranslator.UAV_SPAWN_EMITTER);\r\n\r\n    function preparePrerender() {\r\n        passes.forEach((p, i) => {\r\n            p.preparePrerender();\r\n        });\r\n    }\r\n\r\n    const passes = renderPasses.map((pass, i) => {\r\n        const {\r\n            routines,\r\n            geometry,\r\n            sorting,\r\n            instanceCount,\r\n            instance,\r\n            stride,\r\n            renderStates\r\n        } = pass;\r\n\r\n        const UAV_PRERENDERED = `${FxTranslator.UAV_PRERENDERED}${i}`;\r\n        const UAV_SERIALS = `${FxTranslator.UAV_SERIALS}${i}`;\r\n\r\n        const prerenderBundle = routines[EPartRenderRoutines.k_Prerender];\r\n        const bundle = setupFxRoutineBytecodeBundle(`${name}/prerender`, <RoutineBytecodeBundleT>prerenderBundle, capacity * instanceCount, uavResources);\r\n\r\n        const uavPrerendered = uavResources.find(uav => uav.name === UAV_PRERENDERED);\r\n        const uavSerials = uavResources.find(uav => uav.name === UAV_SERIALS);\r\n\r\n        const vertexBundle = <RoutineShaderBundleT>routines[EPartRenderRoutines.k_Vertex];\r\n        const vertexGLSLBundle = <RoutineGLSLSourceBundleT>vertexBundle.shaders.find((shader, i) => vertexBundle.shadersType[i] === RoutineSourceBundle.RoutineGLSLSourceBundle);\r\n\r\n        const pixelBundle = <RoutineShaderBundleT>routines[EPartRenderRoutines.k_Pixel];\r\n        const pixelGLSLBundle = <RoutineGLSLSourceBundleT>pixelBundle.shaders.find((shader, i) => pixelBundle.shadersType[i] === RoutineSourceBundle.RoutineGLSLSourceBundle);\r\n\r\n        const vertexShader = <string>vertexGLSLBundle.code;\r\n        const pixelShader = <string>pixelGLSLBundle.code;\r\n        const instanceLayout = vertexGLSLBundle.attributes;\r\n\r\n        const getNumRenderedParticles = () => UAV.readCounter(uavPrerendered) * instanceCount;\r\n\r\n        // if no prerender bundle then all particles must be prerendered within update stage\r\n        // looking for prerendered reflection among prerender or update routine uavs\r\n        const uavPrerendReflect: UAVBundleT = (<RoutineBytecodeBundleT>(bundle ? routines[EPartRenderRoutines.k_Prerender] : simulationRoutines[EPartSimRoutines.k_Update]))\r\n            .resources.uavs.find(uavReflection => uavReflection.name === UAV_PRERENDERED);\r\n\r\n        const cbufs: IMap<IConstantBuffer> = {};\r\n        const scanCbuffer = (sharedCbufs: IMap<IConstantBuffer>, bundle: RoutineGLSLSourceBundleT, usage: EUsage) => {\r\n            for (let { name, slot, size, fields } of bundle.cbuffers) {\r\n                // skip same name buffers\r\n                const cbuf = sharedCbufs[`${name}`] ||= {\r\n                    name: `${name}`,\r\n                    slot,\r\n                    size,\r\n                    usage,\r\n                    fields: fields.map(({ name, semantic, size, padding, type: { length } }) =>\r\n                    ({\r\n                        name: `${name}`,\r\n                        semantic: `${semantic || name}`,\r\n                        size,\r\n                        padding,\r\n                        length\r\n                    }))\r\n                };\r\n                cbuf.usage |= usage;\r\n            }\r\n        };\r\n\r\n        // merge VS & PS constant buffer into shared list \r\n        // it's guaranteed by translator that buffers with the same name are the same\r\n        scanCbuffer(cbufs, vertexGLSLBundle, EUsage.k_Vertex);\r\n        scanCbuffer(cbufs, pixelGLSLBundle, EUsage.k_Pixel);\r\n\r\n        const cbuffers = Object.values(cbufs);\r\n\r\n        //\r\n        // Sorting\r\n        //\r\n\r\n        const uavNonSorted = uavPrerendered;\r\n        // share memory with WASM bundle if used\r\n        const uavNonSortedU8 = VM.memoryToU8Array(uavNonSorted.data);\r\n\r\n        let uavPrerendReflectSorted: UAVBundleT = null;\r\n        let uavSorted: Bytecode.IUAV = null;\r\n        let uavSortedU8: Uint8Array = null;\r\n        let uavSerialsI32: Int32Array = null;\r\n\r\n        if (sorting) {\r\n            uavPrerendReflectSorted = new UAVBundleT(`${uavPrerendReflect.name}Sorted`, uavPrerendReflect.slot, uavPrerendReflect.stride, uavPrerendReflect.type);\r\n            uavSorted = createUAVsEx([uavPrerendReflectSorted], capacity * instanceCount, uavResources)[0];\r\n            uavSortedU8 = VM.memoryToU8Array(uavSorted.data);\r\n            uavSerialsI32 = VM.memoryToI32Array(uavSerials.data);\r\n        }\r\n\r\n\r\n        // dump prerendered particles\r\n        const dump = (): void => {\r\n            let nPart = getNumRenderedParticles();\r\n            verbose(`dump ${nPart}/${capacity} prerendred particles: `);\r\n            for (let iElement = 0; iElement < nPart; ++iElement) {\r\n                verbose(VM.asNativeRaw(UAV.readElement(uavNonSorted, iElement), instance));\r\n            }\r\n        };\r\n\r\n\r\n        function serialize() {\r\n            if (!sorting) {\r\n                return;\r\n            }\r\n\r\n            const nStrideF32 = stride * instanceCount; // stride in floats\r\n\r\n            assert(uavSortedU8.byteLength >> 2 === nStrideF32 * capacity);\r\n\r\n            const srcF32 = new Float32Array(uavNonSortedU8.buffer, uavNonSortedU8.byteOffset, uavNonSortedU8.byteLength >> 2);\r\n            const dstF32 = new Float32Array(uavSortedU8.buffer, uavSortedU8.byteOffset, uavSortedU8.byteLength >> 2);\r\n\r\n            const indicies = [];\r\n\r\n            // todo: sort inplace using serials pairs\r\n            for (let iPart = 0; iPart < UAV.readCounter(uavPrerendered); ++iPart) {\r\n                const sortIndex = uavSerialsI32[iPart * 2 + 0];\r\n                const partIndex = uavSerialsI32[iPart * 2 + 1];\r\n                indicies.push([partIndex, sortIndex]);\r\n            };\r\n            indicies.sort((a, b) => -a[1] + b[1]);\r\n\r\n            for (let i = 0; i < indicies.length; ++i) {\r\n                const iFrom = indicies[i][0] * nStrideF32;\r\n                const iTo = i * nStrideF32;\r\n\r\n                const from = srcF32.subarray(iFrom, iFrom + nStrideF32);\r\n                const copyTo = dstF32.subarray(iTo, iTo + nStrideF32);\r\n                copyTo.set(from);\r\n            }\r\n        }\r\n\r\n        function getData() { return asBundleMemory(sorting ? uavSortedU8 : uavNonSortedU8); }\r\n        function getDesc() {\r\n            const states = {};\r\n            renderStates.forEach(({ type, value }) => { states[type] = value; });\r\n            return {\r\n                instanceName: instance.name as string,\r\n                instanceLayout: instanceLayout.map(({ name, offset, size }) => ({ name: <string>name, offset, size })), // FIXME\r\n                stride,\r\n                geometry: <string>geometry,                                                                             // FIXME\r\n                sorting,\r\n                vertexShader,\r\n                pixelShader,\r\n                renderStates: states,\r\n                cbuffers\r\n            };\r\n        }\r\n\r\n\r\n        function preparePrerender() {\r\n            if (uavPrerendered) {\r\n                UAV.overwriteCounter(uavPrerendered, 0);\r\n            }\r\n            if (uavSerials) {\r\n                UAV.overwriteCounter(uavSerials, 0);\r\n            }\r\n        }\r\n\r\n\r\n        function prerender(uniforms: Uniforms) {\r\n            if (!bundle) {\r\n                // manual prerender is used\r\n                return;\r\n            }\r\n\r\n            // simulation could be omitted (effect is paused for ex.) \r\n            // but prerender counters still have to be dropped\r\n            // if we want to continue prerender every frame\r\n            preparePrerender();\r\n            bundle.setConstants(uniforms);\r\n            bundle.run(Math.ceil(capacity / bundle.groupsizex));\r\n        }\r\n\r\n\r\n        function setTexture(name: string, tex: ITexture) {\r\n            bundle?.setTexture(name, tex);\r\n        }\r\n\r\n\r\n        function setTrimesh(name: string, mesh: ITrimesh) {\r\n            bundle?.setTrimesh(name, mesh);\r\n        }\r\n\r\n\r\n        return {\r\n            getDesc,\r\n            getData,\r\n            getNumRenderedParticles,                                                                           // FIXME\r\n            setTexture,\r\n            setTrimesh,\r\n            serialize,\r\n            preparePrerender,\r\n            prerender,\r\n            dump\r\n        };\r\n    });\r\n\r\n    const getNumParticles = () => capacity - UAV.readCounter(uavDeadIndices);\r\n    const getName = () => <string>name;\r\n    const getType = (): 'emitter' => 'emitter';\r\n    const getPassCount = () => passes.length;\r\n    const getPass = (i: number) => passes[i];\r\n    const getCapacity = () => capacity;\r\n\r\n\r\n    function setTrimesh(name: string, mesh: ITrimesh) {\r\n        spawnBundle.setTrimesh(name, mesh);\r\n        initBundle.setTrimesh(name, mesh);\r\n        updateBundle.setTrimesh(name, mesh);\r\n        passes.forEach(pass => pass.setTrimesh(name, mesh));\r\n    }\r\n\r\n\r\n    function setTexture(name: string, tex: ITexture): void {\r\n        spawnBundle.setTexture(name, tex);\r\n        initBundle.setTexture(name, tex);\r\n        updateBundle.setTexture(name, tex);\r\n        passes.forEach(pass => pass.setTexture(name, tex));\r\n    }\r\n\r\n    function reset() {\r\n        // reset all available particles\r\n        resetBundle.run(Math.ceil(capacity / resetBundle.groupsizex));\r\n        UAV.overwriteCounter(uavDeadIndices, capacity);\r\n    }\r\n\r\n\r\n    function update(uniforms: Uniforms) {\r\n        // drop prerender counters all the time before update\r\n        // because some effects may use \"draw\" operator\r\n        // which means that simulation and preprender are mixed\r\n        preparePrerender();\r\n\r\n        updateBundle.setConstants(uniforms);\r\n        updateBundle.run(Math.ceil(capacity / updateBundle.groupsizex));\r\n    }\r\n\r\n\r\n    function prerender(uniforms: Uniforms) {\r\n        passes.forEach(pass => pass.prerender(uniforms));\r\n    }\r\n\r\n    function serialize() {\r\n        passes.forEach(pass => pass.serialize());\r\n    }\r\n\r\n\r\n    function emit(uniforms: Uniforms) {\r\n        initBundle.setConstants(uniforms);\r\n        initBundle.run(VM.memoryToI32Array(uavInitArguments.data)[0]);\r\n\r\n        spawnBundle.setConstants(uniforms);\r\n        spawnBundle.run(1);\r\n    }\r\n\r\n    function simulate(uniforms: Uniforms) {\r\n        update(uniforms);\r\n        emit(uniforms);\r\n    }\r\n\r\n    /** @deprecated */\r\n    function dump() {\r\n        const npart = getNumParticles();\r\n        const partSize = particle.size;\r\n\r\n        verbose(`particles total: ${npart} ( ${UAV.readCounter(uavDeadIndices)}/${capacity} )`);\r\n\r\n        const uavStatesI32 = VM.memoryToI32Array(uavStates.data);\r\n        const uavParticlesU8 = VM.memoryToU8Array(uavParticles.data);\r\n\r\n        uavStatesI32.forEach((alive, iPart) => {\r\n            if (alive) {\r\n                const partRaw = new Uint8Array(uavParticlesU8.buffer, uavParticlesU8.byteOffset + iPart * partSize, partSize);\r\n                verbose(iPart, VM.asNativeRaw(partRaw, particle));\r\n            }\r\n        });\r\n    }\r\n\r\n    function createDebugViewer() {\r\n        return createParticleDebugViewer(\r\n            particle, \r\n            capacity, \r\n            uavDeadIndices, \r\n            uavStates, \r\n            uavParticles\r\n        );\r\n    }\r\n\r\n    return {\r\n        // abstract interface\r\n        getType,\r\n        getName,\r\n        getCapacity,\r\n        getPassCount,\r\n        getPass,\r\n        getNumParticles,\r\n\r\n        reset,\r\n        simulate,\r\n        prerender,\r\n        serialize,\r\n\r\n        setTrimesh,\r\n        setTexture,\r\n\r\n        dump,\r\n        createDebugViewer\r\n    };\r\n}\r\n\r\ntype TSEmitter = ReturnType<typeof createTsEmitter>;\r\n\r\nfunction compareFxTypeLayouts(left: TypeLayoutT, right: TypeLayoutT) {\r\n    return JSON.stringify(left) == JSON.stringify(right);\r\n}\r\n\r\n// function compareFxControls(left: UIControlT[], right: UIControlT[]) {\r\n//     return JSON.stringify(left) == JSON.stringify(right);\r\n// }\r\n\r\n// todo: rework comparisson to be more readable and compact\r\nfunction comparePartFxBundles(left: PartBundleT, right: PartBundleT): boolean {\r\n    if (left.capacity != right.capacity) return false;\r\n    if (left.renderPasses.length != right.renderPasses.length) return false;\r\n    if (!compareFxTypeLayouts(left.particle, right.particle)) return false;\r\n    for (let i = 0; i < left.renderPasses.length; ++i) {\r\n        if (left.renderPasses[i].geometry != right.renderPasses[i].geometry) return false;\r\n        if (left.renderPasses[i].sorting != right.renderPasses[i].sorting) return false;\r\n        if (left.renderPasses[i].instanceCount != right.renderPasses[i].instanceCount) return false;\r\n        if (!compareFxTypeLayouts(left.renderPasses[i].instance, right.renderPasses[i].instance)) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function copyTsEmitter(dst: ITechnique, src: ITechnique): boolean {\r\n    assert(dst.getType() === 'emitter' && src.getType() === 'emitter');\r\n    if (comparePartFxBundles((<TSEmitter>dst).bundle.content as PartBundleT, (<TSEmitter>src).bundle.content as PartBundleT)) {\r\n        (<TSEmitter>dst).uavResources.forEach((uav, i) =>\r\n            VM.memoryToU8Array(uav.buffer).set(VM.memoryToU8Array((<TSEmitter>src).uavResources[i].buffer)));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function destroyTsEmitter(tech: ITechnique): void {\r\n    assert(tech.getType() === 'emitter');\r\n    let emitter = <IEmitter>tech;\r\n    let { uavResources } = <TSEmitter>emitter;\r\n    uavResources.forEach(uav => {\r\n        VM.destroyUAV(uav);\r\n        // verbose(`UAV '${uav.name}' has been destroyed.`);\r\n    });\r\n    verbose(`emitter '${emitter.getName()}' has been dropped.`);\r\n}\r\n\r\nexport function createTsEmitter(bundle: BundleT) {\r\n    let uavResources: Bytecode.IUAV[] = [];\r\n    let newly = createEmiterFromBundle(bundle, uavResources);\r\n    return { bundle, uavResources, ...newly };\r\n}\r\n\r\n\r\nexport function createTsTexture({ width, height }: ITextureDesc, data: ArrayBufferView): TSTexture {\r\n    const DESCRIPTOR_SIZE = 64;\r\n    const bytesPerPixel = 4;\r\n    const size = bytesPerPixel * width * height;\r\n    const layout = new Uint8Array(DESCRIPTOR_SIZE + size);\r\n    const dest = layout.subarray(DESCRIPTOR_SIZE);\r\n    if (data) {\r\n        assert(data.byteLength === size);\r\n        const src = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n        dest.set(src);\r\n    } else {\r\n        dest.fill(0);\r\n    }\r\n\r\n    const desc = new DataView(layout.buffer, 0, DESCRIPTOR_SIZE);\r\n    desc.setInt32(0, width, true);\r\n    desc.setInt32(4, height, true);\r\n    // set format R8G8B8A8 == 0\r\n    desc.setInt32(8, 0, true);\r\n\r\n    return { layout: VM.copyViewToMemory(layout) };\r\n}\r\n\r\n\r\nexport function destroyTsTexture(texture: ITexture): void {\r\n    const { layout } = texture as TSTexture;\r\n    VM.releaseMemory(layout);\r\n    verbose(`texture has been dropped.`);\r\n}\r\n\r\n\r\nexport function createTsTrimesh(desc: ITrimeshDesc,\r\n    vertices: ArrayBufferView, faces: ArrayBufferView,\r\n    indicesAdj: ArrayBufferView, faceAdj: ArrayBufferView): TSTrimesh {\r\n    const { vertCount, faceCount } = desc;\r\n    return {\r\n        vertCount,\r\n        faceCount,\r\n        vertices: VM.copyViewToMemory(vertices),\r\n        faces: VM.copyViewToMemory(faces),\r\n        indicesAdj: VM.copyViewToMemory(indicesAdj),\r\n        faceAdj: VM.copyViewToMemory(faceAdj)\r\n    };\r\n}\r\n\r\n\r\nexport function destroyTsTrimesh(mesh: ITrimesh) {\r\n    const { vertices, faces, indicesAdj, faceAdj } = mesh as TSTrimesh;\r\n    VM.releaseMemory(vertices);\r\n    VM.releaseMemory(faces);\r\n    VM.releaseMemory(indicesAdj);\r\n    VM.releaseMemory(faceAdj);\r\n}\r\n","import { IMap } from '@lib/idl/IMap';\r\nimport { EUsage, IConstantBuffer, ITechnique9, ITechnique9PassDesc } from '@lib/idl/ITechnique9';\r\nimport { ITechnique } from '@lib/idl/ITechnique';\r\n\r\nimport { BundleT } from '@lib/idl/bundles/auto/fx/bundle';\r\nimport { MatBundleT } from '@lib/idl/bundles/auto/fx/mat-bundle';\r\nimport { RoutineShaderBundleT } from '@lib/idl/bundles/auto/fx/routine-shader-bundle';\r\nimport { EMatRenderRoutines } from '@lib/idl/bundles/auto/fx/emat-render-routines';\r\nimport { RoutineGLSLSourceBundleT } from '@lib/idl/bundles/auto/fx/routine-glslsource-bundle';\r\nimport { RoutineSourceBundle } from '@lib/idl/bundles/auto/fx/routine-source-bundle';\r\n\r\n/** @deprecated */\r\nfunction createMaterialFromBundle(bundle: BundleT): ITechnique9 {\r\n    const { name, content } = bundle;\r\n    const { renderPasses } = content as MatBundleT;\r\n\r\n    const passes = renderPasses.map((pass, i) => {\r\n        const {\r\n            routines,\r\n            instance,\r\n            stride,\r\n            renderStates\r\n        } = pass;\r\n\r\n        const vertexBundle = <RoutineShaderBundleT>routines[EMatRenderRoutines.k_Vertex];\r\n        const vertexGLSLBundle = <RoutineGLSLSourceBundleT>vertexBundle.shaders.find( (shader, i) => vertexBundle.shadersType[i] === RoutineSourceBundle.RoutineGLSLSourceBundle);\r\n\r\n        const pixelBundle = <RoutineShaderBundleT>routines[EMatRenderRoutines.k_Pixel];\r\n        const pixelGLSLBundle = <RoutineGLSLSourceBundleT>pixelBundle.shaders.find( (shader, i) => pixelBundle.shadersType[i] === RoutineSourceBundle.RoutineGLSLSourceBundle);\r\n        \r\n        const vertexShader = <string>vertexGLSLBundle.code;\r\n        const pixelShader = <string>pixelGLSLBundle.code;\r\n        const instanceLayout = vertexGLSLBundle.attributes;\r\n\r\n        const states = {};\r\n        renderStates.forEach(({ type, value }) => { states[type] = value; });\r\n\r\n        const cbufs: IMap<IConstantBuffer> = {};\r\n        const scanCbuffer = (sharedCbufs: IMap<IConstantBuffer>, bundle: RoutineGLSLSourceBundleT, usage: EUsage) => {\r\n            for (let { name, slot, size, fields } of bundle.cbuffers) {\r\n                // skip same name buffers\r\n                const cbuf = sharedCbufs[`${name}`] ||= {\r\n                    name: `${name}`, \r\n                    slot,\r\n                    size, \r\n                    usage,\r\n                    fields: fields.map(({ name, semantic, size, padding, type: { length } }) => \r\n                        ({ \r\n                            name: `${name}`, \r\n                            semantic: `${semantic || name}`, \r\n                            size, \r\n                            padding, \r\n                            length \r\n                        }))\r\n                };\r\n                cbuf.usage |= usage;\r\n            }\r\n        };\r\n\r\n        // merge VS & PS constant buffer into shared list \r\n        // it's guaranteed by translator that buffers with the same name are the same\r\n        scanCbuffer(cbufs, vertexGLSLBundle, EUsage.k_Vertex);\r\n        scanCbuffer(cbufs, pixelGLSLBundle, EUsage.k_Pixel);\r\n\r\n        const cbuffers = Object.values(cbufs);\r\n\r\n        function getDesc(): ITechnique9PassDesc {\r\n            return {\r\n                instanceName: instance.name as string,\r\n                instanceLayout: instanceLayout.map(({ name, offset, size }) => ({ name: <string>name, offset, size })), // FIXME\r\n                stride,                                                                          // FIXME\r\n                vertexShader,\r\n                pixelShader,\r\n                renderStates: states,\r\n                cbuffers\r\n            };\r\n        }\r\n\r\n        return {\r\n            getDesc\r\n        };\r\n    });\r\n\r\n\r\n    const getName = () => <string>name;\r\n    const getType = (): 'material' => 'material';\r\n    const getPassCount = () => passes.length;\r\n    const getPass = (i: number) => passes[i];\r\n\r\n    return {\r\n        // abstract interface\r\n        getType,\r\n        getName,\r\n        getPassCount,\r\n        getPass\r\n    };\r\n}\r\n\r\n/** @deprecated */\r\nexport function copyTsMaterial(dst: ITechnique, src: ITechnique): boolean\r\n{\r\n    return false;\r\n}\r\n\r\n/** @deprecated */\r\nexport function destroyTsMaterial(tech: ITechnique): void \r\n{\r\n    // nothing todo\r\n}\r\n\r\n/** @deprecated */\r\nexport function createTsMaterial(bundle: BundleT)\r\n{\r\n    let newly = createMaterialFromBundle(bundle);\r\n    return { bundle, ...newly };\r\n}\r\n","import { ITechnique11 } from \"@lib/idl/ITechnique11\";\r\nimport { ITechnique } from \"@lib/idl/ITechnique\";\r\n// import * as VM from '@lib/fx/bytecode/VM';\r\nimport * as TSVM from \"@lib/fx/bytecode/VM/ts/bridge\";\r\n\r\nimport { BundleT } from \"@lib/idl/bundles/auto/fx/bundle\";\r\nimport { Technique11BundleT } from \"@lib/idl/bundles/auto/technique11_generated\";\r\n\r\nfunction createTechnique11FromBundle(bundle: BundleT): ITechnique11 {\r\n    const { name, content } = bundle;\r\n    const tech11 = content as Technique11BundleT;\r\n\r\n    const passes = tech11.passes.map(({ code, shaders, shadersType }, i) => {\r\n        // const render = VM.make(`pass-${i}`, code);\r\n        // todo: add WASM support \r\n        const render = TSVM.make(`pass-${i}`, new Uint8Array(code));\r\n\r\n        return {\r\n            render,\r\n            shaders\r\n        };\r\n    });\r\n\r\n    const getName = () => <string>name;\r\n    const getType = (): 'technique11' => 'technique11';\r\n    const getPassCount = () => passes.length;\r\n    const getPass = (i: number) => passes[i];\r\n    // const vmBundle = VM.make(debugName, routineBundle.code);\r\n    return {\r\n        getType,\r\n        getName,\r\n        getPassCount,\r\n        getPass\r\n    };\r\n}\r\n\r\n////////////////////////////////////////////////\r\n\r\nexport function copyTsTechnique11(dst: ITechnique, src: ITechnique): boolean\r\n{\r\n    return false;\r\n}\r\n\r\nexport function destroyTsTechnique11(tech: ITechnique): void \r\n{\r\n    // nothing todo\r\n}\r\n\r\nexport function createTsTechnique11(bundle: BundleT)\r\n{\r\n    let newly = createTechnique11FromBundle(bundle);\r\n    return { bundle, ...newly };\r\n}\r\n","import { verbose } from '@lib/common';\r\n\r\nexport function make() {\r\n    let pauseTime: number;\r\n    let pauseDelay: number;\r\n    let startTime: number;\r\n    let elapsedTimeLevel: number;\r\n    let active: boolean;\r\n    let paused: number;\r\n    let frameNumber: number;\r\n\r\n    const constants = {\r\n        elapsedTime: 0,\r\n        elapsedTimeLevel: 0,\r\n        frameNumber: 0\r\n    };\r\n\r\n    function stop() {\r\n        active = false;\r\n        paused = 0;\r\n        verbose('timeline stopped');\r\n    }\r\n\r\n    function start() {\r\n        constants.elapsedTime = 0;\r\n        constants.elapsedTimeLevel = 0;\r\n        constants.frameNumber = 0;\r\n\r\n        paused = 0;\r\n        pauseDelay = 0;\r\n        pauseTime = 0;\r\n        frameNumber = 0;\r\n        startTime = Date.now();\r\n        elapsedTimeLevel = 0;\r\n        active = true;\r\n        verbose('timeline started');\r\n    }\r\n\r\n    function tick() {\r\n        if (isStopped() || isPaused()) {\r\n            return;\r\n        }\r\n\r\n        const dt = Date.now() - startTime - pauseDelay;\r\n        constants.elapsedTime = (dt - elapsedTimeLevel) / 1000;\r\n        constants.elapsedTimeLevel = elapsedTimeLevel / 1000;\r\n        constants.frameNumber = ++frameNumber;\r\n        elapsedTimeLevel = dt;\r\n        // frameNumber++;\r\n    }\r\n\r\n    function isStopped() {\r\n        return !active;\r\n    }\r\n\r\n    function isPaused() {\r\n        return !!paused;\r\n    }\r\n\r\n    function pause()\r\n    {\r\n        if (isStopped())\r\n            return;\r\n        \r\n        if (!isPaused()) {\r\n            pauseTime = Date.now();\r\n        }\r\n\r\n        paused++;\r\n    }\r\n\r\n    function unpause()\r\n    {\r\n        if (isStopped() || !isPaused())\r\n            return;\r\n        \r\n        paused--;\r\n\r\n        if (!isPaused()) {\r\n            pauseDelay += Date.now() - pauseTime;\r\n        }\r\n    }\r\n\r\n    function getConstants()\r\n    {\r\n        return constants;\r\n    }\r\n\r\n    return {\r\n        getConstants,\r\n        start,\r\n        stop,\r\n        tick,\r\n        isStopped,\r\n\r\n        pause,\r\n        unpause,\r\n        isPaused\r\n    };\r\n}\r\n\r\nexport type ITimeline = ReturnType<typeof make>;\r\n","import { assert } from \"@lib/common\";\r\nimport { createOutput, IOutput } from \"./Output\";\r\n\r\nexport class BaseEmitter {\r\n    private blocks: IOutput[] = [];\r\n    private stack: IOutput[] = [];\r\n\r\n    private top() { return this.stack[this.depth() - 1]; }\r\n    \r\n    private findOrCreateOutput(name?: string) {\r\n        const i = this.blocks.findIndex(block => name && block.name === name);\r\n        const block = i !== -1\r\n            ? this.blocks.splice(i, 1)[0]\r\n            : createOutput({ name });\r\n        return block;\r\n    }\r\n\r\n    protected depth() { \r\n        return this.stack.length;\r\n    }\r\n\r\n    begin(block?: string) {\r\n        this.stack.push(this.findOrCreateOutput(block));\r\n    }\r\n\r\n    /**\r\n     * @param prologue Move block to the beginning.\r\n     */\r\n    end(prologue = false) {\r\n        const block = this.stack.pop();\r\n        \r\n        if (block.isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        if (!prologue) {\r\n            this.blocks.push(block);\r\n        } else {\r\n            this.blocks = [ block, ...this.blocks ];\r\n        }\r\n    }\r\n\r\n    push(pad?) {\r\n        this.top().push(pad);\r\n    }\r\n\r\n    pop() {\r\n        this.top().pop();\r\n    }\r\n\r\n    emitNewline(n = 1) { Array(n).fill(0).forEach(i => this.top()?.newline()); }\r\n    emitKeyword(kw: string) { this.top()?.keyword(kw); }\r\n    emitNoSpace() { this.top()?.ignoreNextSpace(); }\r\n    emitSpace() { this.emitChar(' '); this.emitNoSpace(); }\r\n    emitChar(char: string) { this.top()?.add(char); }\r\n    emitLine(line: string) { \r\n        this.emitChar(line);\r\n        this.emitNewline(); \r\n    }\r\n\r\n    clear(): void {\r\n        assert(this.stack.length == 0);\r\n        this.blocks = [];\r\n    }\r\n\r\n    toString(): string {\r\n        const res = this.blocks\r\n            .map(block => block.toString())\r\n            .filter(code => !!code)\r\n            .join('\\n\\n');\r\n        this.clear();\r\n        return res;\r\n    }\r\n\r\n    valueOf(): string {\r\n        return this.toString();\r\n    }\r\n}","import { IInstruction, ITypeInstruction, IFunctionDeclInstruction, ITypeDeclInstruction, ITypedefInstruction, IVariableDeclInstruction, ICbufferInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLASTDocument } from \"@lib/idl/ISLASTDocument\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { CodeEmitter, CodeContext, ICodeEmitterOptions, ICodeContextOptions } from \"./CodeEmitter\";\r\n\r\nexport interface ICodeConvolutionContextOptions extends ICodeContextOptions {\r\n    textDocument?: ITextDocument;\r\n    slastDocument?: ISLASTDocument\r\n}\r\n\r\nexport class CodeConvolutionContext extends CodeContext {\r\n    declare readonly opts: ICodeConvolutionContextOptions;\r\n    \r\n    constructor(opts?: ICodeConvolutionContextOptions) {\r\n        super(opts);\r\n    }\r\n\r\n    // list of convolute includes\r\n    readonly includeDeps: string[] = [];\r\n\r\n    get textDocument(): ITextDocument { return this.opts.textDocument; }\r\n    get slastDocument(): ISLASTDocument { return this.opts.slastDocument; }\r\n}\r\n\r\nexport class CodeConvolutionEmitter<ContextT extends CodeConvolutionContext> extends CodeEmitter<ContextT> {\r\n    // todo: add caching\r\n    protected convoluteToInclude(ctx: ContextT, decl: IInstruction) {\r\n        if (!decl) {\r\n            return false;\r\n        }\r\n\r\n        if (!ctx.slastDocument || !ctx.textDocument) {\r\n            return false;\r\n        }\r\n\r\n        if (!decl.sourceNode) {\r\n            return false;\r\n        }\r\n\r\n        const src = decl.sourceNode.loc;\r\n        const includes = ctx.slastDocument.includes;\r\n\r\n        let dst = src;\r\n        while (dst && String(ctx.textDocument.uri) !== String(dst.start.file)) {\r\n            dst = includes.get(String(dst.start.file));\r\n        }\r\n\r\n        // no includes are found\r\n        if (dst == src) {\r\n            return false;\r\n        }\r\n\r\n        // extract original include expression\r\n        const { start, end } = dst;\r\n        const include = ctx.textDocument.source.substring(start.offset, end.offset);\r\n\r\n        // TODO: remove temp hack!\r\n        if (include.includes('lib.hlsl')) {\r\n            return false;\r\n        }\r\n\r\n        if (ctx.includeDeps.includes(include)) {\r\n            return true;\r\n        }\r\n\r\n        ctx.includeDeps.push(include);\r\n        return true;\r\n    }\r\n\r\n    emitComplexTypeDecl(ctx: ContextT, ctype: ITypeInstruction) {\r\n        if (!this.convoluteToInclude(ctx, ctype))\r\n            super.emitComplexTypeDecl(ctx, ctype);\r\n    }\r\n\r\n    emitFunction(ctx: ContextT, fn: IFunctionDeclInstruction) {\r\n        if (!this.convoluteToInclude(ctx, fn))\r\n            super.emitFunction(ctx, fn);\r\n    }\r\n\r\n    emitTypeDecl(ctx: ContextT, decl: ITypeDeclInstruction) {\r\n        if (!this.convoluteToInclude(ctx, decl))\r\n            super.emitTypeDecl(ctx, decl);\r\n    }\r\n\r\n    emitTypedef(ctx: ContextT, def: ITypedefInstruction) {\r\n        if (!this.convoluteToInclude(ctx, def))\r\n            super.emitTypedef(ctx, def);\r\n    }\r\n\r\n    emitGlobalVariable(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        if (!this.convoluteToInclude(ctx, decl))\r\n            super.emitGlobalVariable(ctx, decl);\r\n    }\r\n\r\n    emitCbuffer(ctx: ContextT, cbuf: ICbufferInstruction) {\r\n        if (!this.convoluteToInclude(ctx, cbuf))\r\n            super.emitCbuffer(ctx, cbuf);\r\n    }\r\n\r\n    emitTexture(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        if (!this.convoluteToInclude(ctx, decl))\r\n            super.emitTexture(ctx, decl);\r\n    }\r\n\r\n    toString(ctx?: ContextT): string {\r\n        const code = super.toString();\r\n        if (!ctx) {\r\n            return code;\r\n        }\r\n        if (!ctx.includeDeps.length) {\r\n            return code;\r\n        }\r\n        const includes = ctx.includeDeps.join('\\n');\r\n        return `${includes}\\n\\n${code}`;\r\n    }\r\n\r\n\r\n    emit(ctx: ContextT, instr: IInstruction): CodeConvolutionEmitter<ContextT> {\r\n        super.emit(ctx, instr);\r\n        return this;\r\n    }\r\n\r\n\r\n    private static ccEmitter = new CodeConvolutionEmitter({ omitEmptyParams: true });\r\n\r\n\r\n    static translate(instr: IInstruction, ctx: CodeConvolutionContext = new CodeConvolutionContext): string {\r\n        return CodeConvolutionEmitter.ccEmitter.emit(ctx, instr).toString(ctx);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n","import { assert, isBoolean, isDef, isNull } from \"@lib/common\";\r\nimport { instruction, variable, types } from \"@lib/fx/analisys/helpers\";\r\nimport { EInstructionTypes, IAnnotationInstruction, IArithmeticExprInstruction, IAssignmentExprInstruction, IAttributeInstruction, IBitwiseExprInstruction, ICastExprInstruction, ICbufferInstruction, ICompileExprInstruction, IComplexExprInstruction, IConditionalExprInstruction, IConstructorCallInstruction, IDeclStmtInstruction, IExprInstruction, IExprStmtInstruction, IForStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IIdExprInstruction, IIfStmtInstruction, IInitExprInstruction, IInstruction, IInstructionCollector, ILiteralInstruction, ILogicalExprInstruction, IPassInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IRelationalExprInstruction, IReturnStmtInstruction, IStateBlockInstruction, IStmtBlockInstruction, ITypeDeclInstruction, ITypedefInstruction, ITypedInstruction, ITypeInstruction, IUnaryExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { fn } from \"@lib/fx/analisys/helpers/fn\";\r\nimport { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { EVariableUsageFlags } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { isString } from \"@lib/util/s3d/type\";\r\nimport { BaseEmitter } from \"./BaseEmitter\";\r\nimport { BreakStmtInstruction } from \"../analisys/instructions/BreakStmtInstruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\n\r\nexport interface ITypeInfo {\r\n    typeName: string;\r\n    length: number;\r\n    usage?: string;\r\n}\r\n\r\nexport enum EUsages {\r\n    k_Vertex = 0x01,\r\n    k_Pixel = 0x02,\r\n    k_Compute = 0x04\r\n};\r\n\r\n\r\nexport interface IUavReflection {\r\n    register: number;\r\n    name: string;\r\n    /** @deprecated */\r\n    type: string;           // \"RWBuffer<float4>\", \"AppendBuffer<int>\" etc. \r\n    uavType: string;        // \"RWBuffer\"\r\n    elementType: string;    // \"float4\"\r\n};\r\n\r\n\r\nexport interface IBufferReflection {\r\n    register: number;\r\n    name: string;\r\n    /** @deprecated */\r\n    type: string;           // \"Buffer<float4>\", \"AppendBuffer<int>\" etc. \r\n    bufType: string;        // \"Buffer\"\r\n    elementType: string;    // \"float4\"\r\n}\r\n\r\n\r\nexport interface ITextureReflection {\r\n    register: number;\r\n    name: string;\r\n    /** @deprecated */\r\n    type: string;           // \"Texture2D<float4>\"\r\n    texType: string;        // \"Texture2D\"\r\n    elementType: string;    // \"float4\"\r\n}\r\n\r\n\r\nexport interface ICSShaderReflection {\r\n    name: string;\r\n    numthreads: number[];\r\n    uavs: IUavReflection[];\r\n    buffers: IBufferReflection[];\r\n    textures: ITextureReflection[];\r\n}\r\n\r\n\r\nexport interface IUniformReflection {\r\n    name: string;\r\n    typeName: string;\r\n    semantic?: string;\r\n    length?: number;\r\n}\r\n\r\n\r\nexport interface ICbReflection {\r\n    register: number;\r\n    name: string;\r\n    size: number; // byte length\r\n}\r\n\r\nexport interface ICodeEmitterOptions {\r\n    // do not print 'in' for function parameters even if it is specified\r\n    omitInUsage?: boolean;\r\n    // skip complex type parameters of zero size\r\n    omitEmptyParams?: boolean;\r\n}\r\n\r\n\r\nfunction pushUniq<T>(arr: Array<T>, elem: T) {\r\n    if (arr.indexOf(elem) == -1)\r\n        arr.push(elem);\r\n}\r\n\r\nexport type CodeContextMode = 'vs' | 'ps' | 'cs' | 'gs' | 'hs' | 'ds' | 'raw';\r\n\r\nexport interface ICodeContextOptions {\r\n    mode?: CodeContextMode;\r\n    // rename entry point\r\n    entryName?: string;\r\n\r\n    // temp solution\r\n    /** @deprecated Expected to use dynamic constants in the future. */\r\n    constants?: {\r\n        type: string;\r\n        value: number | boolean;\r\n    }[];\r\n}\r\n\r\n\r\nexport class CodeContext {\r\n    // known globals like: functions, types, uniforms etc.\r\n    private knownSignatures: Set<string> = new Set();\r\n\r\n    readonly uavs: IUavReflection[] = [];\r\n    readonly textures: ITextureReflection[] = [];\r\n    readonly buffers: IBufferReflection[] = [];\r\n    readonly cbuffers: ICbReflection[] = [];\r\n    readonly CSShaders: ICSShaderReflection[] = [];\r\n\r\n    protected CSShader?: ICSShaderReflection;\r\n\r\n    readonly opts: ICodeContextOptions;\r\n\r\n    constructor(opts: ICodeContextOptions = {}) {\r\n        this.opts = opts;\r\n        this.opts.mode ||= 'raw';\r\n        console.assert([ 'vs', 'ps', 'ds', 'hs', 'gs', 'cs', 'raw' ].includes(this.opts.mode));\r\n    }\r\n\r\n    get entryName(): string { return this.opts.entryName; }\r\n    get mode(): CodeContextMode { return this.opts.mode; }\r\n    isPixel() { return this.mode === 'ps'; }\r\n    isVertex() { return this.mode === 'vs'; }\r\n    isRaw() { return this.mode === 'raw'; }\r\n\r\n\r\n    has(signature: string): boolean {\r\n        return this.knownSignatures.has(signature);\r\n    }\r\n\r\n\r\n    add(signature: string): void {\r\n        assert(!this.has(signature));\r\n        this.knownSignatures.add(signature);\r\n    }\r\n\r\n\r\n    // note: cbuffers without predefined register are not supported yet (!)\r\n    addCbuffer(cbuf: ICbufferInstruction): ICbReflection {\r\n        assert(!this.has(cbuf.name));\r\n        this.add(cbuf.name);\r\n\r\n        const { name, type: { size } } = cbuf;\r\n        const register = SystemScope.resolveRegister(cbuf).index;\r\n        const buf = { name, size, register };\r\n        this.cbuffers.push(buf);\r\n\r\n        return buf;\r\n    }\r\n\r\n\r\n    addTexture(type: string, name: string): ITextureReflection {\r\n        assert(!this.has(name));\r\n        this.add(name);\r\n\r\n        const register = this.buffers.length + this.textures.length;\r\n        const regexp = /^([\\w]+)<([\\w0-9_]+)>$/;\r\n        const match = type.match(regexp) || [ `${type}<float4>`, `${type}`, `float4` ];\r\n        const texture = <ITextureReflection>{\r\n            name,\r\n            type,\r\n            texType: match[1],\r\n            elementType: match[2],\r\n            register\r\n        };\r\n\r\n        this.textures.push(texture);\r\n        return texture;\r\n    }\r\n\r\n\r\n    addUav(type: string, name: string): IUavReflection {\r\n        assert(!this.has(name));\r\n        this.add(name);\r\n\r\n        const register = this.uavs.length;\r\n        const regexp = /^([\\w]+)<([\\w0-9_]+)>$/;\r\n        const match = type.match(regexp);\r\n        assert(match);\r\n        const uav = {\r\n            name,\r\n            type,\r\n            uavType: match[1],\r\n            elementType: match[2],\r\n            register\r\n        };\r\n\r\n        this.uavs.push(uav);\r\n        return uav;\r\n    }\r\n\r\n\r\n\r\n    addBuffer(type: string, name: string): IBufferReflection {\r\n        assert(!this.has(name));\r\n        this.add(name);\r\n\r\n        const register = this.buffers.length + this.textures.length;\r\n        const regexp = /^([\\w]+)<([\\w0-9_]+)>$/;\r\n        const match = type.match(regexp);\r\n        assert(match);\r\n\r\n        const buf = {\r\n            name,\r\n            type,\r\n            bufType: match[1],\r\n            elementType: match[2],\r\n            register\r\n        };\r\n\r\n        this.buffers.push(buf);\r\n        return buf;\r\n    }\r\n\r\n\r\n    beginCsShader(name: string, numthreads: number[]) {\r\n        const uavs = [];\r\n        const buffers = [];\r\n        const textures = [];\r\n        this.CSShader = { name, numthreads, uavs, buffers, textures };\r\n    }\r\n\r\n\r\n    endCsShader() {\r\n        const sh = this.CSShader;\r\n        assert(sh);\r\n        assert(!this.has(sh.name));\r\n        this.add(sh.name);\r\n        this.CSShaders.push(sh);\r\n\r\n        this.CSShader = null;\r\n    }\r\n\r\n\r\n    linkBuffer(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            pushUniq(sh.buffers, this.buffers.find(b => b.name == name));\r\n        }\r\n    }\r\n\r\n\r\n    linkCbuffer(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            // pushUniq(sh.cbuffers, this.cbuffers.find(b => b.name == name));\r\n        }\r\n    }\r\n\r\n\r\n    linkUav(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            pushUniq(sh.uavs, this.uavs.find(u => u.name == name));\r\n        }\r\n    }\r\n\r\n    linkTexture(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            pushUniq(sh.textures, this.textures.find(t => t.name == name));\r\n        }\r\n    }\r\n}\r\n\r\nexport class CodeEmitter<ContextT extends CodeContext> extends BaseEmitter {\r\n    constructor(protected options: ICodeEmitterOptions = {}) {\r\n        super();\r\n    }\r\n\r\n\r\n    protected isMain() {\r\n        return this.depth() === 1;\r\n    }\r\n\r\n\r\n    protected resolveTypeName(type: ITypeInstruction): string {\r\n        return type.name;\r\n    }\r\n\r\n\r\n    protected resolveType(ctx: ContextT, type: ITypeInstruction): ITypeInfo {\r\n        if (!type) {\r\n            return null;\r\n        }\r\n\r\n        let complex = type.isComplex();\r\n\r\n        let length: number;\r\n        let typeName: string;\r\n        let usages: string[];\r\n        let usage: string;\r\n\r\n        if (!complex) {\r\n            typeName = this.resolveTypeName(type);\r\n        } else {\r\n            typeName = type.name;\r\n            // find original type instead of VariableType wrapper. \r\n            const originalType = type.scope.findType(type.name);\r\n            this.emit(ctx, originalType);\r\n        }\r\n\r\n        if (type.instructionType === EInstructionTypes.k_VariableType) {\r\n            const vtype = type as IVariableTypeInstruction;\r\n            usages = vtype.usages as string[];\r\n        }\r\n\r\n        if (type.isNotBaseArray()) {\r\n            length = type.length;\r\n        }\r\n\r\n        if (usages && usages.length) {\r\n            usage = usages.filter(u => !this.options.omitInUsage || u != 'in').join(' ');\r\n        }\r\n\r\n        return { typeName, length, usage };\r\n    }\r\n\r\n\r\n    emitBuffer(ctx: ContextT, type: string, name: string, comment?: string): void {\r\n        if (!ctx.has(name)) {\r\n            const buf = ctx.addBuffer(type, name);\r\n            this.begin();\r\n            {\r\n                comment && this.emitComment(comment);\r\n                this.emitKeyword(`${type} ${name}: register(t${buf.register});`);\r\n            }\r\n            this.end();\r\n        }\r\n        ctx.linkBuffer(name);\r\n    }\r\n\r\n\r\n    emitUav(ctx: ContextT, type: string, name: string, comment?: string): void {\r\n        if (!ctx.has(name)) {\r\n            const uav = ctx.addUav(type, name);\r\n            this.begin();\r\n            {\r\n                comment && this.emitComment(comment);\r\n                this.emitKeyword(`${type} ${name}: register(u${uav.register});`);\r\n            }\r\n            this.end();\r\n        }\r\n        ctx.linkUav(name);\r\n    }\r\n\r\n\r\n\r\n    emitTexture(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        const { name, type } = decl;\r\n        this.emitTextureRaw(ctx, type.name, name);\r\n    }\r\n\r\n\r\n\r\n    emitTextureRaw(ctx: ContextT, type: string, name: string, comment?: string): void {\r\n        if (!ctx.has(name)) {\r\n            const tex = ctx.addTexture(type, name);\r\n            this.begin();\r\n            {\r\n                comment && this.emitComment(comment);\r\n                this.emitKeyword(`${type} ${name}: register(t${tex.register});`);\r\n            }\r\n            this.end();\r\n        }\r\n        ctx.linkTexture(name);\r\n    }\r\n\r\n\r\n    emitLine(line: string, comment?: string) {\r\n        this.emitChar(line);\r\n        comment && assert(comment.split('\\n').length === 1);\r\n        comment && (this.emitChar('\\t'), this.emitComment(comment));\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    emitComment(comment: string) {\r\n        //\r\n        if (comment.indexOf('\\n') === -1) {\r\n            this.emitLine(`// ${comment}`);\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * \r\n         */\r\n        this.emitLine('/**');\r\n        this.push(' * ');\r\n        comment.split('\\n').forEach(line => this.emitLine(line));\r\n        this.pop();\r\n        this.emitLine(' */');\r\n    }\r\n\r\n\r\n    emitComplexType(ctx: ContextT, type: ITypeInstruction) {\r\n        assert(type.isComplex());\r\n        this.emitKeyword('struct');\r\n        this.emitKeyword(type.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n\r\n        type.fields.map(field => (this.emitComplexField(ctx, field), this.emitNewline()));\r\n\r\n        this.pop();\r\n        this.emitChar('}');\r\n    }\r\n\r\n\r\n    emitComplexTypeDecl(ctx: ContextT, ctype: ITypeInstruction) {\r\n        if (ctx.has(ctype.name)) {\r\n            return;\r\n        }\r\n\r\n        ctx.add(ctype.name);\r\n\r\n        this.begin();\r\n        this.emitComplexType(ctx, ctype);\r\n        this.emitChar(';');\r\n        this.end();\r\n    }\r\n\r\n    // todo: remove hack with rename mutator\r\n    emitVariableNoInit(ctx: ContextT, decl: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string): void {\r\n        const { typeName, length, usage } = this.resolveType(ctx, decl.type);\r\n        const name = rename ? rename(decl) : decl.name;\r\n\r\n        usage && this.emitKeyword(usage);\r\n        this.emitKeyword(typeName);\r\n        this.emitKeyword(name);\r\n        length && this.emitChar(`[${length}]`);\r\n        decl.semantic && this.emitSemantic(ctx, decl.semantic);\r\n        decl.annotation && this.emitAnnotation(ctx, decl.annotation);\r\n    }\r\n\r\n\r\n    // todo: remove hack with rename mutator\r\n    emitVariable(ctx: ContextT, src: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string): void {\r\n        this.emitVariableNoInit(ctx, src, rename);\r\n        if (src.initExpr) {\r\n            // blocks are valid for blend/raster/depth state initialization.\r\n            const isBlock = src.initExpr.instructionType === EInstructionTypes.k_StateBlockExpr;\r\n            if (!isBlock) {\r\n                this.emitKeyword('=');\r\n                this.emitSpace();\r\n            }\r\n            this.emitExpression(ctx, src.initExpr);\r\n        }\r\n    }\r\n\r\n\r\n    emitIfStmt(ctx: ContextT, stmt: IIfStmtInstruction): void {\r\n        this.emitKeyword('if');\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, stmt.cond);\r\n        this.emitChar(')');\r\n        this.emitNewline();\r\n\r\n        if (stmt.conseq) {\r\n            this.emitStmt(ctx, stmt.conseq);\r\n        } else {\r\n            this.emitChar(';');\r\n        }\r\n\r\n        if (stmt.contrary) {\r\n            this.emitNewline();\r\n            this.emitKeyword('else');\r\n            this.emitStmt(ctx, stmt.contrary);\r\n        }\r\n    }\r\n\r\n\r\n    emitSemantic(ctx: ContextT, semantic: string) {\r\n        this.emitChar(':');\r\n        this.emitKeyword(semantic);\r\n    }\r\n\r\n\r\n    emitAnnotation(ctx: ContextT, anno: IAnnotationInstruction) {\r\n        // TODO: add annotation emission.\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    emitCompile(ctx: ContextT, compile: ICompileExprInstruction) {\r\n        this.emitFunction(ctx, compile.function);\r\n\r\n        this.emitKeyword('compile');\r\n        this.emitKeyword(compile.function.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(ctx, compile.args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    protected evaluateEntryName(ctx: ContextT, fn: IFunctionDeclInstruction) {\r\n        const fnName = fn.name;\r\n        const entryName = ctx.entryName;\r\n        if (!isString(entryName)) return fnName;\r\n        if (isDef(fn.scope.functions[entryName]))\r\n            // todo: emit correct error\r\n            console.error('entry point already exists');\r\n        return entryName;\r\n    }\r\n\r\n\r\n    protected emitEntryParams(ctx: ContextT, params: IVariableDeclInstruction[]) {\r\n        // emit constants instead of uniforms arguments if provided\r\n        const constants = ctx.opts.constants;\r\n        if (constants) {\r\n            params.filter(p => p.type.isUniform()).forEach((param, i) => {\r\n                const c = constants[i];\r\n                const name = param.name;\r\n\r\n                if (ctx.has(name)) {\r\n                    // global variable with the same name as argument already exists\r\n                    console.assert(false, '?!');\r\n                    return;\r\n                }\r\n\r\n                ctx.add(name);\r\n                this.begin();\r\n                this.emitLine(`static const ${c.type} ${name} = ${String(c.value)};`);\r\n                this.end();\r\n            })\r\n        }\r\n\r\n        // skip uniform arguments if constant substitution were passed\r\n        params\r\n            .filter(p => (!this.options.omitEmptyParams || p.type.size !== 0) && (!p.type.isUniform() || !constants))\r\n            .forEach((param, i, list) => {\r\n                this.emitParam(ctx, param);\r\n                (i + 1 != list.length) && this.emitChar(',');\r\n            });\r\n    }\r\n\r\n\r\n    // todo: add compute entry support\r\n    protected emitEntryFunction(ctx: ContextT, fn: IFunctionDeclInstruction) {\r\n        const { def } = fn;\r\n        const { typeName } = this.resolveType(ctx, def.returnType);\r\n\r\n        this.begin();\r\n        {\r\n            // in case of hlsl materials it's typical to swap arbitrary name for bundle name\r\n            // to simplify further compilation\r\n            let fnName = this.evaluateEntryName(ctx, fn);\r\n            this.emitKeyword(typeName);\r\n            this.emitKeyword(fnName);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitEntryParams(ctx, def.params);\r\n            this.emitChar(')');\r\n\r\n            // todo: validate complex type sematics\r\n            // all the output parameters of entry function must have valid semantics\r\n            if (!def.returnType.isComplex()) {\r\n                if (ctx.isPixel()) {\r\n                    this.emitChar(':');\r\n                    this.emitKeyword(fn.semantic || 'SV_Target0');\r\n                }\r\n            }\r\n            this.emitNewline();\r\n            this.emitBlock(ctx, fn.impl);\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    protected emitAttributes(ctx: ContextT, attrs: IAttributeInstruction[]) {\r\n        attrs?.forEach(attr => {\r\n            this.emitChar(`[`);\r\n            this.emitNoSpace();\r\n            this.emitKeyword(attr.name);\r\n            this.emitNoSpace();\r\n            if (attr.args) {\r\n                this.emitChar('(');\r\n                this.emitNoSpace();\r\n                this.emitExpressionList(ctx, attr.args);\r\n                this.emitChar(')');\r\n                this.emitNoSpace();\r\n            }\r\n            this.emitChar(`]`);\r\n            this.emitNewline();\r\n        });\r\n    }\r\n    \r\n\r\n    protected emitRegularFunction(ctx: ContextT, fn: IFunctionDeclInstruction) {\r\n        if (!fn) {\r\n            return;\r\n        }\r\n\r\n        const { def } = fn;\r\n        const { typeName } = this.resolveType(ctx, def.returnType);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitAttributes(ctx, fn.attrs);\r\n            this.emitKeyword(typeName);\r\n            this.emitKeyword(fn.name);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitParams(ctx, def.params);\r\n            this.emitChar(')');\r\n            this.emitNewline();\r\n            if (fn.impl)\r\n                this.emitBlock(ctx, fn.impl);\r\n            else \r\n                this.emitChar(';');\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    emitFunction(ctx: ContextT, decl: IFunctionDeclInstruction) {\r\n        if (!decl) {\r\n            return;\r\n        }\r\n\r\n        const sign = fn.signature(decl.def);\r\n        if (ctx.has(sign)) {\r\n            return;\r\n        }\r\n\r\n        ctx.add(sign);\r\n\r\n        const isEntry = (this.depth() == 0) && !ctx.isRaw();\r\n        if (isEntry) this.emitEntryFunction(ctx, decl);\r\n        else this.emitRegularFunction(ctx, decl);\r\n    }\r\n\r\n\r\n    emitCollector(ctx: ContextT, collector: IInstructionCollector) {\r\n        this.begin();\r\n        for (let instr of collector.instructions) {\r\n            this.emit(ctx, instr);\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    emitTypeDecl(ctx: ContextT, decl: ITypeDeclInstruction) {\r\n        this.resolveType(ctx, decl.type);\r\n    }\r\n\r\n\r\n    emitTypedef(ctx: ContextT, def: ITypedefInstruction) {\r\n        // nothing todo because current implementation implies\r\n        // immediate target type substitution \r\n        return;\r\n        /*\r\n            this.emitKeyword('typedef');\r\n            // todo: add support for typedefs like:\r\n            //  typedef const float4 T;\r\n            //          ^^^^^^^^^^^^\r\n            this.emitKeyword(def.type.name);\r\n            this.emitKeyword(def.alias);\r\n            this.emitChar(';');\r\n            this.emitNewline();\r\n        */\r\n    }\r\n\r\n    emitForInit(ctx: ContextT, init: ITypedInstruction) {\r\n        if (instruction.isExpression(init)) {\r\n            this.emitExpression(ctx, init as IExprInstruction);\r\n        } else {\r\n            this.emitVariable(ctx, init as IVariableDeclInstruction);\r\n        }\r\n    }\r\n\r\n    emitForStmt(ctx: ContextT, stmt: IForStmtInstruction) {\r\n\r\n        //for(int i = 0;i < 4;++ i)\r\n        //{\r\n        //  ...\r\n        //}\r\n\r\n        this.emitKeyword('for');\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n\r\n        this.emitForInit(ctx, stmt.init);\r\n        this.emitChar(';');\r\n\r\n        this.emitExpression(ctx, stmt.cond);\r\n        this.emitChar(';');\r\n\r\n        this.emitExpression(ctx, stmt.step);\r\n        this.emitChar(')');\r\n\r\n        if (stmt.body.instructionType === EInstructionTypes.k_StmtBlock)\r\n            this.emitNewline();\r\n        this.emitStmt(ctx, stmt.body);\r\n    }\r\n\r\n\r\n    emitExpression(ctx: ContextT, expr: IExprInstruction) {\r\n        if (!expr) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n        | ICastExprInstruction\r\n        | ILogicalExprInstruction\r\n        | IPostfixIndexInstruction\r\n        | ISamplerStateBlockInstruction\r\n        */\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                return this.emitArithmetic(ctx, expr as IArithmeticExprInstruction);\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                return this.emitAssigment(ctx, expr as IAssignmentExprInstruction);\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                return this.emitPostfixPoint(ctx, expr as IPostfixPointInstruction);\r\n            case EInstructionTypes.k_IdExpr:\r\n                return this.emitIdentifier(ctx, expr as IIdExprInstruction);\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                return this.emitFCall(ctx, expr as IFunctionCallInstruction);\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                return this.emitCCall(ctx, expr as IConstructorCallInstruction);\r\n            case EInstructionTypes.k_FloatExpr:\r\n                return this.emitFloat(ctx, expr as ILiteralInstruction<number>);\r\n            case EInstructionTypes.k_IntExpr:\r\n                return this.emitInteger(ctx, expr as ILiteralInstruction<number>);\r\n            case EInstructionTypes.k_BoolExpr:\r\n                return this.emitBool(ctx, expr as ILiteralInstruction<boolean>);\r\n            case EInstructionTypes.k_StringExpr:\r\n                return this.emitString(ctx, expr as ILiteralInstruction<string>);\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return this.emitComplexExpr(ctx, expr as IComplexExprInstruction);\r\n            case EInstructionTypes.k_CompileExpr:\r\n                return this.emitCompile(ctx, expr as ICompileExprInstruction);\r\n            case EInstructionTypes.k_ConditionalExpr:\r\n                return this.emitConditionalExpr(ctx, expr as IConditionalExprInstruction);\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                return this.emitRelationalExpr(ctx, expr as IRelationalExprInstruction);\r\n            case EInstructionTypes.k_LogicalExpr:\r\n                return this.emitLogicalExpr(ctx, expr as ILogicalExprInstruction);\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                return this.emitUnaryExpr(ctx, expr as IUnaryExprInstruction);\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n                return this.emitPostfixArithmetic(ctx, expr as IPostfixArithmeticInstruction);\r\n            case EInstructionTypes.k_InitExpr:\r\n                return this.emitInitExpr(ctx, expr as IInitExprInstruction);\r\n            case EInstructionTypes.k_CastExpr:\r\n                return this.emitCast(ctx, expr as ICastExprInstruction);\r\n            case EInstructionTypes.k_BitwiseExpr:\r\n                return this.emitBitwise(ctx, expr as IBitwiseExprInstruction);\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                return this.emitPostfixIndex(ctx, expr as IPostfixIndexInstruction);\r\n            case EInstructionTypes.k_StateBlockExpr:\r\n                return this.emitStateBlockExpr(ctx, expr as IStateBlockInstruction);\r\n            default:\r\n                this.emitLine(`/* ... unsupported expression '${expr.instructionName}' ... */`);\r\n                assert(false, `unsupported instruction found: ${expr.instructionName}`);\r\n        }\r\n    }\r\n\r\n\r\n    emitFloat(ctx: ContextT, lit: ILiteralInstruction<number>) {\r\n        const sval = String(lit.value);\r\n        this.emitKeyword(sval);\r\n        (sval.indexOf('.') === -1) && this.emitChar('.');\r\n        this.emitChar('f');\r\n    }\r\n\r\n\r\n    emitBool(ctx: ContextT, lit: ILiteralInstruction<boolean>) {\r\n        this.emitKeyword(lit.value ? 'true' : 'false');\r\n    }\r\n    \r\n\r\n    emitString(ctx: ContextT, lit: ILiteralInstruction<string>) {\r\n        this.emitKeyword(lit.value);\r\n    }\r\n\r\n\r\n    emitComplexExpr(ctx: ContextT, complex: IComplexExprInstruction) {\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, complex.expr);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitConditionalExpr(ctx: ContextT, cond: IConditionalExprInstruction) {\r\n        this.emitExpression(ctx, cond.condition);\r\n        this.emitKeyword('?');\r\n        this.emitExpression(ctx, cond.left as IExprInstruction);\r\n        this.emitKeyword(':');\r\n        this.emitExpression(ctx, cond.right as IExprInstruction);\r\n    }\r\n\r\n\r\n    emitInteger(ctx: ContextT, lit: ILiteralInstruction<number>) {\r\n        const int = lit as IntInstruction;\r\n        this.emitKeyword(`${int.heximal ? '0x' + int.value.toString(16).toUpperCase() : int.value.toFixed(0)}${!int.signed ? 'u' : ''}`);\r\n    }\r\n\r\n\r\n    emitRelationalExpr(ctx: ContextT, rel: IRelationalExprInstruction) {\r\n        this.emitExpression(ctx, rel.left);\r\n        this.emitKeyword(rel.operator);\r\n        this.emitExpression(ctx, rel.right);\r\n    }\r\n\r\n\r\n    emitLogicalExpr(ctx: ContextT, rel: ILogicalExprInstruction) {\r\n        this.emitExpression(ctx, rel.left);\r\n        this.emitKeyword(rel.operator);\r\n        this.emitExpression(ctx, rel.right);\r\n    }\r\n\r\n\r\n    emitUnaryExpr(ctx: ContextT, unary: IUnaryExprInstruction) {\r\n        this.emitChar(unary.operator);\r\n        this.emitExpression(ctx, unary.expr);\r\n    }\r\n\r\n\r\n    emitPostfixArithmetic(ctx: ContextT, par: IPostfixArithmeticInstruction) {\r\n        this.emitExpression(ctx, par.expr);\r\n        this.emitChar(par.operator);\r\n    }\r\n\r\n\r\n    emitPostfixIndex(ctx: ContextT, pfidx: IPostfixIndexInstruction) {\r\n        this.emitExpression(ctx, pfidx.element);\r\n        this.emitChar('[');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, pfidx.index);\r\n        this.emitChar(']');\r\n    }\r\n\r\n\r\n    emitStateBlockExpr(ctx: ContextT, stblk: IStateBlockInstruction) {\r\n        if (ctx.mode !== 'raw') {\r\n            // no need to emit state blocks in plain hlsl shaders\r\n            return;\r\n        }\r\n\r\n        assert('not implemented');\r\n    }\r\n\r\n\r\n    emitBreakStmt(ctx: ContextT, brk: BreakStmtInstruction) {\r\n        this.emitLine(`${brk.operator};`);\r\n    }\r\n\r\n\r\n    emitExpressionList(ctx: ContextT, list: IExprInstruction[]) {\r\n        list?.forEach((expr, i) => {\r\n            this.emitExpression(ctx, expr);\r\n            (i != list.length - 1) && this.emitChar(',');\r\n        })\r\n    }\r\n\r\n\r\n    emitParam(ctx: ContextT, param: IVariableDeclInstruction) {\r\n        this.emitVariable(ctx, param);\r\n    }\r\n\r\n\r\n    emitParams(ctx: ContextT, params: IVariableDeclInstruction[]) {\r\n        params.filter(p => !this.options.omitEmptyParams || p.type.size !== 0).forEach((param, i, list) => {\r\n            this.emitParam(ctx, param);\r\n            (i + 1 != list.length) && this.emitChar(',');\r\n        });\r\n    }\r\n\r\n\r\n    emitInitExpr(ctx: ContextT, init: IInitExprInstruction) {\r\n        if (init.args.length > 1) {\r\n            this.emitChar('{');\r\n            this.emitNoSpace();\r\n            this.emitExpressionList(ctx, init.args);\r\n            this.emitChar('}');\r\n            return;\r\n        }\r\n\r\n        this.emitExpression(ctx, init.args[0]);\r\n    }\r\n\r\n\r\n    emitCast(ctx: ContextT, cast: ICastExprInstruction) {\r\n        if (cast.isUseless()) {\r\n            return;\r\n        }\r\n\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n\r\n        const { typeName } = this.resolveType(ctx, cast.type);\r\n        this.emitKeyword(typeName);\r\n\r\n        this.emitChar(')');\r\n        this.emitNoSpace();\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, cast.expr);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitBitwise(ctx: ContextT, bwise: IBitwiseExprInstruction) {\r\n        this.emitExpression(ctx, bwise.left);\r\n        this.emitKeyword(bwise.operator);\r\n        this.emitSpace();\r\n        this.emitExpression(ctx, bwise.right);\r\n    }\r\n\r\n\r\n    emitArithmetic(ctx: ContextT, arthm: IArithmeticExprInstruction) {\r\n        this.emitExpression(ctx, arthm.left);\r\n        this.emitKeyword(arthm.operator);\r\n        this.emitSpace();\r\n        this.emitExpression(ctx, arthm.right);\r\n    }\r\n\r\n\r\n    emitAssigment(ctx: ContextT, asgm: IAssignmentExprInstruction) {\r\n        this.emitExpression(ctx, asgm.left);\r\n        this.emitKeyword(asgm.operator);\r\n        this.emitSpace();\r\n        assert(instruction.isExpression(asgm.right));\r\n        this.emitExpression(ctx, asgm.right as IExprInstruction);\r\n    }\r\n\r\n\r\n    emitPostfixPoint(ctx: ContextT, pfxp: IPostfixPointInstruction) {\r\n        // todo: skip brackets wherever possible to avoid exprs like (a).x;\r\n        if (pfxp.element.instructionType === EInstructionTypes.k_IdExpr ||\r\n            pfxp.element.instructionType === EInstructionTypes.k_PostfixPointExpr) {\r\n            this.emitExpression(ctx, pfxp.element);\r\n        } else {\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitExpression(ctx, pfxp.element);\r\n            this.emitChar(')');\r\n        }\r\n        this.emitChar('.');\r\n        this.emitChar(pfxp.postfix.name);\r\n    }\r\n\r\n\r\n    emitCbufferField(ctx: ContextT, field: IVariableDeclInstruction) {\r\n        this.emitVariable(ctx, field);\r\n        this.emitChar(';');\r\n        this.emitChar('\\t')\r\n        this.emitComment(`padding ${field.type.padding}, size ${field.type.size}`);\r\n    }\r\n\r\n\r\n    emitCbuffer(ctx: ContextT, cbuf: ICbufferInstruction) {\r\n        if (!ctx.has(cbuf.name)) {\r\n            ctx.addCbuffer(cbuf);\r\n\r\n            this.begin();\r\n            this.emitComment(`size: ${cbuf.type.size}`);\r\n            this.emitKeyword('cbuffer');\r\n            if (cbuf.id) {\r\n                this.emitKeyword(cbuf.name);\r\n            }\r\n            const reg = SystemScope.resolveRegister(cbuf);\r\n            if (reg.index !== -1) {\r\n                this.emitChar(':');\r\n                this.emitKeyword('register');\r\n                this.emitChar('(');\r\n                this.emitNoSpace();\r\n                this.emitKeyword(`${reg.type}${reg.index}`);\r\n                this.emitNoSpace();\r\n                this.emitChar(')');\r\n            }\r\n            this.emitNewline();\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                cbuf.type.fields.forEach(field => {\r\n                    this.emitCbufferField(ctx, field);\r\n                });\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n            this.emitChar(';');\r\n            // emit annotation?\r\n            this.end();\r\n        }\r\n        ctx.linkCbuffer(cbuf.name);\r\n    }\r\n\r\n\r\n    // request global declaration for local identifier\r\n    emitGlobal(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        const { name, type } = decl;\r\n        const isUniformArg = this.isMain() && decl.isParameter() && type.isUniform();\r\n\r\n        if (decl.isGlobal()/* || isUniformArg*/) {\r\n            if (decl.usageFlags & EVariableUsageFlags.k_Cbuffer) {\r\n                const cbufType = decl.parent;\r\n                const cbuf = <ICbufferInstruction>cbufType.parent;\r\n                this.begin();\r\n                this.emitCbuffer(ctx, cbuf);\r\n                this.end();\r\n            } else if (SystemScope.isTexture(type)) {\r\n                this.begin();\r\n                this.emitTexture(ctx, decl);\r\n                this.end();\r\n            } else {\r\n                this.begin();\r\n                this.emitGlobalVariable(ctx, decl);\r\n                this.end();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    emitIdentifier(ctx: ContextT, id: IIdExprInstruction) {\r\n        const { decl, name } = id;\r\n\r\n        this.emitGlobal(ctx, decl);\r\n        this.emitKeyword(name);\r\n    }\r\n\r\n\r\n    emitCCall(ctx: ContextT, call: IConstructorCallInstruction) {\r\n        const args = call.args as IExprInstruction[];\r\n        const { typeName } = this.resolveType(ctx, call.ctor);\r\n\r\n        this.emitKeyword(typeName);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(ctx, args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    // todo: remove hack with rename mutator\r\n    emitFCall(ctx: ContextT, call: IFunctionCallInstruction, rename: (decl: IFunctionDeclInstruction) => string = decl => decl.name) {\r\n        const { decl, args, callee } = call;\r\n\r\n        if (decl.instructionType !== EInstructionTypes.k_SystemFunctionDecl) {\r\n            this.emitFunction(ctx, decl);\r\n        }\r\n\r\n        if (callee) {\r\n            this.emitExpression(ctx, callee);\r\n            this.emitChar('.');\r\n            this.emitNoSpace();\r\n        }\r\n        this.emitKeyword(rename(decl));\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(ctx, args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitReturnStmt(ctx: ContextT, stmt: IReturnStmtInstruction) {\r\n        this.emitKeyword('return');\r\n        this.emitSpace();\r\n        this.emitExpression(ctx, stmt.expr);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitExpressionStmt(ctx: ContextT, stmt: IExprStmtInstruction) {\r\n        this.emitExpression(ctx, stmt.expr);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitLocalVariable(ctx: ContextT, stmt: IVariableDeclInstruction) {\r\n        this.emitVariable(ctx, stmt);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitGlobalVariable(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        if (ctx.has(decl.name)) {\r\n            return;\r\n        }\r\n\r\n        ctx.add(decl.name);\r\n\r\n        this.begin();\r\n        this.emitVariable(ctx, decl);\r\n        this.emitChar(';');\r\n        this.end();\r\n    }\r\n\r\n\r\n    emitComplexField(ctx: ContextT, instr: IVariableDeclInstruction) {\r\n        console.assert(instr.instructionType === EInstructionTypes.k_VariableDecl);\r\n\r\n        this.emitVariable(ctx, instr);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitDeclStmt(ctx: ContextT, stmt: IDeclStmtInstruction) {\r\n        stmt.declList.forEach(decl => {\r\n            console.assert(decl.instructionType === EInstructionTypes.k_VariableDecl);\r\n            this.emitLocalVariable(ctx, decl as IVariableDeclInstruction);\r\n        });\r\n    }\r\n\r\n\r\n    /*\r\n        | IStmtBlockInstruction\r\n        | IWhileStmtInstruction\r\n        | IForStmtInstruction;\r\n    */\r\n    emitStmt(ctx: ContextT, stmt: IInstruction) {\r\n        switch (stmt.instructionType) {\r\n            case EInstructionTypes.k_DeclStmt:\r\n                this.emitDeclStmt(ctx, stmt as IDeclStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ExprStmt:\r\n                this.emitExpressionStmt(ctx, stmt as IExprStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ReturnStmt:\r\n                this.emitReturnStmt(ctx, stmt as IReturnStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_SemicolonStmt:\r\n                this.emitChar(';');\r\n                break;\r\n            case EInstructionTypes.k_IfStmt:\r\n                this.emitIfStmt(ctx, stmt as IIfStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_StmtBlock:\r\n                this.emitBlock(ctx, stmt as IStmtBlockInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ForStmt:\r\n                this.emitForStmt(ctx, stmt as IForStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_BreakStmt:\r\n                this.emitBreakStmt(ctx, stmt as BreakStmtInstruction);\r\n                break;\r\n            default:\r\n                this.emitLine(`/* ... unsupported stmt '${stmt.instructionName}' .... */`);\r\n                console.warn(`unknown stmt found: '${stmt.instructionName}'`);\r\n        }\r\n    }\r\n\r\n\r\n    emitBlock(ctx: ContextT, blk: IStmtBlockInstruction) {\r\n        // if (!blk.stmtList.length)\r\n        // {\r\n        //     this.emitChar(';');\r\n        //     return;\r\n        // }\r\n\r\n        this.emitChar('{');\r\n        this.push();\r\n        blk.stmtList.forEach(stmt => (this.emitStmt(ctx, stmt), this.emitNewline()));\r\n        this.pop();\r\n        this.emitChar('}');\r\n    }\r\n\r\n\r\n    emitPass(ctx: ContextT, pass: IPassInstruction) {\r\n        this.emitKeyword('pass');\r\n        pass.name && this.emitKeyword(pass.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n        this.emitPassBody(ctx, pass);\r\n        this.pop();\r\n        this.emitChar('}');\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    emitPassBody(ctx: ContextT, pass: IPassInstruction) {\r\n        // TODO: replace with emitCompile();\r\n        if (pass.vertexShader) {\r\n            this.emitFunction(ctx, pass.vertexShader);\r\n\r\n            this.emitKeyword('VertexShader');\r\n            this.emitKeyword('=');\r\n            this.emitKeyword('compile');\r\n            this.emitKeyword(pass.vertexShader.name);\r\n            this.emitChar('()');\r\n            this.emitChar(';');\r\n            this.emitNewline();\r\n        }\r\n\r\n        if (pass.pixelShader) {\r\n            this.emitFunction(ctx, pass.pixelShader);\r\n\r\n            this.emitKeyword('PixelShader');\r\n            this.emitKeyword('=');\r\n            this.emitKeyword('compile');\r\n            this.emitKeyword(pass.pixelShader.name);\r\n            this.emitChar('()');\r\n            this.emitChar(';');\r\n            this.emitNewline();\r\n        }\r\n\r\n        if (pass.renderStates) {\r\n            for (let key in pass.renderStates) {\r\n                const state = pass.renderStates[key];\r\n                if (state != ERenderStateValues.UNDEF) {\r\n                    this.emitKeyword(ERenderStates[Number(key)]);\r\n                    this.emitChar('=');\r\n                    this.emitKeyword(ERenderStateValues[state]);\r\n                    this.emitChar(';');\r\n                    this.emitNewline();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.emitNewline();\r\n\r\n        // mwalk(pass.renderStates, (val, key) => {\r\n        //     console.log(ERenderStates[key], ERenderStateValues[val]);\r\n        // });\r\n    }\r\n\r\n\r\n    emit(ctx: ContextT, instr: IInstruction): CodeEmitter<ContextT> {\r\n        if (!instr) {\r\n            // TODO: emit error.\r\n            this.emitLine('/* ... empty instruction .... */');\r\n            return this;\r\n        }\r\n\r\n        if (instruction.isExpression(instr)) {\r\n            this.emitExpression(ctx, instr as IExprInstruction);\r\n            return this;\r\n        }\r\n\r\n        if (instruction.isStatement(instr)) {\r\n            this.emitStmt(ctx, instr);\r\n            return this;\r\n        }\r\n\r\n        //\r\n        // Other types\r\n        //\r\n\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_FunctionDecl:\r\n                this.emitFunction(ctx, instr as IFunctionDeclInstruction);\r\n                break;\r\n            case EInstructionTypes.k_CbufferDecl:\r\n                this.emitCbuffer(ctx, instr as ICbufferInstruction);\r\n                break;\r\n            case EInstructionTypes.k_VariableDecl:\r\n                this.emitGlobalVariable(ctx, instr as IVariableDeclInstruction);\r\n                break;\r\n            case EInstructionTypes.k_Collector:\r\n                this.emitCollector(ctx, instr as IInstructionCollector);\r\n                break;\r\n            case EInstructionTypes.k_TypeDecl:\r\n                this.emitTypeDecl(ctx, instr as ITypeDeclInstruction);\r\n                break;\r\n            case EInstructionTypes.k_TypedefDecl:\r\n                this.emitTypedef(ctx, instr as ITypedefInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ComplexType:\r\n            case EInstructionTypes.k_VariableType:\r\n                // todo: addComplexType ?\r\n                this.emitComplexTypeDecl(ctx, instr as ITypeInstruction);\r\n                break;\r\n            default:\r\n                this.emitLine(`/* ... unsupported instruction '${instr.instructionName}' .... */`);\r\n                assert(false, `unsupported instruction found: ${instr.instructionName}`);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    private static cEmitter = new CodeEmitter({ omitEmptyParams: true });\r\n\r\n    static translate(instr: IInstruction, ctx: CodeContext = new CodeContext): string {\r\n        return CodeEmitter.cEmitter.emit(ctx, instr).toString();\r\n    }\r\n\r\n    static translateDocument(document: ISLDocument, ctx: CodeContext = new CodeContext): string {\r\n        if (isNull(document)) {\r\n            return '';\r\n        }\r\n\r\n        if (isNull(document.root)) {\r\n            return '';\r\n        }\r\n\r\n        return CodeEmitter.translate(document.root, ctx);\r\n    }\r\n}\r\n\r\n// export function emit(instr: IInstruction): string {\r\n//     return CodeEmitter.translate(instr);\r\n// }\r\n","import { assert, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { T_INT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ICompileExprInstruction, IInstruction, IPresetInstruction, ITechnique11Instruction, ITechniqueInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IDrawStmtInstruction, IPartFxInstruction, IPartFxPassInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { CodeConvolutionContext, CodeConvolutionEmitter } from \"./CodeConvolutionEmitter\";\r\n\r\n\r\nexport class FxConvolutionContext extends CodeConvolutionContext {\r\n    protected technique?: ITechniqueInstruction | ITechnique11Instruction = null;\r\n\r\n\r\n    tech(): ITechniqueInstruction | ITechnique11Instruction {\r\n        return this.technique;\r\n    }\r\n\r\n\r\n    beginTechnique(tech: ITechniqueInstruction | ITechnique11Instruction) {\r\n        assert(isNull(this.technique));\r\n        this.technique = tech;\r\n    }\r\n\r\n\r\n    endTechnique() {\r\n        assert(isDefAndNotNull(this.technique));\r\n        this.technique = null;\r\n    }\r\n}\r\n\r\nexport class FxEmitter<ContextT extends FxConvolutionContext> extends CodeConvolutionEmitter<ContextT> {\r\n    protected emitRoutineProperty(ctx: ContextT, name: string, routine: ICompileExprInstruction) {\r\n        this.emitKeyword(name);\r\n        this.emitKeyword('=');\r\n        this.emitSpace();\r\n        this.emitCompile(ctx, routine);\r\n        this.emitChar(';');\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    protected emitStringProperty(ctx: ContextT, name: string, id: string) {\r\n        this.emitKeyword(name),\r\n            this.emitKeyword('='),\r\n            this.emitKeyword(id),\r\n            this.emitChar(';'),\r\n            this.emitNewline()\r\n    }\r\n\r\n\r\n    protected emitSpawnStmt(ctx: ContextT, stmt: ISpawnStmtInstruction) {\r\n        const fx = <IPartFxInstruction>ctx.tech();\r\n        const init = stmt.scope.findFunction(stmt.name, [fx.particle, T_INT, ...stmt.args.map(a => a.type)]);\r\n\r\n        this.emitFunction(ctx, init);\r\n\r\n        this.emitKeyword(`spawn(${stmt.count})`);\r\n        this.emitKeyword(stmt.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        stmt.args.forEach((arg, i, list) => {\r\n            this.emitExpression(ctx, arg);\r\n            (i + 1 != list.length) && this.emitChar(',');\r\n        });\r\n        this.emitChar(')');\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    protected emitDrawStmt(ctx: ContextT, stmt: IDrawStmtInstruction) {\r\n\r\n        this.emitKeyword(`draw`);\r\n        this.emitKeyword(stmt.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        stmt.args.forEach((arg, i, list) => {\r\n            this.emitExpression(ctx, arg);\r\n            (i + 1 != list.length) && this.emitChar(',');\r\n        });\r\n        this.emitChar(')');\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitPartFxDecl(ctx: ContextT, fx: IPartFxInstruction) {\r\n        ctx.beginTechnique(fx);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitKeyword('partFx');\r\n            fx.name && this.emitKeyword(fx.name);\r\n            fx.semantic && this.emitSemantic(ctx, fx.semantic);\r\n            fx.annotation && this.emitAnnotation(ctx, fx.annotation);\r\n            this.emitNewline();\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                fx.capacity && this.emitStringProperty(ctx, 'Capacity', String(fx.capacity));\r\n\r\n                fx.spawnRoutine && this.emitRoutineProperty(ctx, 'SpawnRoutine', fx.spawnRoutine);\r\n                fx.initRoutine && this.emitRoutineProperty(ctx, 'InitRoutine', fx.initRoutine);\r\n                fx.updateRoutine && this.emitRoutineProperty(ctx, 'UpdateRoutine', fx.updateRoutine);\r\n\r\n                this.emitNewline();\r\n                fx.passes.forEach((pass, i) => (this.emitPartFxPass(ctx, pass),\r\n                    i !== fx.passes.length - 1 && this.emitNewline()));\r\n                this.emitNewline();\r\n                fx.presets.forEach((preset, i) => (this.emitPresetDecl(ctx, preset),\r\n                    i !== fx.presets.length - 1 && this.emitNewline()));\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        ctx.endTechnique();\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    emitTechniqueDecl(ctx: ContextT, fx: ITechniqueInstruction) {\r\n        ctx.beginTechnique(fx);\r\n        this.begin();\r\n        {\r\n            this.emitKeyword('technique');\r\n            fx.name && this.emitKeyword(fx.name);\r\n            fx.semantic && this.emitSemantic(ctx, fx.semantic);\r\n            fx.annotation && this.emitAnnotation(ctx, fx.annotation);\r\n            this.emitNewline();\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitNewline();\r\n                fx.passes.forEach((pass, i) => (this.emitPass(ctx, pass),\r\n                    i !== fx.passes.length - 1 && this.emitNewline()));\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n        ctx.endTechnique();\r\n    }\r\n\r\n\r\n    emitTechnique11Decl(ctx: ContextT, fx: ITechnique11Instruction) {\r\n        console.warn(`emitTechnique11Decl() not implemented`);\r\n    }\r\n\r\n\r\n    emitPartFxPass(ctx: ContextT, pass: IPartFxPassInstruction) {\r\n        this.emitKeyword('pass');\r\n        pass.name && this.emitKeyword(pass.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n        {\r\n            pass.prerenderRoutine && this.emitRoutineProperty(ctx, 'PrerenderRoutine', pass.prerenderRoutine);\r\n            pass.sorting && this.emitStringProperty(ctx, 'Sorting', String(pass.sorting));\r\n            this.emitStringProperty(ctx, 'Geometry', `\"${pass.geometry}\"`);\r\n            pass.instanceCount !== 1 && this.emitStringProperty(ctx, 'InstanceCount', String(pass.instanceCount));\r\n\r\n            super.emitPassBody(ctx, pass);\r\n        }\r\n        this.pop();\r\n        this.emitChar('}');\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    emitPresetDecl(ctx: ContextT, preset: IPresetInstruction) {\r\n        this.emitKeyword('preset');\r\n        preset.name && this.emitKeyword(preset.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n        {\r\n            preset.props.forEach(prop => {\r\n                this.emitKeyword(prop.id.name);\r\n                this.emitKeyword('=');\r\n                this.emitKeyword('{');\r\n                this.emitExpressionList(ctx, prop.args);\r\n                this.emitKeyword('}');\r\n                this.emitChar(';');\r\n                this.emitNewline();\r\n            });\r\n        }\r\n        this.pop();\r\n        this.emitChar('}');\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    emitStmt(ctx: ContextT, stmt: IInstruction) {\r\n        switch (stmt.instructionType) {\r\n            case EInstructionTypes.k_SpawnStmt:\r\n                this.emitSpawnStmt(ctx, stmt as ISpawnStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_DrawStmt:\r\n                this.emitDrawStmt(ctx, stmt as IDrawStmtInstruction);\r\n                break;\r\n            default:\r\n                super.emitStmt(ctx, stmt);\r\n        }\r\n    }\r\n\r\n\r\n    emit(ctx: ContextT, instr: IInstruction): FxEmitter<ContextT> {\r\n        if (!instr) {\r\n            return this;\r\n        }\r\n\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_PartFxDecl:\r\n                this.emitPartFxDecl(ctx, instr as IPartFxInstruction);\r\n                break;\r\n            case EInstructionTypes.k_TechniqueDecl:\r\n                this.emitTechniqueDecl(ctx, instr as ITechniqueInstruction);\r\n                break;\r\n            case EInstructionTypes.k_Technique11Decl:\r\n                this.emitTechnique11Decl(ctx, instr as ITechnique11Instruction);\r\n                break;\r\n            default:\r\n                super.emit(ctx, instr)\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    private static fxEmitter = new FxEmitter({ omitEmptyParams: true });\r\n\r\n\r\n    static translate(instr: IInstruction, ctx: FxConvolutionContext = new FxConvolutionContext): string {\r\n        return FxEmitter.fxEmitter.emit(ctx, instr).toString(ctx);\r\n    }\r\n\r\n\r\n    static translateDocument(document: ISLDocument, ctx: FxConvolutionContext = new FxConvolutionContext): string {\r\n        if (isNull(document)) {\r\n            return '';\r\n        }\r\n        if (isNull(document.root)) {\r\n            return '';\r\n        }\r\n        return FxEmitter.translate(document.root, ctx);\r\n    }\r\n\r\n\r\n    static translateTechnique(document: ISLDocument, techName: string, ctx: FxConvolutionContext = new FxConvolutionContext): string {\r\n        if (isNull(document)) {\r\n            return '';\r\n        }\r\n        if (isNull(document.root)) {\r\n            return '';\r\n        }\r\n        return FxEmitter.translate(document.root.scope.findTechnique(techName), ctx);\r\n    }\r\n}\r\n\r\n","import { assert, isDef, isString } from \"@lib/common\";\r\nimport { types } from \"@lib/fx/analisys/helpers\";\r\nimport { FloatInstruction } from \"@lib/fx/analisys/instructions/FloatInstruction\";\r\nimport { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { StringInstruction } from \"@lib/fx/analisys/instructions/StringInstruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { isBoolBasedType, isFloatBasedType, isIntBasedType, isUintBasedType, T_FLOAT, T_FLOAT4, T_INT, T_VOID } from \"@lib/fx/analisys/SystemScope\";\r\nimport { ControlValueType, PropertyValueType } from \"@lib/fx/bundles/utils\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { EInstructionTypes, ICompileShader11Instruction, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IInitExprInstruction, IInstruction, ILiteralInstruction, ITechnique11Instruction, ITechniqueInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { EPassDrawMode, IDrawStmtInstruction, IPartFxInstruction, IPartFxPassInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\nimport { Color, Vector2, Vector3, Vector4 } from \"@sandbox/store/IStoreState\";\r\nimport { ICodeConvolutionContextOptions } from \"./CodeConvolutionEmitter\";\r\nimport { ICSShaderReflection, IUniformReflection } from \"./CodeEmitter\";\r\nimport { FxConvolutionContext, FxEmitter } from \"./FxEmitter\";\r\nimport { visitor } from '@lib/fx/Visitors';\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { EVariableUsageFlags } from \"../analisys/instructions/VariableDeclInstruction\";\r\n\r\nexport interface IViewTypeProperty {\r\n    name: string;\r\n    type: string;\r\n    value: PropertyValueType;\r\n}\r\n\r\nexport interface IUIControl {\r\n    name: string;\r\n    type: string;                       // like color\r\n    value: ControlValueType;\r\n    properties: IViewTypeProperty[];    // custom parameters, like min/max/step etc.\r\n}\r\n\r\nexport interface IPresetEntry {\r\n    name: string;\r\n    type: string;\r\n    value: ControlValueType;\r\n}\r\n\r\nexport interface IPreset {\r\n    name: string;\r\n    desc: string;\r\n    data: IPresetEntry[];\r\n}\r\n\r\nexport type IUIControlReflection = IUIControl;\r\n\r\n/** @deprecated */\r\nexport interface IPassReflection {\r\n    instance: string;\r\n    VSParticleShader: string;\r\n    PSParticleShader: string;\r\n\r\n    renderStates: { [key: number/* ERenderStates */]: ERenderStateValues };\r\n}\r\n\r\nexport interface IPass11Reflection {\r\n    // todo\r\n}\r\n\r\n\r\n/** @deprecated */\r\nexport interface ITechniqueReflection<PassT extends IPassReflection = IPassReflection> {\r\n    name: string;\r\n    passes: PassT[];\r\n    controls: IUIControl[];\r\n    presets: IPreset[];\r\n}\r\n\r\n\r\nexport interface ITechnique11Reflection<PassT extends IPass11Reflection = IPass11Reflection> {\r\n    name: string;\r\n    controls: IUIControl[];\r\n}\r\n\r\n\r\nexport interface ITriMeshReflection {\r\n    name: string; // original name\r\n    vertexCountUName: string;\r\n    faceCountUName: string;\r\n    verticesName: string;\r\n    facesName: string;\r\n    indicesAdjName: string; // GS suitable adj info, 6 x nFaces\r\n    faceAdjName: string;\r\n\r\n    // resourcePath: string;\r\n}\r\n\r\n\r\nexport interface IPartFxPassReflection extends IPassReflection {\r\n    sorting: boolean;\r\n    geometry: string;\r\n    instanceCount: number;\r\n    CSParticlesPrerenderRoutine: ICSShaderReflectionEx;\r\n    drawMode: number; // EPassDrawMode (0 - auto, 1 - manual)\r\n}\r\n\r\nexport interface IPartFxReflection extends ITechniqueReflection<IPartFxPassReflection> {\r\n    capacity: number;\r\n    particle: string; // << particle type name\r\n    CSParticlesSpawnRoutine: ICSShaderReflectionEx;\r\n    CSParticlesResetRoutine: ICSShaderReflectionEx;\r\n    CSParticlesInitRoutine: ICSShaderReflectionEx;\r\n    CSParticlesUpdateRoutine: ICSShaderReflectionEx;\r\n}\r\n\r\n// returns hlsl system type name corresponding to ui type\r\nfunction typeNameOfUIControl(ctrl: IUIControl) {\r\n    const type = ctrl.type;\r\n    switch (type) {\r\n        case 'color':\r\n            return 'float4';\r\n        case 'int':\r\n        case 'uint':\r\n        case 'float':\r\n        case 'float2':\r\n        case 'float3':\r\n        case 'float4':\r\n            return type;\r\n        default:\r\n            console.assert(false, `unsupported UI type: ${type}`);\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\nfunction pushUniq<T>(arr: Array<T>, elem: T) {\r\n    if (arr.indexOf(elem) == -1)\r\n        arr.push(elem);\r\n}\r\n\r\nconst camelToSnakeCase = str => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\r\n\r\n\r\nexport interface IFxContextExOptions extends ICodeConvolutionContextOptions {\r\n    uiControlsGatherToDedicatedConstantBuffer?: boolean;\r\n    uiControlsConstantBufferRegister?: number;\r\n    uiControlsConstantBufferName?: string;\r\n\r\n    globalUniformsGatherToDedicatedConstantBuffer?: boolean;\r\n    globalUniformsConstantBufferRegister?: number;\r\n    globalUniformsConstantBufferName?: string;\r\n\r\n    argUniformsToDedicatedConstantBuffer?: boolean;\r\n    argUniformsConstantBufferRegister?: number;\r\n    argUniformsConstantBufferName?: string;\r\n}\r\n\r\n\r\nexport interface ICSShaderReflectionEx extends ICSShaderReflection {\r\n    trimeshes: ITriMeshReflection[];\r\n}\r\n\r\n\r\nconst isPartId = (p: IVariableDeclInstruction) =>\r\n    (p.semantic === 'PART_ID' || p.name == 'partId') && types.equals(/u?int/, p.type);\r\nconst isSpawnId = (p: IVariableDeclInstruction) =>\r\n    (p.semantic === 'SPAWN_ID' || p.name == 'spawnId') && types.equals(/u?int/, p.type);\r\n\r\ninterface IOptParam {\r\n    name: string;\r\n    checker: (p: IVariableDeclInstruction) => boolean;\r\n}\r\n\r\nfunction resolveOptIndices(params: IOptParam[], def: IFunctionDefInstruction): number[] {\r\n    return params.map(({ checker }) => def.params.findIndex(checker));\r\n}\r\n\r\nfunction resolveOptArguments(params: IOptParam[], def: IFunctionDefInstruction): string[] {\r\n    const indices = resolveOptIndices(params, def);\r\n    const n = indices.filter(i => i !== -1).length;\r\n    const res = new Array(n);\r\n    for (let i = 0; i < indices.length; ++i) {\r\n        const pos = indices[i];\r\n        if (pos !== -1) {\r\n            res[pos] = params[i].name;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nexport const AUTOGEN_GLOBALS = `AUTOGEN_GLOBALS`;\r\nexport const AUTOGEN_CONTROLS = `AUTOGEN_CONTROLS`;\r\n\r\nexport class FxTranslatorContext extends FxConvolutionContext {\r\n    // (!) override\r\n    declare readonly CSShaders: ICSShaderReflectionEx[];\r\n\r\n    readonly techniques: (ITechniqueReflection | IPartFxReflection)[] = [];\r\n    readonly techniques11: ITechnique11Reflection[] = [];\r\n    readonly controls: IUIControlReflection[] = [];\r\n    readonly trimeshes: ITriMeshReflection[] = [];\r\n    // todo: use reflection\r\n    readonly uniforms: IUniformReflection[] = [];\r\n    // todo: use reflection\r\n    readonly spawners: IFunctionDeclInstruction[] = [];\r\n\r\n    // (!) override\r\n    declare protected CSShader?: ICSShaderReflectionEx;\r\n    // (!) override\r\n    declare readonly opts: IFxContextExOptions;\r\n\r\n\r\n    // specific reflection, signature has been already added during global variable processing\r\n    addControl(ctrl: IUIControl): IUIControlReflection {\r\n        this.controls.push(ctrl);\r\n        return ctrl;\r\n    }\r\n\r\n\r\n    addTechnique<T extends ITechniqueReflection | IPartFxReflection>(refl: T): T {\r\n        assert(!this.has(refl.name));\r\n        assert(!isDef(this.techniques[0]));\r\n        this.add(refl.name);\r\n        this.techniques[0] = refl;\r\n        return refl;\r\n    }\r\n\r\n\r\n    addTechnique11<T extends ITechnique11Reflection>(refl: T): T {\r\n        assert(!this.has(refl.name));\r\n        assert(!isDef(this.techniques[0]));\r\n        this.add(refl.name);\r\n        this.techniques11[0] = refl;\r\n        return refl;\r\n    }\r\n\r\n\r\n    addUniform(uniform: IUniformReflection): IUniformReflection {\r\n        this.uniforms.push(uniform);\r\n        return uniform;\r\n    }\r\n\r\n\r\n    addTrimesh(mesh: ITriMeshReflection): ITriMeshReflection {\r\n        assert(!this.has(mesh.name));\r\n        this.add(mesh.name);\r\n        this.trimeshes.push(mesh);\r\n        return mesh;\r\n    }\r\n\r\n\r\n    addSpawnCtor(decl: IFunctionDeclInstruction): IFunctionDeclInstruction {\r\n        assert(!this.has(decl.name));\r\n        this.add(decl.name);\r\n        this.spawners.push(decl);\r\n        return decl;\r\n    }\r\n\r\n\r\n    linkTrimesh(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            pushUniq(sh.trimeshes, this.trimeshes.find(t => t.name == name));\r\n        }\r\n    }\r\n\r\n    // override CodeEmitterContext::beginCsShader()\r\n    beginCsShader(name: string, numthreads: number[]) {\r\n        const uavs = [];\r\n        const buffers = [];\r\n        const textures = [];\r\n        const trimeshes = [];\r\n        this.CSShader = { name, numthreads, uavs, buffers, textures, trimeshes };\r\n    }\r\n}\r\n\r\n\r\nexport class FxTranslator<ContextT extends FxTranslatorContext> extends FxEmitter<ContextT> {\r\n    static UAV_PARTICLES = 'uavParticles';\r\n    static UAV_STATES = 'uavStates';\r\n    static UAV_DEAD_INDICES = 'uavDeadIndices';\r\n    static UAV_CREATION_REQUESTS = 'uavCreationRequests';\r\n    static UAV_PRERENDERED = 'uavPrerendered';\r\n    static UAV_SERIALS = 'uavSerials';\r\n    static UAV_SPAWN_DISPATCH_ARGUMENTS = 'uavSpawnDispatchArguments';\r\n    static UAV_SPAWN_EMITTER = `uavEmitter`;\r\n\r\n    private static UAV_PARTICLES_DESCRIPTION = `The buffer contains user-defined particle data.`;\r\n    private static UAV_STATES_DESCRIPTION = `The buffer contains the state of the particles, Alive or dead.`;\r\n    private static UAV_DEAD_INDICES_DESCRIPTION = `The buffer contains indicies of dead particles.`;\r\n    private static UAV_CREATION_REQUESTS_DESCRIPTION = 'The buffer contatins information about the number and type of particles to be created';\r\n    private static UAV_SERIALS_DESCRIPTION = 'The buffer contains hashes are required for correct sorting during render buffer filling.';\r\n    private static UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION = 'The buffer contains arguments of dispatch required to run initialization of new particles.';\r\n    private static UAV_SPAWN_EMITTER_DESCRIPTION = 'The buffer containts constant data avaialble across frames.';\r\n\r\n    private static SPAWN_OPERATOR_POLYFILL_NAME = '__spawn_op';\r\n    private static SPAWN_OPERATOR_TYPE = '__SPAWN_T__';\r\n    private static DRAW_OPERATOR_POLYFILL_NAME = '__draw_op';\r\n\r\n    private static CS_PARTICLE_RESET_ROUTINE = 'CSParticlesResetRoutine';\r\n    private static CS_PARTICLE_SPAWN_ROUTINE = 'CSParticlesSpawnRoutine';\r\n    private static CS_PARTICLE_INIT_ROUTINE = 'CSParticlesInitRoutine';\r\n    private static CS_PARTICLE_UPDATE_ROUTINE = 'CSParticlesUpdateRoutine';\r\n    private static CS_PARTICLE_PRERENDER_SHADER = 'CSParticlesPrerenderShader';\r\n\r\n\r\n\r\n    /*\r\n        https://help.autodesk.com/view/MAXDEV/2023/ENU/?guid=shader_semantics_and_annotations\r\n        https://help.autodesk.com/view/MAXDEV/2022/ENU/?guid=Max_Developer_Help_3ds_max_sdk_features_rendering_programming_hardware_shaders_shader_semantics_and_annotations_supported_hlsl_shader_annotation_html\r\n    */\r\n    protected addControl(ctx: ContextT, src: IVariableDeclInstruction): boolean {\r\n        const { id, type, initExpr, annotation } = src;\r\n\r\n        if (!annotation) {\r\n            return false; //TODO: controls without annotations\r\n        }\r\n\r\n        if (!src.isGlobal()) {\r\n            return false;\r\n        }\r\n\r\n        let length = type.isNotBaseArray() ? type.length : -1;\r\n        for (let i = 0; i < Math.abs(length); ++i) {\r\n            const postfix = `${length > 0 ? `[${i}]` : ``}`;\r\n            const ctrl: IUIControl = {\r\n                name: id.name + postfix,\r\n                type: type.name,\r\n                value: null,\r\n                properties: []\r\n            };\r\n\r\n\r\n            if (annotation) {\r\n                annotation.decls.forEach(decl => {\r\n                    let propertyName = decl.name;\r\n                    let propertyType = decl.type.name;\r\n                    switch (propertyName) {\r\n                        case 'UIType': propertyName = '__type'; break;\r\n                        case 'UIName': propertyName = '__caption'; break;\r\n                        case 'UIMin': propertyName = '__min'; break;\r\n                        case 'UIMax': propertyName = '__max'; break;\r\n                        case 'UIStep': propertyName = '__step'; break;\r\n                    }\r\n\r\n                    let propertyValue = getPropertyValue(propertyType, decl.initExpr);\r\n                    if (['__min', '__max', '__step'].indexOf(propertyName) !== -1) {\r\n                        if (propertyType === 'float' && ctrl.type === 'float' ||\r\n                            propertyType === 'int' && ctrl.type === 'int' ||\r\n                            propertyType === 'uint' && ctrl.type === 'uint') {\r\n                            ctrl.properties.push({ name: propertyName, type: propertyType, value: propertyValue });\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (propertyName === '__type' && propertyType !== 'string') {\r\n                            return;\r\n                        }\r\n                        if (propertyName === '__type' && propertyValue === 'color') {\r\n                            ctrl.type = 'color';\r\n                            return;\r\n                        }\r\n                        ctrl.properties.push({ name: propertyName, type: propertyType, value: propertyValue });\r\n                    }\r\n                });\r\n            }\r\n\r\n            const caption = ctrl.properties.find(prop => prop.name === \"__caption\");\r\n            if (caption) {\r\n                (caption.value as string) += postfix;\r\n            }\r\n\r\n            const encodeCtrlExpr = (type: string, initExpr: IExprInstruction) => {\r\n                if (initExpr.instructionType === EInstructionTypes.k_InitExpr) {\r\n                    return encodeInitExprToControlValue(type, (<IInitExprInstruction>initExpr)?.args);\r\n                } else {\r\n                    return encodeInitExprToControlValue(type, [ initExpr ]);\r\n                }\r\n            }\r\n\r\n            if (length == -1) {\r\n                ctrl.value = encodeCtrlExpr(ctrl.type, src.initExpr);\r\n            } else {\r\n                let args = (<IInitExprInstruction>src.initExpr)?.args;\r\n                ctrl.value = encodeCtrlExpr(ctrl.type, args[i]);\r\n            }\r\n\r\n            ctx.addControl(ctrl);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    protected trimeshBaseName(name: string) {\r\n        return `trim${name[0].toUpperCase()}${name.slice(1)}`;\r\n    }\r\n\r\n\r\n    protected isTrimesh(type: IVariableTypeInstruction): boolean {\r\n        const TRIMESH_NAME = 'TriMesh';\r\n        return !!type?.name.includes(TRIMESH_NAME);\r\n    }\r\n\r\n\r\n    protected emitTrimeshDecl(ctx: ContextT, decl: IVariableDeclInstruction): void {\r\n        const type = decl.type;\r\n        const regexp = /^([\\w]+)<([\\w0-9_]+)>$/;\r\n        const match = type.name.match(regexp);\r\n        assert(match);\r\n\r\n        // uavType: match[1],\r\n        // elementType: match[2],\r\n\r\n        const elementType = decl.scope.findType(match[2]);\r\n        const name = decl.name;\r\n        const baseName = this.trimeshBaseName(name);\r\n        // todo: check that such a variable doesn't exists\r\n        const vertexCountUName = `${baseName}VertexCount`;\r\n        const faceCountUName = `${baseName}FaceCount`;\r\n        const verticesName = `${baseName}Vertices`;\r\n        const facesName = `${baseName}Faces`;\r\n        const indicesAdjName = `${baseName}GsAdjacency`;\r\n        const faceAdjName = `${baseName}FaceAdjacency`;\r\n\r\n        const { typeName: elementTypeName } = this.resolveType(ctx, elementType);\r\n\r\n        const vertices = this.emitBuffer(ctx, `StructuredBuffer<${elementTypeName}>`, verticesName, \"vertices\");\r\n        const faces = this.emitBuffer(ctx, `Buffer<uint3>`, facesName, \"faces\");\r\n        const indicesAdj = this.emitBuffer(ctx, `Buffer<uint>`, indicesAdjName, \"gs like adjacency\");\r\n        const faceAdj = this.emitBuffer(ctx, `Buffer<uint>`, faceAdjName, \"face adjacency\");\r\n\r\n        if (!ctx.has(name)) {\r\n            // uniform uint trimesh0_vert_count;\r\n            // uniform uint trimesh0_face_count;\r\n            // StructuredBuffer<Vert> trimesh0_vert;\r\n            // Buffer<uint3> trimesh0_faces;\r\n            // Buffer<uint> trimesh0_faces_adj;\r\n\r\n            if (ctx.opts.globalUniformsGatherToDedicatedConstantBuffer) {\r\n                ctx.addUniform({ name: vertexCountUName, typeName: 'uint' });\r\n            } else {\r\n                this.emitGlobalRaw(ctx, vertexCountUName, `uniform uint ${vertexCountUName}`);\r\n            }\r\n\r\n            if (ctx.opts.globalUniformsGatherToDedicatedConstantBuffer) {\r\n                ctx.addUniform({ name: faceCountUName, typeName: 'uint' });\r\n            } else {\r\n                this.emitGlobalRaw(ctx, faceCountUName, `uniform uint ${faceCountUName}`);\r\n            }\r\n\r\n            this.begin();\r\n            this.emitLine(`void ${baseName}_GetDimensions(out uint vertCount, out uint faceCount)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`vertCount = ${vertexCountUName};`);\r\n                this.emitLine(`faceCount = ${faceCountUName};`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n\r\n            this.emitNewline();\r\n            this.emitNewline();\r\n\r\n            this.emitLine(`${elementTypeName} ${baseName}_LoadVertex(uint vert)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`return ${verticesName}[vert];`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n\r\n            this.emitNewline();\r\n            this.emitNewline();\r\n\r\n            this.emitLine(`uint3 ${baseName}_LoadFace(uint face)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`return ${facesName}[face];`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n\r\n            this.emitNewline();\r\n            this.emitNewline();\r\n\r\n            this.emitLine(`void ${baseName}_LoadGSAdjacency(uint face, out uint vertices[6])`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint offset = face * 6u;`);\r\n                this.emitLine(`vertices[0] = ${indicesAdjName}[offset];`);\r\n                this.emitLine(`vertices[1] = ${indicesAdjName}[offset + 1];`);\r\n                this.emitLine(`vertices[2] = ${indicesAdjName}[offset + 2];`);\r\n                this.emitLine(`vertices[3] = ${indicesAdjName}[offset + 3];`);\r\n                this.emitLine(`vertices[4] = ${indicesAdjName}[offset + 4];`);\r\n                this.emitLine(`vertices[5] = ${indicesAdjName}[offset + 5];`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n\r\n\r\n            this.emitLine(`void ${baseName}_LoadFaceAdjacency(uint face, out uint faces[3])`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint offset = face * 3u;`);\r\n                this.emitLine(`faces[0] = ${faceAdjName}[offset];`);\r\n                this.emitLine(`faces[1] = ${faceAdjName}[offset + 1];`);\r\n                this.emitLine(`faces[2] = ${faceAdjName}[offset + 2];`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n\r\n\r\n            this.end();\r\n\r\n            // let resourcePath = null;\r\n            // let resource = decl.annotation.decls.find(({ name }) => name == 'resource');\r\n            // if (resource && resource.type.name == 'string') {\r\n            //     // '<this>' resource value means \"this\" resource\r\n            //     resourcePath = (resource.initExpr.args[0] as StringInstruction).value.slice(1, -1); // remove quotes\r\n            // }\r\n\r\n            const mesh = {\r\n                name,\r\n\r\n                vertexCountUName,\r\n                faceCountUName,\r\n\r\n                verticesName,\r\n                facesName,\r\n                indicesAdjName,\r\n                faceAdjName\r\n            };\r\n\r\n            ctx.addTrimesh(mesh);\r\n\r\n            let value = (decl.annotation.decls.find(({ name }) => (name == 'name' || name == 'ResourceName'))\r\n                ?.initExpr as StringInstruction)?.value;\r\n            value = value?.slice(1, -1) || null;\r\n            const control: IUIControl = { name, type: 'mesh', value, properties: [] };\r\n            ctx.addControl(control);\r\n        }\r\n\r\n        ctx.linkTrimesh(name);\r\n    }\r\n\r\n\r\n    emitTriMeshCall(ctx: ContextT, call: IFunctionCallInstruction) {\r\n        switch (call.decl.name) {\r\n            case 'LoadFace':\r\n            case 'LoadVertex':\r\n            case 'LoadGSAdjacency':\r\n            case 'LoadFaceAdjacency':\r\n            case 'GetDimensions':\r\n                {\r\n                    // note: it makes imporsible to pass tri meshes as function arguments\r\n                    assert(call.callee.instructionType === EInstructionTypes.k_IdExpr);\r\n                    const id = <IIdExprInstruction>call.callee;\r\n\r\n                    this.emitGlobalVariable(ctx, id.decl);\r\n\r\n                    this.emitKeyword(`${this.trimeshBaseName(id.name)}_${call.decl.name}`);\r\n                    this.emitNoSpace();\r\n                    this.emitChar('(');\r\n                    this.emitNoSpace();\r\n                    this.emitExpressionList(ctx, call.args);\r\n                    this.emitChar(')');\r\n                }\r\n                break;\r\n            default:\r\n                assert(false);\r\n        }\r\n    }\r\n\r\n\r\n    emitFCall(ctx: ContextT, call: IFunctionCallInstruction, rename?) {\r\n        if (this.isTrimesh(call.callee?.type)) {\r\n            this.emitTriMeshCall(ctx, call);\r\n            return;\r\n        }\r\n\r\n        super.emitFCall(ctx, call, rename);\r\n    }\r\n\r\n\r\n    emitGlobalVariable(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        // same convolution as in CodeConvolutionEmitter::emitGlobalVariable()\r\n        // convolute here in order to no print variables from includes\r\n        if (this.convoluteToInclude(ctx, decl)) {\r\n            return;\r\n        }\r\n\r\n        const { type } = decl;\r\n\r\n        // trimesh use builtin check of context existance\r\n        // note: must be counted as ctx.addTrimesh() (not just ctx.add())\r\n        if (this.isTrimesh(decl.type)) {\r\n            this.emitTrimeshDecl(ctx, decl);\r\n            return;\r\n        }\r\n\r\n        // same check as in CodeEmitter::emitGlobalVariable();\r\n        if (ctx.has(decl.name)) {\r\n            return;\r\n        }\r\n\r\n        if (this.addControl(ctx, decl)) {\r\n            this.emitControlVariable(ctx, decl);\r\n            ctx.add(decl.name);\r\n            return;\r\n        }\r\n\r\n        const isUniform = type.isUniform() ||\r\n            (!type.isStatic() && decl.isGlobal() &&\r\n                !SystemScope.isSamplerState(type) &&\r\n                !SystemScope.isBuffer(type) &&\r\n                !SystemScope.isUAV(type) &&\r\n                !SystemScope.isTexture(type));\r\n\r\n        if (isUniform) {\r\n            this.emitUniformVariable(ctx, decl);\r\n            ctx.add(decl.name);\r\n            return;\r\n        }\r\n\r\n        // fallback to stanalone printing\r\n        super.emitGlobalVariable(ctx, decl);\r\n    }\r\n\r\n\r\n    protected emitControlVariable(ctx: ContextT, decl: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string) {\r\n        if (!ctx.opts.uiControlsGatherToDedicatedConstantBuffer) {\r\n            // quick way to promote uniform qualifier to GLSL code\r\n            this.emitKeyword('uniform');\r\n            this.emitVariableNoInit(ctx, decl, rename);\r\n            this.emitChar(';');\r\n        }\r\n    }\r\n\r\n\r\n    protected emitUniformVariable(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        const KNOWN_EXTERNAL_GLOBALS = [\r\n            'ELAPSED_TIME',\r\n            'ELAPSED_TIME_LEVEL',\r\n            'FRAME_NUMBER',\r\n\r\n            'PARENT_POSITION',              // << remove\r\n            'MODEL_MATRIX',                 // << remove\r\n            'MODEL_VIEW_PROJECTION_MATRIX', // << remove\r\n            \r\n            'CAMERA_POSITION',\r\n            'VIEW_MATRIX',\r\n            'VIEW_PROJECTION_MATRIX',\r\n            'PROJECTION_MATRIX',\r\n        ];\r\n\r\n        const semantic = decl.semantic || camelToSnakeCase(decl.name).toUpperCase();\r\n\r\n        if (!!(decl.usageFlags & EVariableUsageFlags.k_Argument)) {\r\n            // todo: set TRUE by default (!)\r\n            if (ctx.opts.argUniformsToDedicatedConstantBuffer || true) {\r\n                \r\n            }\r\n        }\r\n\r\n        if (!KNOWN_EXTERNAL_GLOBALS.includes(semantic)) {\r\n            // super.emitVariable(ctx, decl);\r\n            console.warn(`Unsupported uniform has been used: ${decl.toCode()} (${decl.usageFlags}).`);\r\n            // return;\r\n        }\r\n\r\n        const isGlobal = true; // global update required\r\n        const isLocal = false; // per object update required\r\n\r\n        if (!ctx.opts.globalUniformsGatherToDedicatedConstantBuffer && isGlobal) {\r\n            super.emitVariable(ctx, decl);\r\n            this.emitChar(';');\r\n            return;\r\n        }\r\n\r\n        if (isGlobal) {\r\n            let { name, semantic, type: { name: typeName, length } } = decl;\r\n            if (!decl.type.isNotBaseArray()) length = -1;\r\n            const uniform = { name, semantic, typeName, length };\r\n            ctx.addUniform(uniform);\r\n        }\r\n    }\r\n\r\n\r\n    // todo: remove hack with rename mutator\r\n    // emitVariable(ctx: ContextT, decl: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string) {\r\n    //     const { type } = decl;\r\n    //     super.emitVariable(ctx, decl, rename);\r\n    // }\r\n\r\n\r\n    emitTexture(ctx: ContextT, decl: IVariableDeclInstruction): void {\r\n        const { name, type } = decl;\r\n\r\n        if (!ctx.has(name)) {\r\n            let value = (decl.annotation?.decls.find(({ name }) => (name == 'name' || name == 'ResourceName'))\r\n                ?.initExpr as StringInstruction)?.value;\r\n            value = value?.slice(1, -1) || null;\r\n            const control = <IUIControl>{ name, type: 'texture2d', value, properties: [] };\r\n            ctx.addControl(control);\r\n        }\r\n\r\n        super.emitTexture(ctx, decl);\r\n    }\r\n\r\n\r\n    protected emitSpawnStmt(ctx: ContextT, stmt: ISpawnStmtInstruction) {\r\n        const fx = <IPartFxInstruction>ctx.tech();\r\n\r\n        // looking for:\r\n        // Init(out Part part, int partId: PART_ID, int spawnId: SPAWN_ID, ...parameters)\r\n        // Init(out Part part, int partId: PART_ID, ...parameters)\r\n        // Init(out Part part, ...parameters)\r\n        let argsList = [[/u?int/, /u?int/], [/u?int/], []]\r\n            .map(v => [fx.particle, ...v, ...stmt.args.map(a => a.type)]);\r\n\r\n        let init = null;\r\n        for (const args of argsList) {\r\n            init = stmt.scope.findFunction(stmt.name, args);\r\n            if (init) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!init) {\r\n            for (const args of argsList) {\r\n                console.error(`could not find spawn inititalizer: ${stmt.name}(${args.map(a => `${a}`).join(', ')})`);\r\n            }\r\n            return;\r\n        }\r\n\r\n\r\n        if (!ctx.has(init.name)) {\r\n            ctx.addSpawnCtor(init);\r\n\r\n            const guid = ctx.spawners.indexOf(init) + 1;\r\n            this.emitSpawnOperator(ctx, guid, init);\r\n        }\r\n\r\n        const guid = ctx.spawners.indexOf(init) + 1;\r\n\r\n        this.emitKeyword(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}${guid}__`);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitKeyword(`(uint)`);\r\n        this.emitNoSpace();\r\n        this.emitChar('(');\r\n        this.emitExpression(ctx, stmt.count);\r\n        this.emitChar(')');\r\n        if (stmt.args.length) {\r\n            this.emitChar(',');\r\n            this.emitExpressionList(ctx, stmt.args);\r\n        }\r\n        this.emitChar(')');\r\n        this.emitChar(';');\r\n        this.emitNewline();\r\n\r\n        // super.emitSpawnStmt(stmt);\r\n    }\r\n\r\n\r\n    protected emitDrawStmt(ctx: ContextT, { name, args }: IDrawStmtInstruction) {\r\n        const fx = <IPartFxInstruction>ctx.tech();//<IPartFxInstruction>pass.parent;\r\n        const pass = fx.passes.find(pass => pass.name == name);\r\n\r\n        if (!pass) {\r\n            console.warn(`pass<${name}> for draw operator has not been found.`);\r\n            return;\r\n        }\r\n\r\n        const i = fx.passes.indexOf(pass);\r\n\r\n        if (!ctx.has(name)) {\r\n            ctx.add(name);\r\n\r\n            const prerenderFn = pass.prerenderRoutine.function;\r\n            this.emitFunction(ctx, prerenderFn);\r\n            this.emitPrerenderRoutune(ctx, pass, i);\r\n        }\r\n        this.emitKeyword(`${FxTranslator.DRAW_OPERATOR_POLYFILL_NAME}${i}`);\r\n        this.emitChar(`(`);\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(ctx, args);\r\n        this.emitChar(`)`);\r\n        this.emitChar(';');\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    protected emitResetShader(ctx: ContextT) {\r\n        const name = FxTranslator.CS_PARTICLE_RESET_ROUTINE;\r\n        const numthreads = [64, 1, 1];\r\n        const fx = <IPartFxInstruction>ctx.tech();\r\n        const capacity = fx.capacity;\r\n\r\n        ctx.beginCsShader(name, numthreads);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint tid = DTid.x;`);\r\n                this.emitLine(`if (tid >= ${capacity}) return;`);\r\n\r\n                this.emitUav(ctx, `RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION);\r\n                this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}[tid] = tid;`);\r\n\r\n                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION);\r\n                this.emitLine(`${FxTranslator.UAV_STATES}[tid] = 0;`);\r\n\r\n                const { typeName: partType } = this.resolveType(ctx, fx.particle);\r\n                this.emitUav(ctx, `RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION);\r\n                this.emitLine(`${partType} Particle;`);\r\n\r\n                assert(fx.particle.isComplex());\r\n                fx.particle.fields.forEach(({ name, type }: IVariableDeclInstruction) => {\r\n                    assert(type.length >= 1);\r\n                    let zero = isFloatBasedType(type) ? '0.f' : isBoolBasedType(type) ? 'false' : '0';\r\n                    if (type.length === 1) {\r\n                        this.emitLine(`Particle.${name} = ${zero};`);\r\n                    } else {\r\n                        this.emitLine(`Particle.${name} = ${type.name}(${Array(type.length).fill(zero).join(', ')});`);\r\n                    }\r\n                });\r\n\r\n                this.emitLine(`${FxTranslator.UAV_PARTICLES}[tid] = Particle;`);\r\n\r\n                // reset emitter if required\r\n                const spawnFn = fx.spawnRoutine.function;\r\n                if (spawnFn.def.params.length > 0) {\r\n                    const p0 = spawnFn.def.params[0];\r\n                    this.emitLine(`if (tid == 0)`);\r\n                    this.emitChar('{');\r\n                    this.push();\r\n                    {\r\n                        this.emitUav(ctx, `RWStructuredBuffer<${p0.type.name}>`,\r\n                            `${FxTranslator.UAV_SPAWN_EMITTER}`, FxTranslator.UAV_SPAWN_EMITTER_DESCRIPTION);\r\n\r\n                        this.emitLine(`${p0.type.name} ${p0.name};`);\r\n                        if (p0.type.isComplex()) {\r\n                            for (const field of p0.type.fields) {\r\n                                if (field.type.isComplex()) {\r\n                                    // todo: add support\r\n                                    continue;\r\n                                }\r\n\r\n                                if (field.initExpr) {\r\n                                    this.emitKeyword(`${p0.name}.${field.name} =`);\r\n                                    this.emitExpression(ctx, field.initExpr);\r\n                                    this.emitChar(';');\r\n                                    this.emitNewline();\r\n                                } else {\r\n                                    this.emitKeyword(`${p0.name}.${field.name} =`);\r\n                                    this.emitKeyword(`(${field.type.name})0`);\r\n                                    this.emitChar(';');\r\n                                    this.emitNewline();\r\n                                }\r\n                            }\r\n                        } else {\r\n                            // todo: add support of system types\r\n                        }\r\n                        this.emitLine(`${FxTranslator.UAV_SPAWN_EMITTER}[0] = ${p0.name};`);\r\n                    }\r\n                    this.pop();\r\n                    this.emitChar('}');\r\n                }\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n        ctx.endCsShader();\r\n    }\r\n\r\n\r\n    // TOOD: sync groupSize with value used inside the emitInitShader();\r\n    protected emitSpawnOperator(ctx: ContextT, guid: number, ctor: IFunctionDeclInstruction, groupSize: number = 64) {\r\n        this.begin();\r\n        {\r\n            this.emitKeyword('void');\r\n            this.emitKeyword(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}${guid}__`);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitKeyword(`uint nPart`);\r\n\r\n            const optParams = [\r\n                { name: `Particle`, checker: () => true }, // always presented\r\n                { name: `PartId`, checker: isPartId },\r\n                { name: `SpawnId`, checker: isSpawnId }\r\n            ];\r\n\r\n            let optArgs = [];\r\n\r\n            if (ctor) {\r\n                optArgs = resolveOptArguments(optParams, ctor.def);\r\n\r\n                if (ctor.def.params.length > optArgs.length) {\r\n                    this.emitChar(',');\r\n                    this.emitParams(ctx, ctor.def.params.slice(optArgs.length));\r\n                }\r\n            }\r\n\r\n            this.emitChar(')');\r\n            this.emitNewline();\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitUav(ctx, `RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`,\r\n                    FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION);\r\n                this.emitUav(ctx, `RWBuffer<uint>`,\r\n                    FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION);\r\n\r\n                this.emitLine(`int nGroups = (int)ceil((float)nPart / ${groupSize}.f);`);\r\n                this.emitLine(`uint RequestId;`);\r\n                this.emitLine(`// layout: [ uint GroupCountX, uint GroupCountY, uint GroupCountZ ]`);\r\n                this.emitLine(`InterlockedAdd(${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[0], nGroups, RequestId);`);\r\n                this.emitLine(`for (int i = 0; i < nGroups; ++i)`);\r\n                this.emitChar(`{`);\r\n                this.push();\r\n                {\r\n                    // params\r\n                    const request = `${FxTranslator.UAV_CREATION_REQUESTS}[RequestId]`;\r\n                    this.emitLine(`${request}.count = min(nPart, ${groupSize}u);`);\r\n                    this.emitLine(`${request}.offset = ${groupSize}u * i;`);\r\n                    this.emitLine(`${request}.type = ${guid}u;`);\r\n\r\n                    if (ctor) {\r\n                        const params = ctor.def.params;\r\n                        let nfloat = 0;\r\n                        // skip first two arguments\r\n                        params.slice(optArgs.length).forEach(param => {\r\n                            let type = param.type;\r\n                            if (type.isComplex()) {\r\n                                assert(false, 'unsupported', type.toCode());\r\n                            }\r\n\r\n                            let n = type.size / T_FLOAT.size;\r\n                            for (let i = 0; i < n; ++i) {\r\n                                this.emitLine(`${request}.payload[${Math.floor(nfloat / 4)}][${nfloat % 4}] = asfloat(${param.name}${type.isArray() ? `[${i % 4}]` : ``});`);\r\n                                nfloat++;\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    this.emitLine(`nPart -= ${groupSize}u;`);\r\n                    this.emitLine(`RequestId += 1;`);\r\n                }\r\n                this.pop();\r\n                this.emitChar(`}`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    protected emitGlobalRaw(ctx: ContextT, name: string, content: string) {\r\n        if (ctx.has(name)) {\r\n            return;\r\n        }\r\n        ctx.add(name);\r\n        this.begin();\r\n        this.emitChar(`${content};`);\r\n        this.end();\r\n    }\r\n\r\n\r\n    protected emitSpawnShader(ctx: ContextT) {\r\n        const fx = <IPartFxInstruction>ctx.tech();\r\n        if (!fx.spawnRoutine) {\r\n            return null;\r\n        }\r\n\r\n        const spawnFn = fx.spawnRoutine.function;\r\n        const elapsedTime = fx.scope.findVariable('elapsedTime');\r\n\r\n        const name = FxTranslator.CS_PARTICLE_SPAWN_ROUTINE;\r\n        const numthreads = [1, 1, 1];\r\n\r\n\r\n        ctx.beginCsShader(name, numthreads);\r\n\r\n        this.emitUav(ctx, `RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`,\r\n            FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION);\r\n        this.emitUav(ctx, `RWBuffer<uint>`,\r\n            FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION);\r\n\r\n        if (fx.initRoutine) {\r\n            // default spawn op needed only if regulat emission is used\r\n            this.emitSpawnOperator(ctx, 0, null);\r\n        }\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`if (DTid.x != 0u) return;`);\r\n                this.emitNewline();\r\n\r\n                this.emitLine(`// usage of 4th element of ${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS} as temp value of number of particles`);\r\n                this.emitFunction(ctx, spawnFn);\r\n\r\n                if (elapsedTime) {\r\n                    this.emitGlobal(ctx, elapsedTime);\r\n                } else {\r\n                    // IP: remove this hack\r\n                    this.emitGlobalRaw(ctx, 'elapsedTime', 'uniform float elapsedTime');\r\n                }\r\n\r\n                // todo: move to dispatch arguments reset routine\r\n                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[0] = 0u;`);\r\n                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[1] = 1u;`);\r\n                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[2] = 1u;`);\r\n\r\n                if (types.equals(spawnFn.def.returnType, T_VOID)) {\r\n                    if (spawnFn.def.params.length == 1) {\r\n                        const p0 = spawnFn.def.params[0];\r\n\r\n                        this.emitUav(ctx, `RWStructuredBuffer<${p0.type.name}>`,\r\n                            `${FxTranslator.UAV_SPAWN_EMITTER}`, FxTranslator.UAV_SPAWN_EMITTER_DESCRIPTION);\r\n\r\n                        this.emitChar('{');\r\n                        this.push();\r\n                        this.emitLine(`${p0.type.name} ${p0.name} = ${FxTranslator.UAV_SPAWN_EMITTER}[0];`);\r\n                        this.emitLine(`${spawnFn.name}(${p0.name});`);\r\n                        this.emitLine(`${FxTranslator.UAV_SPAWN_EMITTER}[0] = ${p0.name};`);\r\n                        this.pop();\r\n                        this.emitChar('}');\r\n                    } else {\r\n                        this.emitLine(`${spawnFn.name}();`);\r\n                    }\r\n                } else {\r\n                    assert(types.equals(spawnFn.def.returnType, T_INT));\r\n\r\n                    this.emitLine(`float nPartAddFloat = asfloat(${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[3]) + (float)${spawnFn.name}() * elapsedTime;`);\r\n                    this.emitLine(`float nPartAdd = floor(nPartAddFloat);`);\r\n                    // TODO: replace with InterlockedExchange()\r\n\r\n                    this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[3] = asuint(nPartAddFloat - nPartAdd);`);\r\n                    this.emitLine(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}0__((uint)nPartAdd);`);\r\n                }\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        ctx.endCsShader();\r\n    }\r\n\r\n\r\n    protected emitEntryParams(ctx: ContextT, params: IVariableDeclInstruction[]) {\r\n        // all uniform parameters will be printed as global variables through their id\r\n        params\r\n            // .filter(p => (!this.options.omitEmptyParams || p.type.size !== 0) && !p.type.isUniform())\r\n            .forEach((param, i, list) => {\r\n                this.emitParam(ctx, param);\r\n                (i + 1 != list.length) && this.emitChar(',');\r\n            });\r\n    }\r\n\r\n\r\n    protected emitInitShader(ctx: ContextT) {\r\n        const fx = <IPartFxInstruction>ctx.tech();\r\n        const initFn = fx.initRoutine?.function;\r\n\r\n        const name = FxTranslator.CS_PARTICLE_INIT_ROUTINE;\r\n        const numthreads = [64, 1, 1];\r\n\r\n        ctx.beginCsShader(name, numthreads);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint GroupId = Gid.x;`);\r\n                this.emitLine(`uint ThreadId = GTid.x;`);\r\n                // TODO: emit operator instead!\r\n                this.emitUav(ctx, `RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION);\r\n                this.emitLine(`uint nPart = ${FxTranslator.UAV_CREATION_REQUESTS}[GroupId].count;`);\r\n                this.emitNewline();\r\n                this.emitLine(`if (ThreadId >= nPart) return;`);\r\n                this.emitNewline();\r\n                this.emitUav(ctx, `RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION);\r\n                this.emitLine(`int n = (int)${FxTranslator.UAV_DEAD_INDICES}.DecrementCounter();`);\r\n                this.emitComment(`a bit confusing way to check for particles running out`);\r\n                this.emitLine(`if (n <= 0)`);\r\n                this.emitChar('{');\r\n                this.push();\r\n                {\r\n                    this.emitComment(`not very beautiful, but a cheap way not to`);\r\n                    this.emitComment(`think about the correctness of this counter`);\r\n                    this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}.IncrementCounter();`);\r\n                    this.emitLine('return;');\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n                this.emitNewline();\r\n                this.emitNewline();\r\n                this.emitLine(`uint PartId = ${FxTranslator.UAV_DEAD_INDICES}[n];`);\r\n\r\n                const { typeName: partType } = this.resolveType(ctx, fx.particle);\r\n                this.emitUav(ctx, `RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION);\r\n                this.emitLine(`${partType} Particle;`);\r\n\r\n                // it's ok if here is no init function found\r\n                // it means that generic spawner is used\r\n                if (initFn) {\r\n                    this.emitFunction(ctx, initFn);\r\n                }\r\n\r\n                const request = `${FxTranslator.UAV_CREATION_REQUESTS}[GroupId]`;\r\n\r\n                this.emitLine(`uint Type = ${request}.type;`);\r\n                this.emitLine(`uint SpawnId = ${request}.offset + ThreadId;`);\r\n\r\n                const optParams = [\r\n                    { name: `Particle`, checker: () => true }, // always presented\r\n                    { name: `PartId`, checker: isPartId },\r\n                    { name: `SpawnId`, checker: isSpawnId }\r\n                ];\r\n\r\n                if (initFn) {\r\n                    const optArgs = resolveOptArguments(optParams, initFn.def);\r\n\r\n                    this.emitLine(`if (Type == 0u)`);\r\n                    this.emitChar('{');\r\n                    this.push();\r\n                    {\r\n                        this.emitLine(`${initFn.name}(${optArgs.join(', ')});`);\r\n                    }\r\n                    this.pop();\r\n                    this.emitChar('}');\r\n                    this.emitNewline();\r\n                }\r\n\r\n                ctx.spawners.forEach((ctor, i) => {\r\n                    this.emitFunction(ctx, ctor);\r\n\r\n                    if (initFn || i > 0) {\r\n                        this.emitKeyword(`else`);\r\n                        this.emitSpace();\r\n                    }\r\n\r\n                    this.emitLine(`if (Type == ${i + 1}u)`);\r\n                    this.emitChar('{');\r\n                    this.push();\r\n                    {\r\n                        const optArgs = resolveOptArguments(optParams, ctor.def);\r\n\r\n                        // TODO: move param unpacking to separate function\r\n                        // unpack arguments\r\n                        let nfloat = 0;\r\n                        let params = ctor.def.params.slice(optArgs.length);\r\n                        params.forEach(param => {\r\n                            this.emitVariable(ctx, param);\r\n                            this.emitChar(';');\r\n                            this.emitNewline();\r\n\r\n                            const type = param.type;\r\n                            if (type.isComplex()) {\r\n                                assert(false, 'unsupported', type.toCode());\r\n                            }\r\n\r\n                            let interpreter = 'asfloat';\r\n                            if (isFloatBasedType(type)) { interpreter = 'asfloat'; }\r\n                            if (isIntBasedType(type)) { interpreter = 'asint'; }\r\n                            if (isUintBasedType(type)) { interpreter = 'asuint'; }\r\n\r\n                            let n = type.size / T_FLOAT.size;\r\n                            for (let i = 0; i < n; ++i) {\r\n                                this.emitLine(`${param.name}${type.isArray() ? `[${i % 4}]` : ``} = ${interpreter}(${request}.payload[${Math.floor(nfloat / 4)}][${nfloat % 4}]);`);\r\n                                nfloat++;\r\n                            }\r\n\r\n\r\n                            this.emitNewline();\r\n                        });\r\n\r\n                        this.emitKeyword(ctor.name);\r\n                        this.emitChar('(');\r\n                        this.emitNoSpace();\r\n\r\n                        this.emitKeyword(optArgs.join(', '));\r\n\r\n                        if (params.length > 0) {\r\n                            this.emitChar(',');\r\n                            params.forEach((param, i, list) => {\r\n                                this.emitKeyword(param.name);\r\n                                (i + 1 != list.length) && this.emitChar(', ');\r\n                            });\r\n                        }\r\n                        this.emitChar(')');\r\n                        this.emitChar(';');\r\n                        this.emitNewline();\r\n                    }\r\n                    this.pop();\r\n                    this.emitChar('}');\r\n                    this.emitNewline();\r\n                });\r\n                this.emitLine(`${FxTranslator.UAV_PARTICLES}[PartId] = Particle;`);\r\n                this.emitComment('set particles\\'s state as \\'Alive\\'');\r\n                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION);\r\n                this.emitLine(`${FxTranslator.UAV_STATES}[PartId] = 1;`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        ctx.endCsShader();\r\n    }\r\n\r\n\r\n    protected emitUpdateShader(ctx: ContextT) {\r\n        const fx = <IPartFxInstruction>ctx.tech();\r\n        const updateFn = fx.updateRoutine.function;\r\n\r\n        const name = FxTranslator.CS_PARTICLE_UPDATE_ROUTINE;\r\n        const numthreads = [64, 1, 1];\r\n\r\n        ctx.beginCsShader(name, numthreads);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint PartId = DTid.x;`);\r\n                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION);\r\n                this.emitLine(`bool Alive = (bool)${FxTranslator.UAV_STATES}[PartId];`);\r\n                this.emitNewline();\r\n                this.emitLine(`[branch]`);\r\n                this.emitLine(`if(!Alive) return;`);\r\n                this.emitNewline();\r\n\r\n                const { typeName: partType } = this.resolveType(ctx, fx.particle);\r\n                this.emitUav(ctx, `RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION);\r\n                this.emitLine(`${partType} Particle = ${FxTranslator.UAV_PARTICLES}[PartId];`);\r\n                this.emitNewline();\r\n\r\n                this.emitFunction(ctx, updateFn);\r\n\r\n                this.emitLine(`[branch]`);\r\n                this.emitLine(`if (!${updateFn.name}(Particle${updateFn.def.params.length > 1 ? ', PartId' : ''}))`);\r\n                this.emitChar('{');\r\n                this.push();\r\n                {\r\n                    this.emitUav(ctx, `RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION);\r\n                    this.emitComment('returning the particle index to the list of the dead');\r\n                    this.emitLine(`uint n = ${FxTranslator.UAV_DEAD_INDICES}.IncrementCounter();`);\r\n                    this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}[n] = PartId;`);\r\n                    this.emitNewline();\r\n\r\n                    this.emitComment('set particles\\'s state as \\'dead\\'');\r\n                    this.emitLine(`${FxTranslator.UAV_STATES}[PartId] = 0;`);\r\n                    this.emitLine('return;');\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n                this.emitNewline();\r\n                this.emitNewline();\r\n\r\n                this.emitLine(`${FxTranslator.UAV_PARTICLES}[PartId] = Particle;`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        this.emitUav(ctx, `RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`,\r\n            FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION);\r\n        this.emitUav(ctx, `RWBuffer<uint>`,\r\n            FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION);\r\n\r\n        ctx.endCsShader();\r\n    }\r\n\r\n\r\n    protected emitPrerenderRoutune(ctx: ContextT, pass: IPartFxPassInstruction, i: number) {\r\n        const fx = <IPartFxInstruction>ctx.tech();\r\n        const prerenderFn = pass.prerenderRoutine.function;\r\n        const { typeName: prerenderedType } = this.resolveType(ctx, prerenderFn.def.params[1].type);\r\n        const { typeName: partType } = this.resolveType(ctx, fx.particle);\r\n        this.begin();\r\n        {\r\n            this.emitLine(`void ${FxTranslator.DRAW_OPERATOR_POLYFILL_NAME}${i}(${partType} Particle)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n\r\n            /*\r\n                void __draw_op0(Part Particle)\r\n                {\r\n                    uint PrerenderId = uavPrerendered0.IncrementCounter();\r\n                    uint SerialId = uavSerials0.IncrementCounter();\r\n                    DefaultShaderInput Prerendered;\r\n                    int SortIndex = prerender(Particle, Prerendered);\r\n                    uavSerials0[SerialId] = int2(SortIndex, PrerenderId);\r\n                    uavPrerendered0[PrerenderId] = Prerendered;\r\n                }\r\n\r\n                void __draw_op0(Part Particle)\r\n                {\r\n                    uint PrerenderId = uavPrerendered0.IncrementCounter();\r\n                    uint SerialId = uavSerials0.IncrementCounter();\r\n                    for (int InstanceId = 0; InstanceId < 5; ++ InstanceId) {\r\n                        DefaultShaderInput Prerendered;\r\n                        int SortIndex = prerender(Particle, Prerendered, InstanceId);\r\n                        if (InstanceId == 0) {\r\n                            uavSerials0[SerialId] = int2(SortIndex, PrerenderId);\r\n                        }\r\n                        uavPrerendered0[PrerenderId * 5 + InstanceId] = Prerendered;\r\n                    }\r\n                }\r\n            */\r\n\r\n            {\r\n                this.emitUav(ctx, `RWStructuredBuffer<${prerenderedType}>`, `${FxTranslator.UAV_PRERENDERED}${i}`);\r\n\r\n                if (pass.sorting) {\r\n                    this.emitUav(ctx, `RWStructuredBuffer<int2>`, `${FxTranslator.UAV_SERIALS}${i}`, FxTranslator.UAV_SERIALS_DESCRIPTION);\r\n                }\r\n\r\n                this.emitLine(`uint PrerenderId = ${FxTranslator.UAV_PRERENDERED}${i}.IncrementCounter();`);\r\n                if (pass.sorting) {\r\n                    this.emitLine(`uint SerialId = ${FxTranslator.UAV_SERIALS}${i}.IncrementCounter();`);\r\n                }\r\n\r\n                if (pass.instanceCount > 1) {\r\n                    this.emitLine(`for(int InstanceId = 0; InstanceId < ${pass.instanceCount}; InstanceId++)`);\r\n                    this.emitChar('{');\r\n                    this.push();\r\n                }\r\n                {\r\n\r\n                    this.emitLine(`${prerenderedType} Prerendered;`);\r\n\r\n                    const inputIndex = prerenderFn.def.params.findIndex(p => p.type.name === prerenderedType);\r\n                    const partndex = prerenderFn.def.params.findIndex(p => p.type.name === partType);\r\n                    const insidIndex = prerenderFn.def.params.findIndex(p => p.type.name === T_INT.name); // first int arg index\r\n                    const args = [];\r\n                    args[inputIndex] = `Prerendered`;\r\n                    args[partndex] = `Particle`;\r\n\r\n                    if (insidIndex !== -1) {\r\n                        args[insidIndex] = `InstanceId`;\r\n                    }\r\n\r\n                    if (types.equals(prerenderFn.def.returnType, T_VOID)) {\r\n                        this.emitLine(`int SortIndex = 0;`);\r\n                        this.emitLine(`${prerenderFn.name}(${args.join(', ')});`);\r\n                    }\r\n                    else {\r\n                        this.emitLine(`int SortIndex = ${prerenderFn.name}(${args.join(', ')});`);\r\n                    }\r\n\r\n                    if (pass.sorting) {\r\n                        if (pass.instanceCount > 1) {\r\n                            this.emitLine(`if (InstanceId == 0)`);\r\n                            this.push();\r\n                            this.emitLine(`${FxTranslator.UAV_SERIALS}${i}[SerialId] = int2(SortIndex, PrerenderId);`);\r\n                            this.pop();\r\n                        } else {\r\n                            this.emitLine(`${FxTranslator.UAV_SERIALS}${i}[SerialId] = int2(SortIndex, PrerenderId);`);\r\n                        }\r\n                    }\r\n\r\n                    if (pass.instanceCount > 1) {\r\n                        this.emitLine(`${FxTranslator.UAV_PRERENDERED}${i}[PrerenderId * ${pass.instanceCount} + InstanceId] = Prerendered;`);\r\n                    }\r\n                    else {\r\n                        this.emitLine(`${FxTranslator.UAV_PRERENDERED}${i}[PrerenderId] = Prerendered;`);\r\n                    }\r\n\r\n                }\r\n\r\n                if (pass.instanceCount > 1) {\r\n                    this.pop();\r\n                    this.emitChar('}');\r\n                    this.emitNewline();\r\n                }\r\n\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    protected emitPrerenderShader(ctx: ContextT, pass: IPartFxPassInstruction, i: number) {\r\n        const prerenderFn = pass.prerenderRoutine.function;\r\n\r\n        const name = `${FxTranslator.CS_PARTICLE_PRERENDER_SHADER}${i}`;\r\n        const numthreads = [64, 1, 1];\r\n        const fx = <IPartFxInstruction>ctx.tech();\r\n\r\n        ctx.beginCsShader(name, numthreads);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint PartId = DTid.x;`);\r\n                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION);\r\n                this.emitLine(`bool Alive = (bool)${FxTranslator.UAV_STATES}[PartId];`);\r\n                this.emitNewline();\r\n                this.emitLine(`[branch]`);\r\n                this.emitLine(`if(!Alive) return;`);\r\n                this.emitNewline();\r\n\r\n                this.emitFunction(ctx, prerenderFn);\r\n\r\n                const { typeName: partType } = this.resolveType(ctx, fx.particle);\r\n                this.emitUav(ctx, `RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION);\r\n                this.emitLine(`${partType} Particle = ${FxTranslator.UAV_PARTICLES}[PartId];`);\r\n\r\n                this.emitPrerenderRoutune(ctx, pass, i);\r\n                this.emitLine(`${FxTranslator.DRAW_OPERATOR_POLYFILL_NAME}${i}(Particle);`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        ctx.endCsShader();\r\n    }\r\n\r\n\r\n    protected emitSpawnOpContainer(ctx: ContextT) {\r\n        const payloadSize = ctx.spawners.map(\r\n            // slice 1 or 2 depending on necessity of partID\r\n            ctor => ctor.def.params.slice(2).map(param => param.type.size).reduce((size, summ) => summ + size, 0))\r\n            .reduce((size, summ) => summ + size, 0);\r\n\r\n        const alignment = T_FLOAT4.size;\r\n        const numF4 = Math.ceil(payloadSize / alignment);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`struct ${FxTranslator.SPAWN_OPERATOR_TYPE}`);\r\n            this.emitChar(`{`);\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint count;      // number of particles inside group`);\r\n                this.emitLine(`uint offset;     // number of particles prior this group (to determ spawn id)`);\r\n                this.emitLine(`uint type;       // type of spawner (type of function to init)`);\r\n\r\n                // this.emitLine(`uint _pad[2];`);\r\n                // emit padding?\r\n\r\n                if (numF4 > 0) {\r\n                    this.emitNewline();\r\n                    this.emitLine(`float4 payload[${numF4}];`);\r\n                }\r\n            }\r\n            this.pop();\r\n            this.emitChar(`}`);\r\n            this.emitChar(';');\r\n        }\r\n        // NOTE: emit as prologue!\r\n        this.end(true);\r\n    }\r\n\r\n\r\n    protected finalizeTechnique(ctx: ContextT) {\r\n        if (ctx.opts.globalUniformsGatherToDedicatedConstantBuffer && ctx.uniforms.length > 0) {\r\n            const index = ctx.opts.globalUniformsConstantBufferRegister || -1;\r\n\r\n            // check that no one uses the same register\r\n            for (let name in ctx.tech()?.scope.cbuffers) {\r\n                let cbuf = ctx.tech().scope.cbuffers[name];\r\n                if (SystemScope.resolveRegister(cbuf).index === index) {\r\n                    console.error(`register ${index} is already used by cbuffer '${cbuf.name}'`);\r\n                }\r\n            }\r\n\r\n            const name = ctx.opts.globalUniformsConstantBufferName || AUTOGEN_GLOBALS;\r\n            this.begin();\r\n            {\r\n                this.emitKeyword('cbuffer');\r\n                this.emitKeyword(name);\r\n\r\n                if (index !== -1) {\r\n                    this.emitChar(':');\r\n                    this.emitKeyword('register');\r\n                    this.emitChar('(');\r\n                    this.emitNoSpace();\r\n                    this.emitKeyword(`b${index}`);\r\n                    this.emitNoSpace();\r\n                    this.emitChar(')');\r\n                }\r\n\r\n                this.emitNewline();\r\n                this.emitChar('{');\r\n                this.push();\r\n                {\r\n                    ctx.uniforms.forEach(({ name, typeName, semantic, length }) => {\r\n                        this.emitKeyword(typeName);\r\n                        this.emitKeyword(name);\r\n                        if (length > 0) {\r\n                            this.emitChar(`[${length}]`);\r\n                        }\r\n                        if (semantic) {\r\n                            this.emitSemantic(ctx, semantic);\r\n                        } else {\r\n                            this.emitSemantic(ctx, camelToSnakeCase(name).toUpperCase());\r\n                        }\r\n\r\n                        this.emitChar(';');\r\n                        this.emitNewline();\r\n                    });\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n                this.emitChar(';');\r\n            }\r\n            this.end(true); // move to prologue\r\n        }\r\n\r\n        const uiControls = ctx.controls.filter(ctrl => !['texture2d', 'mesh'].includes(ctrl.type));\r\n        if (ctx.opts.uiControlsGatherToDedicatedConstantBuffer && uiControls.length > 0) {\r\n            const index = ctx.opts.uiControlsConstantBufferRegister || -1;\r\n\r\n            // check that no one uses the same register\r\n            for (let name in ctx.tech()?.scope.cbuffers) {\r\n                let cbuf = ctx.tech().scope.cbuffers[name];\r\n                if (SystemScope.resolveRegister(cbuf).index === index) {\r\n                    console.error(`register ${index} is already used by cbuffer '${cbuf.name}'`);\r\n                }\r\n            }\r\n\r\n            const name = ctx.opts.uiControlsConstantBufferName || AUTOGEN_CONTROLS;\r\n            this.begin();\r\n            {\r\n                this.emitKeyword('cbuffer');\r\n                this.emitKeyword(name);\r\n\r\n                if (index !== -1) {\r\n                    this.emitChar(':');\r\n                    this.emitKeyword('register');\r\n                    this.emitChar('(');\r\n                    this.emitNoSpace();\r\n                    this.emitKeyword(`b${index}`);\r\n                    this.emitNoSpace();\r\n                    this.emitChar(')');\r\n                }\r\n\r\n                this.emitNewline();\r\n                this.emitChar('{');\r\n                this.push();\r\n                {\r\n                    // collect all array elements (color[2]) into array \"color\"\r\n                    const nameRexp = /([\\w_][\\w\\d]+)(\\[([\\d]+)\\])?/;\r\n                    const fields: IMap<{ name: string; type: string }> = {};\r\n                    uiControls.forEach(ctrl => {\r\n                        const name = ctrl.name;\r\n                        const match = name.match(nameRexp);\r\n                        const type = typeNameOfUIControl(ctrl);\r\n                        fields[match[1]] ||= { name, type };\r\n                        fields[match[1]].name = match[3] ? `${match[1]}[${Number(match[3]) + 1}]` : match[1];\r\n                    });\r\n\r\n                    Object.values(fields).forEach(ctrl => {\r\n                        this.emitKeyword(ctrl.type);\r\n                        this.emitKeyword(ctrl.name);\r\n                        this.emitChar(';');\r\n                        this.emitNewline();\r\n                    });\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n                this.emitChar(';');\r\n            }\r\n            this.end(true); // move to prologue\r\n        }\r\n    }\r\n\r\n\r\n    emitPartFxDecl(ctx: ContextT, fx: IPartFxInstruction): void {\r\n        if (!fx.particle) {\r\n            return;\r\n        }\r\n\r\n        // note: only one effect can be translated at a time \r\n        ctx.beginTechnique(fx);\r\n\r\n        this.emitSpawnShader(ctx);\r\n        this.emitResetShader(ctx);\r\n\r\n        if (fx.updateRoutine) {\r\n            this.emitUpdateShader(ctx);\r\n        }\r\n\r\n        this.emitInitShader(ctx);\r\n\r\n        const passes = fx.passes.map((pass, i): IPartFxPassReflection => {\r\n            const { prerenderRoutine, vertexShader: vs, pixelShader: ps, drawMode } = pass;\r\n            let { sorting, geometry, instanceCount } = pass;\r\n            let VSParticleShader: string = null;\r\n            let PSParticleShader: string = null;\r\n            let renderStates = pass.renderStates;\r\n\r\n            if (prerenderRoutine && drawMode === EPassDrawMode.k_Auto) {\r\n                this.emitPrerenderShader(ctx, pass, i);\r\n            }\r\n\r\n            if (vs) {\r\n                this.emitFunction(ctx, vs);\r\n                VSParticleShader = vs.name;\r\n            }\r\n\r\n            if (ps) {\r\n                this.emitFunction(ctx, ps);\r\n                PSParticleShader = ps.name;\r\n            }\r\n\r\n            const { typeName: instance } = this.resolveType(ctx, pass.particleInstance);\r\n            const CSParticlesPrerenderRoutine = ctx.CSShaders.find(sh => sh.name == `${FxTranslator.CS_PARTICLE_PRERENDER_SHADER}${i}`);\r\n\r\n            return {\r\n                instance,\r\n                sorting,\r\n                geometry,\r\n                instanceCount,\r\n                VSParticleShader,\r\n                PSParticleShader,\r\n                renderStates,\r\n                CSParticlesPrerenderRoutine,\r\n                drawMode\r\n            };\r\n        });\r\n\r\n        this.emitSpawnOpContainer(ctx);\r\n        this.finalizeTechnique(ctx);\r\n\r\n        const { name, capacity } = fx;\r\n        const particle = this.resolveType(ctx, fx.particle).typeName;\r\n        const CSParticlesSpawnRoutine = ctx.CSShaders.find(sh => sh.name == FxTranslator.CS_PARTICLE_SPAWN_ROUTINE);\r\n        const CSParticlesResetRoutine = ctx.CSShaders.find(sh => sh.name == FxTranslator.CS_PARTICLE_RESET_ROUTINE);\r\n        const CSParticlesUpdateRoutine = ctx.CSShaders.find(sh => sh.name == FxTranslator.CS_PARTICLE_UPDATE_ROUTINE);;\r\n        const CSParticlesInitRoutine = ctx.CSShaders.find(sh => sh.name == FxTranslator.CS_PARTICLE_INIT_ROUTINE);;\r\n        const controls = [...ctx.controls];\r\n        const presets = FxTranslator.parsePresets(fx);\r\n\r\n        const pfx: IPartFxReflection = {\r\n            name,\r\n            capacity,\r\n            particle,\r\n            passes,\r\n            CSParticlesSpawnRoutine,\r\n            CSParticlesResetRoutine,\r\n            CSParticlesInitRoutine,\r\n            CSParticlesUpdateRoutine,\r\n            controls,\r\n            presets\r\n        };\r\n\r\n        ctx.addTechnique(pfx);\r\n        ctx.endTechnique();\r\n    }\r\n\r\n\r\n    emitTechniqueDecl(ctx: ContextT, tech: ITechniqueInstruction): void {\r\n        // note: only one effect can be tranclated at a time \r\n        ctx.beginTechnique(tech);\r\n\r\n        const { name } = tech;\r\n\r\n        tech.passes.forEach((pass, i) => {\r\n            const { vertexShader: vs, pixelShader: ps } = pass;\r\n            if (vs) {\r\n                this.emitFunction(ctx, vs);\r\n            }\r\n            if (ps) {\r\n                this.emitFunction(ctx, ps);\r\n            }\r\n        });\r\n\r\n        const passes = tech.passes.map((pass, i): IPassReflection => {\r\n            const { vertexShader, pixelShader } = pass;\r\n\r\n            let VSParticleShader: string = null;\r\n            let PSParticleShader: string = null;\r\n\r\n            if (vertexShader) {\r\n                VSParticleShader = vertexShader.name;\r\n            }\r\n\r\n            if (pixelShader) {\r\n                PSParticleShader = pixelShader.name;\r\n            }\r\n\r\n            // todo: \r\n            const matInstance = vertexShader?.def.params[0].type;\r\n            const { typeName: instance } = this.resolveType(ctx, matInstance);\r\n\r\n            const renderStates = pass.renderStates;\r\n\r\n            return {\r\n                instance,\r\n                VSParticleShader,\r\n                PSParticleShader,\r\n                renderStates\r\n            };\r\n        });\r\n\r\n        // emit global uniforms and so on.\r\n        this.finalizeTechnique(ctx);\r\n\r\n        const controls = [...ctx.controls];\r\n        const presets = FxTranslator.parsePresets(tech);\r\n        const refl = {\r\n            name,\r\n            passes,\r\n            controls,\r\n            presets\r\n        };\r\n\r\n        ctx.addTechnique(refl);\r\n        ctx.endTechnique();\r\n    }\r\n\r\n\r\n    emitTechnique11Decl(ctx: ContextT, tech: ITechnique11Instruction): void {\r\n        // note: only one effect can be tranclated at a time \r\n        ctx.beginTechnique(tech);\r\n\r\n        const { name } = tech;\r\n\r\n        for (const pass of tech.passes) {\r\n            visitor(pass, (instr: IInstruction, owner?: IInstruction) => {\r\n                if (instr.instructionType === EInstructionTypes.k_CompileShader11Expr) {\r\n                    const cmpl = instr as ICompileShader11Instruction;\r\n                    // const SH_TYPE = {\r\n                    //     'vs': 'VertexShader',\r\n                    //     'ps': 'PixelShader',\r\n                    //     'cs': 'ComputeShader',\r\n                    //     'gs': 'GeometryShader'\r\n                    // };\r\n                    // const ext = cmpl.ver.substring(0, 2);\r\n                    // const type = SH_TYPE[ext];\r\n                    // assert(isString(type), 'unknown type found');\r\n\r\n                    this.emitEntryFunction(ctx, cmpl.func);\r\n                }\r\n                // todo: add support of global defined shaders\r\n            });\r\n        }\r\n\r\n        // emit global uniforms and so on.\r\n        this.finalizeTechnique(ctx);\r\n\r\n        const controls = [...ctx.controls];\r\n\r\n        const refl = {\r\n            name,\r\n            controls\r\n        };\r\n\r\n        ctx.addTechnique11(refl);\r\n        ctx.endTechnique();\r\n    }\r\n\r\n\r\n    static parsePresets(fx: ITechniqueInstruction): IPreset[] {\r\n        return fx.presets.map((preset, i): IPreset => {\r\n            const name = preset.name;\r\n            const desc = null; // todo\r\n            let data: IPresetEntry[] = [];\r\n            preset.props.forEach(control => {\r\n                if (!control) {\r\n                    //FIX: In a case when the set of controls has changed, but the preset has remained the same.\r\n                    return;\r\n                }\r\n\r\n                const src = control.resolveDeclaration();\r\n                let controlType = src.type.name.toLowerCase(); // Texture2D => texture2d\r\n                if (src.annotation) {\r\n                    src.annotation.decls.forEach(prop => {\r\n                        const propertyName = prop.name;\r\n                        const propertyType = prop.type.name;\r\n                        const propertyValue = getPropertyValue(propertyType, prop.initExpr);\r\n                        if ((propertyName === '__type' || propertyName === 'UIType') &&\r\n                            propertyType === 'string' && propertyValue === 'color') {\r\n                            controlType = 'color';\r\n                            return;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                const value = encodeInitExprToControlValue(controlType, control.args);\r\n                data.push({ name: src.name, type: controlType, value });\r\n            });\r\n            return { name, desc, data };\r\n        });\r\n    }\r\n\r\n\r\n    private static fxtTranslator = new FxTranslator({ omitEmptyParams: true });\r\n\r\n    static translate(instr: IInstruction, ctx: FxTranslatorContext = new FxTranslatorContext): string {\r\n        FxTranslator.fxtTranslator.emit(ctx, instr);\r\n        // hack to print gathered buffers\r\n        if (instr.instructionType === EInstructionTypes.k_FunctionDecl) {\r\n            FxTranslator.fxtTranslator.finalizeTechnique(ctx);\r\n        }\r\n        return FxTranslator.fxtTranslator.toString(ctx);\r\n    }\r\n}\r\n\r\nfunction getPropertyValue(type: string, instr: IExprInstruction): PropertyValueType {\r\n    instr = getExpr(instr);\r\n    switch (type) {\r\n        case 'int': return (instr as IntInstruction).value;\r\n        case 'uint': return (instr as IntInstruction).value;\r\n        case 'float': return (instr as FloatInstruction).value;\r\n        // hack to remove quotes (should have been fixed during analyze stage)\r\n        case 'string': return (instr as StringInstruction).value.split('\"').join('');\r\n    }\r\n    assert(false, 'Unsupported type');\r\n    return null;\r\n}\r\n\r\nfunction encodeInitExprToControlValue(type: string, args: IExprInstruction[]): ControlValueType {\r\n    switch (type) {\r\n        case 'int': return (getExpr(args[0]) as IntInstruction).value;\r\n        case 'uint': return (getExpr(args[0]) as IntInstruction).value;\r\n        case 'float': return (getExpr(args[0]) as FloatInstruction).value;\r\n        case 'float2': {\r\n            let x = (getExpr(args[0]) as FloatInstruction).value;\r\n            let y = (getExpr(args[1]) as FloatInstruction).value;\r\n            return { x: x, y: y } as Vector2;\r\n        }\r\n        case 'float3': {\r\n            let x = (getExpr(args[0]) as FloatInstruction).value;\r\n            let y = (getExpr(args[1]) as FloatInstruction).value;\r\n            let z = (getExpr(args[2]) as FloatInstruction).value;\r\n            return { x: x, y: y, z: z } as Vector3;\r\n        }\r\n        case 'float4': {\r\n            let x = (getExpr(args[0]) as FloatInstruction).value;\r\n            let y = (getExpr(args[1]) as FloatInstruction).value;\r\n            let z = (getExpr(args[2]) as FloatInstruction).value;\r\n            let w = (getExpr(args[3]) as FloatInstruction).value;\r\n            return { x: x, y: y, z: z, w: w } as Vector4;\r\n        }\r\n        case 'color': {\r\n            let r = (getExpr(args[0]) as FloatInstruction).value;\r\n            let g = (getExpr(args[1]) as FloatInstruction).value;\r\n            let b = (getExpr(args[2]) as FloatInstruction).value;\r\n            let a = (getExpr(args[3]) as FloatInstruction).value;\r\n            return { r: r, g: g, b: b, a: a } as Color;\r\n        }\r\n        case 'texture2d': {\r\n            // remove quotes\r\n            return (getExpr(args[0]) as StringInstruction).value?.slice(1, -1) || null;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\nfunction getExpr(expr: IExprInstruction): IExprInstruction {\r\n    return expr.instructionType === EInstructionTypes.k_InitExpr\r\n        ? ((expr as IInitExprInstruction).args[0])\r\n        : (<ILiteralInstruction<number>>expr);\r\n}\r\n","import { assert, isDef } from \"@lib/common\";\r\nimport { types, instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { IdExprInstruction } from \"@lib/fx/analisys/instructions/IdExprInstruction\";\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, ICbufferInstruction, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IInitExprInstruction, IInstruction, ILiteralInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { CodeEmitter, CodeContext, ICodeEmitterOptions, ITypeInfo } from \"./CodeEmitter\";\r\n\r\nconst GlslTypeNames = {\r\n    'void': 'void',\r\n    'uint': 'uint',\r\n    'uint2': 'uvec2',\r\n    'uint3': 'uvec3',\r\n    'uint4': 'uvec4',\r\n    'bool': 'bool',\r\n    'bool2': 'bvec2',\r\n    'bool3': 'bvec3',\r\n    'bool4': 'bvec4',\r\n    'int': 'int',\r\n    'int2': 'ivec2',\r\n    'int3': 'ivec3',\r\n    'int4': 'ivec4',\r\n    'float': 'float',\r\n    'float2': 'vec2',\r\n    'float3': 'vec3',\r\n    'float4': 'vec4',\r\n    'float4x4': 'mat4',\r\n    'float3x3': 'mat3x3',\r\n    'float3x4': 'mat3x4'\r\n}\r\n\r\n// const HlslTypeNames = Object.fromEntries(Object.entries(GlslTypeNames).map(([k, v]) => [v, k]));\r\n\r\n\r\nconst sname = {\r\n    attr: (decl: IVariableDeclInstruction) => decl.semantic ?\r\n        `a_${decl.semantic.toLowerCase()}` :\r\n        `a_${decl.name}_${decl.instructionID}`,\r\n    varying: (decl: IVariableDeclInstruction) => decl.semantic ?\r\n        `v_${decl.semantic.toLowerCase()}` :\r\n        `v_${decl.name}_${decl.instructionID}`,\r\n    // uniform: (decl: IVariableDeclInstruction) => `u_${decl.name}`\r\n};\r\n\r\nconst IS_POSITION = (semantic: string) => ['POSITION', 'SV_POSITION'].indexOf(semantic.toUpperCase()) !== -1;\r\nconst IS_INSTANCEID = (semantic: string) => ['INSTANCE_ID', 'SV_INSTANCEID'].indexOf(semantic.toUpperCase()) !== -1;\r\nconst IS_VERTEXID = (semantic: string) => ['VERTEX_ID', 'SV_VERTEXID'].indexOf(semantic.toUpperCase()) !== -1;\r\n\r\nfunction determMostPreciseBaseType(left: ITypeInstruction, right: ITypeInstruction): ITypeInstruction {\r\n    const length =\r\n        SystemScope.isScalarType(left)\r\n            ? right.length\r\n            : SystemScope.isScalarType(right)\r\n                ? left.length\r\n                : Math.min(left.length, right.length);\r\n    const mpbt = SystemScope.determMostPreciseBaseType(left, right);\r\n    const mpt = SystemScope.findType(`${mpbt.name}${length === 1 ? '' : length}`);\r\n    return mpt;\r\n}\r\n\r\nexport class GLSLContext extends CodeContext {\r\n    location: number = 0;\r\n\r\n    has(signature: string): boolean {\r\n        // nothing todo - built in GLSL function\r\n        const SYSTEM_FUNCS = ['unpackHalf2x16(uint)'];\r\n        if (SYSTEM_FUNCS.includes(signature)) {\r\n            return true;\r\n        }\r\n        return super.has(signature);\r\n    }\r\n}\r\n\r\n\r\nexport class GLSLEmitter<ContextT extends GLSLContext> extends CodeEmitter<ContextT> {\r\n\r\n    protected resolveTypeName(type: ITypeInstruction): string {\r\n        const typeName = GlslTypeNames[type.name];\r\n        if (!isDef(typeName)) {\r\n            assert(false, `unknown built in type found '${type.name}'`);\r\n            return type.name;\r\n        }\r\n\r\n        return typeName;\r\n    }\r\n\r\n    // GLSL doesn't support static keyword\r\n    protected resolveType(ctx: ContextT, type: ITypeInstruction): ITypeInfo {\r\n        let info = super.resolveType(ctx, type);\r\n        if (info) {\r\n            info.usage = info.usage?.split(' ').filter(kw => kw !== 'static').join(' ');\r\n        }\r\n        return info;\r\n    }\r\n\r\n\r\n    protected isVaryingOrAttributeAlias(ctx: ContextT, pfxp: IPostfixPointInstruction) {\r\n        if (this.isMain() && !ctx.isRaw()) {\r\n            if (pfxp.element.instructionType === EInstructionTypes.k_IdExpr) {\r\n                const id = pfxp.element as IdExprInstruction;\r\n                if (id.decl.isParameter() && !id.decl.type.isUniform()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    emitExpressionWithCast(ctx: ContextT, expr: IExprInstruction, type: ITypeInstruction) {\r\n        const { typeName } = this.resolveType(ctx, type);\r\n        if (!types.equals(type, expr.type)) {\r\n            this.emitKeyword(typeName);\r\n            this.emitNoSpace();\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitExpression(ctx, expr);\r\n            this.emitChar(')');\r\n        } else {\r\n            this.emitExpression(ctx, expr);\r\n        }\r\n    }\r\n\r\n\r\n    emitExpressionListWithCast(ctx: ContextT, list: IExprInstruction[], types: ITypeInstruction[]) {\r\n        list?.forEach((expr, i) => {\r\n            this.emitExpressionWithCast(ctx, list[i], types[i]);\r\n            (i != list.length - 1) && this.emitChar(',');\r\n        })\r\n    }\r\n\r\n\r\n    emitArithmetic(ctx: ContextT, arthm: IArithmeticExprInstruction) {\r\n        let { left, right, operator } = arthm;\r\n        if (!types.equals(left.type, right.type)) {\r\n            const mpt = determMostPreciseBaseType(left.type, right.type);\r\n            this.emitExpressionWithCast(ctx, left, mpt);\r\n            this.emitKeyword(operator);\r\n            this.emitSpace();\r\n            this.emitExpressionWithCast(ctx, right, mpt);\r\n            return;\r\n        }\r\n        super.emitArithmetic(ctx, arthm);\r\n    }\r\n\r\n\r\n    emitAssigment(ctx: ContextT, asgm: IAssignmentExprInstruction) {\r\n        let { left, right, operator } = asgm;\r\n        if (!types.equals(left.type, right.type)) {\r\n            const mpt = determMostPreciseBaseType(left.type, right.type);\r\n            this.emitExpressionWithCast(ctx, left, mpt);\r\n            this.emitKeyword(operator);\r\n            this.emitSpace();\r\n            assert(instruction.isExpression(right));\r\n            this.emitExpressionWithCast(ctx, right as IExprInstruction, mpt);\r\n            return;\r\n        }\r\n        super.emitAssigment(ctx, asgm);\r\n    }\r\n\r\n\r\n    emitSemantic(ctx: ContextT, semantic: string) {\r\n        // disabling of semantics emission.\r\n    }\r\n\r\n\r\n    emitPostfixIndex(ctx: ContextT, pfidx: IPostfixIndexInstruction) {\r\n        if (/^Buffer(<[a-zA-Z0-9_]+>)?$/.test(pfidx.element.type.name)) {\r\n            // TODO: fixme\r\n            this.emitKeyword(`${this.resolveType(ctx, pfidx.type).typeName}(0.0, 0.0, 0.0, 0.0)`);\r\n            return;\r\n            // this.emitLine(`texelFetch(`, texelCoord, 0).x`);\r\n            this.emitKeyword('texelFetch');\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitExpression(ctx, pfidx.element);\r\n            this.emitChar(',');\r\n            this.emitKeyword(`ivec2`);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitExpression(ctx, pfidx.index);\r\n            this.emitChar(',');\r\n            this.emitKeyword('0');\r\n            this.emitChar(')');\r\n            this.emitChar(',');\r\n            this.emitKeyword('0');\r\n            this.emitChar(')');\r\n            return;\r\n        }\r\n        super.emitPostfixIndex(ctx, pfidx);\r\n    }\r\n\r\n\r\n    emitVariableNoInit(ctx: ContextT, src: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string): void {\r\n        const { type } = src;\r\n        if (src.isGlobal()) {\r\n            // IP: hack for fake compartibility with GLSL 3.00 ES\r\n            // convert buffers to samplers\r\n            if (SystemScope.isBuffer(type)) {\r\n                const { typeName } = this.resolveType(ctx, type.arrayElementType);\r\n\r\n                this.emitKeyword('uniform highp');\r\n                if (['ivec4'].includes(typeName)) {\r\n                    this.emitKeyword('isampler2D');\r\n                } else if (['uvec4'].includes(typeName)) {\r\n                    this.emitKeyword('usampler2D');\r\n                } else {\r\n                    this.emitKeyword('sampler2D');\r\n                }\r\n                this.emitKeyword(src.name);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // todo: add support not only for 2D textures\r\n        if (SystemScope.isTexture(type)) {\r\n            this.emitKeyword('sampler2D');\r\n            this.emitKeyword(src.name);\r\n            return;\r\n        }\r\n\r\n        super.emitVariableNoInit(ctx, src, rename);\r\n    }\r\n\r\n\r\n    emitVariable(ctx: ContextT, src: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string): void {\r\n        this.emitVariableNoInit(ctx, src, rename);\r\n        if (src.initExpr) {\r\n            this.emitKeyword('=');\r\n            this.emitSpace();\r\n            if (!types.equals(src.type, src.initExpr.type)) {\r\n                const { typeName } = this.resolveType(ctx, src.type);\r\n                this.emitKeyword(`${typeName}`);\r\n                this.emitChar('(');\r\n                this.emitNoSpace();\r\n                this.emitExpression(ctx, src.initExpr);\r\n                this.emitChar(')');\r\n            } else {\r\n                this.emitExpression(ctx, src.initExpr);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    protected emitPrologue(ctx: ContextT, def: IFunctionDefInstruction): void {\r\n        this.begin();\r\n        {\r\n            this.emitLine(`#version 300 es`);\r\n\r\n            this.emitLine(`precision highp float;`);\r\n            this.emitLine(`precision highp int;`);\r\n            // this.emitLine(`precision highp unsigned int;`);\r\n        }\r\n        this.end();\r\n        this.begin();\r\n        {\r\n            for (const param of def.params) {\r\n                if (param.type.isUniform()) {\r\n                    continue;\r\n                }\r\n\r\n                const type = param.type;\r\n\r\n                // this.emitComment(param.toCode());\r\n                // this.emitNewline();\r\n\r\n                if (!type.isComplex()) {\r\n                    this.emitVaryingOrAttribute(ctx, param);\r\n                    continue;\r\n                }\r\n\r\n                type.fields.forEach(field => {\r\n                    assert(!field.type.isNotBaseArray() && !field.type.isComplex());\r\n                    this.emitVaryingOrAttribute(ctx, field);\r\n                });\r\n            }\r\n        }\r\n        this.end();\r\n\r\n        this.begin();\r\n        {\r\n            // for (const param of def.params) {\r\n            //     if (!param.type.isUniform()) {\r\n            //         continue;\r\n            //     }\r\n\r\n            //     this.emitVariable(ctx, param);\r\n            //     this.emitChar(`;`);\r\n            //     this.emitNewline();\r\n            // }\r\n        }\r\n        this.end();\r\n\r\n\r\n        if (ctx.mode === 'vs') {\r\n            this.begin();\r\n            {\r\n                const retType = def.returnType;\r\n                assert(retType.isComplex(), 'basic types unsupported yet');\r\n\r\n                retType.fields.forEach(field => this.emitVarying(ctx, field));\r\n            }\r\n            this.end();\r\n        }\r\n\r\n        if (ctx.mode === 'ps') {\r\n            // layout(location = 0) out vec3 color;\r\n            this.begin();\r\n\r\n            if (types.equals(def.returnType, SystemScope.T_FLOAT4)) {\r\n                this.emitLine(`layout(location = 0) out vec4 out_color;`);\r\n            } else if (def.returnType.isComplex()) {\r\n                const ctype = def.returnType;\r\n                ctype.fields.forEach((field, i) => {\r\n                    const { typeName } = this.resolveType(ctx, field.type);\r\n                    assert(!field.type.isComplex() && !field.type.isNotBaseArray());\r\n                    this.emitLine(`layout(location = ${i}) out ${typeName} out_${field.name};`);\r\n                });\r\n            } else {\r\n                assert(false, 'unsupported pixel shader output format');\r\n            }\r\n\r\n            this.end();\r\n        }\r\n    }\r\n\r\n\r\n    emitKeyword(kw: string) {\r\n        // IP: temp fix for reserved GLSL keyword\r\n        if (kw === 'input') kw = 'input1';\r\n        super.emitKeyword(kw);\r\n    }\r\n\r\n\r\n    emitTextureRaw(ctx: ContextT, type: string, name: string, comment?: string): void {\r\n        if (!ctx.has(name)) {\r\n            const tex = ctx.addTexture(type, name);\r\n            this.begin();\r\n            {\r\n                comment && this.emitComment(comment);\r\n                this.emitKeyword(`uniform sampler2D ${name};`);\r\n            }\r\n            this.end();\r\n        }\r\n        ctx.linkTexture(name);\r\n    }\r\n\r\n\r\n    protected emitAttribute(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        // skip specific semantics like SV_InstanceID in favor of gl_InstanceID \r\n        if (IS_INSTANCEID(decl.semantic)) return;\r\n        if (IS_VERTEXID(decl.semantic)) return;\r\n\r\n        (this.emitKeyword(`layout(location = ${ctx.location++}) in`), this.emitVariable(ctx, decl, sname.attr), this.emitChar(';'), this.emitNewline());\r\n    }\r\n\r\n\r\n    protected emitVarying(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        const { type } = decl;\r\n        if (type.isComplex()) {\r\n            type.fields.forEach(field => this.emitVarying(ctx, field));\r\n            return;\r\n        }\r\n\r\n        const usage: { [key in typeof ctx.mode]?: string } = {\r\n            vs: 'out',\r\n            ps: 'in'\r\n        };\r\n\r\n        (this.emitKeyword(usage[ctx.mode]), this.emitVariable(ctx, decl, sname.varying), this.emitChar(';'), this.emitNewline());\r\n    }\r\n\r\n\r\n    protected emitVaryingOrAttribute(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        switch (ctx.mode) {\r\n            case 'vs':\r\n                return this.emitAttribute(ctx, decl);\r\n            case 'ps':\r\n                return this.emitVarying(ctx, decl);\r\n        }\r\n    }\r\n\r\n\r\n    emitCbuffer(ctx: ContextT, cbuf: ICbufferInstruction) {\r\n        if (!ctx.has(cbuf.name)) {\r\n            ctx.addCbuffer(cbuf);\r\n            this.begin();\r\n            this.emitComment(`size: ${cbuf.type.size}`);\r\n            this.emitKeyword('uniform');\r\n            if (cbuf.id) {\r\n                this.emitKeyword(cbuf.name);\r\n            }\r\n            this.emitNewline();\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                cbuf.type.fields.forEach(field => {\r\n                    this.emitVariable(ctx, field);\r\n                    this.emitChar(';');\r\n                    this.emitChar('\\t')\r\n                    this.emitComment(`padding ${field.type.padding}, size ${field.type.size}`);\r\n                });\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n            this.emitChar(';');\r\n            this.end();\r\n        }\r\n        ctx.linkCbuffer(cbuf.name);\r\n    }\r\n\r\n\r\n    emitFloat(ctx: ContextT, lit: ILiteralInstruction<number>) {\r\n        const sval = String(lit.value);\r\n        this.emitKeyword(sval);\r\n        (sval.indexOf('.') === -1) && this.emitChar('.0');\r\n    }\r\n\r\n\r\n    attr(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        return ctx.isVertex() ? sname.attr(decl) : sname.varying(decl);\r\n    }\r\n\r\n\r\n    emitPostfixPoint(ctx: ContextT, pfxp: IPostfixPointInstruction) {\r\n        // if (IS_INSTANCEID(pfxp.postfix.decl.semantic)) {\r\n        //     this.emitKeyword(`gl_InstanceID`);\r\n        //     return;\r\n        // }\r\n\r\n        super.emitPostfixPoint(ctx, pfxp);\r\n    }\r\n\r\n\r\n    emitFCall(ctx: ContextT, call: IFunctionCallInstruction) {\r\n        const { decl, args, callee } = call;\r\n\r\n        switch (decl.name) {\r\n            case 'mul':\r\n                assert(args.length == 2);\r\n                this.emitMulIntrinsic(ctx, args[0], args[1]);\r\n                return;\r\n            case 'lerp':\r\n                super.emitFCall(ctx, call, (decl) => 'mix');\r\n                return;\r\n            case 'frac':\r\n                super.emitFCall(ctx, call, (decl) => 'fract');\r\n                return;\r\n            case 'asuint':\r\n                // call.decl.def.params[0].type.name === 'float' ? 'floatBitsToUint' : 'floatBitsToUint'\r\n                super.emitFCall(ctx, call, (decl) => 'floatBitsToUint');\r\n                return;\r\n            case 'asfloat':\r\n                super.emitFCall(ctx, call, (decl) => 'uintBitsToFloat');\r\n                return;\r\n            case 'fmod':\r\n                super.emitFCall(ctx, call, (decl) => 'mod');\r\n                return;\r\n            case 'clip':\r\n                this.emitClipIntrinsic(ctx, args[0]);\r\n                return;\r\n\r\n        }\r\n\r\n        // todo: add correct samplers support (!)\r\n        if (callee) {\r\n            const type = callee.type;\r\n            if (SystemScope.isTexture(type)) {\r\n                const id = callee as IIdExprInstruction;\r\n                this.emitGlobal(ctx, id.decl);\r\n\r\n                if (decl.name == 'Sample') {\r\n                    this.emitKeyword(`texture`);\r\n                    this.emitChar('(');\r\n                    this.emitNoSpace();\r\n                    this.emitKeyword(id.name);\r\n                    this.emitChar(`,`);\r\n                    this.emitExpressionList(ctx, args.slice(1)); // remove sampler argument\r\n                    this.emitChar(')');\r\n                }\r\n\r\n                if (decl.name == 'GetDimensions') {\r\n                    this.emitChar('{');\r\n                    this.push();\r\n\r\n                    this.emitKeyword(`ivec2`);\r\n                    this.emitKeyword(`temp`);\r\n                    this.emitSpace();\r\n                    this.emitChar(`=`);\r\n                    this.emitKeyword('textureSize');\r\n                    this.emitChar('(');\r\n                    this.emitNoSpace();\r\n                    this.emitKeyword(id.name);\r\n                    this.emitChar(`,`);\r\n                    this.emitKeyword('int');\r\n                    this.emitChar('(');\r\n                    this.emitNoSpace();\r\n                    this.emitExpression(ctx, args[0]);\r\n                    this.emitChar(')');\r\n                    this.emitChar(')');\r\n                    this.emitChar(';');\r\n                    this.emitNewline();\r\n\r\n                    this.emitExpression(ctx, args[1]);\r\n                    this.emitSpace();\r\n                    this.emitChar(`=`);\r\n                    this.emitKeyword('uint(temp.x)');\r\n                    this.emitChar(';');\r\n                    this.emitNewline();\r\n\r\n                    this.emitExpression(ctx, args[2]);\r\n                    this.emitSpace();\r\n                    this.emitChar(`=`);\r\n                    this.emitKeyword('uint(temp.y)');\r\n                    this.emitChar(';');\r\n                    this.emitNewline();\r\n\r\n                    this.pop();\r\n                    this.emitChar('}');\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        // super.emitFCall(ctx, call);\r\n        if (decl.instructionType !== EInstructionTypes.k_SystemFunctionDecl) {\r\n            this.emitFunction(ctx, decl);\r\n        }\r\n\r\n        if (callee) {\r\n            this.emitExpression(ctx, callee);\r\n            this.emitChar('.');\r\n            this.emitNoSpace();\r\n        }\r\n        this.emitKeyword(decl.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionListWithCast(ctx, args, decl.def.params.map(p => p.type));\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitCast(ctx: ContextT, cast: ICastExprInstruction): void {\r\n        if (cast.isUseless()) {\r\n            return;\r\n        }\r\n\r\n        // replace '(vec3)value' to 'vec3(value)'\r\n        if (GlslTypeNames[cast.type.name]) {\r\n            const { typeName } = this.resolveType(ctx, cast.type);\r\n            this.emitKeyword(typeName);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitExpression(ctx, cast.expr);\r\n            this.emitChar(')');\r\n            return;\r\n        }\r\n\r\n        super.emitCast(ctx, cast);\r\n    }\r\n\r\n\r\n    emitInitExpr(ctx: ContextT, init: IInitExprInstruction) {\r\n        // replaced '{1, 2, 3}' to 'ivec3(1, 2, 3)'\r\n        if (GlslTypeNames[init.type.name]) {\r\n            const { typeName } = this.resolveType(ctx, init.type);\r\n            this.emitKeyword(typeName);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitExpressionList(ctx, init.args);\r\n            this.emitChar(')');\r\n            return;\r\n        }\r\n\r\n        super.emitInitExpr(ctx, init);\r\n    }\r\n\r\n\r\n    // todo: use emitEntryFunction instead\r\n    emitFunction(ctx: ContextT, fn: IFunctionDeclInstruction) {\r\n        const def = fn.def;\r\n        const retType = def.returnType;\r\n\r\n        const isSupported = ctx.isVertex() || ctx.isPixel();\r\n        if (this.depth() === 0 && isSupported) {\r\n            this.emitPrologue(ctx, fn.def);\r\n            const { typeName } = this.resolveType(ctx, def.returnType);\r\n\r\n            super.emitRegularFunction(ctx, fn);\r\n\r\n            // emit main()\r\n            this.begin();\r\n            {\r\n                this.emitChar('void main(void)');\r\n                this.emitNewline();\r\n                this.emitChar('{');\r\n                this.push();\r\n                const params = fn.def.params.filter(p => p.type.size !== 0);\r\n                {\r\n                    for (let p of params) {\r\n                        const pname = p.name;\r\n                        const { typeName } = this.resolveType(ctx, p.type);\r\n\r\n                        this.emitKeyword(typeName);\r\n                        this.emitKeyword(pname);\r\n                        this.emitChar(';');\r\n                        this.emitNewline();\r\n\r\n                        const fline = (decl: IVariableDeclInstruction, ids: string[]) => {\r\n                            if (decl.type.isComplex() && !SystemScope.isBase(decl.type)) {\r\n                                decl.type.fields.forEach(field => fline(field, [...ids, decl.name]));\r\n                                return;\r\n                            }\r\n                            for (let id of ids) {\r\n                                this.emitKeyword(id);\r\n                                this.emitChar('.');\r\n                                this.emitNoSpace();\r\n                            }\r\n                            this.emitKeyword(decl.name);\r\n                            this.emitSpace();\r\n                            this.emitChar('=');\r\n                            if (IS_INSTANCEID(decl.semantic)) {\r\n                                this.emitKeyword('uint(gl_InstanceID)');\r\n                            } else if (IS_VERTEXID(decl.semantic)) {\r\n                                this.emitKeyword('uint(gl_VertexID)');\r\n                            } else {\r\n                                this.emitKeyword(this.attr(ctx, decl));\r\n                            }\r\n                            this.emitChar(';');\r\n                            this.emitNewline();\r\n                        }\r\n\r\n                        fline(p, []);\r\n                    }\r\n\r\n                    const tempName = 'temp';\r\n\r\n                    this.emitKeyword(typeName);\r\n                    this.emitKeyword(tempName);\r\n                    this.emitKeyword('=');\r\n                    this.emitKeyword(fn.name);\r\n                    this.emitChar('(');\r\n                    this.emitNoSpace();\r\n                    params.forEach((param, i, list) => {\r\n                        this.emitKeyword(param.name);\r\n                        (i + 1 != list.length) && this.emitChar(',');\r\n                    });\r\n                    this.emitChar(')');\r\n                    this.emitChar(';');\r\n                    this.emitNewline();\r\n\r\n                    if (ctx.isVertex()) {\r\n\r\n                        // emit prologue like:\r\n                        // v_name = temp.name;\r\n                        {\r\n                            let fline; // emit field line\r\n                            let cdown; // breakdown and emit complex decl\r\n\r\n                            fline = (decl: IVariableDeclInstruction, ids: string[]) => {\r\n                                if (decl.type.isComplex() && !SystemScope.isBase(decl.type)) {\r\n                                    cdown(decl.type, [...ids, decl.name]);\r\n                                    return;\r\n                                }\r\n                                this.emitKeyword(sname.varying(decl));\r\n                                this.emitSpace();\r\n                                this.emitChar('=');\r\n                                for (let id of ids) {\r\n                                    this.emitKeyword(id);\r\n                                    this.emitChar('.');\r\n                                    this.emitNoSpace();\r\n                                }\r\n                                this.emitKeyword(decl.name);\r\n                                this.emitChar(';');\r\n                                this.emitNewline();\r\n                            }\r\n\r\n                            cdown = (type: ITypeInstruction, ids: string[]) => type.fields.forEach(field => fline(field, ids));\r\n                            cdown(retType, [tempName]);\r\n\r\n                        }\r\n\r\n                        const fieldPos = retType.fields.filter(field => (IS_POSITION(field.semantic)))[0];\r\n                        this.emitKeyword('gl_Position');\r\n                        this.emitKeyword('=');\r\n                        this.emitKeyword(tempName);\r\n                        this.emitChar('.');\r\n                        this.emitChar(fieldPos?.name);\r\n                        this.emitChar(';');\r\n                        this.emitNewline();\r\n                    } else { // ps\r\n                        if (types.equals(def.returnType, SystemScope.T_FLOAT4)) {\r\n                            this.emitKeyword('out_color');\r\n                            this.emitKeyword('=');\r\n                            this.emitKeyword(tempName);\r\n                            this.emitChar(';');\r\n                            this.emitNewline();\r\n                        } else if (def.returnType.isComplex()) {\r\n                            const ctype = def.returnType;\r\n                            for (const field of ctype.fields) {\r\n                                this.emitKeyword(`out_${field.name}`);\r\n                                this.emitKeyword('=');\r\n                                this.emitKeyword(`${tempName}.${field.name}`);\r\n                                this.emitChar(';');\r\n                                this.emitNewline();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n            }\r\n            this.end();\r\n            return;\r\n        }\r\n\r\n        super.emitFunction(ctx, fn);\r\n    }\r\n\r\n\r\n    //\r\n    // intrinsics\r\n    //\r\n\r\n    emitMulIntrinsic(ctx: ContextT, left: IExprInstruction, right: IExprInstruction) {\r\n        this.emitChar('(');\r\n        this.emitExpression(ctx, left);\r\n        this.emitKeyword('*');\r\n        this.emitExpression(ctx, right);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    // todo: call autogen function?\r\n    emitClipIntrinsic(ctx: ContextT, x: IExprInstruction) {\r\n        this.emitKeyword('if');\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, x);\r\n        this.emitChar(')');\r\n        this.emitKeyword(`<`)\r\n        this.emitKeyword(`0.0`);\r\n        this.emitChar(')');\r\n        this.emitKeyword(`discard`);\r\n    }\r\n\r\n    // is used in Bundle.ts\r\n    static $declToAttributeName(decl: IVariableDeclInstruction) {\r\n        return sname.attr(decl);\r\n    }\r\n\r\n\r\n    private static glslEmitter = new GLSLEmitter({ omitEmptyParams: true, omitInUsage: true });\r\n\r\n\r\n    static translate(instr: IInstruction, ctx: GLSLContext = new GLSLContext): string {\r\n        return GLSLEmitter.glslEmitter.emit(ctx, instr).toString();\r\n    }\r\n}\r\n\r\n\r\n","export function createOutput({ tab = '\\t', nl = '\\n', name = null } = {}) {\r\n    let data: string[] = [''];\r\n    let nesting = [];\r\n    let count = 0;\r\n    let noNextSpace = false;\r\n\r\n    const push = (pad = tab) => (nesting.push(pad), count && newline());\r\n    const pop = () => (nesting.pop(), count && newline());\r\n    const toString = () => data.join(nl);\r\n    const ignoreNextSpace = () => noNextSpace = true;\r\n\r\n    function add(val: string) {\r\n        if (!count) {\r\n            for (let i = 0; i < nesting.length; ++i) val = nesting[i] + val;\r\n        }\r\n        \r\n        data[data.length - 1] += val;\r\n        count++;\r\n        noNextSpace = false;\r\n    }\r\n\r\n    function keyword(token: string) {\r\n        !noNextSpace && count && add(' ');\r\n        add(token);\r\n    }\r\n\r\n    function newline() {\r\n        data.push('');\r\n        count = 0;\r\n    }\r\n\r\n    function isEmpty() {\r\n        return data.length == 1 && \r\n            data[0].length == 0;\r\n    }\r\n\r\n    return {\r\n        isEmpty,\r\n        keyword,\r\n        ignoreNextSpace,\r\n        push,\r\n        pop,\r\n        newline,\r\n        add,\r\n        toString,\r\n        name\r\n    };\r\n}\r\n\r\n\r\nexport type IOutput = ReturnType<typeof createOutput>;","export enum EAnalyzerErrors {\r\n    SystemTypeRedefinition = 2202,\r\n    TypeRedefinition,\r\n    VariableRedefinition,\r\n    SystemVariableRedefinition,\r\n    FunctionRedifinition,\r\n    CbufferRedefinition,\r\n    SystemFunctionRedefinition,\r\n\r\n    UnsupportedTypeDecl,\r\n    UnsupportedExpr,\r\n    UnknownVarName,\r\n    UnknownInstruction,\r\n    InvalidArithmeticOperation,\r\n    InvalidArithmeticAssigmentOperation,\r\n    InvalidAssigmentOperation,\r\n    InvalidBitwiseOperation,\r\n    InvalidLeftHandSideInAssignment,\r\n    InvalidRelationalOperation,\r\n    InvalidLogicOperation,\r\n    InvalidConditionType ,\r\n    InvalidConditonValueTypes,\r\n    InvalidCastTypeUsage,\r\n    InvalidCastTypeNotBase,\r\n    InvalidCastUnknownType,\r\n    InvalidUnaryOperation,\r\n    InvalidPostfixNotArray,\r\n    InvalidPostfixNotIntIndex,\r\n    InvalidPostfixNotField,\r\n    InvalidPostfixArithmetic,\r\n    InvalidComplexNotFunction,\r\n    InvalidComplexNotType,\r\n    InvalidComplexNotConstructor,\r\n    InvalidCompileNotFunction,\r\n    InvalidCompileFunctionNotValid,\r\n    FunctionRedefinition,\r\n    InvalidWhileCondition,\r\n    InvalidDoWhileCondition,\r\n    InvalidIfCondition,\r\n    InvalidForInitExpr,\r\n    InvalidForInitEmptyIterator,\r\n    InvalidForConditionEmpty,\r\n    InvalidForConditionRelation,\r\n    InvalidForStepEmpty,\r\n    InvalidForStepOperator,\r\n    InvalidForStepExpr,\r\n    InvalidNewFieldForStructName,\r\n    InvalidNewFieldForStructSematic,\r\n    InvalidNewAnnotationVar,\r\n    InvalidFunctionParameterDefenitionDefaultNeeded,\r\n    CannotChooseFunction,\r\n    InvalidFuncDefenitionReturnType,\r\n    InvalidSystemFunctionReturnType,\r\n    InvalidTypeNameNotType,\r\n    InvalidTypeNameTemplateNotFound,\r\n    InvalidTypeScope,\r\n    CannotProduceType,\r\n    InvalidTypeVectorMatrix,\r\n    TechniqueNameRedefinition,\r\n    InvalidFunctionRecursionNotAllowed,\r\n    InvalidFunctionImplementationNotFound,\r\n    // InvalidFunctionUsageVertex,\r\n    // InvalidFunctionUsagePixel,\r\n    FunctionIsNotCompatibleWithVertexShader,\r\n    FunctionIsNotCompatibleWithPixelShader,\r\n    InvalidReturnStmtVoid,\r\n    InvalidReturnStmtEmpty,\r\n    InvalidReturnStmtTypesNotEqual,\r\n    InvalidFunctionReturnType,\r\n    InvalidFunctionParameterUsage,\r\n    InvalidTypeForWriting,\r\n    InvalidTypeForReading,\r\n    InvalidExprIsNotLValue,\r\n    InvalidVariableInitializing,   // TODO: << remove (see desc below)\r\n    InvalidVariableInitializingEx, // TODO: << remove error in favor of custom errors\r\n    UnsupportedStateIndex,\r\n    InvalidSamplerTexture,\r\n    CannotCalcPadding,\r\n    ImportedComponentNotExists,\r\n    InvalidFunctionReturnStmtNotFound,\r\n    UnsupportedProvideAs,\r\n    UnreachableCode,\r\n    OperatorCannotBeUsedWithGivenLValue, // for ex.: cannot perfom (bool4)x*=(int4)y;\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    PartFx_VertexShaderParametersMismatch,\r\n    PartFx_InvalidSpawnStmtInitializerNotFound,\r\n    // PartFx_RenderPassWasNotFound, // << moved to warnings\r\n    PartFx_DrawOpOnlyAllowedWithinUpdateRoutine\r\n};\r\n","export enum EAnalyzerWarnings {\r\n    UnsupportedRenderStateTypeUsed = 3000,\r\n    IncompleteTechnique,\r\n    IncompletePass,\r\n    UselessPassState,\r\n    EmptySemicolon,\r\n    InvalidCbufferRegister,\r\n\r\n    ImplicitTypeConversion,\r\n    ImplicitTypeTruncation,\r\n\r\n    Deprecated,\r\n\r\n    // part fx\r\n    PartFx_SortingCannotBeApplied,\r\n    PartFx_PresetPropertyHasNotBeenFound,\r\n    PartFx_RenderPassWasNotFound,\r\n    PartFx_EmitterPersistentDataMustBeMarkedAsInout,\r\n\r\n    ExternCall\r\n}","/** @deprecated */\r\nexport enum ERenderStateValues {\r\n    UNDEF = 0,\r\n\r\n    TRUE,\r\n    FALSE,\r\n\r\n    ZERO,\r\n    ONE,\r\n    SRCCOLOR,\r\n    INVSRCCOLOR,\r\n    SRCALPHA,\r\n    INVSRCALPHA,\r\n    DESTALPHA,\r\n    INVDESTALPHA,\r\n    DESTCOLOR,\r\n    INVDESTCOLOR,\r\n    SRCALPHASAT,\r\n\r\n    NONE,\r\n    CW,\r\n    CCW,\r\n    FRONT,\r\n    BACK,\r\n    FRONT_AND_BACK,\r\n\r\n    NEVER,\r\n    LESS,\r\n    EQUAL,\r\n    LESSEQUAL,\r\n    GREATER,\r\n    NOTEQUAL,\r\n    GREATEREQUAL,\r\n    ALWAYS,\r\n\r\n    FUNCADD,\r\n    FUNCSUBTRACT,\r\n    FUNCREVERSESUBTRACT,\r\n\r\n    // HACK: temp hack\r\n    LINELIST,\r\n    LINESTRIP,\r\n    TRIANGLELIST,\r\n    TRAINGLESTRIP,\r\n    POINTLIST\r\n}\r\n/*\r\n//\r\n//\r\n//\r\n\r\nexport enum BLEND {\r\n    ZERO = 1,\r\n    ONE = 2,\r\n    SRC_COLOR = 3,\r\n    INV_SRC_COLOR = 4,\r\n    SRC_ALPHA = 5,\r\n    INV_SRC_ALPHA = 6,\r\n    DEST_ALPHA = 7,\r\n    INV_DEST_ALPHA = 8,\r\n    DEST_COLOR = 9,\r\n    INV_DEST_COLOR = 10,\r\n    SRC_ALPHA_SAT = 11,\r\n    BLEND_FACTOR = 14,\r\n    INV_BLEND_FACTOR = 15,\r\n    SRC1_COLOR = 16,\r\n    INV_SRC1_COLOR = 17,\r\n    SRC1_ALPHA = 18,\r\n    INV_SRC1_ALPHA = 19\r\n};\r\n\r\n\r\nexport enum BLEND_OP {\r\n    ADD = 1,\r\n    SUBTRACT = 2,\r\n    REV_SUBTRACT = 3,\r\n    MIN = 4,\r\n    MAX = 5\r\n};\r\n\r\n\r\nexport class RENDER_TARGET_BLEND_DESC {\r\n    BlendEnable: boolean;\r\n    SrcBlend: BLEND;\r\n    DestBlend: BLEND;\r\n    BlendOp: BLEND_OP;\r\n    SrcBlendAlpha: BLEND;\r\n    DestBlendAlpha: BLEND;\r\n    BlendOpAlpha: BLEND_OP;\r\n    RenderTargetWriteMask: number;\r\n};\r\n\r\n\r\n//\r\n//\r\n//\r\n\r\nexport enum DEPTH_WRITE_MASK {\r\n    ZERO = 0,\r\n    ALL = 1\r\n};\r\n\r\n\r\nexport enum COMPARISON_FUNC {\r\n    NEVER = 1,\r\n    LESS = 2,\r\n    EQUAL = 3,\r\n    LESS_EQUAL = 4,\r\n    GREATER = 5,\r\n    NOT_EQUAL = 6,\r\n    GREATER_EQUAL = 7,\r\n    ALWAYS = 8\r\n};\r\n\r\n\r\nexport enum STENCIL_OP {\r\n    KEEP = 1,\r\n    ZERO = 2,\r\n    REPLACE = 3,\r\n    INCR_SAT = 4,\r\n    DECR_SAT = 5,\r\n    INVERT = 6,\r\n    INCR = 7,\r\n    DECR = 8\r\n};\r\n\r\n\r\nexport class DEPTH_STENCILOP_DESC {\r\n    StencilFailOp: STENCIL_OP;\r\n    StencilDepthFailOp: STENCIL_OP;\r\n    StencilPassOp: STENCIL_OP;\r\n    StencilFunc: COMPARISON_FUNC;\r\n};\r\n\r\n//\r\n//\r\n//\r\n\r\nexport enum PRIMITIVE_TOPOLOGY {\r\n    UNDEFINED = 0,\r\n    POINTLIST = 1,\r\n    LINELIST = 2,\r\n    LINESTRIP = 3,\r\n    TRIANGLELIST = 4,\r\n    TRIANGLESTRIP = 5,\r\n    LINELIST_ADJ = 10,\r\n    LINESTRIP_ADJ = 11,\r\n    TRIANGLELIST_ADJ = 12,\r\n    TRIANGLESTRIP_ADJ = 13\r\n};\r\n\r\n//\r\n//\r\n//\r\n\r\nenum CULL_MODE {\r\n    NONE = 1,\r\n    FRONT = 2,\r\n    BACK = 3,\r\n    // ?\r\n    FRONT_AND_BACK = 4\r\n};\r\n\r\n\r\nenum FILL_MODE {\r\n    WIREFRAME = 2,\r\n    SOLID = 3\r\n};\r\n\r\n\r\nclass RASTERIZER_DESC {\r\n    FillMode: FILL_MODE;\r\n    CullMode: CULL_MODE;\r\n    FrontCounterClockwise: boolean;\r\n    DepthBias: number;\r\n    DepthBiasClamp: number;\r\n    SlopeScaledDepthBias: number;\r\n    DepthClipEnable: boolean;\r\n    ScissorEnable: boolean;\r\n    MultisampleEnable: boolean;\r\n    AntialiasedLineEnable: boolean;\r\n}\r\n*/\r\n","\r\n/** @deprecated */\r\nexport enum ERenderStates {\r\n\tBLENDENABLE,\r\n\tCULLFACEENABLE,\r\n\tZENABLE,\r\n\tZWRITEENABLE,\r\n\tDITHERENABLE,\r\n\tSCISSORTESTENABLE,\r\n\tSTENCILTESTENABLE,\r\n\tPOLYGONOFFSETFILLENABLE,\r\n\r\n\tCULLFACE,\r\n\tFRONTFACE,\r\n\r\n\tSRCBLENDCOLOR,\r\n\tDESTBLENDCOLOR,\r\n\r\n\tSRCBLENDALPHA,\r\n\tDESTBLENDALPHA,\r\n\r\n\tBLENDEQUATIONCOLOR,\r\n\tBLENDEQUATIONALPHA,\r\n\r\n\tZFUNC,\r\n\r\n\tALPHABLENDENABLE,\r\n\tALPHATESTENABLE,\r\n\r\n\tSRCBLEND, // Fake, set SRCBLENDCOLOR, SRCBLENDALPHA. Not use in setRenderState\r\n\tDESTBLEND, // Fake, set DESTBLENDCOLOR, DESTBLENDALPHA. Not use in setRenderState\r\n\r\n\tBLENDFUNC, // Fake, set SRCBLENDCOLOR, DESTBLENDCOLOR, SRCBLENDALPHA, DESTBLENDALPHA. Not use in setRenderState\r\n\tBLENDFUNCSEPARATE, // Fake, set SRCBLENDCOLOR, DESTBLENDCOLOR, SRCBLENDALPHA, DESTBLENDALPHA. Not use in setRenderState\r\n\r\n\tBLENDEQUATION, // Fake, set BLENDEQUATIONCOLOR, BLENDEQUATIONALPHA. Not use in setRenderState\r\n\tBLENDEQUATIONSEPARATE, // Fake, set BLENDEQUATIONCOLOR, BLENDEQUATIONALPHA. Not use in setRenderState\r\n\r\n\r\n\t// HACK:\r\n\tPRIMITIVETOPOLOGY,\r\n}\r\n","import { IPosition, IRange } from \"./parser/IParser\";\r\n\r\nexport enum EDiagnosticCategory {\r\n    k_Warning,\r\n    k_Error\r\n}\r\n\r\n\r\nexport interface IDiagnosticEntry<DESC_T> {\r\n    category: EDiagnosticCategory;\r\n    code: number;\r\n    desc: DESC_T;\r\n}\r\n\r\n\r\ntype IDiagnosticDescription = string;\r\n\r\nexport interface IDiagnosticMessage extends IRange {\r\n    code: string;\r\n    category: EDiagnosticCategory;\r\n    start: IPosition;\r\n    end: IPosition;\r\n    /** @deprecated */\r\n    file?: string;\r\n    content: string;\r\n}\r\n\r\nexport interface IDiagnosticReport {\r\n    errors: number;\r\n    warnings: number;\r\n\r\n    messages: IDiagnosticMessage[];\r\n}\r\n\r\n\r\n\r\nexport interface IDiagnostics<DESC_T> {\r\n    reset(): void;\r\n    resolve(): IDiagnosticReport;\r\n    error(code: number, desc: DESC_T);\r\n    warning(code: number, desc: DESC_T);\r\n    critical(code: number, desc: DESC_T);\r\n    prettyPrint(): string;\r\n    hasErrors(): boolean;\r\n    getLastError(): IDiagnosticMessage;\r\n}\r\n","import { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\nexport enum EInstructionTypes {\r\n    k_Instruction = 0,\r\n    \r\n    k_Id,\r\n    k_Provide,\r\n    k_Collector,\r\n    k_Keyword,      // FIXME: useless type\r\n    k_Simple,       // FIXME: useless type\r\n    k_SamplerState,\r\n    k_Attribute,\r\n    k_Annotation,   // FIXME: instruction is not fully implemented\r\n    k_UsageType,    // FIXME: instruction is not implemented\r\n    \r\n    k_Typed,        // NOTE: Abstract type\r\n    k_VariableType,\r\n    k_SystemType,\r\n    k_ComplexType,  // todo: merge with system type\r\n    k_ProxyType,\r\n    \r\n    k_Expr,         // NOTE: Abstract type\r\n    k_IdExpr,\r\n    k_IntExpr,\r\n    k_FloatExpr,\r\n    k_BoolExpr,\r\n    k_StringExpr,\r\n    k_NullExpr,\r\n    k_ArithmeticExpr,\r\n    k_AssignmentExpr,\r\n    k_BitwiseExpr,\r\n    k_RelationalExpr,\r\n    k_LogicalExpr,\r\n    k_ConditionalExpr,\r\n    k_CastExpr,\r\n    k_UnaryExpr,\r\n    k_PostfixIndexExpr,\r\n    k_PostfixPointExpr,\r\n    k_PostfixArithmeticExpr,\r\n    k_ComplexExpr,\r\n    k_FunctionCallExpr,\r\n    k_ConstructorCallExpr,\r\n    /** @deprecated */\r\n    k_CompileExpr,\r\n    k_CompileShader11Expr,\r\n    k_InitExpr,\r\n    k_StateBlockExpr,\r\n    /** @deprecated */\r\n    k_SamplerStateBlockExpr,\r\n\r\n    k_Decl,\r\n    k_TypeDecl,\r\n    k_TypedefDecl,\r\n    k_VariableDecl,\r\n    k_StructDecl,\r\n    k_FunctionDecl,\r\n    k_SystemFunctionDecl,\r\n    k_FunctionDef,\r\n    /** @deprecated */\r\n    k_PassDecl,\r\n    /** @deprecated */\r\n    k_TechniqueDecl,\r\n    k_Technique11Decl,\r\n    k_CbufferDecl,\r\n    \r\n    k_Stmt,\r\n    k_ExprStmt,\r\n    k_BreakStmt,\r\n    k_WhileStmt,\r\n    k_ForStmt,\r\n    k_IfStmt,\r\n    k_DeclStmt,\r\n    k_ReturnStmt,\r\n    k_SemicolonStmt,\r\n    k_StmtBlock,\r\n    \r\n    // part fx\r\n    k_PartFxDecl,\r\n    k_PartFxPass,\r\n    k_SpawnStmt,\r\n    k_DrawStmt,\r\n    k_PresetDecl,\r\n    k_PresetProperty\r\n}\r\n\r\n\r\nexport enum ECheckStage {\r\n    CODE_TARGET_SUPPORT, /*       (GLSL) */\r\n    SELF_CONTAINED /*  ,    , , .   . */\r\n    // VALIDATION  /*      ,     */ \r\n}\r\n\r\nexport enum EVarUsedMode {\r\n    k_Read,\r\n    k_Write,\r\n    k_ReadWrite,\r\n    k_Undefined,\r\n    k_Default = k_ReadWrite\r\n}\r\n\r\n\r\nexport interface IInstructionError {\r\n    code: number;\r\n    info: any;\r\n}\r\n\r\nexport interface ITypeUseInfoContainer {\r\n    type: IVariableTypeInstruction;\r\n    isRead: boolean;\r\n    isWrite: boolean;\r\n    numRead: number;\r\n    numWrite: number;\r\n    numUsed: number;\r\n}\r\n\r\nexport enum EExtractExprType {\r\n    k_Header,\r\n\r\n    k_Float,\r\n    k_Int,\r\n    k_Bool,\r\n\r\n    k_Float2,\r\n    k_Int2,\r\n    k_Bool2,\r\n\r\n    k_Float3,\r\n    k_Int3,\r\n    k_Bool3,\r\n\r\n    k_Float4,\r\n    k_Int4,\r\n    k_Bool4,\r\n\r\n    k_Float4x4\r\n}\r\n\r\n\r\nexport enum EScopeType {\r\n    k_System,\r\n    k_Global,\r\n    k_Default,\r\n    k_Struct,\r\n    k_Cbuffer,\r\n    k_Annotation\r\n}\r\n\r\n\r\nexport interface ITypeTemplate {\r\n    readonly name: string;\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction;\r\n    typeName(args?: ITypeInstruction[]): string;\r\n}\r\n\r\n\r\nexport interface IScope {\r\n    strictMode: boolean;\r\n\r\n    readonly parent: IScope;\r\n    readonly type: EScopeType;\r\n\r\n    readonly variables: IMap<IVariableDeclInstruction>;\r\n    readonly types: IMap<ITypeInstruction>;\r\n    readonly functions: IMap<IFunctionDeclInstruction[]>;\r\n    readonly typeTemplates: IMap<ITypeTemplate>;\r\n    readonly techniques: IMap<ITechniqueInstruction>;\r\n    readonly techniques11: IMap<ITechnique11Instruction>;\r\n    readonly cbuffers: IMap<ICbufferInstruction>;\r\n\r\n    /** Recursive check for all parents for strict mode */\r\n    isStrict(): boolean;\r\n\r\n    findVariable(variableName: string): IVariableDeclInstruction;\r\n    findType(typeName: string): ITypeInstruction;\r\n    findTypeTemplate(typeName: string): ITypeTemplate;\r\n    findFunction(funcName: string, args: Array<ITypeInstruction | RegExp>): IFunctionDeclInstruction | null | undefined;\r\n    /** @deprecated */\r\n    findTechnique(techName: string): ITechniqueInstruction | null;\r\n    findTechnique11(techName: string): ITechnique11Instruction | null;\r\n    findCbuffer(cbufName: string): ICbufferInstruction | null;\r\n\r\n    /** @deprecated */\r\n    findFunctionInScope(func: IFunctionDeclInstruction): IFunctionDeclInstruction;\r\n\r\n    addVariable(variable: IVariableDeclInstruction): boolean;\r\n    addType(type: ITypeInstruction): boolean;\r\n    addTypeAlias(typeName: string, aliasName: string): boolean;\r\n    addTypeAlias(type: ITypeInstruction, aliasName: string): boolean;\r\n    addTypeTemplate(template: ITypeTemplate): boolean;\r\n    addFunction(func: IFunctionDeclInstruction): boolean;\r\n    /** @deprecated */\r\n    addTechnique(technique: ITechniqueInstruction): boolean;\r\n    addTechnique11(technique: ITechnique11Instruction): boolean;\r\n    addCbuffer(cbuf: ICbufferInstruction): boolean;\r\n}\r\n\r\n\r\n/**\r\n * All opertion are represented by: \r\n * operator : arg1 ... argn\r\n * Operator and instructions may be empty.\r\n */\r\nexport interface IInstruction {\r\n    readonly parent: IInstruction;\r\n    readonly scope: IScope;\r\n\r\n    readonly sourceNode: IParseNode | null;\r\n    readonly instructionType: EInstructionTypes;\r\n    readonly instructionID: number;\r\n    readonly instructionName: string;\r\n\r\n    toString(): string;\r\n    toCode(): string;\r\n\r\n    /** Internal API */\r\n    $withParent<T extends IInstruction>(parent: IInstruction): T;\r\n    $withNoParent<T extends IInstruction>(): T;\r\n}\r\n\r\n\r\nexport interface IInstructionCollector extends IInstruction {\r\n    readonly instructions: IInstruction[];\r\n}\r\n\r\n\r\nexport interface ISimpleInstruction extends IInstruction {\r\n    readonly value: string;\r\n}\r\n\r\n\r\nexport interface IProvideInstruction extends IInstruction {\r\n    readonly moduleName: string;\r\n}\r\n\r\n\r\n\r\nexport interface ITypeInstruction extends IInstruction {\r\n    readonly size: number;\r\n    readonly name: string;\r\n    readonly baseType: ITypeInstruction;\r\n    readonly length: number;\r\n    readonly arrayElementType: ITypeInstruction;\r\n\r\n    readonly writable: boolean;\r\n    readonly readable: boolean;\r\n\r\n    readonly fields: IVariableDeclInstruction[];\r\n    readonly methods: IFunctionDeclInstruction[];\r\n\r\n    // Returns true if it's allowed to apply [] operator.\r\n    isArray(): boolean;\r\n    // Returns true is type is user defined array.\r\n    // an user defined array like: float f[4]\r\n    // not: float4 \r\n    isNotBaseArray(): boolean;\r\n    // Returns true if it's user defined structure\r\n    // todo: move to types.isComplex()\r\n    isComplex(): boolean;\r\n\r\n    hasFieldWithSematics(semantic: string);\r\n    hasAllUniqueSemantics(): boolean;\r\n    hasFieldWithoutSemantics(): boolean;\r\n\r\n    /** \r\n     * @deprecated \r\n     * todo: move to types.findFieldByName(type, name)\r\n     */\r\n    getField(fieldName: string): IVariableDeclInstruction;\r\n    /** \r\n     * @deprecated \r\n     * todo: move to types.findFieldBySemantic(type, name)\r\n     */\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction;\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    getMethod(methodName: string, args?: Array<ITypeInstruction | RegExp>): IFunctionDeclInstruction;\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string;\r\n}\r\n\r\n\r\nexport type IVariableUsage = 'uniform' | 'const' | 'in' | 'out' | 'inout' | 'unsigned' | 'static' | 'precise';\r\n\r\nexport interface IVariableTypeInstruction extends ITypeInstruction {\r\n    readonly usages: IVariableUsage[];\r\n    readonly subType: ITypeInstruction;\r\n    readonly padding: number;\r\n    readonly aligment: number;\r\n\r\n    isUniform(): boolean;\r\n    isStatic(): boolean;\r\n    isConst(): boolean;\r\n\r\n    // for structures internal usage\r\n    $overwritePadding(padding: number, aligment: number): void;\r\n}\r\n\r\n\r\nexport interface ITypedInstruction extends IInstruction {\r\n    readonly type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport interface IConditionalExprInstruction extends IExprInstruction {\r\n    readonly condition: IExprInstruction;\r\n    readonly left: ITypedInstruction;\r\n    readonly right: ITypedInstruction;\r\n}\r\n\r\n\r\nexport interface IDeclInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly id: IIdInstruction;\r\n\r\n    readonly semantic: string;\r\n    readonly annotation: IAnnotationInstruction;\r\n}\r\n\r\n\r\nexport interface IFunctionDefInstruction extends IDeclInstruction {\r\n    readonly returnType: IVariableTypeInstruction;\r\n    readonly name: string;\r\n    readonly params: IVariableDeclInstruction[];\r\n}\r\n\r\n\r\nexport interface ITypeDeclInstruction extends IDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport interface ITypedefInstruction extends IDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n    readonly alias: string;\r\n}\r\n\r\n\r\nexport interface IRegister {\r\n    type: 'u' | 'b' | 't' | 's' | null;\r\n    index: number;\r\n    // space ?\r\n};\r\n\r\nexport interface ICbufferInstruction extends IDeclInstruction, ITypedInstruction {\r\n    \r\n}\r\n\r\n\r\nexport interface ISamplerStateInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly value: IInstruction;\r\n}\r\n\r\n\r\nexport interface IVariableDeclInstruction extends IDeclInstruction, ITypedInstruction {\r\n    readonly type: IVariableTypeInstruction;\r\n    readonly initExpr: IExprInstruction;\r\n    readonly usageFlags: number;\r\n\r\n    isParameter(): boolean;\r\n    isLocal(): boolean;\r\n    isGlobal(): boolean;\r\n    isField(): boolean;\r\n    // is part of the constant buffer ?\r\n    isConstant(): boolean;\r\n}\r\n\r\n\r\nexport interface IFunctionDeclInstruction extends IDeclInstruction {\r\n    readonly def: IFunctionDefInstruction;\r\n    readonly impl: IStmtBlockInstruction;\r\n    readonly attrs: IAttributeInstruction[];\r\n}\r\n\r\n\r\nexport interface IStructDeclInstruction extends IInstruction {\r\n\r\n}\r\n\r\n\r\nexport interface IIdInstruction extends IInstruction {\r\n    readonly name: string;\r\n}\r\n\r\n\r\nexport interface IKeywordInstruction extends IInstruction {\r\n    value: string;\r\n}\r\n\r\n\r\nexport interface IExprInstruction extends ITypedInstruction {\r\n    readonly type: IVariableTypeInstruction;\r\n\r\n    isConst(): boolean;\r\n    isConstExpr(): boolean;\r\n}\r\n\r\nexport type ILogicalOperator = \"&&\" | \"||\";\r\n\r\nexport interface ILogicalExprInstruction extends IExprInstruction {\r\n    operator: ILogicalOperator;\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n}\r\n\r\nexport type IBitwiseOperator = \">>\" | \"<<\" | \"&\" | \"|\" | \"^\";\r\n\r\nexport interface IBitwiseExprInstruction extends IExprInstruction {\r\n    operator: IBitwiseOperator;\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n}\r\n\r\nexport type IUnaryOperator = \"+\" | \"-\" | \"!\" | \"++\" | \"--\";\r\n\r\nexport interface IUnaryExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n    readonly operator: IUnaryOperator;\r\n}\r\n\r\nexport interface IPostfixPointInstruction extends IExprInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly postfix: IIdExprInstruction;\r\n}\r\n\r\n\r\nexport interface IPostfixIndexInstruction extends IExprInstruction {\r\n    readonly index: IExprInstruction;\r\n    readonly element: IExprInstruction;\r\n}\r\n\r\n\r\nexport interface IConstructorCallInstruction extends IExprInstruction {\r\n    readonly args: IInstruction[];\r\n    readonly ctor: IVariableTypeInstruction;\r\n}\r\n\r\nexport type IArithmeticOperator = '+' | '-' | '/' | '*' | '%';\r\n\r\n\r\nexport interface IArithmeticExprInstruction extends IExprInstruction {\r\n    readonly right: IExprInstruction;\r\n    readonly left: IExprInstruction;\r\n    readonly operator: IArithmeticOperator;\r\n}\r\n\r\nexport interface ICastExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n\r\n    /** @deprecated */\r\n    isUseless(): boolean;\r\n}\r\n\r\n\r\nexport interface IComplexExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n}\r\n\r\n\r\nexport interface IPostfixArithmeticInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n    readonly operator: string;\r\n}\r\n\r\n/** @deprecated */\r\nexport interface ISamplerStateBlockInstruction extends IExprInstruction {\r\n    readonly texture: IVariableDeclInstruction;\r\n    readonly params: ISamplerStateInstruction[];\r\n    readonly operator: string;\r\n}\r\n\r\n\r\n/** @deprecated */\r\nexport interface ICompileExprInstruction extends IExprInstruction {\r\n    readonly function: IFunctionDeclInstruction;\r\n    readonly args: IExprInstruction[];\r\n}\r\n\r\nexport interface ICompileShader11Instruction extends IExprInstruction {\r\n    readonly ver: string;\r\n    readonly func: IFunctionDeclInstruction;\r\n    readonly args: IExprInstruction[];\r\n}\r\n\r\nexport interface IRelationalExprInstruction extends IExprInstruction {\r\n    readonly left: IExprInstruction;\r\n    readonly right: IExprInstruction;\r\n    readonly operator: string;\r\n}\r\n\r\nexport interface IAssignmentExprInstruction extends IExprInstruction {\r\n    readonly operator: string;\r\n    readonly left: IExprInstruction;\r\n    readonly right: ITypedInstruction;\r\n}\r\n\r\n\r\nexport interface IInitExprInstruction extends IExprInstruction {\r\n    readonly args: IExprInstruction[];\r\n\r\n    // Returns true if it's not a base array initialization, like \"int a[2] = { 1, 1 }\"\r\n    /** @deprecated */\r\n    isArray(): boolean;\r\n\r\n    // todo: refactor this!!\r\n    optimizeForVariableType(type: IVariableTypeInstruction): boolean;\r\n}\r\n\r\n\r\nexport interface IStateBlockInstruction extends IExprInstruction {\r\n    readonly props: Object; // native json?\r\n    readonly blocks: IStateBlockInstruction[];\r\n}\r\n\r\n\r\nexport interface IIdExprInstruction extends IExprInstruction {\r\n    readonly name: string;\r\n    readonly id: IIdInstruction;\r\n\r\n    /** @helpers */\r\n    readonly type: IVariableTypeInstruction;\r\n    readonly decl: IVariableDeclInstruction;\r\n}\r\n\r\n\r\nexport interface IFunctionCallInstruction extends IExprInstruction {\r\n    readonly callee: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    // move it to method?\r\n    readonly decl: IFunctionDeclInstruction;   \r\n}\r\n\r\n\r\nexport interface ILiteralInstruction<T = number | boolean | string> extends IExprInstruction {\r\n    readonly value: T;\r\n}\r\n\r\n\r\nexport type IExprDerived =\r\n    | IArithmeticExprInstruction\r\n    | IAssignmentExprInstruction\r\n    | ICastExprInstruction\r\n    | ICompileExprInstruction\r\n    | ICompileShader11Instruction\r\n    | IComplexExprInstruction\r\n    | IConditionalExprInstruction\r\n    | IConstructorCallInstruction\r\n    | IFunctionCallInstruction\r\n    | IIdExprInstruction\r\n    | IInitExprInstruction\r\n    | IStateBlockInstruction\r\n    | ILiteralInstruction<number>\r\n    | ILiteralInstruction<boolean>\r\n    | ILiteralInstruction<string>\r\n    | ILogicalExprInstruction\r\n    | IPostfixArithmeticInstruction\r\n    | IPostfixIndexInstruction\r\n    | IPostfixPointInstruction\r\n    | IRelationalExprInstruction\r\n    | ISamplerStateBlockInstruction\r\n    | IUnaryExprInstruction;\r\n\r\nexport interface IAnnotationInstruction extends IInstruction {\r\n    decls: IVariableDeclInstruction[];\r\n}\r\n\r\n\r\nexport interface IStmtInstruction extends IInstruction {\r\n}\r\n\r\nexport interface IAttributeInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly args: ILiteralInstruction<number | boolean>[];\r\n}\r\n\r\nexport interface IForStmtInstruction extends IStmtInstruction {\r\n    readonly init: ITypedInstruction;\r\n    readonly cond: IExprInstruction;\r\n    readonly step: IExprInstruction;\r\n    readonly body: IStmtInstruction;\r\n}\r\n\r\nexport type IDoWhileOperator = \"do\" | \"while\";\r\n\r\nexport interface IWhileStmtInstruction extends IStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly body: IStmtInstruction;\r\n    readonly operator: IDoWhileOperator;\r\n}\r\n\r\nexport interface IDeclStmtInstruction extends IStmtInstruction {\r\n    readonly declList: IDeclInstruction[];\r\n}\r\n\r\nexport type IReturnOperator = \"return\";\r\n\r\nexport interface IReturnStmtInstruction extends IStmtInstruction {\r\n    readonly operator: IReturnOperator;\r\n    readonly expr: IExprInstruction;\r\n}\r\n\r\nexport interface IIfStmtInstruction extends IStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly conseq: IStmtInstruction;\r\n    readonly contrary: IStmtInstruction;\r\n    readonly attrs: IAttributeInstruction[];\r\n}\r\n\r\n\r\nexport interface IStmtBlockInstruction extends IStmtInstruction {\r\n    readonly stmtList: IStmtInstruction[];\r\n}\r\n\r\n\r\n\r\nexport interface IExprStmtInstruction extends IStmtInstruction {\r\n    expr: IExprInstruction;\r\n}\r\n\r\nexport type IPass11Instruction = IFunctionDeclInstruction;\r\n\r\n/** @deprecated */\r\nexport interface IPassInstruction extends IDeclInstruction {\r\n    readonly id: IIdInstruction;\r\n\r\n    readonly vertexShader: IFunctionDeclInstruction;\r\n    readonly pixelShader: IFunctionDeclInstruction;\r\n\r\n    readonly renderStates: IMap<ERenderStateValues>;\r\n    getState(type: ERenderStates): ERenderStateValues;\r\n\r\n    /** check if the pass is ready for runtime */\r\n    isValid(): boolean;\r\n}\r\n\r\n\r\nexport type IStmtDerived =\r\n    | IDeclStmtInstruction\r\n    | IReturnStmtInstruction\r\n    | IIfStmtInstruction\r\n    | IStmtBlockInstruction\r\n    | IExprStmtInstruction\r\n    | IWhileStmtInstruction\r\n    | IForStmtInstruction;\r\n\r\n\r\nexport enum ETechniqueType {\r\n    k_BasicFx,  // << basic Microsoft DirectX like effect\r\n    k_PartFx,\r\n    k_Unknown\r\n}\r\n\r\n//\r\n// Preset extention\r\n//\r\n\r\nexport interface IPresetPropertyInstruction extends IInstruction{ \r\n    id: IIdInstruction;\r\n    args: IExprInstruction[];\r\n \r\n    resolveDeclaration(): IVariableDeclInstruction;\r\n }\r\n \r\n export interface IPresetInstruction extends IDeclInstruction {\r\n    props: IPresetPropertyInstruction[];\r\n }\r\n\r\n//\r\n//\r\n//\r\n\r\nexport interface ITechniqueInstruction extends IDeclInstruction {\r\n    readonly passes: IPassInstruction[];\r\n    readonly type: ETechniqueType;\r\n\r\n    /** check if the technique is ready for runtime */\r\n    isValid(): boolean;\r\n\r\n    // todo: separate from basic dx effect functionality (?)\r\n    // Preset extention (non-standart)\r\n    // note: see PRESETS_EX define in HLSL.gr\r\n    readonly presets: IPresetInstruction[];\r\n}\r\n\r\n\r\nexport interface ITechnique11Instruction extends IDeclInstruction {\r\n    readonly passes: IPass11Instruction[];\r\n\r\n    /** check if the technique is ready for runtime */\r\n    isValid(): boolean;\r\n}\r\n\r\nexport interface IFunctionDeclListMap {\r\n    [functionName: string]: IFunctionDeclInstruction[];\r\n}\r\n\r\n","import { ERenderStateValues } from \"./ERenderStateValues\";\r\nimport { IMap } from \"./IMap\";\r\nimport { ITechnique, ITechniqueRenderPass } from \"./ITechnique\";\r\n\r\nexport interface IAttribute {\r\n    size: number;\r\n    offset: number;\r\n    name: string;\r\n}\r\n\r\n\r\nexport enum EUsage {\r\n    k_Vertex = 0x01,\r\n    k_Pixel = 0x02,\r\n    k_Compute = 0x04\r\n};\r\n\r\n\r\nexport interface IConstanBufferField {\r\n    name: string;\r\n    semantic: string;\r\n    size: number;\r\n    padding: number;\r\n    length: number;\r\n}\r\n\r\n\r\nexport interface IConstantBuffer {\r\n    slot: number;\r\n    name: string;\r\n    size: number;\r\n    usage: number;\r\n    fields: IConstanBufferField[];\r\n}\r\n\r\n\r\n/** @deprecated */\r\nexport interface ITechnique9PassDesc\r\n{\r\n    instanceName: string;\r\n    instanceLayout: IAttribute[];\r\n    stride: number; // number of float elements in the prerendered particle (src)\r\n\r\n    // GLSL shader's sources\r\n    vertexShader: string;\r\n    pixelShader: string;\r\n\r\n    renderStates: IMap<ERenderStateValues>;\r\n\r\n    cbuffers: IConstantBuffer[];\r\n}\r\n\r\n/** @deprecated */\r\nexport interface ITechnique9RenderPass<DESC_T extends ITechnique9PassDesc = ITechnique9PassDesc> extends ITechniqueRenderPass {\r\n    getDesc(): DESC_T;\r\n}\r\n\r\n/** @deprecated */\r\nexport interface ITechnique9<PASS_T extends ITechnique9RenderPass = ITechnique9RenderPass> extends ITechnique<PASS_T> {}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { TypeField, TypeFieldT } from './type-field';\r\n\r\n\r\nexport class CBBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):CBBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsCBBundle(bb:flatbuffers.ByteBuffer, obj?:CBBundle):CBBundle {\r\n  return (obj || new CBBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsCBBundle(bb:flatbuffers.ByteBuffer, obj?:CBBundle):CBBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new CBBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nslot():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nsize():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nfields(index: number, obj?:TypeField):TypeField|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new TypeField()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nfieldsLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startCBBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(4);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addSlot(builder:flatbuffers.Builder, slot:number) {\r\n  builder.addFieldInt32(1, slot, 0);\r\n}\r\n\r\nstatic addSize(builder:flatbuffers.Builder, size:number) {\r\n  builder.addFieldInt32(2, size, 0);\r\n}\r\n\r\nstatic addFields(builder:flatbuffers.Builder, fieldsOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, fieldsOffset, 0);\r\n}\r\n\r\nstatic createFieldsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startFieldsVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endCBBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createCBBundle(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, slot:number, size:number, fieldsOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  CBBundle.startCBBundle(builder);\r\n  CBBundle.addName(builder, nameOffset);\r\n  CBBundle.addSlot(builder, slot);\r\n  CBBundle.addSize(builder, size);\r\n  CBBundle.addFields(builder, fieldsOffset);\r\n  return CBBundle.endCBBundle(builder);\r\n}\r\n\r\nunpack(): CBBundleT {\r\n  return new CBBundleT(\r\n    this.name(),\r\n    this.slot(),\r\n    this.size(),\r\n    this.bb!.createObjList(this.fields.bind(this), this.fieldsLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: CBBundleT): void {\r\n  _o.name = this.name();\r\n  _o.slot = this.slot();\r\n  _o.size = this.size();\r\n  _o.fields = this.bb!.createObjList(this.fields.bind(this), this.fieldsLength());\r\n}\r\n}\r\n\r\nexport class CBBundleT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public slot: number = 0,\r\n  public size: number = 0,\r\n  public fields: (TypeFieldT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const fields = CBBundle.createFieldsVector(builder, builder.createObjectOffsetList(this.fields));\r\n\r\n  return CBBundle.createCBBundle(builder,\r\n    name,\r\n    this.slot,\r\n    this.size,\r\n    fields\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { TypeLayout, TypeLayoutT } from '../type-layout';\r\n\r\n\r\nexport class BufferBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):BufferBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsBufferBundle(bb:flatbuffers.ByteBuffer, obj?:BufferBundle):BufferBundle {\r\n  return (obj || new BufferBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsBufferBundle(bb:flatbuffers.ByteBuffer, obj?:BufferBundle):BufferBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new BufferBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nslot():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstride():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\ntype(obj?:TypeLayout):TypeLayout|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new TypeLayout()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nstatic startBufferBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(4);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addSlot(builder:flatbuffers.Builder, slot:number) {\r\n  builder.addFieldInt32(1, slot, 0);\r\n}\r\n\r\nstatic addStride(builder:flatbuffers.Builder, stride:number) {\r\n  builder.addFieldInt32(2, stride, 0);\r\n}\r\n\r\nstatic addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, typeOffset, 0);\r\n}\r\n\r\nstatic endBufferBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\n\r\nunpack(): BufferBundleT {\r\n  return new BufferBundleT(\r\n    this.name(),\r\n    this.slot(),\r\n    this.stride(),\r\n    (this.type() !== null ? this.type()!.unpack() : null)\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: BufferBundleT): void {\r\n  _o.name = this.name();\r\n  _o.slot = this.slot();\r\n  _o.stride = this.stride();\r\n  _o.type = (this.type() !== null ? this.type()!.unpack() : null);\r\n}\r\n}\r\n\r\nexport class BufferBundleT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public slot: number = 0,\r\n  public stride: number = 0,\r\n  public type: TypeLayoutT|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const type = (this.type !== null ? this.type!.pack(builder) : 0);\r\n\r\n  BufferBundle.startBufferBundle(builder);\r\n  BufferBundle.addName(builder, name);\r\n  BufferBundle.addSlot(builder, this.slot);\r\n  BufferBundle.addStride(builder, this.stride);\r\n  BufferBundle.addType(builder, type);\r\n\r\n  return BufferBundle.endBufferBundle(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport { MatBundle, MatBundleT } from '../fx/mat-bundle';\r\nimport { PartBundle, PartBundleT } from '../fx/part-bundle';\r\nimport { Technique11Bundle, Technique11BundleT } from '../fx/technique11bundle';\r\n\r\n\r\nexport enum BundleContent {\r\n  NONE = 0,\r\n  PartBundle = 1,\r\n  MatBundle = 2,\r\n  Technique11Bundle = 3\r\n}\r\n\r\nexport function unionToBundleContent(\r\n  type: BundleContent,\r\n  accessor: (obj:MatBundle|PartBundle|Technique11Bundle) => MatBundle|PartBundle|Technique11Bundle|null\r\n): MatBundle|PartBundle|Technique11Bundle|null {\r\n  switch(BundleContent[type]) {\r\n    case 'NONE': return null; \r\n    case 'PartBundle': return accessor(new PartBundle())! as PartBundle;\r\n    case 'MatBundle': return accessor(new MatBundle())! as MatBundle;\r\n    case 'Technique11Bundle': return accessor(new Technique11Bundle())! as Technique11Bundle;\r\n    default: return null;\r\n  }\r\n}\r\n\r\nexport function unionListToBundleContent(\r\n  type: BundleContent, \r\n  accessor: (index: number, obj:MatBundle|PartBundle|Technique11Bundle) => MatBundle|PartBundle|Technique11Bundle|null, \r\n  index: number\r\n): MatBundle|PartBundle|Technique11Bundle|null {\r\n  switch(BundleContent[type]) {\r\n    case 'NONE': return null; \r\n    case 'PartBundle': return accessor(index, new PartBundle())! as PartBundle;\r\n    case 'MatBundle': return accessor(index, new MatBundle())! as MatBundle;\r\n    case 'Technique11Bundle': return accessor(index, new Technique11Bundle())! as Technique11Bundle;\r\n    default: return null;\r\n  }\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class BundleMeta {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):BundleMeta {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsBundleMeta(bb:flatbuffers.ByteBuffer, obj?:BundleMeta):BundleMeta {\r\n  return (obj || new BundleMeta()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsBundleMeta(bb:flatbuffers.ByteBuffer, obj?:BundleMeta):BundleMeta {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new BundleMeta()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nauthor():string|null\r\nauthor(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nauthor(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nsource():string|null\r\nsource(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nsource(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nstatic startBundleMeta(builder:flatbuffers.Builder) {\r\n  builder.startObject(2);\r\n}\r\n\r\nstatic addAuthor(builder:flatbuffers.Builder, authorOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, authorOffset, 0);\r\n}\r\n\r\nstatic addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, sourceOffset, 0);\r\n}\r\n\r\nstatic endBundleMeta(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createBundleMeta(builder:flatbuffers.Builder, authorOffset:flatbuffers.Offset, sourceOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  BundleMeta.startBundleMeta(builder);\r\n  BundleMeta.addAuthor(builder, authorOffset);\r\n  BundleMeta.addSource(builder, sourceOffset);\r\n  return BundleMeta.endBundleMeta(builder);\r\n}\r\n\r\nunpack(): BundleMetaT {\r\n  return new BundleMetaT(\r\n    this.author(),\r\n    this.source()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: BundleMetaT): void {\r\n  _o.author = this.author();\r\n  _o.source = this.source();\r\n}\r\n}\r\n\r\nexport class BundleMetaT {\r\nconstructor(\r\n  public author: string|Uint8Array|null = null,\r\n  public source: string|Uint8Array|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const author = (this.author !== null ? builder.createString(this.author!) : 0);\r\n  const source = (this.source !== null ? builder.createString(this.source!) : 0);\r\n\r\n  return BundleMeta.createBundleMeta(builder,\r\n    author,\r\n    source\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class BundleSignature {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):BundleSignature {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsBundleSignature(bb:flatbuffers.ByteBuffer, obj?:BundleSignature):BundleSignature {\r\n  return (obj || new BundleSignature()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsBundleSignature(bb:flatbuffers.ByteBuffer, obj?:BundleSignature):BundleSignature {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new BundleSignature()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nmode():string|null\r\nmode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nmode(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nversion():string|null\r\nversion(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nversion(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\ncommithash():string|null\r\ncommithash(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ncommithash(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nbranch():string|null\r\nbranch(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nbranch(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\ntimestamp():string|null\r\ntimestamp(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ntimestamp(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nstatic startBundleSignature(builder:flatbuffers.Builder) {\r\n  builder.startObject(5);\r\n}\r\n\r\nstatic addMode(builder:flatbuffers.Builder, modeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, modeOffset, 0);\r\n}\r\n\r\nstatic addVersion(builder:flatbuffers.Builder, versionOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, versionOffset, 0);\r\n}\r\n\r\nstatic addCommithash(builder:flatbuffers.Builder, commithashOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, commithashOffset, 0);\r\n}\r\n\r\nstatic addBranch(builder:flatbuffers.Builder, branchOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, branchOffset, 0);\r\n}\r\n\r\nstatic addTimestamp(builder:flatbuffers.Builder, timestampOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(4, timestampOffset, 0);\r\n}\r\n\r\nstatic endBundleSignature(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createBundleSignature(builder:flatbuffers.Builder, modeOffset:flatbuffers.Offset, versionOffset:flatbuffers.Offset, commithashOffset:flatbuffers.Offset, branchOffset:flatbuffers.Offset, timestampOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  BundleSignature.startBundleSignature(builder);\r\n  BundleSignature.addMode(builder, modeOffset);\r\n  BundleSignature.addVersion(builder, versionOffset);\r\n  BundleSignature.addCommithash(builder, commithashOffset);\r\n  BundleSignature.addBranch(builder, branchOffset);\r\n  BundleSignature.addTimestamp(builder, timestampOffset);\r\n  return BundleSignature.endBundleSignature(builder);\r\n}\r\n\r\nunpack(): BundleSignatureT {\r\n  return new BundleSignatureT(\r\n    this.mode(),\r\n    this.version(),\r\n    this.commithash(),\r\n    this.branch(),\r\n    this.timestamp()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: BundleSignatureT): void {\r\n  _o.mode = this.mode();\r\n  _o.version = this.version();\r\n  _o.commithash = this.commithash();\r\n  _o.branch = this.branch();\r\n  _o.timestamp = this.timestamp();\r\n}\r\n}\r\n\r\nexport class BundleSignatureT {\r\nconstructor(\r\n  public mode: string|Uint8Array|null = null,\r\n  public version: string|Uint8Array|null = null,\r\n  public commithash: string|Uint8Array|null = null,\r\n  public branch: string|Uint8Array|null = null,\r\n  public timestamp: string|Uint8Array|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const mode = (this.mode !== null ? builder.createString(this.mode!) : 0);\r\n  const version = (this.version !== null ? builder.createString(this.version!) : 0);\r\n  const commithash = (this.commithash !== null ? builder.createString(this.commithash!) : 0);\r\n  const branch = (this.branch !== null ? builder.createString(this.branch!) : 0);\r\n  const timestamp = (this.timestamp !== null ? builder.createString(this.timestamp!) : 0);\r\n\r\n  return BundleSignature.createBundleSignature(builder,\r\n    mode,\r\n    version,\r\n    commithash,\r\n    branch,\r\n    timestamp\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { BundleContent, unionToBundleContent, unionListToBundleContent } from '../fx/bundle-content';\r\nimport { BundleMeta, BundleMetaT } from '../fx/bundle-meta';\r\nimport { BundleSignature, BundleSignatureT } from '../fx/bundle-signature';\r\nimport { MatBundle, MatBundleT } from '../fx/mat-bundle';\r\nimport { PartBundle, PartBundleT } from '../fx/part-bundle';\r\nimport { Preset, PresetT } from '../fx/preset';\r\nimport { Technique11Bundle, Technique11BundleT } from '../fx/technique11bundle';\r\nimport { UIControl, UIControlT } from '../fx/uicontrol';\r\n\r\n\r\nexport class Bundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):Bundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsBundle(bb:flatbuffers.ByteBuffer, obj?:Bundle):Bundle {\r\n  return (obj || new Bundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsBundle(bb:flatbuffers.ByteBuffer, obj?:Bundle):Bundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new Bundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nsignature(obj?:BundleSignature):BundleSignature|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? (obj || new BundleSignature()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nmeta(obj?:BundleMeta):BundleMeta|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new BundleMeta()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\ncontentType():BundleContent {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : BundleContent.NONE;\r\n}\r\n\r\ncontent<T extends flatbuffers.Table>(obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\r\n}\r\n\r\ncontrols(index: number, obj?:UIControl):UIControl|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 14);\r\n  return offset ? (obj || new UIControl()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\ncontrolsLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 14);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\npresets(index: number, obj?:Preset):Preset|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 16);\r\n  return offset ? (obj || new Preset()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\npresetsLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 16);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(7);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addSignature(builder:flatbuffers.Builder, signatureOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, signatureOffset, 0);\r\n}\r\n\r\nstatic addMeta(builder:flatbuffers.Builder, metaOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, metaOffset, 0);\r\n}\r\n\r\nstatic addContentType(builder:flatbuffers.Builder, contentType:BundleContent) {\r\n  builder.addFieldInt8(3, contentType, BundleContent.NONE);\r\n}\r\n\r\nstatic addContent(builder:flatbuffers.Builder, contentOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(4, contentOffset, 0);\r\n}\r\n\r\nstatic addControls(builder:flatbuffers.Builder, controlsOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(5, controlsOffset, 0);\r\n}\r\n\r\nstatic createControlsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startControlsVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addPresets(builder:flatbuffers.Builder, presetsOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(6, presetsOffset, 0);\r\n}\r\n\r\nstatic createPresetsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startPresetsVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic finishBundleBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {\r\n  builder.finish(offset);\r\n}\r\n\r\nstatic finishSizePrefixedBundleBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {\r\n  builder.finish(offset, undefined, true);\r\n}\r\n\r\n\r\nunpack(): BundleT {\r\n  return new BundleT(\r\n    this.name(),\r\n    (this.signature() !== null ? this.signature()!.unpack() : null),\r\n    (this.meta() !== null ? this.meta()!.unpack() : null),\r\n    this.contentType(),\r\n    (() => {\r\n      let temp = unionToBundleContent(this.contentType(), this.content.bind(this));\r\n      if(temp === null) { return null; }\r\n      return temp.unpack()\r\n  })(),\r\n    this.bb!.createObjList(this.controls.bind(this), this.controlsLength()),\r\n    this.bb!.createObjList(this.presets.bind(this), this.presetsLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: BundleT): void {\r\n  _o.name = this.name();\r\n  _o.signature = (this.signature() !== null ? this.signature()!.unpack() : null);\r\n  _o.meta = (this.meta() !== null ? this.meta()!.unpack() : null);\r\n  _o.contentType = this.contentType();\r\n  _o.content = (() => {\r\n      let temp = unionToBundleContent(this.contentType(), this.content.bind(this));\r\n      if(temp === null) { return null; }\r\n      return temp.unpack()\r\n  })();\r\n  _o.controls = this.bb!.createObjList(this.controls.bind(this), this.controlsLength());\r\n  _o.presets = this.bb!.createObjList(this.presets.bind(this), this.presetsLength());\r\n}\r\n}\r\n\r\nexport class BundleT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public signature: BundleSignatureT|null = null,\r\n  public meta: BundleMetaT|null = null,\r\n  public contentType: BundleContent = BundleContent.NONE,\r\n  public content: MatBundleT|PartBundleT|Technique11BundleT|null = null,\r\n  public controls: (UIControlT)[] = [],\r\n  public presets: (PresetT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const signature = (this.signature !== null ? this.signature!.pack(builder) : 0);\r\n  const meta = (this.meta !== null ? this.meta!.pack(builder) : 0);\r\n  const content = builder.createObjectOffset(this.content);\r\n  const controls = Bundle.createControlsVector(builder, builder.createObjectOffsetList(this.controls));\r\n  const presets = Bundle.createPresetsVector(builder, builder.createObjectOffsetList(this.presets));\r\n\r\n  Bundle.startBundle(builder);\r\n  Bundle.addName(builder, name);\r\n  Bundle.addSignature(builder, signature);\r\n  Bundle.addMeta(builder, meta);\r\n  Bundle.addContentType(builder, this.contentType);\r\n  Bundle.addContent(builder, content);\r\n  Bundle.addControls(builder, controls);\r\n  Bundle.addPresets(builder, presets);\r\n\r\n  return Bundle.endBundle(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class ColorValue {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):ColorValue {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nr():number {\r\n  return this.bb!.readUint8(this.bb_pos);\r\n}\r\n\r\ng():number {\r\n  return this.bb!.readUint8(this.bb_pos + 1);\r\n}\r\n\r\nb():number {\r\n  return this.bb!.readUint8(this.bb_pos + 2);\r\n}\r\n\r\na():number {\r\n  return this.bb!.readUint8(this.bb_pos + 3);\r\n}\r\n\r\nstatic sizeOf():number {\r\n  return 4;\r\n}\r\n\r\nstatic createColorValue(builder:flatbuffers.Builder, r: number, g: number, b: number, a: number):flatbuffers.Offset {\r\n  builder.prep(1, 4);\r\n  builder.writeInt8(a);\r\n  builder.writeInt8(b);\r\n  builder.writeInt8(g);\r\n  builder.writeInt8(r);\r\n  return builder.offset();\r\n}\r\n\r\n\r\nunpack(): ColorValueT {\r\n  return new ColorValueT(\r\n    this.r(),\r\n    this.g(),\r\n    this.b(),\r\n    this.a()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: ColorValueT): void {\r\n  _o.r = this.r();\r\n  _o.g = this.g();\r\n  _o.b = this.b();\r\n  _o.a = this.a();\r\n}\r\n}\r\n\r\nexport class ColorValueT {\r\nconstructor(\r\n  public r: number = 0,\r\n  public g: number = 0,\r\n  public b: number = 0,\r\n  public a: number = 0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  return ColorValue.createColorValue(builder,\r\n    this.r,\r\n    this.g,\r\n    this.b,\r\n    this.a\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport { ColorValue, ColorValueT } from '../fx/color-value';\r\nimport { Float2Value, Float2ValueT } from '../fx/float2value';\r\nimport { Float3Value, Float3ValueT } from '../fx/float3value';\r\nimport { Float4Value, Float4ValueT } from '../fx/float4value';\r\nimport { FloatValue, FloatValueT } from '../fx/float-value';\r\nimport { IntValue, IntValueT } from '../fx/int-value';\r\nimport { MeshValue, MeshValueT } from '../fx/mesh-value';\r\nimport { TextureValue, TextureValueT } from '../fx/texture-value';\r\nimport { UintValue, UintValueT } from '../fx/uint-value';\r\n\r\n\r\nexport enum ControlValue {\r\n  NONE = 0,\r\n  UintValue = 1,\r\n  IntValue = 2,\r\n  FloatValue = 3,\r\n  Float2Value = 4,\r\n  Float3Value = 5,\r\n  Float4Value = 6,\r\n  ColorValue = 7,\r\n  TextureValue = 8,\r\n  MeshValue = 9\r\n}\r\n\r\nexport function unionToControlValue(\r\n  type: ControlValue,\r\n  accessor: (obj:ColorValue|Float2Value|Float3Value|Float4Value|FloatValue|IntValue|MeshValue|TextureValue|UintValue) => ColorValue|Float2Value|Float3Value|Float4Value|FloatValue|IntValue|MeshValue|TextureValue|UintValue|null\r\n): ColorValue|Float2Value|Float3Value|Float4Value|FloatValue|IntValue|MeshValue|TextureValue|UintValue|null {\r\n  switch(ControlValue[type]) {\r\n    case 'NONE': return null; \r\n    case 'UintValue': return accessor(new UintValue())! as UintValue;\r\n    case 'IntValue': return accessor(new IntValue())! as IntValue;\r\n    case 'FloatValue': return accessor(new FloatValue())! as FloatValue;\r\n    case 'Float2Value': return accessor(new Float2Value())! as Float2Value;\r\n    case 'Float3Value': return accessor(new Float3Value())! as Float3Value;\r\n    case 'Float4Value': return accessor(new Float4Value())! as Float4Value;\r\n    case 'ColorValue': return accessor(new ColorValue())! as ColorValue;\r\n    case 'TextureValue': return accessor(new TextureValue())! as TextureValue;\r\n    case 'MeshValue': return accessor(new MeshValue())! as MeshValue;\r\n    default: return null;\r\n  }\r\n}\r\n\r\nexport function unionListToControlValue(\r\n  type: ControlValue, \r\n  accessor: (index: number, obj:ColorValue|Float2Value|Float3Value|Float4Value|FloatValue|IntValue|MeshValue|TextureValue|UintValue) => ColorValue|Float2Value|Float3Value|Float4Value|FloatValue|IntValue|MeshValue|TextureValue|UintValue|null, \r\n  index: number\r\n): ColorValue|Float2Value|Float3Value|Float4Value|FloatValue|IntValue|MeshValue|TextureValue|UintValue|null {\r\n  switch(ControlValue[type]) {\r\n    case 'NONE': return null; \r\n    case 'UintValue': return accessor(index, new UintValue())! as UintValue;\r\n    case 'IntValue': return accessor(index, new IntValue())! as IntValue;\r\n    case 'FloatValue': return accessor(index, new FloatValue())! as FloatValue;\r\n    case 'Float2Value': return accessor(index, new Float2Value())! as Float2Value;\r\n    case 'Float3Value': return accessor(index, new Float3Value())! as Float3Value;\r\n    case 'Float4Value': return accessor(index, new Float4Value())! as Float4Value;\r\n    case 'ColorValue': return accessor(index, new ColorValue())! as ColorValue;\r\n    case 'TextureValue': return accessor(index, new TextureValue())! as TextureValue;\r\n    case 'MeshValue': return accessor(index, new MeshValue())! as MeshValue;\r\n    default: return null;\r\n  }\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nexport enum EMatRenderRoutines {\r\n  k_Vertex = 0,\r\n  k_Pixel = 1,\r\n  k_Last = 2\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nexport enum EPartRenderRoutines {\r\n  k_Prerender = 0,\r\n  k_Vertex = 1,\r\n  k_Pixel = 2,\r\n  k_Last = 3\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nexport enum EPartSimRoutines {\r\n  k_Reset = 0,\r\n  k_Spawn = 1,\r\n  k_Init = 2,\r\n  k_Update = 3,\r\n  k_Last = 4\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class FloatValue {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):FloatValue {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nvalue():number {\r\n  return this.bb!.readFloat32(this.bb_pos);\r\n}\r\n\r\nstatic sizeOf():number {\r\n  return 4;\r\n}\r\n\r\nstatic createFloatValue(builder:flatbuffers.Builder, value: number):flatbuffers.Offset {\r\n  builder.prep(4, 4);\r\n  builder.writeFloat32(value);\r\n  return builder.offset();\r\n}\r\n\r\n\r\nunpack(): FloatValueT {\r\n  return new FloatValueT(\r\n    this.value()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: FloatValueT): void {\r\n  _o.value = this.value();\r\n}\r\n}\r\n\r\nexport class FloatValueT {\r\nconstructor(\r\n  public value: number = 0.0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  return FloatValue.createFloatValue(builder,\r\n    this.value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class Float2Value {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):Float2Value {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nx():number {\r\n  return this.bb!.readFloat32(this.bb_pos);\r\n}\r\n\r\ny():number {\r\n  return this.bb!.readFloat32(this.bb_pos + 4);\r\n}\r\n\r\nstatic sizeOf():number {\r\n  return 8;\r\n}\r\n\r\nstatic createFloat2Value(builder:flatbuffers.Builder, x: number, y: number):flatbuffers.Offset {\r\n  builder.prep(4, 8);\r\n  builder.writeFloat32(y);\r\n  builder.writeFloat32(x);\r\n  return builder.offset();\r\n}\r\n\r\n\r\nunpack(): Float2ValueT {\r\n  return new Float2ValueT(\r\n    this.x(),\r\n    this.y()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: Float2ValueT): void {\r\n  _o.x = this.x();\r\n  _o.y = this.y();\r\n}\r\n}\r\n\r\nexport class Float2ValueT {\r\nconstructor(\r\n  public x: number = 0.0,\r\n  public y: number = 0.0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  return Float2Value.createFloat2Value(builder,\r\n    this.x,\r\n    this.y\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class Float3Value {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):Float3Value {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nx():number {\r\n  return this.bb!.readFloat32(this.bb_pos);\r\n}\r\n\r\ny():number {\r\n  return this.bb!.readFloat32(this.bb_pos + 4);\r\n}\r\n\r\nz():number {\r\n  return this.bb!.readFloat32(this.bb_pos + 8);\r\n}\r\n\r\nstatic sizeOf():number {\r\n  return 12;\r\n}\r\n\r\nstatic createFloat3Value(builder:flatbuffers.Builder, x: number, y: number, z: number):flatbuffers.Offset {\r\n  builder.prep(4, 12);\r\n  builder.writeFloat32(z);\r\n  builder.writeFloat32(y);\r\n  builder.writeFloat32(x);\r\n  return builder.offset();\r\n}\r\n\r\n\r\nunpack(): Float3ValueT {\r\n  return new Float3ValueT(\r\n    this.x(),\r\n    this.y(),\r\n    this.z()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: Float3ValueT): void {\r\n  _o.x = this.x();\r\n  _o.y = this.y();\r\n  _o.z = this.z();\r\n}\r\n}\r\n\r\nexport class Float3ValueT {\r\nconstructor(\r\n  public x: number = 0.0,\r\n  public y: number = 0.0,\r\n  public z: number = 0.0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  return Float3Value.createFloat3Value(builder,\r\n    this.x,\r\n    this.y,\r\n    this.z\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class Float4Value {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):Float4Value {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nx():number {\r\n  return this.bb!.readFloat32(this.bb_pos);\r\n}\r\n\r\ny():number {\r\n  return this.bb!.readFloat32(this.bb_pos + 4);\r\n}\r\n\r\nz():number {\r\n  return this.bb!.readFloat32(this.bb_pos + 8);\r\n}\r\n\r\nw():number {\r\n  return this.bb!.readFloat32(this.bb_pos + 12);\r\n}\r\n\r\nstatic sizeOf():number {\r\n  return 16;\r\n}\r\n\r\nstatic createFloat4Value(builder:flatbuffers.Builder, x: number, y: number, z: number, w: number):flatbuffers.Offset {\r\n  builder.prep(4, 16);\r\n  builder.writeFloat32(w);\r\n  builder.writeFloat32(z);\r\n  builder.writeFloat32(y);\r\n  builder.writeFloat32(x);\r\n  return builder.offset();\r\n}\r\n\r\n\r\nunpack(): Float4ValueT {\r\n  return new Float4ValueT(\r\n    this.x(),\r\n    this.y(),\r\n    this.z(),\r\n    this.w()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: Float4ValueT): void {\r\n  _o.x = this.x();\r\n  _o.y = this.y();\r\n  _o.z = this.z();\r\n  _o.w = this.w();\r\n}\r\n}\r\n\r\nexport class Float4ValueT {\r\nconstructor(\r\n  public x: number = 0.0,\r\n  public y: number = 0.0,\r\n  public z: number = 0.0,\r\n  public w: number = 0.0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  return Float4Value.createFloat4Value(builder,\r\n    this.x,\r\n    this.y,\r\n    this.z,\r\n    this.w\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class GLSLAttribute {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):GLSLAttribute {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsGLSLAttribute(bb:flatbuffers.ByteBuffer, obj?:GLSLAttribute):GLSLAttribute {\r\n  return (obj || new GLSLAttribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsGLSLAttribute(bb:flatbuffers.ByteBuffer, obj?:GLSLAttribute):GLSLAttribute {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new GLSLAttribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nsize():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\noffset():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nstatic startGLSLAttribute(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addSize(builder:flatbuffers.Builder, size:number) {\r\n  builder.addFieldInt32(0, size, 0);\r\n}\r\n\r\nstatic addOffset(builder:flatbuffers.Builder, offset:number) {\r\n  builder.addFieldInt32(1, offset, 0);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, nameOffset, 0);\r\n}\r\n\r\nstatic endGLSLAttribute(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createGLSLAttribute(builder:flatbuffers.Builder, size:number, offset:number, nameOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  GLSLAttribute.startGLSLAttribute(builder);\r\n  GLSLAttribute.addSize(builder, size);\r\n  GLSLAttribute.addOffset(builder, offset);\r\n  GLSLAttribute.addName(builder, nameOffset);\r\n  return GLSLAttribute.endGLSLAttribute(builder);\r\n}\r\n\r\nunpack(): GLSLAttributeT {\r\n  return new GLSLAttributeT(\r\n    this.size(),\r\n    this.offset(),\r\n    this.name()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: GLSLAttributeT): void {\r\n  _o.size = this.size();\r\n  _o.offset = this.offset();\r\n  _o.name = this.name();\r\n}\r\n}\r\n\r\nexport class GLSLAttributeT {\r\nconstructor(\r\n  public size: number = 0,\r\n  public offset: number = 0,\r\n  public name: string|Uint8Array|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n\r\n  return GLSLAttribute.createGLSLAttribute(builder,\r\n    this.size,\r\n    this.offset,\r\n    name\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class IntValue {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):IntValue {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nvalue():number {\r\n  return this.bb!.readInt32(this.bb_pos);\r\n}\r\n\r\nstatic sizeOf():number {\r\n  return 4;\r\n}\r\n\r\nstatic createIntValue(builder:flatbuffers.Builder, value: number):flatbuffers.Offset {\r\n  builder.prep(4, 4);\r\n  builder.writeInt32(value);\r\n  return builder.offset();\r\n}\r\n\r\n\r\nunpack(): IntValueT {\r\n  return new IntValueT(\r\n    this.value()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: IntValueT): void {\r\n  _o.value = this.value();\r\n}\r\n}\r\n\r\nexport class IntValueT {\r\nconstructor(\r\n  public value: number = 0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  return IntValue.createIntValue(builder,\r\n    this.value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { MatRenderPass, MatRenderPassT } from '../fx/mat-render-pass';\r\n\r\n\r\nexport class MatBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):MatBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsMatBundle(bb:flatbuffers.ByteBuffer, obj?:MatBundle):MatBundle {\r\n  return (obj || new MatBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsMatBundle(bb:flatbuffers.ByteBuffer, obj?:MatBundle):MatBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new MatBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nrenderPasses(index: number, obj?:MatRenderPass):MatRenderPass|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? (obj || new MatRenderPass()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nrenderPassesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startMatBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(1);\r\n}\r\n\r\nstatic addRenderPasses(builder:flatbuffers.Builder, renderPassesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, renderPassesOffset, 0);\r\n}\r\n\r\nstatic createRenderPassesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startRenderPassesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endMatBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createMatBundle(builder:flatbuffers.Builder, renderPassesOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  MatBundle.startMatBundle(builder);\r\n  MatBundle.addRenderPasses(builder, renderPassesOffset);\r\n  return MatBundle.endMatBundle(builder);\r\n}\r\n\r\nunpack(): MatBundleT {\r\n  return new MatBundleT(\r\n    this.bb!.createObjList(this.renderPasses.bind(this), this.renderPassesLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: MatBundleT): void {\r\n  _o.renderPasses = this.bb!.createObjList(this.renderPasses.bind(this), this.renderPassesLength());\r\n}\r\n}\r\n\r\nexport class MatBundleT {\r\nconstructor(\r\n  public renderPasses: (MatRenderPassT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const renderPasses = MatBundle.createRenderPassesVector(builder, builder.createObjectOffsetList(this.renderPasses));\r\n\r\n  return MatBundle.createMatBundle(builder,\r\n    renderPasses\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { RenderState, RenderStateT } from '../fx/render-state';\r\nimport { RoutineBundle, unionToRoutineBundle, unionListToRoutineBundle } from '../fx/routine-bundle';\r\nimport { RoutineBytecodeBundle, RoutineBytecodeBundleT } from '../fx/routine-bytecode-bundle';\r\nimport { RoutineShaderBundle, RoutineShaderBundleT } from '../fx/routine-shader-bundle';\r\nimport { TypeLayout, TypeLayoutT } from '../type-layout';\r\n\r\n\r\nexport class MatRenderPass {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):MatRenderPass {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsMatRenderPass(bb:flatbuffers.ByteBuffer, obj?:MatRenderPass):MatRenderPass {\r\n  return (obj || new MatRenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsMatRenderPass(bb:flatbuffers.ByteBuffer, obj?:MatRenderPass):MatRenderPass {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new MatRenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nroutinesType(index: number):RoutineBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\r\n}\r\n\r\nroutinesTypeLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nroutinesTypeArray():Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nroutines(index: number, obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__union(obj, this.bb!.__vector(this.bb_pos + offset) + index * 4) : null;\r\n}\r\n\r\nroutinesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\ninstance(obj?:TypeLayout):TypeLayout|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new TypeLayout()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nstride():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nrenderStates(index: number, obj?:RenderState):RenderState|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? (obj || new RenderState()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nrenderStatesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startMatRenderPass(builder:flatbuffers.Builder) {\r\n  builder.startObject(5);\r\n}\r\n\r\nstatic addRoutinesType(builder:flatbuffers.Builder, routinesTypeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, routinesTypeOffset, 0);\r\n}\r\n\r\nstatic createRoutinesTypeVector(builder:flatbuffers.Builder, data:RoutineBundle[]):flatbuffers.Offset {\r\n  builder.startVector(1, data.length, 1);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt8(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startRoutinesTypeVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(1, numElems, 1);\r\n}\r\n\r\nstatic addRoutines(builder:flatbuffers.Builder, routinesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, routinesOffset, 0);\r\n}\r\n\r\nstatic createRoutinesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startRoutinesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addInstance(builder:flatbuffers.Builder, instanceOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, instanceOffset, 0);\r\n}\r\n\r\nstatic addStride(builder:flatbuffers.Builder, stride:number) {\r\n  builder.addFieldInt32(3, stride, 0);\r\n}\r\n\r\nstatic addRenderStates(builder:flatbuffers.Builder, renderStatesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(4, renderStatesOffset, 0);\r\n}\r\n\r\nstatic createRenderStatesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startRenderStatesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endMatRenderPass(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\n\r\nunpack(): MatRenderPassT {\r\n  return new MatRenderPassT(\r\n    this.bb!.createScalarList(this.routinesType.bind(this), this.routinesTypeLength()),\r\n    (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.routinesTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.routinesType(targetEnumIndex);\r\n      if(targetEnum === null || RoutineBundle[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToRoutineBundle(targetEnum, this.routines.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })(),\r\n    (this.instance() !== null ? this.instance()!.unpack() : null),\r\n    this.stride(),\r\n    this.bb!.createObjList(this.renderStates.bind(this), this.renderStatesLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: MatRenderPassT): void {\r\n  _o.routinesType = this.bb!.createScalarList(this.routinesType.bind(this), this.routinesTypeLength());\r\n  _o.routines = (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.routinesTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.routinesType(targetEnumIndex);\r\n      if(targetEnum === null || RoutineBundle[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToRoutineBundle(targetEnum, this.routines.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })();\r\n  _o.instance = (this.instance() !== null ? this.instance()!.unpack() : null);\r\n  _o.stride = this.stride();\r\n  _o.renderStates = this.bb!.createObjList(this.renderStates.bind(this), this.renderStatesLength());\r\n}\r\n}\r\n\r\nexport class MatRenderPassT {\r\nconstructor(\r\n  public routinesType: (RoutineBundle)[] = [],\r\n  public routines: (RoutineBytecodeBundleT|RoutineShaderBundleT)[] = [],\r\n  public instance: TypeLayoutT|null = null,\r\n  public stride: number = 0,\r\n  public renderStates: (RenderStateT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const routinesType = MatRenderPass.createRoutinesTypeVector(builder, this.routinesType);\r\n  const routines = MatRenderPass.createRoutinesVector(builder, builder.createObjectOffsetList(this.routines));\r\n  const instance = (this.instance !== null ? this.instance!.pack(builder) : 0);\r\n  const renderStates = MatRenderPass.createRenderStatesVector(builder, builder.createObjectOffsetList(this.renderStates));\r\n\r\n  MatRenderPass.startMatRenderPass(builder);\r\n  MatRenderPass.addRoutinesType(builder, routinesType);\r\n  MatRenderPass.addRoutines(builder, routines);\r\n  MatRenderPass.addInstance(builder, instance);\r\n  MatRenderPass.addStride(builder, this.stride);\r\n  MatRenderPass.addRenderStates(builder, renderStates);\r\n\r\n  return MatRenderPass.endMatRenderPass(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class MeshValue {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):MeshValue {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsMeshValue(bb:flatbuffers.ByteBuffer, obj?:MeshValue):MeshValue {\r\n  return (obj || new MeshValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsMeshValue(bb:flatbuffers.ByteBuffer, obj?:MeshValue):MeshValue {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new MeshValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nvalue():string|null\r\nvalue(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nvalue(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nstatic startMeshValue(builder:flatbuffers.Builder) {\r\n  builder.startObject(1);\r\n}\r\n\r\nstatic addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, valueOffset, 0);\r\n}\r\n\r\nstatic endMeshValue(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createMeshValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  MeshValue.startMeshValue(builder);\r\n  MeshValue.addValue(builder, valueOffset);\r\n  return MeshValue.endMeshValue(builder);\r\n}\r\n\r\nunpack(): MeshValueT {\r\n  return new MeshValueT(\r\n    this.value()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: MeshValueT): void {\r\n  _o.value = this.value();\r\n}\r\n}\r\n\r\nexport class MeshValueT {\r\nconstructor(\r\n  public value: string|Uint8Array|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const value = (this.value !== null ? builder.createString(this.value!) : 0);\r\n\r\n  return MeshValue.createMeshValue(builder,\r\n    value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { PartRenderPass, PartRenderPassT } from '../fx/part-render-pass';\r\nimport { RoutineBundle, unionToRoutineBundle, unionListToRoutineBundle } from '../fx/routine-bundle';\r\nimport { RoutineBytecodeBundle, RoutineBytecodeBundleT } from '../fx/routine-bytecode-bundle';\r\nimport { RoutineShaderBundle, RoutineShaderBundleT } from '../fx/routine-shader-bundle';\r\nimport { TypeLayout, TypeLayoutT } from '../type-layout';\r\n\r\n\r\nexport class PartBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):PartBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsPartBundle(bb:flatbuffers.ByteBuffer, obj?:PartBundle):PartBundle {\r\n  return (obj || new PartBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsPartBundle(bb:flatbuffers.ByteBuffer, obj?:PartBundle):PartBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new PartBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ncapacity():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nsimulationRoutinesType(index: number):RoutineBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\r\n}\r\n\r\nsimulationRoutinesTypeLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nsimulationRoutinesTypeArray():Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nsimulationRoutines(index: number, obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__union(obj, this.bb!.__vector(this.bb_pos + offset) + index * 4) : null;\r\n}\r\n\r\nsimulationRoutinesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nrenderPasses(index: number, obj?:PartRenderPass):PartRenderPass|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new PartRenderPass()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nrenderPassesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nparticle(obj?:TypeLayout):TypeLayout|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? (obj || new TypeLayout()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nstatic startPartBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(5);\r\n}\r\n\r\nstatic addCapacity(builder:flatbuffers.Builder, capacity:number) {\r\n  builder.addFieldInt32(0, capacity, 0);\r\n}\r\n\r\nstatic addSimulationRoutinesType(builder:flatbuffers.Builder, simulationRoutinesTypeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, simulationRoutinesTypeOffset, 0);\r\n}\r\n\r\nstatic createSimulationRoutinesTypeVector(builder:flatbuffers.Builder, data:RoutineBundle[]):flatbuffers.Offset {\r\n  builder.startVector(1, data.length, 1);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt8(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startSimulationRoutinesTypeVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(1, numElems, 1);\r\n}\r\n\r\nstatic addSimulationRoutines(builder:flatbuffers.Builder, simulationRoutinesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, simulationRoutinesOffset, 0);\r\n}\r\n\r\nstatic createSimulationRoutinesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startSimulationRoutinesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addRenderPasses(builder:flatbuffers.Builder, renderPassesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, renderPassesOffset, 0);\r\n}\r\n\r\nstatic createRenderPassesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startRenderPassesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addParticle(builder:flatbuffers.Builder, particleOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(4, particleOffset, 0);\r\n}\r\n\r\nstatic endPartBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\n\r\nunpack(): PartBundleT {\r\n  return new PartBundleT(\r\n    this.capacity(),\r\n    this.bb!.createScalarList(this.simulationRoutinesType.bind(this), this.simulationRoutinesTypeLength()),\r\n    (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.simulationRoutinesTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.simulationRoutinesType(targetEnumIndex);\r\n      if(targetEnum === null || RoutineBundle[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToRoutineBundle(targetEnum, this.simulationRoutines.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })(),\r\n    this.bb!.createObjList(this.renderPasses.bind(this), this.renderPassesLength()),\r\n    (this.particle() !== null ? this.particle()!.unpack() : null)\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: PartBundleT): void {\r\n  _o.capacity = this.capacity();\r\n  _o.simulationRoutinesType = this.bb!.createScalarList(this.simulationRoutinesType.bind(this), this.simulationRoutinesTypeLength());\r\n  _o.simulationRoutines = (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.simulationRoutinesTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.simulationRoutinesType(targetEnumIndex);\r\n      if(targetEnum === null || RoutineBundle[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToRoutineBundle(targetEnum, this.simulationRoutines.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })();\r\n  _o.renderPasses = this.bb!.createObjList(this.renderPasses.bind(this), this.renderPassesLength());\r\n  _o.particle = (this.particle() !== null ? this.particle()!.unpack() : null);\r\n}\r\n}\r\n\r\nexport class PartBundleT {\r\nconstructor(\r\n  public capacity: number = 0,\r\n  public simulationRoutinesType: (RoutineBundle)[] = [],\r\n  public simulationRoutines: (RoutineBytecodeBundleT|RoutineShaderBundleT)[] = [],\r\n  public renderPasses: (PartRenderPassT)[] = [],\r\n  public particle: TypeLayoutT|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const simulationRoutinesType = PartBundle.createSimulationRoutinesTypeVector(builder, this.simulationRoutinesType);\r\n  const simulationRoutines = PartBundle.createSimulationRoutinesVector(builder, builder.createObjectOffsetList(this.simulationRoutines));\r\n  const renderPasses = PartBundle.createRenderPassesVector(builder, builder.createObjectOffsetList(this.renderPasses));\r\n  const particle = (this.particle !== null ? this.particle!.pack(builder) : 0);\r\n\r\n  PartBundle.startPartBundle(builder);\r\n  PartBundle.addCapacity(builder, this.capacity);\r\n  PartBundle.addSimulationRoutinesType(builder, simulationRoutinesType);\r\n  PartBundle.addSimulationRoutines(builder, simulationRoutines);\r\n  PartBundle.addRenderPasses(builder, renderPasses);\r\n  PartBundle.addParticle(builder, particle);\r\n\r\n  return PartBundle.endPartBundle(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { RenderState, RenderStateT } from '../fx/render-state';\r\nimport { RoutineBundle, unionToRoutineBundle, unionListToRoutineBundle } from '../fx/routine-bundle';\r\nimport { RoutineBytecodeBundle, RoutineBytecodeBundleT } from '../fx/routine-bytecode-bundle';\r\nimport { RoutineShaderBundle, RoutineShaderBundleT } from '../fx/routine-shader-bundle';\r\nimport { TypeLayout, TypeLayoutT } from '../type-layout';\r\n\r\n\r\nexport class PartRenderPass {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):PartRenderPass {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsPartRenderPass(bb:flatbuffers.ByteBuffer, obj?:PartRenderPass):PartRenderPass {\r\n  return (obj || new PartRenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsPartRenderPass(bb:flatbuffers.ByteBuffer, obj?:PartRenderPass):PartRenderPass {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new PartRenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nroutinesType(index: number):RoutineBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\r\n}\r\n\r\nroutinesTypeLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nroutinesTypeArray():Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nroutines(index: number, obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__union(obj, this.bb!.__vector(this.bb_pos + offset) + index * 4) : null;\r\n}\r\n\r\nroutinesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\ngeometry():string|null\r\ngeometry(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ngeometry(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nsorting():boolean {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\r\n}\r\n\r\ninstanceCount():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstride():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 14);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\ninstance(obj?:TypeLayout):TypeLayout|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 16);\r\n  return offset ? (obj || new TypeLayout()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nrenderStates(index: number, obj?:RenderState):RenderState|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 18);\r\n  return offset ? (obj || new RenderState()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nrenderStatesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 18);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startPartRenderPass(builder:flatbuffers.Builder) {\r\n  builder.startObject(8);\r\n}\r\n\r\nstatic addRoutinesType(builder:flatbuffers.Builder, routinesTypeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, routinesTypeOffset, 0);\r\n}\r\n\r\nstatic createRoutinesTypeVector(builder:flatbuffers.Builder, data:RoutineBundle[]):flatbuffers.Offset {\r\n  builder.startVector(1, data.length, 1);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt8(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startRoutinesTypeVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(1, numElems, 1);\r\n}\r\n\r\nstatic addRoutines(builder:flatbuffers.Builder, routinesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, routinesOffset, 0);\r\n}\r\n\r\nstatic createRoutinesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startRoutinesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addGeometry(builder:flatbuffers.Builder, geometryOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, geometryOffset, 0);\r\n}\r\n\r\nstatic addSorting(builder:flatbuffers.Builder, sorting:boolean) {\r\n  builder.addFieldInt8(3, +sorting, +false);\r\n}\r\n\r\nstatic addInstanceCount(builder:flatbuffers.Builder, instanceCount:number) {\r\n  builder.addFieldInt32(4, instanceCount, 0);\r\n}\r\n\r\nstatic addStride(builder:flatbuffers.Builder, stride:number) {\r\n  builder.addFieldInt32(5, stride, 0);\r\n}\r\n\r\nstatic addInstance(builder:flatbuffers.Builder, instanceOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(6, instanceOffset, 0);\r\n}\r\n\r\nstatic addRenderStates(builder:flatbuffers.Builder, renderStatesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(7, renderStatesOffset, 0);\r\n}\r\n\r\nstatic createRenderStatesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startRenderStatesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endPartRenderPass(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\n\r\nunpack(): PartRenderPassT {\r\n  return new PartRenderPassT(\r\n    this.bb!.createScalarList(this.routinesType.bind(this), this.routinesTypeLength()),\r\n    (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.routinesTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.routinesType(targetEnumIndex);\r\n      if(targetEnum === null || RoutineBundle[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToRoutineBundle(targetEnum, this.routines.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })(),\r\n    this.geometry(),\r\n    this.sorting(),\r\n    this.instanceCount(),\r\n    this.stride(),\r\n    (this.instance() !== null ? this.instance()!.unpack() : null),\r\n    this.bb!.createObjList(this.renderStates.bind(this), this.renderStatesLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: PartRenderPassT): void {\r\n  _o.routinesType = this.bb!.createScalarList(this.routinesType.bind(this), this.routinesTypeLength());\r\n  _o.routines = (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.routinesTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.routinesType(targetEnumIndex);\r\n      if(targetEnum === null || RoutineBundle[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToRoutineBundle(targetEnum, this.routines.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })();\r\n  _o.geometry = this.geometry();\r\n  _o.sorting = this.sorting();\r\n  _o.instanceCount = this.instanceCount();\r\n  _o.stride = this.stride();\r\n  _o.instance = (this.instance() !== null ? this.instance()!.unpack() : null);\r\n  _o.renderStates = this.bb!.createObjList(this.renderStates.bind(this), this.renderStatesLength());\r\n}\r\n}\r\n\r\nexport class PartRenderPassT {\r\nconstructor(\r\n  public routinesType: (RoutineBundle)[] = [],\r\n  public routines: (RoutineBytecodeBundleT|RoutineShaderBundleT)[] = [],\r\n  public geometry: string|Uint8Array|null = null,\r\n  public sorting: boolean = false,\r\n  public instanceCount: number = 0,\r\n  public stride: number = 0,\r\n  public instance: TypeLayoutT|null = null,\r\n  public renderStates: (RenderStateT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const routinesType = PartRenderPass.createRoutinesTypeVector(builder, this.routinesType);\r\n  const routines = PartRenderPass.createRoutinesVector(builder, builder.createObjectOffsetList(this.routines));\r\n  const geometry = (this.geometry !== null ? builder.createString(this.geometry!) : 0);\r\n  const instance = (this.instance !== null ? this.instance!.pack(builder) : 0);\r\n  const renderStates = PartRenderPass.createRenderStatesVector(builder, builder.createObjectOffsetList(this.renderStates));\r\n\r\n  PartRenderPass.startPartRenderPass(builder);\r\n  PartRenderPass.addRoutinesType(builder, routinesType);\r\n  PartRenderPass.addRoutines(builder, routines);\r\n  PartRenderPass.addGeometry(builder, geometry);\r\n  PartRenderPass.addSorting(builder, this.sorting);\r\n  PartRenderPass.addInstanceCount(builder, this.instanceCount);\r\n  PartRenderPass.addStride(builder, this.stride);\r\n  PartRenderPass.addInstance(builder, instance);\r\n  PartRenderPass.addRenderStates(builder, renderStates);\r\n\r\n  return PartRenderPass.endPartRenderPass(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { CBBundle, CBBundleT } from '../cbbundle';\r\n\r\n\r\nexport class PixelShader {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):PixelShader {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsPixelShader(bb:flatbuffers.ByteBuffer, obj?:PixelShader):PixelShader {\r\n  return (obj || new PixelShader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsPixelShader(bb:flatbuffers.ByteBuffer, obj?:PixelShader):PixelShader {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new PixelShader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ncode():string|null\r\ncode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ncode(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nentryName():string|null\r\nentryName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nentryName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\ncbuffers(index: number, obj?:CBBundle):CBBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new CBBundle()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\ncbuffersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startPixelShader(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addCode(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, codeOffset, 0);\r\n}\r\n\r\nstatic addEntryName(builder:flatbuffers.Builder, entryNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, entryNameOffset, 0);\r\n}\r\n\r\nstatic addCbuffers(builder:flatbuffers.Builder, cbuffersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, cbuffersOffset, 0);\r\n}\r\n\r\nstatic createCbuffersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startCbuffersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endPixelShader(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createPixelShader(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset, entryNameOffset:flatbuffers.Offset, cbuffersOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  PixelShader.startPixelShader(builder);\r\n  PixelShader.addCode(builder, codeOffset);\r\n  PixelShader.addEntryName(builder, entryNameOffset);\r\n  PixelShader.addCbuffers(builder, cbuffersOffset);\r\n  return PixelShader.endPixelShader(builder);\r\n}\r\n\r\nunpack(): PixelShaderT {\r\n  return new PixelShaderT(\r\n    this.code(),\r\n    this.entryName(),\r\n    this.bb!.createObjList(this.cbuffers.bind(this), this.cbuffersLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: PixelShaderT): void {\r\n  _o.code = this.code();\r\n  _o.entryName = this.entryName();\r\n  _o.cbuffers = this.bb!.createObjList(this.cbuffers.bind(this), this.cbuffersLength());\r\n}\r\n}\r\n\r\nexport class PixelShaderT {\r\nconstructor(\r\n  public code: string|Uint8Array|null = null,\r\n  public entryName: string|Uint8Array|null = null,\r\n  public cbuffers: (CBBundleT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const code = (this.code !== null ? builder.createString(this.code!) : 0);\r\n  const entryName = (this.entryName !== null ? builder.createString(this.entryName!) : 0);\r\n  const cbuffers = PixelShader.createCbuffersVector(builder, builder.createObjectOffsetList(this.cbuffers));\r\n\r\n  return PixelShader.createPixelShader(builder,\r\n    code,\r\n    entryName,\r\n    cbuffers\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { ColorValue, ColorValueT } from '../fx/color-value';\r\nimport { ControlValue, unionToControlValue, unionListToControlValue } from '../fx/control-value';\r\nimport { Float2Value, Float2ValueT } from '../fx/float2value';\r\nimport { Float3Value, Float3ValueT } from '../fx/float3value';\r\nimport { Float4Value, Float4ValueT } from '../fx/float4value';\r\nimport { FloatValue, FloatValueT } from '../fx/float-value';\r\nimport { IntValue, IntValueT } from '../fx/int-value';\r\nimport { MeshValue, MeshValueT } from '../fx/mesh-value';\r\nimport { TextureValue, TextureValueT } from '../fx/texture-value';\r\nimport { UintValue, UintValueT } from '../fx/uint-value';\r\n\r\n\r\nexport class PresetEntry {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):PresetEntry {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsPresetEntry(bb:flatbuffers.ByteBuffer, obj?:PresetEntry):PresetEntry {\r\n  return (obj || new PresetEntry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsPresetEntry(bb:flatbuffers.ByteBuffer, obj?:PresetEntry):PresetEntry {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new PresetEntry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nvalueType():ControlValue {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : ControlValue.NONE;\r\n}\r\n\r\nvalue<T extends flatbuffers.Table>(obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\r\n}\r\n\r\nstatic startPresetEntry(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addValueType(builder:flatbuffers.Builder, valueType:ControlValue) {\r\n  builder.addFieldInt8(1, valueType, ControlValue.NONE);\r\n}\r\n\r\nstatic addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, valueOffset, 0);\r\n}\r\n\r\nstatic endPresetEntry(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createPresetEntry(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, valueType:ControlValue, valueOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  PresetEntry.startPresetEntry(builder);\r\n  PresetEntry.addName(builder, nameOffset);\r\n  PresetEntry.addValueType(builder, valueType);\r\n  PresetEntry.addValue(builder, valueOffset);\r\n  return PresetEntry.endPresetEntry(builder);\r\n}\r\n\r\nunpack(): PresetEntryT {\r\n  return new PresetEntryT(\r\n    this.name(),\r\n    this.valueType(),\r\n    (() => {\r\n      let temp = unionToControlValue(this.valueType(), this.value.bind(this));\r\n      if(temp === null) { return null; }\r\n      return temp.unpack()\r\n  })()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: PresetEntryT): void {\r\n  _o.name = this.name();\r\n  _o.valueType = this.valueType();\r\n  _o.value = (() => {\r\n      let temp = unionToControlValue(this.valueType(), this.value.bind(this));\r\n      if(temp === null) { return null; }\r\n      return temp.unpack()\r\n  })();\r\n}\r\n}\r\n\r\nexport class PresetEntryT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public valueType: ControlValue = ControlValue.NONE,\r\n  public value: ColorValueT|Float2ValueT|Float3ValueT|Float4ValueT|FloatValueT|IntValueT|MeshValueT|TextureValueT|UintValueT|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const value = builder.createObjectOffset(this.value);\r\n\r\n  return PresetEntry.createPresetEntry(builder,\r\n    name,\r\n    this.valueType,\r\n    value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { PresetEntry, PresetEntryT } from '../fx/preset-entry';\r\n\r\n\r\nexport class Preset {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):Preset {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsPreset(bb:flatbuffers.ByteBuffer, obj?:Preset):Preset {\r\n  return (obj || new Preset()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsPreset(bb:flatbuffers.ByteBuffer, obj?:Preset):Preset {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new Preset()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\ndesc():string|null\r\ndesc(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ndesc(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\ndata(index: number, obj?:PresetEntry):PresetEntry|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new PresetEntry()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\ndataLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startPreset(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addDesc(builder:flatbuffers.Builder, descOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, descOffset, 0);\r\n}\r\n\r\nstatic addData(builder:flatbuffers.Builder, dataOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, dataOffset, 0);\r\n}\r\n\r\nstatic createDataVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startDataVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endPreset(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createPreset(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, descOffset:flatbuffers.Offset, dataOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  Preset.startPreset(builder);\r\n  Preset.addName(builder, nameOffset);\r\n  Preset.addDesc(builder, descOffset);\r\n  Preset.addData(builder, dataOffset);\r\n  return Preset.endPreset(builder);\r\n}\r\n\r\nunpack(): PresetT {\r\n  return new PresetT(\r\n    this.name(),\r\n    this.desc(),\r\n    this.bb!.createObjList(this.data.bind(this), this.dataLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: PresetT): void {\r\n  _o.name = this.name();\r\n  _o.desc = this.desc();\r\n  _o.data = this.bb!.createObjList(this.data.bind(this), this.dataLength());\r\n}\r\n}\r\n\r\nexport class PresetT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public desc: string|Uint8Array|null = null,\r\n  public data: (PresetEntryT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const desc = (this.desc !== null ? builder.createString(this.desc!) : 0);\r\n  const data = Preset.createDataVector(builder, builder.createObjectOffsetList(this.data));\r\n\r\n  return Preset.createPreset(builder,\r\n    name,\r\n    desc,\r\n    data\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport { FloatValue, FloatValueT } from '../fx/float-value';\r\nimport { IntValue, IntValueT } from '../fx/int-value';\r\nimport { StringValue, StringValueT } from '../fx/string-value';\r\nimport { UintValue, UintValueT } from '../fx/uint-value';\r\n\r\n\r\nexport enum PropertyValue {\r\n  NONE = 0,\r\n  UintValue = 1,\r\n  IntValue = 2,\r\n  FloatValue = 3,\r\n  StringValue = 4\r\n}\r\n\r\nexport function unionToPropertyValue(\r\n  type: PropertyValue,\r\n  accessor: (obj:FloatValue|IntValue|StringValue|UintValue) => FloatValue|IntValue|StringValue|UintValue|null\r\n): FloatValue|IntValue|StringValue|UintValue|null {\r\n  switch(PropertyValue[type]) {\r\n    case 'NONE': return null; \r\n    case 'UintValue': return accessor(new UintValue())! as UintValue;\r\n    case 'IntValue': return accessor(new IntValue())! as IntValue;\r\n    case 'FloatValue': return accessor(new FloatValue())! as FloatValue;\r\n    case 'StringValue': return accessor(new StringValue())! as StringValue;\r\n    default: return null;\r\n  }\r\n}\r\n\r\nexport function unionListToPropertyValue(\r\n  type: PropertyValue, \r\n  accessor: (index: number, obj:FloatValue|IntValue|StringValue|UintValue) => FloatValue|IntValue|StringValue|UintValue|null, \r\n  index: number\r\n): FloatValue|IntValue|StringValue|UintValue|null {\r\n  switch(PropertyValue[type]) {\r\n    case 'NONE': return null; \r\n    case 'UintValue': return accessor(index, new UintValue())! as UintValue;\r\n    case 'IntValue': return accessor(index, new IntValue())! as IntValue;\r\n    case 'FloatValue': return accessor(index, new FloatValue())! as FloatValue;\r\n    case 'StringValue': return accessor(index, new StringValue())! as StringValue;\r\n    default: return null;\r\n  }\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class RenderState {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):RenderState {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsRenderState(bb:flatbuffers.ByteBuffer, obj?:RenderState):RenderState {\r\n  return (obj || new RenderState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsRenderState(bb:flatbuffers.ByteBuffer, obj?:RenderState):RenderState {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new RenderState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ntype():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nvalue():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startRenderState(builder:flatbuffers.Builder) {\r\n  builder.startObject(2);\r\n}\r\n\r\nstatic addType(builder:flatbuffers.Builder, type:number) {\r\n  builder.addFieldInt32(0, type, 0);\r\n}\r\n\r\nstatic addValue(builder:flatbuffers.Builder, value:number) {\r\n  builder.addFieldInt32(1, value, 0);\r\n}\r\n\r\nstatic endRenderState(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createRenderState(builder:flatbuffers.Builder, type:number, value:number):flatbuffers.Offset {\r\n  RenderState.startRenderState(builder);\r\n  RenderState.addType(builder, type);\r\n  RenderState.addValue(builder, value);\r\n  return RenderState.endRenderState(builder);\r\n}\r\n\r\nunpack(): RenderStateT {\r\n  return new RenderStateT(\r\n    this.type(),\r\n    this.value()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: RenderStateT): void {\r\n  _o.type = this.type();\r\n  _o.value = this.value();\r\n}\r\n}\r\n\r\nexport class RenderStateT {\r\nconstructor(\r\n  public type: number = 0,\r\n  public value: number = 0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  return RenderState.createRenderState(builder,\r\n    this.type,\r\n    this.value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport { RoutineBytecodeBundle, RoutineBytecodeBundleT } from '../fx/routine-bytecode-bundle';\r\nimport { RoutineShaderBundle, RoutineShaderBundleT } from '../fx/routine-shader-bundle';\r\n\r\n\r\nexport enum RoutineBundle {\r\n  NONE = 0,\r\n  RoutineBytecodeBundle = 1,\r\n  RoutineShaderBundle = 2\r\n}\r\n\r\nexport function unionToRoutineBundle(\r\n  type: RoutineBundle,\r\n  accessor: (obj:RoutineBytecodeBundle|RoutineShaderBundle) => RoutineBytecodeBundle|RoutineShaderBundle|null\r\n): RoutineBytecodeBundle|RoutineShaderBundle|null {\r\n  switch(RoutineBundle[type]) {\r\n    case 'NONE': return null; \r\n    case 'RoutineBytecodeBundle': return accessor(new RoutineBytecodeBundle())! as RoutineBytecodeBundle;\r\n    case 'RoutineShaderBundle': return accessor(new RoutineShaderBundle())! as RoutineShaderBundle;\r\n    default: return null;\r\n  }\r\n}\r\n\r\nexport function unionListToRoutineBundle(\r\n  type: RoutineBundle, \r\n  accessor: (index: number, obj:RoutineBytecodeBundle|RoutineShaderBundle) => RoutineBytecodeBundle|RoutineShaderBundle|null, \r\n  index: number\r\n): RoutineBytecodeBundle|RoutineShaderBundle|null {\r\n  switch(RoutineBundle[type]) {\r\n    case 'NONE': return null; \r\n    case 'RoutineBytecodeBundle': return accessor(index, new RoutineBytecodeBundle())! as RoutineBytecodeBundle;\r\n    case 'RoutineShaderBundle': return accessor(index, new RoutineShaderBundle())! as RoutineShaderBundle;\r\n    default: return null;\r\n  }\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { BufferBundle, BufferBundleT } from '../fx/buffer-bundle';\r\nimport { TextureBundle, TextureBundleT } from '../fx/texture-bundle';\r\nimport { TrimeshBundle, TrimeshBundleT } from '../fx/trimesh-bundle';\r\nimport { UAVBundle, UAVBundleT } from '../fx/uavbundle';\r\n\r\n\r\nexport class RoutineBytecodeBundleResources {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):RoutineBytecodeBundleResources {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsRoutineBytecodeBundleResources(bb:flatbuffers.ByteBuffer, obj?:RoutineBytecodeBundleResources):RoutineBytecodeBundleResources {\r\n  return (obj || new RoutineBytecodeBundleResources()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsRoutineBytecodeBundleResources(bb:flatbuffers.ByteBuffer, obj?:RoutineBytecodeBundleResources):RoutineBytecodeBundleResources {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new RoutineBytecodeBundleResources()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nuavs(index: number, obj?:UAVBundle):UAVBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? (obj || new UAVBundle()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nuavsLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nbuffers(index: number, obj?:BufferBundle):BufferBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? (obj || new BufferBundle()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nbuffersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\ntextures(index: number, obj?:TextureBundle):TextureBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new TextureBundle()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\ntexturesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\ntrimeshes(index: number, obj?:TrimeshBundle):TrimeshBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new TrimeshBundle()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\ntrimeshesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startRoutineBytecodeBundleResources(builder:flatbuffers.Builder) {\r\n  builder.startObject(4);\r\n}\r\n\r\nstatic addUavs(builder:flatbuffers.Builder, uavsOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, uavsOffset, 0);\r\n}\r\n\r\nstatic createUavsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startUavsVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addBuffers(builder:flatbuffers.Builder, buffersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, buffersOffset, 0);\r\n}\r\n\r\nstatic createBuffersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startBuffersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addTextures(builder:flatbuffers.Builder, texturesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, texturesOffset, 0);\r\n}\r\n\r\nstatic createTexturesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startTexturesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addTrimeshes(builder:flatbuffers.Builder, trimeshesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, trimeshesOffset, 0);\r\n}\r\n\r\nstatic createTrimeshesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startTrimeshesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endRoutineBytecodeBundleResources(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createRoutineBytecodeBundleResources(builder:flatbuffers.Builder, uavsOffset:flatbuffers.Offset, buffersOffset:flatbuffers.Offset, texturesOffset:flatbuffers.Offset, trimeshesOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  RoutineBytecodeBundleResources.startRoutineBytecodeBundleResources(builder);\r\n  RoutineBytecodeBundleResources.addUavs(builder, uavsOffset);\r\n  RoutineBytecodeBundleResources.addBuffers(builder, buffersOffset);\r\n  RoutineBytecodeBundleResources.addTextures(builder, texturesOffset);\r\n  RoutineBytecodeBundleResources.addTrimeshes(builder, trimeshesOffset);\r\n  return RoutineBytecodeBundleResources.endRoutineBytecodeBundleResources(builder);\r\n}\r\n\r\nunpack(): RoutineBytecodeBundleResourcesT {\r\n  return new RoutineBytecodeBundleResourcesT(\r\n    this.bb!.createObjList(this.uavs.bind(this), this.uavsLength()),\r\n    this.bb!.createObjList(this.buffers.bind(this), this.buffersLength()),\r\n    this.bb!.createObjList(this.textures.bind(this), this.texturesLength()),\r\n    this.bb!.createObjList(this.trimeshes.bind(this), this.trimeshesLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: RoutineBytecodeBundleResourcesT): void {\r\n  _o.uavs = this.bb!.createObjList(this.uavs.bind(this), this.uavsLength());\r\n  _o.buffers = this.bb!.createObjList(this.buffers.bind(this), this.buffersLength());\r\n  _o.textures = this.bb!.createObjList(this.textures.bind(this), this.texturesLength());\r\n  _o.trimeshes = this.bb!.createObjList(this.trimeshes.bind(this), this.trimeshesLength());\r\n}\r\n}\r\n\r\nexport class RoutineBytecodeBundleResourcesT {\r\nconstructor(\r\n  public uavs: (UAVBundleT)[] = [],\r\n  public buffers: (BufferBundleT)[] = [],\r\n  public textures: (TextureBundleT)[] = [],\r\n  public trimeshes: (TrimeshBundleT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const uavs = RoutineBytecodeBundleResources.createUavsVector(builder, builder.createObjectOffsetList(this.uavs));\r\n  const buffers = RoutineBytecodeBundleResources.createBuffersVector(builder, builder.createObjectOffsetList(this.buffers));\r\n  const textures = RoutineBytecodeBundleResources.createTexturesVector(builder, builder.createObjectOffsetList(this.textures));\r\n  const trimeshes = RoutineBytecodeBundleResources.createTrimeshesVector(builder, builder.createObjectOffsetList(this.trimeshes));\r\n\r\n  return RoutineBytecodeBundleResources.createRoutineBytecodeBundleResources(builder,\r\n    uavs,\r\n    buffers,\r\n    textures,\r\n    trimeshes\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { RoutineBytecodeBundleResources, RoutineBytecodeBundleResourcesT } from '../fx/routine-bytecode-bundle-resources';\r\n\r\n\r\nexport class RoutineBytecodeBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):RoutineBytecodeBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsRoutineBytecodeBundle(bb:flatbuffers.ByteBuffer, obj?:RoutineBytecodeBundle):RoutineBytecodeBundle {\r\n  return (obj || new RoutineBytecodeBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsRoutineBytecodeBundle(bb:flatbuffers.ByteBuffer, obj?:RoutineBytecodeBundle):RoutineBytecodeBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new RoutineBytecodeBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ncode(index: number):number|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\r\n}\r\n\r\ncodeLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\ncodeArray():Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nresources(obj?:RoutineBytecodeBundleResources):RoutineBytecodeBundleResources|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? (obj || new RoutineBytecodeBundleResources()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nnumthreads(index: number):number|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\r\n}\r\n\r\nnumthreadsLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nnumthreadsArray():Uint32Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? new Uint32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nstatic startRoutineBytecodeBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addCode(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, codeOffset, 0);\r\n}\r\n\r\nstatic createCodeVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {\r\n  builder.startVector(1, data.length, 1);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt8(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startCodeVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(1, numElems, 1);\r\n}\r\n\r\nstatic addResources(builder:flatbuffers.Builder, resourcesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, resourcesOffset, 0);\r\n}\r\n\r\nstatic addNumthreads(builder:flatbuffers.Builder, numthreadsOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, numthreadsOffset, 0);\r\n}\r\n\r\nstatic createNumthreadsVector(builder:flatbuffers.Builder, data:number[]|Uint32Array):flatbuffers.Offset;\r\n/**\r\n * @deprecated This Uint8Array overload will be removed in the future.\r\n */\r\nstatic createNumthreadsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;\r\nstatic createNumthreadsVector(builder:flatbuffers.Builder, data:number[]|Uint32Array|Uint8Array):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt32(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startNumthreadsVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endRoutineBytecodeBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\n\r\nunpack(): RoutineBytecodeBundleT {\r\n  return new RoutineBytecodeBundleT(\r\n    this.bb!.createScalarList(this.code.bind(this), this.codeLength()),\r\n    (this.resources() !== null ? this.resources()!.unpack() : null),\r\n    this.bb!.createScalarList(this.numthreads.bind(this), this.numthreadsLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: RoutineBytecodeBundleT): void {\r\n  _o.code = this.bb!.createScalarList(this.code.bind(this), this.codeLength());\r\n  _o.resources = (this.resources() !== null ? this.resources()!.unpack() : null);\r\n  _o.numthreads = this.bb!.createScalarList(this.numthreads.bind(this), this.numthreadsLength());\r\n}\r\n}\r\n\r\nexport class RoutineBytecodeBundleT {\r\nconstructor(\r\n  public code: (number)[] = [],\r\n  public resources: RoutineBytecodeBundleResourcesT|null = null,\r\n  public numthreads: (number)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const code = RoutineBytecodeBundle.createCodeVector(builder, this.code);\r\n  const resources = (this.resources !== null ? this.resources!.pack(builder) : 0);\r\n  const numthreads = RoutineBytecodeBundle.createNumthreadsVector(builder, this.numthreads);\r\n\r\n  RoutineBytecodeBundle.startRoutineBytecodeBundle(builder);\r\n  RoutineBytecodeBundle.addCode(builder, code);\r\n  RoutineBytecodeBundle.addResources(builder, resources);\r\n  RoutineBytecodeBundle.addNumthreads(builder, numthreads);\r\n\r\n  return RoutineBytecodeBundle.endRoutineBytecodeBundle(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { CBBundle, CBBundleT } from '../cbbundle';\r\nimport { GLSLAttribute, GLSLAttributeT } from '../fx/glslattribute';\r\n\r\n\r\nexport class RoutineGLSLSourceBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):RoutineGLSLSourceBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsRoutineGLSLSourceBundle(bb:flatbuffers.ByteBuffer, obj?:RoutineGLSLSourceBundle):RoutineGLSLSourceBundle {\r\n  return (obj || new RoutineGLSLSourceBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsRoutineGLSLSourceBundle(bb:flatbuffers.ByteBuffer, obj?:RoutineGLSLSourceBundle):RoutineGLSLSourceBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new RoutineGLSLSourceBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ncode():string|null\r\ncode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ncode(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nattributes(index: number, obj?:GLSLAttribute):GLSLAttribute|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? (obj || new GLSLAttribute()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nattributesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\ncbuffers(index: number, obj?:CBBundle):CBBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new CBBundle()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\ncbuffersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startRoutineGLSLSourceBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addCode(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, codeOffset, 0);\r\n}\r\n\r\nstatic addAttributes(builder:flatbuffers.Builder, attributesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, attributesOffset, 0);\r\n}\r\n\r\nstatic createAttributesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startAttributesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addCbuffers(builder:flatbuffers.Builder, cbuffersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, cbuffersOffset, 0);\r\n}\r\n\r\nstatic createCbuffersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startCbuffersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endRoutineGLSLSourceBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createRoutineGLSLSourceBundle(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset, attributesOffset:flatbuffers.Offset, cbuffersOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  RoutineGLSLSourceBundle.startRoutineGLSLSourceBundle(builder);\r\n  RoutineGLSLSourceBundle.addCode(builder, codeOffset);\r\n  RoutineGLSLSourceBundle.addAttributes(builder, attributesOffset);\r\n  RoutineGLSLSourceBundle.addCbuffers(builder, cbuffersOffset);\r\n  return RoutineGLSLSourceBundle.endRoutineGLSLSourceBundle(builder);\r\n}\r\n\r\nunpack(): RoutineGLSLSourceBundleT {\r\n  return new RoutineGLSLSourceBundleT(\r\n    this.code(),\r\n    this.bb!.createObjList(this.attributes.bind(this), this.attributesLength()),\r\n    this.bb!.createObjList(this.cbuffers.bind(this), this.cbuffersLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: RoutineGLSLSourceBundleT): void {\r\n  _o.code = this.code();\r\n  _o.attributes = this.bb!.createObjList(this.attributes.bind(this), this.attributesLength());\r\n  _o.cbuffers = this.bb!.createObjList(this.cbuffers.bind(this), this.cbuffersLength());\r\n}\r\n}\r\n\r\nexport class RoutineGLSLSourceBundleT {\r\nconstructor(\r\n  public code: string|Uint8Array|null = null,\r\n  public attributes: (GLSLAttributeT)[] = [],\r\n  public cbuffers: (CBBundleT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const code = (this.code !== null ? builder.createString(this.code!) : 0);\r\n  const attributes = RoutineGLSLSourceBundle.createAttributesVector(builder, builder.createObjectOffsetList(this.attributes));\r\n  const cbuffers = RoutineGLSLSourceBundle.createCbuffersVector(builder, builder.createObjectOffsetList(this.cbuffers));\r\n\r\n  return RoutineGLSLSourceBundle.createRoutineGLSLSourceBundle(builder,\r\n    code,\r\n    attributes,\r\n    cbuffers\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { CBBundle, CBBundleT } from '../cbbundle';\r\n\r\n\r\nexport class RoutineHLSLSourceBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):RoutineHLSLSourceBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsRoutineHLSLSourceBundle(bb:flatbuffers.ByteBuffer, obj?:RoutineHLSLSourceBundle):RoutineHLSLSourceBundle {\r\n  return (obj || new RoutineHLSLSourceBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsRoutineHLSLSourceBundle(bb:flatbuffers.ByteBuffer, obj?:RoutineHLSLSourceBundle):RoutineHLSLSourceBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new RoutineHLSLSourceBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ncode():string|null\r\ncode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ncode(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nentryName():string|null\r\nentryName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nentryName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\ncbuffers(index: number, obj?:CBBundle):CBBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new CBBundle()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\ncbuffersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startRoutineHLSLSourceBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addCode(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, codeOffset, 0);\r\n}\r\n\r\nstatic addEntryName(builder:flatbuffers.Builder, entryNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, entryNameOffset, 0);\r\n}\r\n\r\nstatic addCbuffers(builder:flatbuffers.Builder, cbuffersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, cbuffersOffset, 0);\r\n}\r\n\r\nstatic createCbuffersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startCbuffersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endRoutineHLSLSourceBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createRoutineHLSLSourceBundle(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset, entryNameOffset:flatbuffers.Offset, cbuffersOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  RoutineHLSLSourceBundle.startRoutineHLSLSourceBundle(builder);\r\n  RoutineHLSLSourceBundle.addCode(builder, codeOffset);\r\n  RoutineHLSLSourceBundle.addEntryName(builder, entryNameOffset);\r\n  RoutineHLSLSourceBundle.addCbuffers(builder, cbuffersOffset);\r\n  return RoutineHLSLSourceBundle.endRoutineHLSLSourceBundle(builder);\r\n}\r\n\r\nunpack(): RoutineHLSLSourceBundleT {\r\n  return new RoutineHLSLSourceBundleT(\r\n    this.code(),\r\n    this.entryName(),\r\n    this.bb!.createObjList(this.cbuffers.bind(this), this.cbuffersLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: RoutineHLSLSourceBundleT): void {\r\n  _o.code = this.code();\r\n  _o.entryName = this.entryName();\r\n  _o.cbuffers = this.bb!.createObjList(this.cbuffers.bind(this), this.cbuffersLength());\r\n}\r\n}\r\n\r\nexport class RoutineHLSLSourceBundleT {\r\nconstructor(\r\n  public code: string|Uint8Array|null = null,\r\n  public entryName: string|Uint8Array|null = null,\r\n  public cbuffers: (CBBundleT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const code = (this.code !== null ? builder.createString(this.code!) : 0);\r\n  const entryName = (this.entryName !== null ? builder.createString(this.entryName!) : 0);\r\n  const cbuffers = RoutineHLSLSourceBundle.createCbuffersVector(builder, builder.createObjectOffsetList(this.cbuffers));\r\n\r\n  return RoutineHLSLSourceBundle.createRoutineHLSLSourceBundle(builder,\r\n    code,\r\n    entryName,\r\n    cbuffers\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { RoutineGLSLSourceBundle, RoutineGLSLSourceBundleT } from '../fx/routine-glslsource-bundle';\r\nimport { RoutineHLSLSourceBundle, RoutineHLSLSourceBundleT } from '../fx/routine-hlslsource-bundle';\r\nimport { RoutineSourceBundle, unionToRoutineSourceBundle, unionListToRoutineSourceBundle } from '../fx/routine-source-bundle';\r\n\r\n\r\nexport class RoutineShaderBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):RoutineShaderBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsRoutineShaderBundle(bb:flatbuffers.ByteBuffer, obj?:RoutineShaderBundle):RoutineShaderBundle {\r\n  return (obj || new RoutineShaderBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsRoutineShaderBundle(bb:flatbuffers.ByteBuffer, obj?:RoutineShaderBundle):RoutineShaderBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new RoutineShaderBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nshadersType(index: number):RoutineSourceBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\r\n}\r\n\r\nshadersTypeLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nshadersTypeArray():Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nshaders(index: number, obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__union(obj, this.bb!.__vector(this.bb_pos + offset) + index * 4) : null;\r\n}\r\n\r\nshadersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startRoutineShaderBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(2);\r\n}\r\n\r\nstatic addShadersType(builder:flatbuffers.Builder, shadersTypeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, shadersTypeOffset, 0);\r\n}\r\n\r\nstatic createShadersTypeVector(builder:flatbuffers.Builder, data:RoutineSourceBundle[]):flatbuffers.Offset {\r\n  builder.startVector(1, data.length, 1);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt8(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startShadersTypeVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(1, numElems, 1);\r\n}\r\n\r\nstatic addShaders(builder:flatbuffers.Builder, shadersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, shadersOffset, 0);\r\n}\r\n\r\nstatic createShadersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startShadersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endRoutineShaderBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createRoutineShaderBundle(builder:flatbuffers.Builder, shadersTypeOffset:flatbuffers.Offset, shadersOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  RoutineShaderBundle.startRoutineShaderBundle(builder);\r\n  RoutineShaderBundle.addShadersType(builder, shadersTypeOffset);\r\n  RoutineShaderBundle.addShaders(builder, shadersOffset);\r\n  return RoutineShaderBundle.endRoutineShaderBundle(builder);\r\n}\r\n\r\nunpack(): RoutineShaderBundleT {\r\n  return new RoutineShaderBundleT(\r\n    this.bb!.createScalarList(this.shadersType.bind(this), this.shadersTypeLength()),\r\n    (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.shadersTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.shadersType(targetEnumIndex);\r\n      if(targetEnum === null || RoutineSourceBundle[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToRoutineSourceBundle(targetEnum, this.shaders.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: RoutineShaderBundleT): void {\r\n  _o.shadersType = this.bb!.createScalarList(this.shadersType.bind(this), this.shadersTypeLength());\r\n  _o.shaders = (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.shadersTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.shadersType(targetEnumIndex);\r\n      if(targetEnum === null || RoutineSourceBundle[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToRoutineSourceBundle(targetEnum, this.shaders.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })();\r\n}\r\n}\r\n\r\nexport class RoutineShaderBundleT {\r\nconstructor(\r\n  public shadersType: (RoutineSourceBundle)[] = [],\r\n  public shaders: (RoutineGLSLSourceBundleT|RoutineHLSLSourceBundleT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const shadersType = RoutineShaderBundle.createShadersTypeVector(builder, this.shadersType);\r\n  const shaders = RoutineShaderBundle.createShadersVector(builder, builder.createObjectOffsetList(this.shaders));\r\n\r\n  return RoutineShaderBundle.createRoutineShaderBundle(builder,\r\n    shadersType,\r\n    shaders\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport { RoutineGLSLSourceBundle, RoutineGLSLSourceBundleT } from '../fx/routine-glslsource-bundle';\r\nimport { RoutineHLSLSourceBundle, RoutineHLSLSourceBundleT } from '../fx/routine-hlslsource-bundle';\r\n\r\n\r\nexport enum RoutineSourceBundle {\r\n  NONE = 0,\r\n  RoutineGLSLSourceBundle = 1,\r\n  RoutineHLSLSourceBundle = 2\r\n}\r\n\r\nexport function unionToRoutineSourceBundle(\r\n  type: RoutineSourceBundle,\r\n  accessor: (obj:RoutineGLSLSourceBundle|RoutineHLSLSourceBundle) => RoutineGLSLSourceBundle|RoutineHLSLSourceBundle|null\r\n): RoutineGLSLSourceBundle|RoutineHLSLSourceBundle|null {\r\n  switch(RoutineSourceBundle[type]) {\r\n    case 'NONE': return null; \r\n    case 'RoutineGLSLSourceBundle': return accessor(new RoutineGLSLSourceBundle())! as RoutineGLSLSourceBundle;\r\n    case 'RoutineHLSLSourceBundle': return accessor(new RoutineHLSLSourceBundle())! as RoutineHLSLSourceBundle;\r\n    default: return null;\r\n  }\r\n}\r\n\r\nexport function unionListToRoutineSourceBundle(\r\n  type: RoutineSourceBundle, \r\n  accessor: (index: number, obj:RoutineGLSLSourceBundle|RoutineHLSLSourceBundle) => RoutineGLSLSourceBundle|RoutineHLSLSourceBundle|null, \r\n  index: number\r\n): RoutineGLSLSourceBundle|RoutineHLSLSourceBundle|null {\r\n  switch(RoutineSourceBundle[type]) {\r\n    case 'NONE': return null; \r\n    case 'RoutineGLSLSourceBundle': return accessor(index, new RoutineGLSLSourceBundle())! as RoutineGLSLSourceBundle;\r\n    case 'RoutineHLSLSourceBundle': return accessor(index, new RoutineHLSLSourceBundle())! as RoutineHLSLSourceBundle;\r\n    default: return null;\r\n  }\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport { PixelShader, PixelShaderT } from '../fx/pixel-shader';\r\nimport { VertexShader, VertexShaderT } from '../fx/vertex-shader';\r\n\r\n\r\nexport enum Shader {\r\n  NONE = 0,\r\n  VertexShader = 1,\r\n  PixelShader = 2\r\n}\r\n\r\nexport function unionToShader(\r\n  type: Shader,\r\n  accessor: (obj:PixelShader|VertexShader) => PixelShader|VertexShader|null\r\n): PixelShader|VertexShader|null {\r\n  switch(Shader[type]) {\r\n    case 'NONE': return null; \r\n    case 'VertexShader': return accessor(new VertexShader())! as VertexShader;\r\n    case 'PixelShader': return accessor(new PixelShader())! as PixelShader;\r\n    default: return null;\r\n  }\r\n}\r\n\r\nexport function unionListToShader(\r\n  type: Shader, \r\n  accessor: (index: number, obj:PixelShader|VertexShader) => PixelShader|VertexShader|null, \r\n  index: number\r\n): PixelShader|VertexShader|null {\r\n  switch(Shader[type]) {\r\n    case 'NONE': return null; \r\n    case 'VertexShader': return accessor(index, new VertexShader())! as VertexShader;\r\n    case 'PixelShader': return accessor(index, new PixelShader())! as PixelShader;\r\n    default: return null;\r\n  }\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class StringValue {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):StringValue {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsStringValue(bb:flatbuffers.ByteBuffer, obj?:StringValue):StringValue {\r\n  return (obj || new StringValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsStringValue(bb:flatbuffers.ByteBuffer, obj?:StringValue):StringValue {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new StringValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nvalue():string|null\r\nvalue(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nvalue(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nstatic startStringValue(builder:flatbuffers.Builder) {\r\n  builder.startObject(1);\r\n}\r\n\r\nstatic addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, valueOffset, 0);\r\n}\r\n\r\nstatic endStringValue(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createStringValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  StringValue.startStringValue(builder);\r\n  StringValue.addValue(builder, valueOffset);\r\n  return StringValue.endStringValue(builder);\r\n}\r\n\r\nunpack(): StringValueT {\r\n  return new StringValueT(\r\n    this.value()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: StringValueT): void {\r\n  _o.value = this.value();\r\n}\r\n}\r\n\r\nexport class StringValueT {\r\nconstructor(\r\n  public value: string|Uint8Array|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const value = (this.value !== null ? builder.createString(this.value!) : 0);\r\n\r\n  return StringValue.createStringValue(builder,\r\n    value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { Technique11RenderPass, Technique11RenderPassT } from '../fx/technique11render-pass';\r\n\r\n\r\nexport class Technique11Bundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):Technique11Bundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsTechnique11Bundle(bb:flatbuffers.ByteBuffer, obj?:Technique11Bundle):Technique11Bundle {\r\n  return (obj || new Technique11Bundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsTechnique11Bundle(bb:flatbuffers.ByteBuffer, obj?:Technique11Bundle):Technique11Bundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new Technique11Bundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\npasses(index: number, obj?:Technique11RenderPass):Technique11RenderPass|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? (obj || new Technique11RenderPass()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\npassesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startTechnique11Bundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(1);\r\n}\r\n\r\nstatic addPasses(builder:flatbuffers.Builder, passesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, passesOffset, 0);\r\n}\r\n\r\nstatic createPassesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startPassesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endTechnique11Bundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createTechnique11Bundle(builder:flatbuffers.Builder, passesOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  Technique11Bundle.startTechnique11Bundle(builder);\r\n  Technique11Bundle.addPasses(builder, passesOffset);\r\n  return Technique11Bundle.endTechnique11Bundle(builder);\r\n}\r\n\r\nunpack(): Technique11BundleT {\r\n  return new Technique11BundleT(\r\n    this.bb!.createObjList(this.passes.bind(this), this.passesLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: Technique11BundleT): void {\r\n  _o.passes = this.bb!.createObjList(this.passes.bind(this), this.passesLength());\r\n}\r\n}\r\n\r\nexport class Technique11BundleT {\r\nconstructor(\r\n  public passes: (Technique11RenderPassT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const passes = Technique11Bundle.createPassesVector(builder, builder.createObjectOffsetList(this.passes));\r\n\r\n  return Technique11Bundle.createTechnique11Bundle(builder,\r\n    passes\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { PixelShader, PixelShaderT } from '../fx/pixel-shader';\r\nimport { Shader, unionToShader, unionListToShader } from '../fx/shader';\r\nimport { VertexShader, VertexShaderT } from '../fx/vertex-shader';\r\n\r\n\r\nexport class Technique11RenderPass {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):Technique11RenderPass {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsTechnique11RenderPass(bb:flatbuffers.ByteBuffer, obj?:Technique11RenderPass):Technique11RenderPass {\r\n  return (obj || new Technique11RenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsTechnique11RenderPass(bb:flatbuffers.ByteBuffer, obj?:Technique11RenderPass):Technique11RenderPass {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new Technique11RenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ncode(index: number):number|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\r\n}\r\n\r\ncodeLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\ncodeArray():Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nshadersType(index: number):Shader|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\r\n}\r\n\r\nshadersTypeLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nshadersTypeArray():Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nshaders(index: number, obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__union(obj, this.bb!.__vector(this.bb_pos + offset) + index * 4) : null;\r\n}\r\n\r\nshadersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startTechnique11RenderPass(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addCode(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, codeOffset, 0);\r\n}\r\n\r\nstatic createCodeVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {\r\n  builder.startVector(1, data.length, 1);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt8(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startCodeVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(1, numElems, 1);\r\n}\r\n\r\nstatic addShadersType(builder:flatbuffers.Builder, shadersTypeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, shadersTypeOffset, 0);\r\n}\r\n\r\nstatic createShadersTypeVector(builder:flatbuffers.Builder, data:Shader[]):flatbuffers.Offset {\r\n  builder.startVector(1, data.length, 1);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt8(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startShadersTypeVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(1, numElems, 1);\r\n}\r\n\r\nstatic addShaders(builder:flatbuffers.Builder, shadersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, shadersOffset, 0);\r\n}\r\n\r\nstatic createShadersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startShadersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endTechnique11RenderPass(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createTechnique11RenderPass(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset, shadersTypeOffset:flatbuffers.Offset, shadersOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  Technique11RenderPass.startTechnique11RenderPass(builder);\r\n  Technique11RenderPass.addCode(builder, codeOffset);\r\n  Technique11RenderPass.addShadersType(builder, shadersTypeOffset);\r\n  Technique11RenderPass.addShaders(builder, shadersOffset);\r\n  return Technique11RenderPass.endTechnique11RenderPass(builder);\r\n}\r\n\r\nunpack(): Technique11RenderPassT {\r\n  return new Technique11RenderPassT(\r\n    this.bb!.createScalarList(this.code.bind(this), this.codeLength()),\r\n    this.bb!.createScalarList(this.shadersType.bind(this), this.shadersTypeLength()),\r\n    (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.shadersTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.shadersType(targetEnumIndex);\r\n      if(targetEnum === null || Shader[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToShader(targetEnum, this.shaders.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: Technique11RenderPassT): void {\r\n  _o.code = this.bb!.createScalarList(this.code.bind(this), this.codeLength());\r\n  _o.shadersType = this.bb!.createScalarList(this.shadersType.bind(this), this.shadersTypeLength());\r\n  _o.shaders = (() => {\r\n    let ret = [];\r\n    for(let targetEnumIndex = 0; targetEnumIndex < this.shadersTypeLength(); ++targetEnumIndex) {\r\n      let targetEnum = this.shadersType(targetEnumIndex);\r\n      if(targetEnum === null || Shader[targetEnum!] === 'NONE') { continue; }\r\n\r\n      let temp = unionListToShader(targetEnum, this.shaders.bind(this), targetEnumIndex);\r\n      if(temp === null) { continue; }\r\n      ret.push(temp.unpack());\r\n    }\r\n    return ret;\r\n  })();\r\n}\r\n}\r\n\r\nexport class Technique11RenderPassT {\r\nconstructor(\r\n  public code: (number)[] = [],\r\n  public shadersType: (Shader)[] = [],\r\n  public shaders: (PixelShaderT|VertexShaderT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const code = Technique11RenderPass.createCodeVector(builder, this.code);\r\n  const shadersType = Technique11RenderPass.createShadersTypeVector(builder, this.shadersType);\r\n  const shaders = Technique11RenderPass.createShadersVector(builder, builder.createObjectOffsetList(this.shaders));\r\n\r\n  return Technique11RenderPass.createTechnique11RenderPass(builder,\r\n    code,\r\n    shadersType,\r\n    shaders\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { TypeLayout, TypeLayoutT } from '../type-layout';\r\n\r\n\r\nexport class TextureBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):TextureBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsTextureBundle(bb:flatbuffers.ByteBuffer, obj?:TextureBundle):TextureBundle {\r\n  return (obj || new TextureBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsTextureBundle(bb:flatbuffers.ByteBuffer, obj?:TextureBundle):TextureBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new TextureBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nslot():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstride():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\ntype(obj?:TypeLayout):TypeLayout|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new TypeLayout()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nstatic startTextureBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(4);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addSlot(builder:flatbuffers.Builder, slot:number) {\r\n  builder.addFieldInt32(1, slot, 0);\r\n}\r\n\r\nstatic addStride(builder:flatbuffers.Builder, stride:number) {\r\n  builder.addFieldInt32(2, stride, 0);\r\n}\r\n\r\nstatic addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, typeOffset, 0);\r\n}\r\n\r\nstatic endTextureBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\n\r\nunpack(): TextureBundleT {\r\n  return new TextureBundleT(\r\n    this.name(),\r\n    this.slot(),\r\n    this.stride(),\r\n    (this.type() !== null ? this.type()!.unpack() : null)\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: TextureBundleT): void {\r\n  _o.name = this.name();\r\n  _o.slot = this.slot();\r\n  _o.stride = this.stride();\r\n  _o.type = (this.type() !== null ? this.type()!.unpack() : null);\r\n}\r\n}\r\n\r\nexport class TextureBundleT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public slot: number = 0,\r\n  public stride: number = 0,\r\n  public type: TypeLayoutT|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const type = (this.type !== null ? this.type!.pack(builder) : 0);\r\n\r\n  TextureBundle.startTextureBundle(builder);\r\n  TextureBundle.addName(builder, name);\r\n  TextureBundle.addSlot(builder, this.slot);\r\n  TextureBundle.addStride(builder, this.stride);\r\n  TextureBundle.addType(builder, type);\r\n\r\n  return TextureBundle.endTextureBundle(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class TextureValue {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):TextureValue {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsTextureValue(bb:flatbuffers.ByteBuffer, obj?:TextureValue):TextureValue {\r\n  return (obj || new TextureValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsTextureValue(bb:flatbuffers.ByteBuffer, obj?:TextureValue):TextureValue {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new TextureValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nvalue():string|null\r\nvalue(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nvalue(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nstatic startTextureValue(builder:flatbuffers.Builder) {\r\n  builder.startObject(1);\r\n}\r\n\r\nstatic addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, valueOffset, 0);\r\n}\r\n\r\nstatic endTextureValue(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createTextureValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  TextureValue.startTextureValue(builder);\r\n  TextureValue.addValue(builder, valueOffset);\r\n  return TextureValue.endTextureValue(builder);\r\n}\r\n\r\nunpack(): TextureValueT {\r\n  return new TextureValueT(\r\n    this.value()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: TextureValueT): void {\r\n  _o.value = this.value();\r\n}\r\n}\r\n\r\nexport class TextureValueT {\r\nconstructor(\r\n  public value: string|Uint8Array|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const value = (this.value !== null ? builder.createString(this.value!) : 0);\r\n\r\n  return TextureValue.createTextureValue(builder,\r\n    value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class TrimeshBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):TrimeshBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsTrimeshBundle(bb:flatbuffers.ByteBuffer, obj?:TrimeshBundle):TrimeshBundle {\r\n  return (obj || new TrimeshBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsTrimeshBundle(bb:flatbuffers.ByteBuffer, obj?:TrimeshBundle):TrimeshBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new TrimeshBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nvertexCountUName():string|null\r\nvertexCountUName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nvertexCountUName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nfaceCountUName():string|null\r\nfaceCountUName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nfaceCountUName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nverticesName():string|null\r\nverticesName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nverticesName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nfacesName():string|null\r\nfacesName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nfacesName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\ngsAdjecencyName():string|null\r\ngsAdjecencyName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ngsAdjecencyName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 14);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nfaceAdjacencyName():string|null\r\nfaceAdjacencyName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nfaceAdjacencyName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 16);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nstatic startTrimeshBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(7);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addVertexCountUName(builder:flatbuffers.Builder, vertexCountUNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, vertexCountUNameOffset, 0);\r\n}\r\n\r\nstatic addFaceCountUName(builder:flatbuffers.Builder, faceCountUNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, faceCountUNameOffset, 0);\r\n}\r\n\r\nstatic addVerticesName(builder:flatbuffers.Builder, verticesNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, verticesNameOffset, 0);\r\n}\r\n\r\nstatic addFacesName(builder:flatbuffers.Builder, facesNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(4, facesNameOffset, 0);\r\n}\r\n\r\nstatic addGsAdjecencyName(builder:flatbuffers.Builder, gsAdjecencyNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(5, gsAdjecencyNameOffset, 0);\r\n}\r\n\r\nstatic addFaceAdjacencyName(builder:flatbuffers.Builder, faceAdjacencyNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(6, faceAdjacencyNameOffset, 0);\r\n}\r\n\r\nstatic endTrimeshBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createTrimeshBundle(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, vertexCountUNameOffset:flatbuffers.Offset, faceCountUNameOffset:flatbuffers.Offset, verticesNameOffset:flatbuffers.Offset, facesNameOffset:flatbuffers.Offset, gsAdjecencyNameOffset:flatbuffers.Offset, faceAdjacencyNameOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  TrimeshBundle.startTrimeshBundle(builder);\r\n  TrimeshBundle.addName(builder, nameOffset);\r\n  TrimeshBundle.addVertexCountUName(builder, vertexCountUNameOffset);\r\n  TrimeshBundle.addFaceCountUName(builder, faceCountUNameOffset);\r\n  TrimeshBundle.addVerticesName(builder, verticesNameOffset);\r\n  TrimeshBundle.addFacesName(builder, facesNameOffset);\r\n  TrimeshBundle.addGsAdjecencyName(builder, gsAdjecencyNameOffset);\r\n  TrimeshBundle.addFaceAdjacencyName(builder, faceAdjacencyNameOffset);\r\n  return TrimeshBundle.endTrimeshBundle(builder);\r\n}\r\n\r\nunpack(): TrimeshBundleT {\r\n  return new TrimeshBundleT(\r\n    this.name(),\r\n    this.vertexCountUName(),\r\n    this.faceCountUName(),\r\n    this.verticesName(),\r\n    this.facesName(),\r\n    this.gsAdjecencyName(),\r\n    this.faceAdjacencyName()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: TrimeshBundleT): void {\r\n  _o.name = this.name();\r\n  _o.vertexCountUName = this.vertexCountUName();\r\n  _o.faceCountUName = this.faceCountUName();\r\n  _o.verticesName = this.verticesName();\r\n  _o.facesName = this.facesName();\r\n  _o.gsAdjecencyName = this.gsAdjecencyName();\r\n  _o.faceAdjacencyName = this.faceAdjacencyName();\r\n}\r\n}\r\n\r\nexport class TrimeshBundleT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public vertexCountUName: string|Uint8Array|null = null,\r\n  public faceCountUName: string|Uint8Array|null = null,\r\n  public verticesName: string|Uint8Array|null = null,\r\n  public facesName: string|Uint8Array|null = null,\r\n  public gsAdjecencyName: string|Uint8Array|null = null,\r\n  public faceAdjacencyName: string|Uint8Array|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const vertexCountUName = (this.vertexCountUName !== null ? builder.createString(this.vertexCountUName!) : 0);\r\n  const faceCountUName = (this.faceCountUName !== null ? builder.createString(this.faceCountUName!) : 0);\r\n  const verticesName = (this.verticesName !== null ? builder.createString(this.verticesName!) : 0);\r\n  const facesName = (this.facesName !== null ? builder.createString(this.facesName!) : 0);\r\n  const gsAdjecencyName = (this.gsAdjecencyName !== null ? builder.createString(this.gsAdjecencyName!) : 0);\r\n  const faceAdjacencyName = (this.faceAdjacencyName !== null ? builder.createString(this.faceAdjacencyName!) : 0);\r\n\r\n  return TrimeshBundle.createTrimeshBundle(builder,\r\n    name,\r\n    vertexCountUName,\r\n    faceCountUName,\r\n    verticesName,\r\n    facesName,\r\n    gsAdjecencyName,\r\n    faceAdjacencyName\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { TypeLayout, TypeLayoutT } from '../type-layout';\r\n\r\n\r\nexport class UAVBundle {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):UAVBundle {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsUAVBundle(bb:flatbuffers.ByteBuffer, obj?:UAVBundle):UAVBundle {\r\n  return (obj || new UAVBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsUAVBundle(bb:flatbuffers.ByteBuffer, obj?:UAVBundle):UAVBundle {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new UAVBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nslot():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstride():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\ntype(obj?:TypeLayout):TypeLayout|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new TypeLayout()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nstatic startUAVBundle(builder:flatbuffers.Builder) {\r\n  builder.startObject(4);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addSlot(builder:flatbuffers.Builder, slot:number) {\r\n  builder.addFieldInt32(1, slot, 0);\r\n}\r\n\r\nstatic addStride(builder:flatbuffers.Builder, stride:number) {\r\n  builder.addFieldInt32(2, stride, 0);\r\n}\r\n\r\nstatic addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, typeOffset, 0);\r\n}\r\n\r\nstatic endUAVBundle(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\n\r\nunpack(): UAVBundleT {\r\n  return new UAVBundleT(\r\n    this.name(),\r\n    this.slot(),\r\n    this.stride(),\r\n    (this.type() !== null ? this.type()!.unpack() : null)\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: UAVBundleT): void {\r\n  _o.name = this.name();\r\n  _o.slot = this.slot();\r\n  _o.stride = this.stride();\r\n  _o.type = (this.type() !== null ? this.type()!.unpack() : null);\r\n}\r\n}\r\n\r\nexport class UAVBundleT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public slot: number = 0,\r\n  public stride: number = 0,\r\n  public type: TypeLayoutT|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const type = (this.type !== null ? this.type!.pack(builder) : 0);\r\n\r\n  UAVBundle.startUAVBundle(builder);\r\n  UAVBundle.addName(builder, name);\r\n  UAVBundle.addSlot(builder, this.slot);\r\n  UAVBundle.addStride(builder, this.stride);\r\n  UAVBundle.addType(builder, type);\r\n\r\n  return UAVBundle.endUAVBundle(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { ColorValue, ColorValueT } from '../fx/color-value';\r\nimport { ControlValue, unionToControlValue, unionListToControlValue } from '../fx/control-value';\r\nimport { Float2Value, Float2ValueT } from '../fx/float2value';\r\nimport { Float3Value, Float3ValueT } from '../fx/float3value';\r\nimport { Float4Value, Float4ValueT } from '../fx/float4value';\r\nimport { FloatValue, FloatValueT } from '../fx/float-value';\r\nimport { IntValue, IntValueT } from '../fx/int-value';\r\nimport { MeshValue, MeshValueT } from '../fx/mesh-value';\r\nimport { TextureValue, TextureValueT } from '../fx/texture-value';\r\nimport { UintValue, UintValueT } from '../fx/uint-value';\r\nimport { ViewTypeProperty, ViewTypePropertyT } from '../fx/view-type-property';\r\n\r\n\r\nexport class UIControl {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):UIControl {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsUIControl(bb:flatbuffers.ByteBuffer, obj?:UIControl):UIControl {\r\n  return (obj || new UIControl()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsUIControl(bb:flatbuffers.ByteBuffer, obj?:UIControl):UIControl {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new UIControl()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nvalueType():ControlValue {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : ControlValue.NONE;\r\n}\r\n\r\nvalue<T extends flatbuffers.Table>(obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\r\n}\r\n\r\nproperties(index: number, obj?:ViewTypeProperty):ViewTypeProperty|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new ViewTypeProperty()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\npropertiesLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startUIControl(builder:flatbuffers.Builder) {\r\n  builder.startObject(4);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addValueType(builder:flatbuffers.Builder, valueType:ControlValue) {\r\n  builder.addFieldInt8(1, valueType, ControlValue.NONE);\r\n}\r\n\r\nstatic addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, valueOffset, 0);\r\n}\r\n\r\nstatic addProperties(builder:flatbuffers.Builder, propertiesOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, propertiesOffset, 0);\r\n}\r\n\r\nstatic createPropertiesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startPropertiesVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endUIControl(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createUIControl(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, valueType:ControlValue, valueOffset:flatbuffers.Offset, propertiesOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  UIControl.startUIControl(builder);\r\n  UIControl.addName(builder, nameOffset);\r\n  UIControl.addValueType(builder, valueType);\r\n  UIControl.addValue(builder, valueOffset);\r\n  UIControl.addProperties(builder, propertiesOffset);\r\n  return UIControl.endUIControl(builder);\r\n}\r\n\r\nunpack(): UIControlT {\r\n  return new UIControlT(\r\n    this.name(),\r\n    this.valueType(),\r\n    (() => {\r\n      let temp = unionToControlValue(this.valueType(), this.value.bind(this));\r\n      if(temp === null) { return null; }\r\n      return temp.unpack()\r\n  })(),\r\n    this.bb!.createObjList(this.properties.bind(this), this.propertiesLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: UIControlT): void {\r\n  _o.name = this.name();\r\n  _o.valueType = this.valueType();\r\n  _o.value = (() => {\r\n      let temp = unionToControlValue(this.valueType(), this.value.bind(this));\r\n      if(temp === null) { return null; }\r\n      return temp.unpack()\r\n  })();\r\n  _o.properties = this.bb!.createObjList(this.properties.bind(this), this.propertiesLength());\r\n}\r\n}\r\n\r\nexport class UIControlT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public valueType: ControlValue = ControlValue.NONE,\r\n  public value: ColorValueT|Float2ValueT|Float3ValueT|Float4ValueT|FloatValueT|IntValueT|MeshValueT|TextureValueT|UintValueT|null = null,\r\n  public properties: (ViewTypePropertyT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const value = builder.createObjectOffset(this.value);\r\n  const properties = UIControl.createPropertiesVector(builder, builder.createObjectOffsetList(this.properties));\r\n\r\n  return UIControl.createUIControl(builder,\r\n    name,\r\n    this.valueType,\r\n    value,\r\n    properties\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\n\r\n\r\nexport class UintValue {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):UintValue {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nvalue():number {\r\n  return this.bb!.readUint32(this.bb_pos);\r\n}\r\n\r\nstatic sizeOf():number {\r\n  return 4;\r\n}\r\n\r\nstatic createUintValue(builder:flatbuffers.Builder, value: number):flatbuffers.Offset {\r\n  builder.prep(4, 4);\r\n  builder.writeInt32(value);\r\n  return builder.offset();\r\n}\r\n\r\n\r\nunpack(): UintValueT {\r\n  return new UintValueT(\r\n    this.value()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: UintValueT): void {\r\n  _o.value = this.value();\r\n}\r\n}\r\n\r\nexport class UintValueT {\r\nconstructor(\r\n  public value: number = 0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  return UintValue.createUintValue(builder,\r\n    this.value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { CBBundle, CBBundleT } from '../cbbundle';\r\nimport { TypeLayout, TypeLayoutT } from '../type-layout';\r\n\r\n\r\nexport class VertexShader {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):VertexShader {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsVertexShader(bb:flatbuffers.ByteBuffer, obj?:VertexShader):VertexShader {\r\n  return (obj || new VertexShader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsVertexShader(bb:flatbuffers.ByteBuffer, obj?:VertexShader):VertexShader {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new VertexShader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ncode():string|null\r\ncode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\ncode(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nentryName():string|null\r\nentryName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nentryName(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\ninput(obj?:TypeLayout):TypeLayout|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new TypeLayout()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\ncbuffers(index: number, obj?:CBBundle):CBBundle|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new CBBundle()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\ncbuffersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startVertexShader(builder:flatbuffers.Builder) {\r\n  builder.startObject(4);\r\n}\r\n\r\nstatic addCode(builder:flatbuffers.Builder, codeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, codeOffset, 0);\r\n}\r\n\r\nstatic addEntryName(builder:flatbuffers.Builder, entryNameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, entryNameOffset, 0);\r\n}\r\n\r\nstatic addInput(builder:flatbuffers.Builder, inputOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, inputOffset, 0);\r\n}\r\n\r\nstatic addCbuffers(builder:flatbuffers.Builder, cbuffersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, cbuffersOffset, 0);\r\n}\r\n\r\nstatic createCbuffersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startCbuffersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endVertexShader(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\n\r\nunpack(): VertexShaderT {\r\n  return new VertexShaderT(\r\n    this.code(),\r\n    this.entryName(),\r\n    (this.input() !== null ? this.input()!.unpack() : null),\r\n    this.bb!.createObjList(this.cbuffers.bind(this), this.cbuffersLength())\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: VertexShaderT): void {\r\n  _o.code = this.code();\r\n  _o.entryName = this.entryName();\r\n  _o.input = (this.input() !== null ? this.input()!.unpack() : null);\r\n  _o.cbuffers = this.bb!.createObjList(this.cbuffers.bind(this), this.cbuffersLength());\r\n}\r\n}\r\n\r\nexport class VertexShaderT {\r\nconstructor(\r\n  public code: string|Uint8Array|null = null,\r\n  public entryName: string|Uint8Array|null = null,\r\n  public input: TypeLayoutT|null = null,\r\n  public cbuffers: (CBBundleT)[] = []\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const code = (this.code !== null ? builder.createString(this.code!) : 0);\r\n  const entryName = (this.entryName !== null ? builder.createString(this.entryName!) : 0);\r\n  const input = (this.input !== null ? this.input!.pack(builder) : 0);\r\n  const cbuffers = VertexShader.createCbuffersVector(builder, builder.createObjectOffsetList(this.cbuffers));\r\n\r\n  VertexShader.startVertexShader(builder);\r\n  VertexShader.addCode(builder, code);\r\n  VertexShader.addEntryName(builder, entryName);\r\n  VertexShader.addInput(builder, input);\r\n  VertexShader.addCbuffers(builder, cbuffers);\r\n\r\n  return VertexShader.endVertexShader(builder);\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { FloatValue, FloatValueT } from '../fx/float-value';\r\nimport { IntValue, IntValueT } from '../fx/int-value';\r\nimport { PropertyValue, unionToPropertyValue, unionListToPropertyValue } from '../fx/property-value';\r\nimport { StringValue, StringValueT } from '../fx/string-value';\r\nimport { UintValue, UintValueT } from '../fx/uint-value';\r\n\r\n\r\nexport class ViewTypeProperty {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):ViewTypeProperty {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsViewTypeProperty(bb:flatbuffers.ByteBuffer, obj?:ViewTypeProperty):ViewTypeProperty {\r\n  return (obj || new ViewTypeProperty()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsViewTypeProperty(bb:flatbuffers.ByteBuffer, obj?:ViewTypeProperty):ViewTypeProperty {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new ViewTypeProperty()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nvalueType():PropertyValue {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : PropertyValue.NONE;\r\n}\r\n\r\nvalue<T extends flatbuffers.Table>(obj:any):any|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\r\n}\r\n\r\nstatic startViewTypeProperty(builder:flatbuffers.Builder) {\r\n  builder.startObject(3);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, nameOffset, 0);\r\n}\r\n\r\nstatic addValueType(builder:flatbuffers.Builder, valueType:PropertyValue) {\r\n  builder.addFieldInt8(1, valueType, PropertyValue.NONE);\r\n}\r\n\r\nstatic addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, valueOffset, 0);\r\n}\r\n\r\nstatic endViewTypeProperty(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createViewTypeProperty(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, valueType:PropertyValue, valueOffset:flatbuffers.Offset):flatbuffers.Offset {\r\n  ViewTypeProperty.startViewTypeProperty(builder);\r\n  ViewTypeProperty.addName(builder, nameOffset);\r\n  ViewTypeProperty.addValueType(builder, valueType);\r\n  ViewTypeProperty.addValue(builder, valueOffset);\r\n  return ViewTypeProperty.endViewTypeProperty(builder);\r\n}\r\n\r\nunpack(): ViewTypePropertyT {\r\n  return new ViewTypePropertyT(\r\n    this.name(),\r\n    this.valueType(),\r\n    (() => {\r\n      let temp = unionToPropertyValue(this.valueType(), this.value.bind(this));\r\n      if(temp === null) { return null; }\r\n      return temp.unpack()\r\n  })()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: ViewTypePropertyT): void {\r\n  _o.name = this.name();\r\n  _o.valueType = this.valueType();\r\n  _o.value = (() => {\r\n      let temp = unionToPropertyValue(this.valueType(), this.value.bind(this));\r\n      if(temp === null) { return null; }\r\n      return temp.unpack()\r\n  })();\r\n}\r\n}\r\n\r\nexport class ViewTypePropertyT {\r\nconstructor(\r\n  public name: string|Uint8Array|null = null,\r\n  public valueType: PropertyValue = PropertyValue.NONE,\r\n  public value: FloatValueT|IntValueT|StringValueT|UintValueT|null = null\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const value = builder.createObjectOffset(this.value);\r\n\r\n  return ViewTypeProperty.createViewTypeProperty(builder,\r\n    name,\r\n    this.valueType,\r\n    value\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { TypeLayout, TypeLayoutT } from './type-layout';\r\n\r\n\r\nexport class TypeField {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):TypeField {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsTypeField(bb:flatbuffers.ByteBuffer, obj?:TypeField):TypeField {\r\n  return (obj || new TypeField()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsTypeField(bb:flatbuffers.ByteBuffer, obj?:TypeField):TypeField {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new TypeField()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\ntype(obj?:TypeLayout):TypeLayout|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? (obj || new TypeLayout()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nsemantic():string|null\r\nsemantic(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nsemantic(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nsize():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\npadding():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startTypeField(builder:flatbuffers.Builder) {\r\n  builder.startObject(5);\r\n}\r\n\r\nstatic addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, typeOffset, 0);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, nameOffset, 0);\r\n}\r\n\r\nstatic addSemantic(builder:flatbuffers.Builder, semanticOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, semanticOffset, 0);\r\n}\r\n\r\nstatic addSize(builder:flatbuffers.Builder, size:number) {\r\n  builder.addFieldInt32(3, size, 0);\r\n}\r\n\r\nstatic addPadding(builder:flatbuffers.Builder, padding:number) {\r\n  builder.addFieldInt32(4, padding, 0);\r\n}\r\n\r\nstatic endTypeField(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createTypeField(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset, nameOffset:flatbuffers.Offset, semanticOffset:flatbuffers.Offset, size:number, padding:number):flatbuffers.Offset {\r\n  TypeField.startTypeField(builder);\r\n  TypeField.addType(builder, typeOffset);\r\n  TypeField.addName(builder, nameOffset);\r\n  TypeField.addSemantic(builder, semanticOffset);\r\n  TypeField.addSize(builder, size);\r\n  TypeField.addPadding(builder, padding);\r\n  return TypeField.endTypeField(builder);\r\n}\r\n\r\nunpack(): TypeFieldT {\r\n  return new TypeFieldT(\r\n    (this.type() !== null ? this.type()!.unpack() : null),\r\n    this.name(),\r\n    this.semantic(),\r\n    this.size(),\r\n    this.padding()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: TypeFieldT): void {\r\n  _o.type = (this.type() !== null ? this.type()!.unpack() : null);\r\n  _o.name = this.name();\r\n  _o.semantic = this.semantic();\r\n  _o.size = this.size();\r\n  _o.padding = this.padding();\r\n}\r\n}\r\n\r\nexport class TypeFieldT {\r\nconstructor(\r\n  public type: TypeLayoutT|null = null,\r\n  public name: string|Uint8Array|null = null,\r\n  public semantic: string|Uint8Array|null = null,\r\n  public size: number = 0,\r\n  public padding: number = 0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const type = (this.type !== null ? this.type!.pack(builder) : 0);\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n  const semantic = (this.semantic !== null ? builder.createString(this.semantic!) : 0);\r\n\r\n  return TypeField.createTypeField(builder,\r\n    type,\r\n    name,\r\n    semantic,\r\n    this.size,\r\n    this.padding\r\n  );\r\n}\r\n}\r\n","// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { TypeField, TypeFieldT } from './type-field';\r\n\r\n\r\nexport class TypeLayout {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n  __init(i:number, bb:flatbuffers.ByteBuffer):TypeLayout {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsTypeLayout(bb:flatbuffers.ByteBuffer, obj?:TypeLayout):TypeLayout {\r\n  return (obj || new TypeLayout()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsTypeLayout(bb:flatbuffers.ByteBuffer, obj?:TypeLayout):TypeLayout {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new TypeLayout()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nfields(index: number, obj?:TypeField):TypeField|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? (obj || new TypeField()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\r\n}\r\n\r\nfieldsLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\nlength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nname():string|null\r\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\r\nname(optionalEncoding?:any):string|Uint8Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\r\n}\r\n\r\nsize():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\r\n}\r\n\r\nstatic startTypeLayout(builder:flatbuffers.Builder) {\r\n  builder.startObject(4);\r\n}\r\n\r\nstatic addFields(builder:flatbuffers.Builder, fieldsOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, fieldsOffset, 0);\r\n}\r\n\r\nstatic createFieldsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addOffset(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startFieldsVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic addLength(builder:flatbuffers.Builder, length:number) {\r\n  builder.addFieldInt32(1, length, 0);\r\n}\r\n\r\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, nameOffset, 0);\r\n}\r\n\r\nstatic addSize(builder:flatbuffers.Builder, size:number) {\r\n  builder.addFieldInt32(3, size, 0);\r\n}\r\n\r\nstatic endTypeLayout(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  return offset;\r\n}\r\n\r\nstatic createTypeLayout(builder:flatbuffers.Builder, fieldsOffset:flatbuffers.Offset, length:number, nameOffset:flatbuffers.Offset, size:number):flatbuffers.Offset {\r\n  TypeLayout.startTypeLayout(builder);\r\n  TypeLayout.addFields(builder, fieldsOffset);\r\n  TypeLayout.addLength(builder, length);\r\n  TypeLayout.addName(builder, nameOffset);\r\n  TypeLayout.addSize(builder, size);\r\n  return TypeLayout.endTypeLayout(builder);\r\n}\r\n\r\nunpack(): TypeLayoutT {\r\n  return new TypeLayoutT(\r\n    this.bb!.createObjList(this.fields.bind(this), this.fieldsLength()),\r\n    this.length(),\r\n    this.name(),\r\n    this.size()\r\n  );\r\n}\r\n\r\n\r\nunpackTo(_o: TypeLayoutT): void {\r\n  _o.fields = this.bb!.createObjList(this.fields.bind(this), this.fieldsLength());\r\n  _o.length = this.length();\r\n  _o.name = this.name();\r\n  _o.size = this.size();\r\n}\r\n}\r\n\r\nexport class TypeLayoutT {\r\nconstructor(\r\n  public fields: (TypeFieldT)[] = [],\r\n  public length: number = 0,\r\n  public name: string|Uint8Array|null = null,\r\n  public size: number = 0\r\n){}\r\n\r\n\r\npack(builder:flatbuffers.Builder): flatbuffers.Offset {\r\n  const fields = TypeLayout.createFieldsVector(builder, builder.createObjectOffsetList(this.fields));\r\n  const name = (this.name !== null ? builder.createString(this.name!) : 0);\r\n\r\n  return TypeLayout.createTypeLayout(builder,\r\n    fields,\r\n    this.length,\r\n    name,\r\n    this.size\r\n  );\r\n}\r\n}\r\n","export enum EOperation {\r\n    // note: assuming that Load is 32bit and Move is 32bit too\r\n    k_I32LoadRegister,          // registers => registers\r\n    k_I32LoadInput,             // input => registers\r\n    \r\n    k_I32LoadInputPointer,      // input pointer => register\r\n    k_I32LoadRegistersPointer,  // register pointer => register\r\n    \r\n    k_I32StoreRegisterPointer,  // register => register pointer\r\n    \r\n    k_I32StoreInput,            // registers => input\r\n    k_I32StoreInputPointer,     // register => input pointer\r\n    \r\n    k_I32SetConst,              // set constant => registers\r\n\r\n    k_I32TextureLoad,           // ...\r\n    k_I32ExternCall,          // call exteranl routine           \r\n\r\n    //\r\n    // Arithemtic operations\r\n    //\r\n\r\n    k_I32Add,\r\n    k_I32Sub,\r\n    k_I32Mul,\r\n    k_I32Div,\r\n    k_I32Mod,\r\n\r\n    k_F32Add,\r\n    k_F32Sub,\r\n    k_F32Mul,\r\n    k_F32Div,\r\n    k_F32Mod,\r\n\r\n    //\r\n    // Relational operations\r\n    //\r\n\r\n    k_U32LessThan,\r\n    k_U32GreaterThanEqual,\r\n    k_I32LessThan,\r\n    k_I32GreaterThanEqual, \r\n    k_I32Equal,\r\n    k_I32NotEqual,\r\n    k_I32Not,\r\n    k_F32LessThan,\r\n    k_F32GreaterThanEqual,\r\n\r\n    //\r\n    // Logical operations\r\n    //\r\n\r\n    k_I32LogicalOr,\r\n    k_I32LogicalAnd,\r\n\r\n    //\r\n    // intrinsics\r\n    //\r\n\r\n    k_F32Frac,\r\n    k_F32Floor,\r\n    k_F32Ceil,\r\n    k_F32Sin,\r\n    k_F32Cos,\r\n    k_F32Abs,\r\n    k_F32Sqrt,\r\n    k_F32Max,\r\n    k_F32Min,\r\n    k_F32Pow,\r\n    \r\n    k_I32Mad,\r\n    k_I32Min,\r\n    k_I32Max,\r\n    \r\n    // \r\n    // Cast operations\r\n    //\r\n\r\n    k_F32ToU32,\r\n    k_F32ToI32,\r\n    k_U32ToF32,\r\n    k_I32ToF32,\r\n\r\n    //\r\n    // Flow control\r\n    //\r\n\r\n    k_JumpIf,\r\n    k_Jump,\r\n\r\n    // the operation is only necessary to maintain the purity of the code, \r\n    // when generating the code will be replaced by a jump for all \r\n    // functions except entry point;\r\n    k_Ret\r\n};","\r\nexport enum EDepthWriteMask {\r\n    k_Zero = 0,\r\n    k_All = 1\r\n}\r\n\r\nexport enum EComparisonFunc {\r\n    k_Never = 1,\r\n    k_Less = 2,\r\n    k_Equal = 3,\r\n    k_LessEqual = 4,\r\n    k_Greater = 5,\r\n    k_NotEqual = 6,\r\n    k_GreaterEqual = 7,\r\n    k_Always = 8\r\n}\r\n\r\nexport enum EStencilOp {\r\n    k_Keep = 1,\r\n    K_zero = 2,\r\n    k_Replace = 3,\r\n    k_IncrSat = 4,\r\n    k_DecrSat = 5,\r\n    k_Invert = 6,\r\n    k_Incr = 7,\r\n    k_Decr = 8\r\n}\r\n\r\nexport interface DepthStencilOpDesc {\r\n    StencilFailOp: EStencilOp;\r\n    StencilDepthFailOp: EStencilOp;\r\n    StencilPassOp: EStencilOp;\r\n    StencilFunc: EComparisonFunc;\r\n}\r\n\r\nexport interface IDepthStencilState {\r\n    DepthEnable: boolean;\r\n    DepthWriteMask: EDepthWriteMask;\r\n    DepthFunc: EComparisonFunc;\r\n    StencilEnable: boolean;\r\n    StencilReadMask: number;\r\n    StencilWriteMask: number;\r\n    FrontFace: DepthStencilOpDesc;\r\n    BackFace: DepthStencilOpDesc;\r\n}\r\n\r\n","\r\nexport { EOperation } from \"./EOperations\";\r\nexport { EComparisonFunc, EDepthWriteMask, EStencilOp, IDepthStencilState } from \"./IDepthStencilState\";\r\n\r\nimport { TypeLayoutT } from \"../bundles/auto/type-layout\";\r\n\r\nexport enum EAddrType {\r\n    k_Registers,\r\n    k_Input,\r\n\r\n    k_PointerRegisters,\r\n    k_PointerInput,\r\n\r\n    k_PipelineStates\r\n};\r\n\r\nexport enum EChunkType {\r\n    k_Constants,\r\n    k_Layout,\r\n    k_Code,\r\n    k_Externs,\r\n    k_Shaders,\r\n    k_DepthStencilStates\r\n};\r\n\r\nexport interface IConstant\r\n{\r\n    name: string;\r\n    size: number;\r\n    offset: number;\r\n    semantic: string;\r\n    type: string;\r\n}\r\n\r\nexport interface IExtern\r\n{\r\n    id: number;\r\n    name: string;\r\n    ret: TypeLayoutT;\r\n    params: TypeLayoutT[];\r\n}\r\n\r\nexport interface IShader {\r\n    ver: string;\r\n    name: string;\r\n    args: {\r\n        type: string;\r\n        value: number | boolean;\r\n    }[];\r\n}\r\n\r\ntype error = 'error';\r\n\r\n// abstract interface represents arbitrary memory region based on chosen VM backend\r\nexport interface IMemory\r\n{\r\n    [index: number]: error;\r\n}\r\n\r\nexport interface INumthreads\r\n{\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n};\r\n\r\nexport interface INumgroups\r\n{\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n};\r\n\r\n\r\nexport interface IUAV\r\n{\r\n    name: string;\r\n    // byte length of a single element\r\n    elementSize: number;\r\n    // number of elements\r\n    length: number;\r\n    // register specified in the shader\r\n    register: number;\r\n    // [ elements ]\r\n    data: IMemory;\r\n    // raw data [ counter, ...elements ]\r\n    buffer: IMemory\r\n    // input index for VM\r\n    index: number;                              // << todo: remove (index = register + internal_uav_offset)\r\n}\r\n\r\nexport interface IBundle \r\n{\r\n    play(): Uint8Array;\r\n    dispatch(numgroups: INumgroups, numthreads: INumthreads);\r\n\r\n    setInput(slot: number, input: IMemory): void;\r\n    getInput(slot: number): IMemory;\r\n    setConstant(name: string, value: Uint8Array): boolean;\r\n\r\n    setExtern(id: number, extern: any): void;\r\n\r\n    getLayout(): IConstant[];\r\n    getExterns(): IExtern[];\r\n}\r\n","import { IDiagnosticReport, IDiagnostics } from '@lib/idl/IDiagnostics';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { IKnownDefine } from '@lib/parser/Preprocessor';\r\nimport { StringRef } from \"@lib/util/StringRef\";\r\n\r\nexport enum ENodeCreateMode {\r\n    k_Default,\r\n    k_Necessary,\r\n    k_Expose,\r\n    k_Skip\r\n}\r\n\r\nexport enum EParserCode {\r\n    // k_Pause,\r\n    k_Ok,\r\n    k_Error\r\n}\r\n\r\nexport enum EParserType {\r\n    k_LR0,\r\n    k_LR1,\r\n    k_LALR\r\n}\r\n\r\nexport enum IASTDocumentFlags {\r\n    k_Optimize = 0x0008,\r\n    k_DeveloperMode = 0x0010\r\n}\r\n\r\n\r\nexport enum EParserFlags {\r\n    k_ForceAppendAll = 0x0001,\r\n    k_AllowExposeMode = 0x0002,\r\n    k_AllowAddMode = 0x0004,\r\n    k_AllowSkipMode = 0x008,\r\n    k_Default = k_AllowAddMode | k_AllowExposeMode | k_AllowSkipMode,\r\n    k_Debug = 0x0010\r\n}\r\n\r\n\r\nexport enum ETokenType {\r\n    k_NumericLiteral = 1,\r\n    k_SinglelineCommentLiteral,\r\n    k_MultilineCommentLiteral,\r\n    k_StringLiteral,\r\n    k_PunctuatorLiteral,\r\n    k_WhitespaceLiteral,\r\n    k_EscapeSequence,\r\n    k_NewlineLiteral,\r\n    k_IdentifierLiteral,\r\n    k_KeywordLiteral,\r\n    K_MacroLiteral,\r\n    k_Unknown,\r\n    k_End\r\n}\r\n\r\n\r\nexport type IFile = StringRef;\r\n\r\nexport interface IPosition {\r\n    file: IFile;\r\n    line: number;\r\n    column: number;\r\n    offset?: number;\r\n}\r\n\r\n// todo: add support for range over multiple files;\r\nexport interface IRange {\r\n    start: IPosition;\r\n    end: IPosition;\r\n\r\n    // see \"Preprocessor.ts\" for more details\r\n    // source?: IRange;\r\n}\r\n\r\nexport interface IToken {\r\n    index: number;\r\n    value: string;\r\n\r\n    name?: string;\r\n    type?: ETokenType;\r\n\r\n    loc?: IRange;\r\n}\r\n\r\n\r\n/**\r\n * Grammar rule corresponding to the entry from grammar file.\r\n */\r\nexport interface IRule {\r\n    left: string;\r\n    right: string[];\r\n\r\n    /**\r\n     * rule index based on parser's '_nRules'; \r\n     */\r\n    index: number;\r\n}\r\n\r\nexport enum EOperationType {\r\n    k_Error = 100,\r\n    k_Shift,\r\n    k_Reduce,\r\n    k_Success,\r\n    k_Ok\r\n}\r\n\r\nexport type IRuleFunction = () => EOperationType;// | Promise<EOperationType>;\r\n\r\nexport interface IParseNode {\r\n    children: IParseNode[];\r\n    parent: IParseNode;\r\n    name: string;\r\n    value: string;\r\n    loc?: IRange;\r\n}\r\n\r\nexport interface IParseTree {\r\n    readonly nodes: IParseNode[];\r\n    readonly lastNode: IParseNode;\r\n    readonly optimized: boolean;\r\n    readonly root: IParseNode;\r\n\r\n    addToken(pToken: IToken): void;\r\n    reduceByRule(pRule: IRule, eCreate: ENodeCreateMode): void;\r\n    finishTree(): void;\r\n\r\n    $pop(loc?: IRange): void;\r\n\r\n\r\n    /** @deprecated */\r\n    clone(): IParseTree;\r\n    /** @deprecated */\r\n    toString(): string;\r\n    /** @deprecated */\r\n    toHTMLString(node?: IParseNode, padding?: string): string;\r\n}\r\n\r\n\r\nexport interface ILexerEngine {\r\n    readonly keywords: IMap<string>;\r\n    readonly punctuators: IMap<string>;\r\n    readonly punctuatorsFirstSymbols: IMap<boolean>;\r\n\r\n\r\n    addPunctuator(value: string, name?: string): string;\r\n    addKeyword(value: string, name: string): string;\r\n\r\n    getTerminalValueByName(name: string): string;\r\n\r\n    isLineTerminator(symbol: string): boolean;\r\n    isKeyword(value: string): boolean;\r\n    isPunctuator(value: string): boolean;\r\n    isNumberStart(ch: string, ch1: string): boolean;\r\n    isCommentStart(ch: string, ch1: string): boolean;\r\n    isStringStart(ch: string): boolean;\r\n    isPunctuatorStart(ch: string): boolean;\r\n    isWhiteSpaceStart(ch: string): boolean;\r\n    isNewlineStart(ch: string): boolean;\r\n    isIdentifierStart(ch: string): boolean;\r\n    isEscapeSequenceStart(ch: string): boolean;\r\n}\r\n\r\nexport interface ILexerConfig {\r\n    engine?: ILexerEngine;\r\n    knownTypes?: Set<string>;\r\n    skipComments?: boolean;\r\n    allowLineTerminators?: boolean;\r\n}\r\n\r\n\r\nexport interface ILexer {\r\n    readonly document: ITextDocument;\r\n    readonly config: ILexerConfig;\r\n\r\n    setTextDocument(textDocument: ITextDocument): ILexer;\r\n    // FIXME: do not use any?\r\n    getPosition(): any;\r\n    setPosition(pos: any): void;\r\n    getDiagnosticReport(): IDiagnosticReport;\r\n    getNextToken(): IToken;\r\n    getNextLine(): IToken;\r\n}\r\n\r\nexport type IncludeResolver = (filename: string) => Promise<ITextDocument>;\r\n\r\nexport interface IASTConfig {\r\n    parser?: IParser;\r\n    knownTypes?: Set<string>;\r\n    ruleFunctions?: Map<string, IRuleFunction>;\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n}\r\n\r\n\r\nexport interface IASTDocument {\r\n    readonly uri: IFile;\r\n    readonly diagnosticReport: IDiagnosticReport;\r\n    readonly root: IParseNode;\r\n}\r\n\r\n\r\n\r\n\r\nexport interface IOperation {\r\n    type: EOperationType;\r\n    rule?: IRule;\r\n    stateIndex?: number;\r\n}\r\n\r\nexport interface IOperationMap {\r\n    [grammarSymbol: string]: IOperation;\r\n    [stateIndex: number]: IOperation;\r\n}\r\n\r\nexport interface ISyntaxTable {\r\n    [stateIndex: number]: {\r\n        [terminal: string]: IOperation;\r\n    }\r\n}\r\n\r\n\r\nexport interface IRuleMap {\r\n    [ruleIndex: number]: IRule;\r\n}\r\n\r\nexport interface IProductions {\r\n    [nonTerminal: string]: IRuleMap;\r\n}\r\n\r\n// TODO: remove type\r\nexport interface IRuleFunctionMap {\r\n    [grammarSymbolOrFuncName: string]: string;\r\n}\r\n\r\nexport interface IRuleFunctionDMap {\r\n    [stateIndex: number]: IRuleFunctionMap;\r\n}\r\n\r\nexport interface IAdditionalFuncInfo {\r\n    name: string;\r\n    position: number;\r\n    rule: IRule;\r\n}\r\n\r\nexport interface IParser {\r\n    readonly lexerEngine: ILexerEngine;\r\n    readonly syntaxTable: ISyntaxTable;\r\n\r\n    findFunctionByState(stateIndex: number, grammarSymbol: string): string\r\n    getRuleCreationMode(nonTerminal: string): ENodeCreateMode;\r\n    getGrammarSymbols(): Map<string, string>;\r\n}\r\n\r\n\r\nexport interface IParserParams {\r\n    grammar: string;\r\n    flags?: number; // EParserFlags\r\n    type?: EParserType;\r\n}\r\n\r\n\r\nexport type ExpectedSymbols = Set<string>;\r\n","import { ICompileExprInstruction, IExprInstruction, IPassInstruction, IStmtInstruction, ITechniqueInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\n// import { EPartFxInstructionTypes } from \"./IPartFxInstruction\";\r\n\r\nexport enum EPassDrawMode {\r\n   k_Auto,\r\n   k_Manual\r\n};\r\n\r\n\r\nexport interface IPartFxPassInstruction extends IPassInstruction {\r\n    readonly sorting: boolean;\r\n    readonly prerenderRoutine: ICompileExprInstruction;\r\n    readonly particleInstance: ITypeInstruction;\r\n    readonly geometry: string;\r\n    readonly instanceCount: number;\r\n    readonly drawMode: EPassDrawMode;\r\n}\r\n\r\n\r\n export interface IPartFxInstruction extends ITechniqueInstruction {\r\n\r\n    readonly spawnRoutine: ICompileExprInstruction;\r\n    readonly initRoutine: ICompileExprInstruction;\r\n    readonly updateRoutine: ICompileExprInstruction;\r\n\r\n    readonly particle: ITypeInstruction;\r\n    readonly capacity: number;\r\n\r\n    readonly passes: IPartFxPassInstruction[];\r\n }\r\n\r\n\r\n export interface ISpawnStmtInstruction extends IStmtInstruction {\r\n    readonly name: string;\r\n    readonly count: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n    \r\n    // resolved properties\r\n   //  readonly fx: IPartFxInstruction;\r\n   //  readonly init: IFunctionDeclInstruction;\r\n }\r\n\r\n export interface IDrawStmtInstruction extends IStmtInstruction {\r\n   readonly name: string;\r\n   readonly args: IExprInstruction[];\r\n}\r\n","import bf from \"@lib/bf\";\r\nimport { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EDiagnosticCategory, IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { EOperationType, EParserCode, IASTConfig, IASTDocument, IASTDocumentFlags as EASTParsingFlags, IFile, ILexer, IParseNode, IParser, IParseTree, IPosition, IRange, IRuleFunction, ISyntaxTable, IToken } from \"@lib/idl/parser/IParser\";\r\nimport { Lexer } from \"@lib/parser/Lexer\";\r\nimport { ParseTree } from \"@lib/parser/ParseTree\";\r\nimport { END_SYMBOL, ERROR, T_NON_TYPE_ID, UNKNOWN_TOKEN } from \"@lib/parser/symbols\";\r\nimport { extendRange } from \"@lib/parser/util\";\r\nimport { DiagnosticException, Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\n\r\nexport enum EParsingErrors {\r\n    SyntaxUnknownError = 2051,\r\n    SyntaxUnexpectedEOF,\r\n    SyntaxRecoverableStateNotFound,\r\n\r\n    GeneralParsingLimitIsReached,\r\n};\r\n\r\n\r\nexport enum EParsingWarnings {\r\n    MacroUnknownWarning = 3000,\r\n\r\n    ReserveWordUsing,\r\n}\r\n\r\n\r\nexport class ParsingDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Parsing diagnostics\", 'P');\r\n    }\r\n\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IMap<any>): IRange {\r\n        if (category === EDiagnosticCategory.k_Warning) {\r\n            switch (code) {\r\n                case EParsingWarnings.MacroUnknownWarning:\r\n                    return desc.loc;\r\n            }\r\n        }\r\n\r\n        //\r\n        // errors\r\n        //\r\n        \r\n        switch (code) {\r\n            case EParsingErrors.SyntaxUnknownError:\r\n            case EParsingErrors.SyntaxUnexpectedEOF:\r\n                return desc.token.loc;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n\r\n    //\r\n    // NODE: position is being resolved only in case of failed range resolving\r\n    //\r\n    protected resolvePosition(category: EDiagnosticCategory, code: number, desc: IMap<any>): IPosition {\r\n        console.assert(code != EParsingErrors.SyntaxUnknownError);\r\n        return { line: desc.line, column: 0, file: null };\r\n    }\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EParsingErrors.SyntaxUnknownError]: \"Syntax error during parsing. Token: '{token.value}'\\n\" +\r\n                \"{token.loc.start.file}:{token.loc.start.line}:{token.loc.start.column}.\",\r\n            [EParsingErrors.SyntaxUnexpectedEOF]: \"Syntax error. Unexpected EOF.\",\r\n            [EParsingErrors.GeneralParsingLimitIsReached]: \"Parsing limit is reached.\",\r\n            [EParsingErrors.SyntaxRecoverableStateNotFound]: \"Recoverable state not found.\"\r\n        };\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: IMap<any>): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { file, loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EParsingWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EParsingErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n\r\n\r\nfunction cloneToken(token: IToken): IToken {\r\n    return {\r\n        ...token,\r\n        loc: {\r\n            start: { ...token.loc.start },\r\n            end: { ...token.loc.end }\r\n        }\r\n    };\r\n}\r\n\r\n\r\n// class Context {\r\n//     allowErrorRecoverty: boolean = true;\r\n//     developerMode: boolean = false;\r\n\r\n//     lexer: Lexer;\r\n//     diagnostics: ParsingDiagnostics;\r\n//     knownTypes: Set<string>;\r\n//     ruleFunctions: Map<string, IRuleFunction>;\r\n    \r\n//     stack: number[] = [0];\r\n\r\n\r\n//     constructor() {\r\n//         this.diagnostics = new ParsingDiagnostics;\r\n//     }\r\n\r\n//     readToken() {\r\n//         return this.lexer.getNextToken();\r\n//     }\r\n\r\n\r\n//     private error(code: number, token: IToken) {\r\n//         this.diagnostics.error(code, { ...this.lexer.getLocation(), token });\r\n//     }\r\n\r\n//     private critical(code: number, token: IToken = null) {\r\n//         this.diagnostics.critical(code, { ...this.lexer.getLocation(), token });\r\n//     }\r\n// }\r\n \r\n\r\nexport class ASTDocument implements IASTDocument {\r\n    protected parser: IParser;\r\n    protected knownTypes: Set<string>;\r\n    protected ruleFunctions: Map<string, IRuleFunction>;\r\n\r\n    protected diag: ParsingDiagnostics;\r\n\r\n    protected tree: IParseTree;\r\n    protected stack: number[];\r\n    \r\n    protected lexer: ILexer;\r\n    protected token: IToken;\r\n\r\n    constructor(config: IASTConfig) {\r\n        assert(config.parser, 'parser engine is not defined');\r\n        this.init(config);\r\n    }\r\n\r\n    protected init({ parser, knownTypes = new Set(), ruleFunctions = new Map }: IASTConfig) {\r\n        this.parser = parser;\r\n        this.knownTypes = knownTypes;\r\n        this.ruleFunctions = ruleFunctions;\r\n    }\r\n\r\n\r\n    get uri(): IFile {\r\n        // TODO: use uri from original textDocument\r\n        return this.lexer.document.uri;\r\n    }\r\n\r\n\r\n    get diagnosticReport(): IDiagnosticReport {\r\n        let lexerReport = this.lexer.getDiagnosticReport();\r\n        let parserReport = this.diag.resolve();\r\n        return Diagnostics.mergeReports([lexerReport, parserReport]);\r\n    }\r\n\r\n    get root(): IParseNode {\r\n        return this.tree.root;\r\n    }\r\n\r\n\r\n    async parse(textDocument: ITextDocument, flags: number = EASTParsingFlags.k_Optimize): Promise<EParserCode> {\r\n        const developerMode = bf.testAll(flags, EASTParsingFlags.k_DeveloperMode);\r\n        const allowErrorRecoverty = true;\r\n        const optimizeTree = bf.testAll(flags, EASTParsingFlags.k_Optimize);\r\n\r\n        this.diag = new ParsingDiagnostics;\r\n        this.tree = new ParseTree(optimizeTree);\r\n        this.stack = [0];\r\n        \r\n        this.setTextDocument(textDocument);\r\n        this.token = await this.readToken();\r\n\r\n        if (this.token.name === END_SYMBOL) {\r\n            return EParserCode.k_Ok;\r\n        }\r\n\r\n        await this.run({ developerMode, allowErrorRecoverty });\r\n\r\n        // clear context\r\n\r\n        // this.stack = null;\r\n        // this.lexer = null;\r\n        // this.token = null;\r\n        // diag\r\n        // tree\r\n\r\n        // end of clear\r\n\r\n        if (this.diag.hasErrors()) {\r\n            console.error('parsing was ended with errors.');\r\n            return EParserCode.k_Error;\r\n        }\r\n\r\n        return EParserCode.k_Ok;\r\n    }\r\n\r\n    protected setTextDocument(textDocument: ITextDocument): void {\r\n        this.lexer = new Lexer({\r\n            engine: this.parser.lexerEngine,\r\n            knownTypes: this.knownTypes\r\n        });\r\n        this.lexer.setTextDocument(textDocument);\r\n    }\r\n\r\n\r\n    protected async readToken(): Promise<IToken> {\r\n        return this.lexer.getNextToken();\r\n    }\r\n\r\n    protected emitWarning(code: number, token: IToken) {\r\n        this.diag.warning(code, { token });\r\n    }\r\n    \r\n    protected emitError(code: number, token: IToken) {\r\n        this.diag.error(code, { token });\r\n    }\r\n\r\n    \r\n    protected emitCritical(code: number, token: IToken = null) {\r\n        this.diag.critical(code, { token });\r\n    }\r\n\r\n\r\n    private async restoreState(syntaxTable: ISyntaxTable, parseTree: ParseTree, stack: number[], causingErrorToken: IToken, errorToken: IToken): Promise<number> {\r\n        while (true) {\r\n            let recoverableState = -1;\r\n            for (let i = stack.length - 1; i >= 0; --i) {\r\n                const errorOp = syntaxTable[stack[i]][ERROR];\r\n                const isRecoverableState = (isDef(errorOp) &&\r\n                    errorOp.type === EOperationType.k_Shift &&\r\n                    syntaxTable[errorOp.stateIndex][causingErrorToken.name]);\r\n                if (isRecoverableState) {\r\n                    recoverableState = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (recoverableState !== -1) {\r\n                const recoveredStateIndex = stack[recoverableState];\r\n                // current op will be: syntaxTable[recoveredStateIndex][ERROR];\r\n\r\n                let stackDiff = stack.length - 1 - recoverableState;\r\n                while (stackDiff != 0) {\r\n                    // extend error token location with the already processed tokens\r\n                    parseTree.$pop(errorToken.loc);\r\n                    stack.pop();\r\n                    stackDiff--;\r\n                }\r\n\r\n                // recoverable state found so continue normal processing as it would be before the error\r\n                return recoveredStateIndex;\r\n            }\r\n\r\n            // TODO: optimize this call!\r\n            extendRange(errorToken.loc, causingErrorToken.loc);\r\n\r\n            if (causingErrorToken.value === END_SYMBOL) {\r\n                // state cant be recovered\r\n                break;\r\n            }\r\n\r\n            // try to restore from the next token\r\n            // FIXME: \r\n            const nextToken: IToken = await this.readToken();\r\n            Object.keys(nextToken).forEach(key => causingErrorToken[key] = nextToken[key]);\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    \r\n    private operationAdditionalAction(stateIndex: number, grammarSymbol: string): EOperationType {\r\n        const funcName = this.parser.findFunctionByState(stateIndex, grammarSymbol);\r\n        if (!isNull(funcName)) {\r\n            assert(!!this.ruleFunctions.has(funcName));\r\n            return this.ruleFunctions.get(funcName)();\r\n        }\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private async run({ developerMode = false, allowErrorRecoverty = true }): Promise<void> {\r\n\r\n        const { syntaxTable } = this.parser;\r\n        const { stack, tree } = this;\r\n\r\n        const undefinedToken: IToken = { index: -1, name: null, value: null };\r\n        let causingErrorToken: IToken = undefinedToken;\r\n\r\n        // debug mode\r\n        const opLimit = 64e5;\r\n        let opCounter = 0;\r\n\r\n        try {\r\n            breakProcessing:\r\n            while (true) {\r\n                // global recursion prevention in debug mode\r\n                if (developerMode) {\r\n                    if (opCounter > opLimit) {\r\n                        this.emitCritical(EParsingErrors.GeneralParsingLimitIsReached);\r\n                    }\r\n                    opCounter++;\r\n                }\r\n\r\n                let currStateIndex = stack[stack.length - 1];\r\n                let op = syntaxTable[currStateIndex][this.token.name];\r\n\r\n                if (allowErrorRecoverty) {\r\n                    if (!op) {\r\n                        const ID_REGEXP = /^[_a-zA-Z][_a-zA-Z0-9]{0,30}$/;\r\n                        const isLikeID = this.token.name !== T_NON_TYPE_ID && ID_REGEXP.test(this.token.value);\r\n                        const canContinueAsID = isLikeID && syntaxTable[currStateIndex][T_NON_TYPE_ID];\r\n\r\n                        // recursion prevention\r\n                        if (causingErrorToken.index !== this.token.index) {\r\n                            if (this.token.name === END_SYMBOL) {\r\n                                this.emitError(EParsingErrors.SyntaxUnexpectedEOF, this.token);\r\n                            } else {\r\n                                // a special case to bypass tokens of the same name with keywords\r\n                                if (canContinueAsID) {\r\n                                    // todo: emit warning(!)\r\n                                    // this.emitWarning(EParsingWarnings.ReserveWordUsing, this.token);\r\n                                } else {\r\n                                    this.emitError(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            // one more attempt to recover but from the next token\r\n                            this.token = await this.readToken();\r\n                            if (this.token.index === -1) debugger;\r\n                            // NOTE: in order to prevent recusrion on END_SYMBOL\r\n                            causingErrorToken = undefinedToken;\r\n                            continue;\r\n                        }\r\n\r\n                        causingErrorToken = cloneToken(this.token);\r\n\r\n                        if (canContinueAsID) {\r\n                            this.token = { ...cloneToken(this.token), name: T_NON_TYPE_ID };\r\n                        } else {\r\n                            // token = { ...token, name: ERROR };\r\n                            this.token = { ...cloneToken(this.token), name: ERROR };\r\n                        }\r\n                    }\r\n                    \r\n                    op = syntaxTable[currStateIndex][this.token.name];\r\n\r\n                    const errorProcessing = this.token.name === ERROR;\r\n                    const errorReductionEnded = !op || (errorProcessing && (op.type === EOperationType.k_Shift));\r\n\r\n                    // state must be recovered if operation is undefined or error reduction was ended. \r\n                    if (errorReductionEnded) {\r\n                        // NOTE: recoveryToken, token, stack and parseTree will be update imlicitly inside the state restore routine. \r\n                        let recoveryToken = cloneToken(causingErrorToken);\r\n                        while (recoveryToken.name === UNKNOWN_TOKEN) {\r\n                            recoveryToken = await this.readToken();\r\n                            if (recoveryToken.index === -1) debugger;\r\n                        }\r\n                        currStateIndex = await this.restoreState(syntaxTable, <ParseTree>tree, stack, recoveryToken, this.token /* error token */);\r\n                        if (currStateIndex === -1) {\r\n                            this.emitCritical(EParsingErrors.SyntaxRecoverableStateNotFound);\r\n                        }\r\n\r\n                        // perform error shift op.\r\n                        op = syntaxTable[currStateIndex][this.token.name]; // token.name === 'ERROR'\r\n                        stack.push(op.stateIndex);\r\n                        tree.addToken(this.token/* error token */);\r\n                        this.token = recoveryToken;\r\n\r\n                        // const nextOp = syntaxTable[op.stateIndex][token.name];\r\n                        // if (nextOp.type === EOperationType.k_Reduce) {\r\n                        //     tokenBuffer.push(rec);\r\n                        // }\r\n\r\n                        // return to normal precesing loop\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isDef(op)) {\r\n                    switch (op.type) {\r\n                        case EOperationType.k_Success:\r\n                            break breakProcessing;\r\n\r\n                        case EOperationType.k_Shift:\r\n                            {\r\n                                const stateIndex = op.stateIndex;\r\n                                stack.push(stateIndex);\r\n                                tree.addToken(this.token);\r\n\r\n                                const additionalOperationCode = this.operationAdditionalAction(stateIndex, this.token.name);\r\n                                if (additionalOperationCode === EOperationType.k_Error) {\r\n                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                } else if (additionalOperationCode === EOperationType.k_Ok) {\r\n                                    this.token = await this.readToken();\r\n                                    if (this.token.index === -1) debugger;\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        case EOperationType.k_Reduce:\r\n                            {\r\n                                const ruleLength = op.rule.right.length;\r\n                                stack.length -= ruleLength;\r\n\r\n                                const stateIndex = syntaxTable[stack[stack.length - 1]][op.rule.left].stateIndex;\r\n\r\n                                stack.push(stateIndex);\r\n                                tree.reduceByRule(op.rule, this.parser.getRuleCreationMode(op.rule.left));\r\n\r\n                                const additionalOperationCode = this.operationAdditionalAction(stateIndex, op.rule.left);\r\n                                if (additionalOperationCode === EOperationType.k_Error) {\r\n                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                }\r\n                            }\r\n                            break;\r\n                    }\r\n                } else {\r\n                    assert(!allowErrorRecoverty, `unexpected end, something went wrong :/`);\r\n                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                }\r\n            }\r\n\r\n            tree.finishTree();\r\n        } catch (e) {\r\n            if (!(e instanceof DiagnosticException)) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import bf from \"@lib/bf\";\r\nimport { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EDiagnosticCategory } from \"@lib/idl/IDiagnostics\";\r\nimport { IDMap, IMap } from \"@lib/idl/IMap\";\r\nimport { ENodeCreateMode as ENodeCreationMode, EOperationType, EParserFlags, EParserType, ExpectedSymbols, IAdditionalFuncInfo, IOperation, IOperationMap, IParser, IParserParams, IPosition, IProductions, IRange, IRule, IRuleFunctionDMap, IRuleMap, ISyntaxTable } from \"@lib/idl/parser/IParser\";\r\nimport { Item } from \"@lib/parser/Item\";\r\nimport { LexerEngine } from \"@lib/parser/Lexer\";\r\nimport { State } from \"@lib/parser/State\";\r\nimport { END_POSITION, END_SYMBOL, FLAG_RULE_CREATE_NODE, FLAG_RULE_EXPOSE_NODE, FLAG_RULE_FUNCTION, FLAG_RULE_SKIP_NODE, INLINE_COMMENT_SYMBOL, LEXER_RULES, START_SYMBOL, T_EMPTY, UNUSED_SYMBOL } from \"@lib/parser/symbols\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\n\r\nexport enum EParserErrors {\r\n    GrammarAddOperation = 2001,\r\n    GrammarAddStateLink,\r\n    GrammarUnexpectedSymbol,\r\n    GrammarInvalidAdditionalFuncName,\r\n    GrammarInvalidKeyword\r\n};\r\n\r\n\r\ntype Terminals = Set<string>;\r\n\r\n\r\nexport class GrammarDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Grammar diagnostics\", 'G');\r\n    }\r\n\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IMap<any>): IRange {\r\n        return null;\r\n    }\r\n\r\n\r\n    protected resolvePosition(category: EDiagnosticCategory, code: number, desc: IMap<any>): IPosition {\r\n        return { line: desc.line, column: 0, file: null };\r\n    }\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EParserErrors.GrammarAddOperation]: \"Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\\n\" +\r\n                \"Conflict in state with index: {stateIndex}. With grammar symbol: \\\"{grammarSymbol}\\\"\\n\" +\r\n                \"Old operation: {oldOperation}\\n\" +\r\n                \"New operation: {newOperation}\\n\" +\r\n                \"For more info init parser in debug-mode and see syntax table and list of states.\" +\r\n                `\\n\\n{stateDesc}`,\r\n            [EParserErrors.GrammarAddStateLink]: \"Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\\n\" +\r\n                \"Conflict in state with index: {stateIndex}. With grammar symbol: \\\"{grammarSymbol}\\\"\\n\" +\r\n                \"Old next state: {oldNextStateIndex}\\n\" +\r\n                \"New next state: {newNextStateIndex}\\n\" +\r\n                \"For more info init parser in debug-mode and see syntax table and list of states.\",\r\n            [EParserErrors.GrammarUnexpectedSymbol]: \"Grammar error. Can`t generate rules from grammar\\n\" +\r\n                \"Unexpected symbol: {unexpectedSymbol}\\n\" +\r\n                \"Expected: {expectedSymbol}\",\r\n            [EParserErrors.GrammarInvalidAdditionalFuncName]: \"Grammar error. Empty additional function name.\",\r\n            [EParserErrors.GrammarInvalidKeyword]: \"Grammar error. Bad keyword: {badKeyword}\\n\" +\r\n                \"All keyword must be define in lexer rule block.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class AbstractParser implements IParser {\r\n    //Process params\r\n\r\n    // TODO: make readonly\r\n    lexerEngine: LexerEngine;\r\n\r\n    //\r\n    // Grammar based Info\r\n    //\r\n\r\n    private _syntaxTable: ISyntaxTable;\r\n\r\n\r\n    /**\r\n     * General structure:\r\n     *  { [symbol name]: { [rule index]: IRule } }\r\n     */\r\n    private _productions: IProductions;\r\n    private _states: State[];\r\n\r\n    /**\r\n * Auxiliary map for all symbols from grammar: symbolName => symbolName.\r\n * For ex.: T_PUNCTUATOR_61 => '='\r\n */\r\n    private _grammarSymbols: Map<string, string>;\r\n\r\n    // functions described in grammar's flags\r\n    private _additionalFuncInfoList: IAdditionalFuncInfo[];\r\n    private _adidtionalFunctByStateDMap: IRuleFunctionDMap;\r\n\r\n    // Additioanal info\r\n\r\n    // flags for rules (extracted from grammar's flags)\r\n    private _ruleCreationModeMap: IMap<number>;\r\n\r\n    // Temp\r\n\r\n    // aux. cache for first terminals\r\n    private _firstTerminalsCache: IMap<Terminals>;\r\n    // private _followTerminalsCache: IDMap<boolean>;\r\n\r\n\r\n    //\r\n    // LALR specific\r\n    //\r\n\r\n    /**\r\n     * Auxiliary map: [item index] => { [item index]: true }\r\n     * Expectation correspondence map.\r\n     */\r\n    // NOTE: default JS object significantly faster than Map<number, Set<number>>\r\n    //       for this case :/\r\n    private _expectedExtensionDMap: IDMap<boolean>;\r\n    private _baseItems: Item[];\r\n    private _closureForItemsCache: IMap<State>;\r\n\r\n    // TODO: use dedicated type for parser engine\r\n    private _diag: GrammarDiagnostics;\r\n\r\n    // grammar: string, flags: number = EParserFlags.k_AllNode, type: EParserType = EParserType.k_LALR\r\n    constructor({ grammar, flags = EParserFlags.k_Default, type = EParserType.k_LALR }: IParserParams) {\r\n        this._syntaxTable = null;\r\n\r\n        this._productions = null;\r\n        this._baseItems = null;\r\n        this._states = null;\r\n\r\n        this._additionalFuncInfoList = null;\r\n        this._adidtionalFunctByStateDMap = null;\r\n\r\n        this._ruleCreationModeMap = null;\r\n\r\n        this._firstTerminalsCache = null;\r\n        // this._followTerminalsCache = null;\r\n        this._closureForItemsCache = null;\r\n\r\n        this._expectedExtensionDMap = null;\r\n        this._diag = new GrammarDiagnostics;\r\n\r\n        this.init({ grammar, flags, type });\r\n    }\r\n\r\n    get syntaxTable(): ISyntaxTable {\r\n        return this._syntaxTable;\r\n    }\r\n\r\n\r\n    findFunctionByState(stateIndex: number, grammarSymbol: string): string {\r\n        const funcDMap = this._adidtionalFunctByStateDMap;\r\n\r\n        if (!isNull(funcDMap) &&\r\n            isDef(funcDMap[stateIndex]) &&\r\n            isDef(funcDMap[stateIndex][grammarSymbol])) {\r\n            return funcDMap[stateIndex][grammarSymbol];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    getRuleCreationMode(nonTerminal: string): ENodeCreationMode {\r\n        return this._ruleCreationModeMap[nonTerminal];\r\n    }\r\n\r\n\r\n    getGrammarSymbols(): Map<string, string> {\r\n        return this._grammarSymbols;\r\n    }\r\n\r\n    protected init({ grammar, flags = EParserFlags.k_Default, type = EParserType.k_LALR }: IParserParams) {\r\n        this.lexerEngine = new LexerEngine();\r\n\r\n        this.generateRules(grammar, flags);\r\n        this.buildSyntaxTable(type);\r\n        this.generateFunctionByStateMap();\r\n\r\n        if (!bf.testAll(flags, EParserFlags.k_Debug)) {\r\n            this.clearMem();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    printStates(isBaseOnly: boolean = true): void {\r\n        if (!isDef(this._states)) {\r\n            console.warn(\"It`s impossible to print states. You must init parser in debug-mode\");\r\n            return;\r\n        }\r\n        const mesg = \"\\n\" + this.statesToString(isBaseOnly);\r\n        console.log(mesg);\r\n    }\r\n\r\n\r\n    printState(stateIndex: number, isBaseOnly: boolean = true): void {\r\n        if (!isDef(this._states)) {\r\n            console.log(\"It`s impossible to print states. You must init parser in debug-mode.\");\r\n            return;\r\n        }\r\n\r\n        var state = this._states[stateIndex];\r\n        if (!isDef(state)) {\r\n            console.log(\"Can not print stete with index: \" + stateIndex.toString());\r\n            return;\r\n        }\r\n\r\n        console.log(`\\n${state.toString(isBaseOnly, this.getGrammarSymbols())}`);\r\n    }\r\n\r\n\r\n    protected critical(code, desc) {\r\n        this._diag.critical(code, desc);\r\n    }\r\n\r\n    private grammarError(code: number, desc) {\r\n        let file = \"grammar\";\r\n\r\n        switch (code) {\r\n            case EParserErrors.GrammarAddOperation:\r\n                {\r\n                    const { stateIndex, grammarSymbol, oldOperation, newOperation } = desc;\r\n                    this.critical(code, {\r\n                        file, line: 0, stateIndex, grammarSymbol,\r\n                        oldOperation: AbstractParser.operationToString(oldOperation),\r\n                        newOperation: AbstractParser.operationToString(newOperation),\r\n                        stateDesc: this._states[stateIndex].toString()\r\n                    });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarAddStateLink:\r\n                {\r\n                    const { stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex } = desc;\r\n                    this.critical(code, { file, line: 0, stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarUnexpectedSymbol:\r\n                {\r\n                    const { grammarLine, expectedSymbol, unexpectedSymbol } = desc;\r\n                    this.critical(code, { file, line: grammarLine, expectedSymbol, unexpectedSymbol });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarInvalidAdditionalFuncName:\r\n                {\r\n                    const { grammarLine } = desc;\r\n                    this.critical(code, { file, line: grammarLine });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarInvalidKeyword:\r\n                {\r\n                    const { grammarLine, badKeyword } = desc;\r\n                    this.critical(code, { file, line: grammarLine, badKeyword })\r\n                }\r\n                break;\r\n            default:\r\n                throw \"invalid case!!!!\";\r\n        }\r\n    }\r\n\r\n\r\n    private clearMem(): void {\r\n        delete this._states;\r\n\r\n        delete this._productions;\r\n        delete this._baseItems;\r\n        // delete this._followTerminalsCache;\r\n        delete this._firstTerminalsCache;\r\n        delete this._closureForItemsCache;\r\n        delete this._expectedExtensionDMap;\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for the state's dublicate.\r\n     */\r\n    private hasState(state: State, type: EParserType): State {\r\n        return this._states.find(stateIth => stateIth.isEqual(state, type)) || null;\r\n    }\r\n\r\n\r\n    private nonTerminals(): string[] {\r\n        return Object.keys(this._productions);\r\n    }\r\n\r\n    private rules(nonTerminal: string): IRule[] {\r\n        const prods = this._productions[nonTerminal];\r\n        return prods ? Object.keys(prods).map(ruleIndex => prods[ruleIndex]) : null;\r\n    }\r\n\r\n    private ruleCreationMode(symbol: string) {\r\n        return this._ruleCreationModeMap[symbol];\r\n    }\r\n\r\n    /**\r\n     * terminals & non-terminals;\r\n     */\r\n    private symbols(): string[] {\r\n        return [...this._grammarSymbols.keys()];\r\n    }\r\n\r\n    private isTerminal(symbol: string): boolean {\r\n        return !(this._productions[symbol]);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add item to 'stateList' and set item's index in it.\r\n     */\r\n    private pushState(state: State): void {\r\n        state.index = this._states.length;\r\n        this._states.push(state);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add item to 'baseItemList' and set item's index in it.\r\n     */\r\n    private pushBaseItem(item: Item): void {\r\n        item.index = this._baseItems.length;\r\n        this._baseItems.push(item);\r\n    }\r\n\r\n\r\n    private tryAddState(state: State, type: EParserType): State {\r\n        let res = this.hasState(state, type);\r\n\r\n        if (isNull(res)) {\r\n            if (type === EParserType.k_LR0) {\r\n                state.eachItem(item => this.pushBaseItem(item));\r\n            }\r\n\r\n            this.pushState(state);\r\n            this.closure(state, type);\r\n\r\n            return state;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    private hasEmptyRule(symbol: string): boolean {\r\n        if (this.isTerminal(symbol)) {\r\n            return false;\r\n        }\r\n\r\n        return !!this.rules(symbol).find(rule => rule.right.length === 0);\r\n    }\r\n\r\n\r\n    private pushInSyntaxTable(syntaxTable: ISyntaxTable, stateIndex: number, symbol: string, operation: IOperation): void {\r\n        syntaxTable[stateIndex] = syntaxTable[stateIndex] || {};\r\n\r\n        if (isDef(syntaxTable[stateIndex][symbol])) {\r\n            this.grammarError(EParserErrors.GrammarAddOperation, {\r\n                stateIndex: stateIndex,\r\n                grammarSymbol: this.convertGrammarSymbol(symbol),\r\n                oldOperation: this._syntaxTable[stateIndex][symbol],\r\n                newOperation: operation\r\n            });\r\n        }\r\n\r\n        syntaxTable[stateIndex][symbol] = operation;\r\n    }\r\n\r\n\r\n    private addStateLink(state: State, nextState: State, symbol: string): void {\r\n        let isAddState = state.addNextState(symbol, nextState);\r\n        if (!isAddState) {\r\n            this.grammarError(EParserErrors.GrammarAddStateLink, {\r\n                stateIndex: state.index,\r\n                oldNextStateIndex: state.nextStates[symbol] || null,\r\n                newNextStateIndex: nextState.index,\r\n                grammarSymbol: this.convertGrammarSymbol(symbol)\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    private firstTerminals(symbol: string): Terminals {\r\n        if (this.isTerminal(symbol)) {\r\n            return null;\r\n        }\r\n\r\n        if (isDef(this._firstTerminalsCache[symbol])) {\r\n            return this._firstTerminalsCache[symbol];\r\n        }\r\n\r\n        const rules = this.rules(symbol);\r\n        const res: Terminals = this._firstTerminalsCache[symbol] = new Set<string>();\r\n\r\n        if (this.hasEmptyRule(symbol)) {\r\n            res.add(T_EMPTY);\r\n        }\r\n\r\n        if (isNull(rules)) {\r\n            return res;\r\n        }\r\n\r\n        for (let i = 0; i < rules.length; ++i) {\r\n            const rule = rules[i];\r\n            const right = rule.right;\r\n\r\n            let isFinish = false;\r\n\r\n            for (let j = 0; j < right.length; j++) {\r\n                if (right[j] === symbol) {\r\n                    if (res.has(T_EMPTY)) {\r\n                        continue;\r\n                    }\r\n\r\n                    isFinish = true;\r\n                    break;\r\n                }\r\n\r\n                const terminals = this.firstTerminals(right[j]);\r\n\r\n                if (isNull(terminals)) {\r\n                    res.add(right[j]);\r\n                } else {\r\n                    for (const terminal of terminals) {\r\n                        res.add(terminal);\r\n                    }\r\n                }\r\n\r\n                if (!this.hasEmptyRule(right[j])) {\r\n                    isFinish = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!isFinish) {\r\n                res.add(T_EMPTY);\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    // private followTerminal(symbolVal: string): IMap<boolean> {\r\n    //     if (isDef(this._followTerminalsCache[symbolVal])) {\r\n    //         return this._followTerminalsCache[symbolVal];\r\n    //     }\r\n\r\n    //     var i: number = 0, j: number = 0, k: number = 0, l: number = 0, m: number = 0;\r\n    //     var pRulesDMap: IRuleDMap = this._rulesDMap;\r\n    //     var rulesDMapKeys: string[], pRulesMapKeys: string[];\r\n\r\n    //     var rule: IRule;\r\n    //     var pTempRes: IMap<boolean>;\r\n    //     var pTempKeys: string[];\r\n    //     var res: IMap<boolean>;\r\n\r\n    //     var right: string[];\r\n    //     var isFinish: boolean;\r\n\r\n    //     var sFirstKey: string;\r\n    //     var sSecondKey: string;\r\n\r\n    //     res = this._followTerminalsCache[symbolVal] = <IMap<boolean>>{};\r\n\r\n    //     if (isNull(pRulesDMap)) {\r\n    //         return res;\r\n    //     }\r\n\r\n    //     rulesDMapKeys = Object.keys(pRulesDMap);\r\n    //     for (i = 0; i < rulesDMapKeys.length; i++) {\r\n    //         sFirstKey = rulesDMapKeys[i];\r\n\r\n    //         if (isNull(pRulesDMap[sFirstKey])) {\r\n    //             continue;\r\n    //         }\r\n\r\n    //         pRulesMapKeys = Object.keys(pRulesDMap[sFirstKey]);\r\n\r\n    //         for (j = 0; j < pRulesMapKeys.length; j++) {\r\n    //             rule = pRulesDMap[sFirstKey][sSecondKey];\r\n    //             right = rule.right;\r\n\r\n    //             for (k = 0; k < right.length; k++) {\r\n    //                 if (right[k] === symbolVal) {\r\n    //                     if (k === right.length - 1) {\r\n    //                         pTempRes = this.followTerminal(rule.left);\r\n\r\n    //                         pTempKeys = Object.keys(pTempRes);\r\n    //                         for (m = 0; m < pTempKeys.length; i++) {\r\n    //                             res[pTempKeys[m]] = true;\r\n    //                         }\r\n    //                     }\r\n    //                     else {\r\n    //                         isFinish = false;\r\n\r\n    //                         for (l = k + 1; l < right.length; l++) {\r\n    //                             pTempRes = this.firstTerminal(right[l]);\r\n\r\n    //                             if (isNull(pTempRes)) {\r\n    //                                 res[right[l]] = true;\r\n    //                                 isFinish = true;\r\n    //                                 break;\r\n    //                             }\r\n    //                             else {\r\n    //                                 pTempKeys = Object.keys(pTempRes);\r\n    //                                 for (m = 0; m < pTempKeys.length; i++) {\r\n    //                                     res[pTempKeys[m]] = true;\r\n    //                                 }\r\n    //                             }\r\n\r\n    //                             if (!pTempRes[T_EMPTY]) {\r\n    //                                 isFinish = true;\r\n    //                                 break;\r\n    //                             }\r\n    //                         }\r\n\r\n    //                         if (!isFinish) {\r\n    //                             pTempRes = this.followTerminal(rule.left);\r\n\r\n    //                             pTempKeys = Object.keys(pTempRes);\r\n    //                             for (m = 0; m < pTempKeys.length; i++) {\r\n    //                                 res[pTempKeys[m]] = true;\r\n    //                             }\r\n    //                         }\r\n    //                     }\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     return res;\r\n    // }\r\n\r\n    private firstTerminalsForSet(symbolList: string[], expectedSymbols: ExpectedSymbols): Terminals {\r\n        const res = new Set<string>();\r\n\r\n        for (let i = 0; i < symbolList.length; i++) {\r\n            const terminals = this.firstTerminals(symbolList[i]);\r\n\r\n            if (isNull(terminals)) {\r\n                res.add(symbolList[i]);\r\n                return res;\r\n            }\r\n\r\n            let isEmpty = false;\r\n            for (const symbol of terminals) {\r\n                if (symbol === T_EMPTY) {\r\n                    isEmpty = true;\r\n                    continue;\r\n                }\r\n                res.add(symbol);\r\n            }\r\n\r\n            if (!isEmpty) {\r\n                return res;\r\n            }\r\n        }\r\n\r\n        if (!isNull(expectedSymbols)) {\r\n            expectedSymbols.forEach(expectedSymbol => res.add(expectedSymbol));\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    private generateRules(grammarSource: string, flags: EParserFlags): void {\r\n        let allRuleList: string[] = grammarSource.split(/\\r?\\n/);\r\n        let tempRule: string[];\r\n        let rule: IRule;\r\n        let isLexerBlock = false;\r\n\r\n        this._productions = <IProductions>{};\r\n        this._additionalFuncInfoList = <IAdditionalFuncInfo[]>[];\r\n        this._ruleCreationModeMap = <IMap<number>>{};\r\n        this._grammarSymbols = new Map([['END_SYMBOL', END_SYMBOL]]);\r\n\r\n        let i = 0, j = 0;\r\n\r\n        // append all nodes ignoring any flags\r\n        const forceAppendAllMode = bf.testAll(flags, EParserFlags.k_ForceAppendAll);\r\n        // force unwind node if it is marked as '--expose'\r\n        const allowExposeMode = bf.testAll(flags, EParserFlags.k_AllowExposeMode);\r\n        // force add node if it is marked as '--add'\r\n        const allowAddMode = bf.testAll(flags, EParserFlags.k_AllowAddMode);\r\n        // remove node from parsing tree if it is marked as '--skip'\r\n        const allowSkipMode = bf.testAll(flags, EParserFlags.k_AllowSkipMode);\r\n\r\n        let symbolsWithNodeMap: IMap<number> = this._ruleCreationModeMap;\r\n\r\n        let name: string;\r\n\r\n        let nRules = 0;\r\n\r\n        for (i = 0; i < allRuleList.length; i++) {\r\n            if (allRuleList[i] === \"\" || allRuleList[i] === \"\\r\") {\r\n                continue;\r\n            }\r\n\r\n            // split rule like 'S : Program'\r\n            tempRule = allRuleList[i].trim().split(/\\s* \\s*/);\r\n\r\n            // ignore rules starting with '#'\r\n            if (tempRule[0][0] == INLINE_COMMENT_SYMBOL) {\r\n                continue;\r\n            }\r\n\r\n            if (isLexerBlock) {\r\n                if ((tempRule.length === 3 || (tempRule.length === 4 && tempRule[3] === \"\")) &&\r\n                    ((tempRule[2][0] === \"\\\"\" || tempRule[2][0] === \"'\") && tempRule[2].length > 3)) {\r\n\r\n                    //TERMINALS\r\n                    if (tempRule[2][0] !== tempRule[2][tempRule[2].length - 1]) {\r\n                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {\r\n                            unexpectedSymbol: tempRule[2][tempRule[2].length - 1],\r\n                            expectedSymbol: tempRule[2][0],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n\r\n                    tempRule[2] = tempRule[2].slice(1, tempRule[2].length - 1);\r\n\r\n                    var ch: string = tempRule[2][0];\r\n\r\n\r\n                    if ((ch === \"_\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                        name = this.lexerEngine.addKeyword(tempRule[2], tempRule[0]);\r\n                    }\r\n                    else {\r\n                        name = this.lexerEngine.addPunctuator(tempRule[2], tempRule[0]);\r\n                    }\r\n\r\n                    this._grammarSymbols.set(name, tempRule[2]);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            // looking for '--LEXER--' keyword\r\n            if (tempRule[0] === LEXER_RULES) {\r\n                isLexerBlock = true;\r\n                continue;\r\n            }\r\n\r\n            //NON TERMNINAL RULES\r\n            if (!isDef(this._productions[tempRule[0]])) {\r\n                this._productions[tempRule[0]] = <IRuleMap>{};\r\n            }\r\n\r\n            rule = {\r\n                left: tempRule[0],\r\n                right: <string[]>[],\r\n                index: 0\r\n            };\r\n\r\n            this._grammarSymbols.set(tempRule[0], tempRule[0]);\r\n\r\n            if (forceAppendAllMode) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Default;\r\n            } else if (allowExposeMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Default;\r\n            } else if (allowAddMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Expose;\r\n            } else if (allowSkipMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Skip;\r\n            }\r\n\r\n            for (j = 2; j < tempRule.length; j++) {\r\n                if (tempRule[j] === \"\") {\r\n                    continue;\r\n                }\r\n                // handle flag '--add'\r\n                if (tempRule[j] === FLAG_RULE_CREATE_NODE) {\r\n                    if (allowAddMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Necessary;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (tempRule[j] === FLAG_RULE_SKIP_NODE) {\r\n                    if (allowSkipMode && !forceAppendAllMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Skip;\r\n                    }\r\n                    continue;\r\n                }\r\n                // handle flag '--expose'\r\n                if (tempRule[j] === FLAG_RULE_EXPOSE_NODE) {\r\n                    if (allowExposeMode && !forceAppendAllMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Expose;\r\n                    }\r\n                    continue;\r\n                }\r\n                // looking for additional user functions like '--F includeCode'\r\n                if (tempRule[j] === FLAG_RULE_FUNCTION) {\r\n                    if ((!tempRule[j + 1] || tempRule[j + 1].length === 0)) {\r\n                        this.grammarError(EParserErrors.GrammarInvalidAdditionalFuncName, { grammarLine: i });\r\n                    }\r\n\r\n                    const funcInfo = <IAdditionalFuncInfo>{\r\n                        name: tempRule[j + 1],\r\n                        position: rule.right.length,\r\n                        rule: rule\r\n                    };\r\n                    this._additionalFuncInfoList.push(funcInfo);\r\n                    j++;\r\n                    continue;\r\n                }\r\n                // handle string literlas\r\n                if (tempRule[j][0] === \"'\" || tempRule[j][0] === \"\\\"\") {\r\n                    if (tempRule[j].length !== 3) {\r\n                        this.grammarError(EParserErrors.GrammarInvalidKeyword, {\r\n                            badKeyword: tempRule[j],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n                    if (tempRule[j][0] !== tempRule[j][2]) {\r\n                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {\r\n                            unexpectedSymbol: tempRule[j][2],\r\n                            expectedSymbol: tempRule[j][0],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n\r\n                    name = this.lexerEngine.addPunctuator(tempRule[j][1]);\r\n                    rule.right.push(name);\r\n                    this._grammarSymbols.set(name, tempRule[j][1]);\r\n                }\r\n                else {\r\n                    rule.right.push(tempRule[j]);\r\n                    this._grammarSymbols.set(tempRule[j], tempRule[j]);\r\n                }\r\n            }\r\n\r\n            rule.index = nRules;\r\n            this._productions[tempRule[0]][rule.index] = rule;\r\n            nRules++;\r\n\r\n            // TODO: emit diagnostics error instead.\r\n            assert(nRules != 1 || isDef(this._productions[START_SYMBOL][0]));\r\n        }\r\n    }\r\n\r\n\r\n    private generateFunctionByStateMap(): void {\r\n        const stateList = this._states;\r\n        const funcInfoList = this._additionalFuncInfoList;\r\n        const funcByStateDMap = this._adidtionalFunctByStateDMap = <IRuleFunctionDMap>{};\r\n\r\n        for (let i = 0; i < funcInfoList.length; i++) {\r\n            const funcInfo = funcInfoList[i];\r\n            const rule = funcInfo.rule;\r\n            const pos = funcInfo.position;\r\n            const grammarSymbol = rule.right[pos - 1];\r\n\r\n            for (let j = 0; j < stateList.length; j++) {\r\n                if (stateList[j].hasRule(rule, pos)) {\r\n                    funcByStateDMap[stateList[j].index] = funcByStateDMap[stateList[j].index] || {};\r\n                    funcByStateDMap[stateList[j].index][grammarSymbol] = funcInfo.name;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private generateFirstState_LR0(): void {\r\n        const state = new State();\r\n        // START_SYMBOL should be always defined at the beginning of grammar\r\n        const firstRule = this._productions[START_SYMBOL][0];\r\n        const item = new Item(firstRule, 0);\r\n\r\n        this.pushBaseItem(item);\r\n        state.push(item);\r\n\r\n        this.closure_LR0(state);\r\n        this.pushState(state);\r\n    }\r\n\r\n\r\n    private generateFirstState_LR(): void {\r\n        const state = new State();\r\n        const firstRule = this._productions[START_SYMBOL][0];\r\n\r\n        state.push(new Item(firstRule, 0, [END_SYMBOL]));\r\n\r\n        this.closure_LR(state);\r\n        this.pushState(state);\r\n    }\r\n\r\n\r\n    private closure(state: State, type: EParserType) {\r\n        if (type === EParserType.k_LR0) {\r\n            this.closure_LR0(state);\r\n        } else {\r\n            this.closure_LR(state);\r\n        }\r\n    }\r\n\r\n\r\n    private closure_LR0(state: State) {\r\n        // NOTE: loop grows implicitly inside state.tryPush() function.\r\n        //       do not change this loop.\r\n        state.eachItem(item => {\r\n            const symbol = item.symbolName();\r\n            if (symbol !== END_POSITION && !this.isTerminal(symbol)) {\r\n                this.rules(symbol).forEach(rule => state.tryPush_LR0(rule, 0));\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    private closure_LR(state: State) {\r\n        let isNewExpected: boolean;\r\n        do {\r\n            isNewExpected = false;\r\n            state.eachItem(item => {\r\n                const symbol = item.symbolName();\r\n                if (symbol !== END_POSITION && !this.isTerminal(symbol)) {\r\n                    const nextSymbols = item.rule.right.slice(item.pos + 1);\r\n                    const expectedTerminals = this.firstTerminalsForSet(nextSymbols, item.expectedSymbols);\r\n\r\n                    this.rules(symbol).forEach(rule => {\r\n                        expectedTerminals.forEach(expectedTerminal => {\r\n                            if (state.tryPush_LR(rule, 0, expectedTerminal)) {\r\n                                isNewExpected = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n        } while (isNewExpected);\r\n    }\r\n\r\n\r\n    private static nextState_LR0(state: State, symbol: string): State {\r\n        const nextState = new State();\r\n\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === symbol) {\r\n                nextState.push(new Item(item.rule, item.pos + 1));\r\n            }\r\n        });\r\n\r\n        return nextState;\r\n    }\r\n\r\n\r\n    private static nextState_LR(state: State, symbol: string): State {\r\n        const nextState = new State();\r\n\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === symbol) {\r\n                const expectedSymbols = Array.from(item.expectedSymbols);\r\n                nextState.push(new Item(item.rule, item.pos + 1, expectedSymbols));\r\n            }\r\n        });\r\n\r\n        return nextState;\r\n    }\r\n\r\n\r\n    private deleteNotBaseItems(): void {\r\n        this._states.forEach(state => state.deleteNotBase());\r\n    }\r\n\r\n\r\n    private closureForItem({ rule, pos }: Item): State {\r\n        const indexVal = rule.index + \"_\" + pos;\r\n\r\n        let state = this._closureForItemsCache[indexVal];\r\n        if (isDef(state)) {\r\n            return state;\r\n        }\r\n\r\n        state = new State();\r\n        state.push(new Item(rule, pos, [UNUSED_SYMBOL]));\r\n\r\n        this.closure_LR(state);\r\n        this._closureForItemsCache[indexVal] = state;\r\n\r\n        return state;\r\n    }\r\n\r\n\r\n    private addLinkExpected(item: Item, itemX: Item): void {\r\n        let table = this._expectedExtensionDMap;\r\n        let index = item.index;\r\n\r\n        table[index] = table[index] || {};\r\n        table[index][itemX.index] = true;\r\n    }\r\n\r\n\r\n    private determineExpected(testState: State, symbol: string): void {\r\n        const stateNext = testState.nextStates[symbol] || null;\r\n\r\n        if (isNull(stateNext)) {\r\n            return;\r\n        }\r\n\r\n        // at this moment all items already 'base' because of\r\n        // deleteNotBase() call before.\r\n        testState.eachBaseItem(baseItem => {\r\n            const state = this.closureForItem(baseItem);\r\n            stateNext.eachBaseItem(baseItemNext => {\r\n                const item = state.hasChildItem(baseItemNext);\r\n                if (item) {\r\n                    item.expectedSymbols.forEach(symbol => {\r\n                        if (symbol === UNUSED_SYMBOL) {\r\n                            this.addLinkExpected(baseItem, baseItemNext);\r\n                        } else {\r\n                            baseItemNext.addExpected(symbol);\r\n                        }\r\n                    })\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    private generateLinksExpected(): void {\r\n        const states = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        states.forEach(state =>\r\n            symbols.forEach(symbol =>\r\n                this.determineExpected(state, symbol)));\r\n    }\r\n\r\n\r\n    private expandExpected(): void {\r\n        const baseItems = this._baseItems;\r\n        const itemExpected = baseItems.map(item => true);\r\n        const table = this._expectedExtensionDMap;\r\n\r\n        baseItems[0].addExpected(END_SYMBOL);\r\n        itemExpected[0] = (true);\r\n\r\n        let isNewExpected: boolean;\r\n        do {\r\n            isNewExpected = false;\r\n            baseItems.forEach((baseItem) => {\r\n                if (itemExpected[baseItem.index] && isDefAndNotNull(table[baseItem.index])) {\r\n                    let indexesOfExpectedItems = Object.keys(table[baseItem.index]).map(idx => Number(idx));\r\n\r\n                    baseItem.expectedSymbols.forEach(expectedSymbol => {\r\n                        indexesOfExpectedItems.forEach(expectedIndex => {\r\n                            const baseItemExpected = baseItems[expectedIndex];\r\n                            if (baseItemExpected.addExpected(expectedSymbol)) {\r\n                                itemExpected[expectedIndex] = true;\r\n                                isNewExpected = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n                itemExpected[baseItem.index] = false;\r\n            });\r\n        } while (isNewExpected);\r\n    }\r\n\r\n\r\n    private generateStates(type: EParserType): void {\r\n        if (type === EParserType.k_LR0) {\r\n            this.generateStates_LR0();\r\n        }\r\n        else if (type === EParserType.k_LR1) {\r\n            this.generateStates_LR();\r\n        }\r\n        else if (type === EParserType.k_LALR) {\r\n            this.generateStates_LALR();\r\n        }\r\n    }\r\n\r\n\r\n    private generateStates_LR0(): void {\r\n        this.generateFirstState_LR0();\r\n\r\n        const stateList = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        // NOTE: do not change this loop!\r\n        for (let i = 0; i < stateList.length; i++) {\r\n            const state = stateList[i];\r\n            for (let j = 0; j < symbols.length; j++) {\r\n                const symbol = symbols[j];\r\n                let stateNext = AbstractParser.nextState_LR0(state, symbol);\r\n\r\n                if (!stateNext.isEmpty()) {\r\n                    stateNext = this.tryAddState(stateNext, EParserType.k_LR0);\r\n                    this.addStateLink(state, stateNext, symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private generateStates_LR(): void {\r\n        this._firstTerminalsCache = {};\r\n        this.generateFirstState_LR();\r\n\r\n        const stateList = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        // NOTE: do not change this loop!\r\n        for (let i = 0; i < stateList.length; i++) {\r\n            const state = stateList[i];\r\n            for (let j = 0; j < symbols.length; j++) {\r\n                let symbol = symbols[j];\r\n                let stateNext = AbstractParser.nextState_LR(state, symbol);\r\n\r\n                if (!stateNext.isEmpty()) {\r\n                    stateNext = this.tryAddState(stateNext, EParserType.k_LR1);\r\n                    this.addStateLink(state, stateNext, symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private generateStates_LALR(): void {\r\n        this._baseItems = [];\r\n        this._expectedExtensionDMap = {};\r\n        this._closureForItemsCache = {};\r\n        this._firstTerminalsCache = {};\r\n\r\n        this.generateStates_LR0();\r\n        this.deleteNotBaseItems();\r\n        this.generateLinksExpected();\r\n        this.expandExpected();\r\n\r\n        this._states.forEach(state => this.closure_LR(state));\r\n    }\r\n\r\n\r\n    private addReducing(syntaxTable: ISyntaxTable, state: State, reduceOperationsMap: IOperationMap): void {\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === END_POSITION) {\r\n                if (item.rule.left === START_SYMBOL) {\r\n                    this.pushInSyntaxTable(syntaxTable, state.index, END_SYMBOL, { type: EOperationType.k_Success });\r\n                } else {\r\n                    for (const expectedSymbol of item.expectedSymbols) {\r\n                        this.pushInSyntaxTable(syntaxTable, state.index, expectedSymbol, reduceOperationsMap[item.rule.index]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    private addShift(syntaxTable: ISyntaxTable, state: State, shiftOperationsMap: IOperationMap) {\r\n        const nextStates = state.nextStates;\r\n        const nextSymbols = Object.keys(nextStates);\r\n        for (let i = 0; i < nextSymbols.length; i++) {\r\n            const nextState = nextStates[nextSymbols[i]];\r\n            this.pushInSyntaxTable(syntaxTable, state.index, nextSymbols[i], shiftOperationsMap[nextState.index]);\r\n        }\r\n    }\r\n\r\n    private buildSyntaxTable(type: EParserType): void {\r\n        this._states = [];\r\n        this._syntaxTable = {};\r\n\r\n        const stateList = this._states;\r\n        const syntaxTable = this._syntaxTable;\r\n\r\n        this.generateStates(type);\r\n\r\n        const reduceOperationsMap: IOperationMap = {};\r\n        const shiftOperationsMap: IOperationMap = {};\r\n\r\n        stateList.forEach(state => {\r\n            shiftOperationsMap[state.index] = <IOperation>{\r\n                type: EOperationType.k_Shift,\r\n                stateIndex: state.index\r\n            };\r\n        })\r\n\r\n        const nonTerminals = this.nonTerminals();\r\n        nonTerminals.forEach(nonTerminal => {\r\n            this.rules(nonTerminal).forEach(rule => {\r\n                reduceOperationsMap[rule.index] = {\r\n                    type: EOperationType.k_Reduce,\r\n                    rule: rule\r\n                };\r\n            });\r\n        });\r\n\r\n        //Build syntax table\r\n        stateList.forEach(state => {\r\n            this.addReducing(syntaxTable, state, reduceOperationsMap);\r\n            this.addShift(syntaxTable, state, shiftOperationsMap);\r\n        });\r\n    }\r\n\r\n\r\n    private statesToString(isBaseOnly: boolean = true): string {\r\n        if (!this._states) {\r\n            return \"\";\r\n        }\r\n\r\n        let msg = \"\";\r\n        for (let i = 0; i < this._states.length; i++) {\r\n            msg += this._states[i].toString(isBaseOnly, this._grammarSymbols);\r\n            msg += \" \";\r\n        }\r\n\r\n        return msg;\r\n    }\r\n\r\n\r\n    private static operationToString(operation: IOperation): string {\r\n        let opVal: string = \"\";\r\n\r\n        switch (operation.type) {\r\n            case EOperationType.k_Shift:\r\n                opVal = \"SHIFT to state \" + operation.stateIndex.toString();\r\n                break;\r\n            case EOperationType.k_Reduce:\r\n                opVal = \"REDUCE by rule { \" + AbstractParser.ruleToString(operation.rule) + \" }\";\r\n                break;\r\n            case EOperationType.k_Success:\r\n                opVal = \"SUCCESS\";\r\n                break;\r\n        }\r\n\r\n        return opVal;\r\n    }\r\n\r\n\r\n    private static ruleToString(rule: IRule): string {\r\n        let ruleVal: string;\r\n\r\n        ruleVal = rule.left + \" : \" + rule.right.join(\" \");\r\n\r\n        return ruleVal;\r\n    }\r\n\r\n\r\n    private convertGrammarSymbol(symbol: string): string {\r\n        if (!this.isTerminal(symbol)) {\r\n            return symbol;\r\n        }\r\n        return this.lexerEngine.getTerminalValueByName(symbol);\r\n    }\r\n\r\n\r\n\r\n    private static $parserEngine: IParser = null;\r\n    private static $parserParams: IParserParams = null;\r\n\r\n    // /**\r\n    //  * Create a singleton instance of parser for internal use.\r\n    //  */\r\n    // static init(\r\n    //     parserParams: IParserParams, \r\n    //     ParserEngineConstructor: new (grammar, flags, type) => IParserEngine = null\r\n    //     ): IParserEngine {\r\n    //     const { grammar, flags, type } = parserParams;\r\n\r\n    //     if (!grammar) {\r\n    //         return ParserEngine.$parserEngine;\r\n    //     }\r\n\r\n    //     if (deepEqual(parserParams, ParserEngine.$parserParams)) {\r\n    //         return ParserEngine.$parserEngine;\r\n    //     }\r\n\r\n    //     if (isNull(ParserEngineConstructor)) {\r\n    //         ParserEngineConstructor = ParserEngine;\r\n    //     }\r\n\r\n    //     console.time();\r\n    //     console.log('%c Creating parser engine....', 'background: #222; color: #bada55');\r\n    //     ParserEngine.$parserParams = parserParams;\r\n\r\n    //     try {\r\n    //         ParserEngine.$parserEngine = new ParserEngineConstructor(grammar, flags, type);\r\n    //         console.log('%c [ DONE ]', 'background: #222; color: #bada55');\r\n    //     } catch (e) {\r\n    //         ParserEngine.$parserEngine = null;\r\n    //         console.error('%c [ FAILED ]', 'background: #ffdcd6; color: #ff0000');\r\n\r\n    //         if (e instanceof DiagnosticException) {\r\n    //             verbose(e.stack);\r\n    //         }\r\n    //         throw e;\r\n    //     }\r\n\r\n    //     console.timeEnd();\r\n\r\n    //     return ParserEngine.$parserEngine;\r\n    // }\r\n\r\n\r\n    // static async parse(source: string, uri = \"stdin\", flags = EParsingFlags.k_Optimize) {\r\n\r\n    //     const engine = ParserEngine.$parserEngine;\r\n\r\n    //     const timeLabel = `parse ${uri}`;\r\n    //     console.time(timeLabel);\r\n    //     // All diagnostic exceptions should be already handled inside parser.\r\n    //     const parser = new ParserEngine.$parserEngine.parse(source, filename, flags)\r\n    //     let result = await ;\r\n    //     console.timeEnd(timeLabel);\r\n\r\n    //     let diag = ParserEngine.$parserEngine.getDiagnostics();\r\n    //     let ast = ParserEngine.$parserEngine.getSyntaxTree();\r\n\r\n    //     return { result, diag, ast };\r\n    // }\r\n}\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { ILexer, ILexerConfig, IToken } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { END_SYMBOL } from \"@lib/parser/symbols\";\r\n\r\nexport class CachingLexer implements ILexer {\r\n    private tokens: IToken[];\r\n    private pos: number;\r\n\r\n    constructor(tokens: IToken[]) {\r\n        this.tokens = tokens || [];\r\n        this.pos = 0;\r\n    }\r\n\r\n    /**\r\n     * Dummy api\r\n     */\r\n    get document(): ITextDocument { assert(false); return null; }\r\n    get config(): ILexerConfig { assert(false); return null; }\r\n    \r\n    setTextDocument(textDocument: ITextDocument): ILexer { assert(false); return this; }\r\n    getNextLine(): IToken { assert(false); return null; }\r\n    /** end */\r\n\r\n    getPosition(): number {\r\n        return this.pos;\r\n    }\r\n\r\n    setPosition(pos: number): void {\r\n        this.pos = pos;\r\n    }\r\n\r\n    getDiagnosticReport(): IDiagnosticReport {\r\n        assert(false);\r\n        return null;\r\n    }\r\n\r\n    getNextToken(): IToken {\r\n        return this.tokens[this.pos++] || CachingLexer.END_TOKEN;\r\n    }\r\n\r\n    private static END_TOKEN = {\r\n        index: -1,\r\n        name: END_SYMBOL,\r\n        value: END_SYMBOL,\r\n        loc: null\r\n    };\r\n}\r\n\r\n","import { EParserType, ExpectedSymbols, IRule } from \"@lib/idl/parser/IParser\";\r\nimport { END_POSITION } from \"@lib/parser/symbols\";\r\n\r\n\r\nexport class Item {\r\n    rule: IRule;\r\n    /**\r\n     * Position in item. \r\n     * left: right0,   right1, ...., rightN;\r\n     *               ^\r\n     *               position\r\n     */\r\n    pos: number;\r\n    /**\r\n     * Index in parser.\r\n     * (Uniq ID)\r\n     */\r\n    index: number;\r\n\r\n    expectedSymbols: ExpectedSymbols;\r\n\r\n    constructor(rule: IRule, pos: number, expectedSymbols?: string[]) {\r\n        this.rule = rule;\r\n        this.pos = pos;\r\n        this.index = 0;\r\n        this.expectedSymbols = new Set<string>();\r\n\r\n        if (expectedSymbols) {\r\n            expectedSymbols.forEach(symbol => this.addExpected(symbol));\r\n        }\r\n    }\r\n\r\n    isEqual(item: Item, type: EParserType = EParserType.k_LR0): boolean {\r\n        if (type === EParserType.k_LR0) {\r\n            return (this.rule === item.rule && this.pos === item.pos);\r\n        } \r\n        \r\n        if (type === EParserType.k_LR1) {\r\n            if (!(this.rule === item.rule && this.pos === item.pos && this.expectedSymbols.size === item.expectedSymbols.size)) {\r\n                return false;\r\n            }\r\n\r\n            for (const symbol of this.expectedSymbols) {\r\n                if (!item.isExpected(symbol)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } \r\n\r\n        //We never must be here, for LALR(1) we work with LR0 items. This 'else'-stmt only for closure-compliler.\r\n        return false;\r\n    }\r\n\r\n    isParentItem(item: Item): boolean {\r\n        return (this.rule === item.rule && this.pos === item.pos + 1);\r\n    }\r\n\r\n    isChildItem(item: Item): boolean {\r\n        return (this.rule === item.rule && this.pos === item.pos - 1);\r\n    }\r\n\r\n    symbolName(): string {\r\n        const right = this.rule.right;\r\n        if (this.pos === right.length) {\r\n            return END_POSITION;\r\n        }\r\n        return right[this.pos];\r\n    }\r\n\r\n    // lastSymbolName(): string {\r\n    //     return this.rule.right[this.rule.right.length - 1] || T_EMPTY;\r\n    // }\r\n\r\n    // // get next symbol name\r\n    // nextSymbolName(): string {\r\n    //     return this.rule.right[this.pos + 1] || END_POSITION;\r\n    // }\r\n\r\n    isExpected(symbol: string): boolean {\r\n        return this.expectedSymbols.has(symbol);\r\n    }\r\n\r\n    addExpected(symbol: string): boolean {\r\n        if (this.isExpected(symbol)) {\r\n            return false;\r\n        }\r\n        this.expectedSymbols.add(symbol);\r\n        return true;\r\n    }\r\n\r\n    toString(grammarSymbols: Map<string, string> = null): string {\r\n        const { left, right } = this.rule;\r\n\r\n        let msg = `${left} -> `;\r\n\r\n        msg += right\r\n            .map(s => Item.decodeSymbol(s, grammarSymbols))\r\n            .map((s, k) => (k === this.pos ? `. ${s}` : `${s}`))\r\n            .join(' ');\r\n\r\n        if (this.pos === right.length) {\r\n            msg += \" . \";\r\n        }\r\n\r\n        if (this.expectedSymbols) {\r\n            const expectedTokens = Array.from(this.expectedSymbols).map(k => Item.decodeSymbol(k, grammarSymbols));\r\n\r\n            if (expectedTokens.length) {\r\n                msg += \", \" + expectedTokens.join(' ');\r\n            }\r\n        }\r\n\r\n        return msg;\r\n    }\r\n\r\n\r\n    static decodeSymbol(s: string, grammarSymbols: Map<string, string>) {\r\n        return (grammarSymbols ? ((grammarSymbols.get(s) && s !== grammarSymbols.get(s)) ? `'${grammarSymbols.get(s)}'` : s) : s);\r\n    }\r\n}\r\n","import { assert } from '@lib/common';\r\nimport { EDiagnosticCategory, IDiagnosticReport } from '@lib/idl/IDiagnostics';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { ETokenType, ILexer, ILexerConfig, ILexerEngine, IPosition, IRange, IToken } from '@lib/idl/parser/IParser';\r\nimport { END_SYMBOL, EOF, T_FLOAT, T_LINE_TERMINATOR, T_MACRO, T_MACRO_CONCAT, T_NON_TYPE_ID, T_STRING, T_TYPE_ID, T_UINT, UNKNOWN_TOKEN } from '@lib/parser/symbols';\r\nimport * as util from '@lib/parser/util';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\n\r\n\r\ninterface ILexerDiagDesc {\r\n    file: string;\r\n    token: IToken;\r\n}\r\n\r\n\r\nenum ELexerErrors {\r\n    UnknownToken = 2101,\r\n    InvalidToken = 2102\r\n};\r\n\r\n\r\nclass LexerDiagnostics extends Diagnostics<ILexerDiagDesc> {\r\n    constructor() {\r\n        super(\"Lexer Diagnostics\", 'L');\r\n    }\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: ILexerDiagDesc): string {\r\n        return desc.file;\r\n    }\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: ILexerDiagDesc): IRange {\r\n        return desc.token.loc;\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [ELexerErrors.UnknownToken]: \"Unknown token: {token.value}.\",\r\n            [ELexerErrors.InvalidToken]: \"Invalid token: {token.value}.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport class LexerEngine implements ILexerEngine {\r\n    readonly keywords: IMap<string> = {};\r\n    readonly punctuators: IMap<string> = {};\r\n    readonly punctuatorsFirstSymbols: IMap<boolean> = {};\r\n\r\n\r\n    addPunctuator(value: string, name: string = LexerEngine.getPunctuatorName(value)): string {\r\n        this.punctuators[value] = name;\r\n        this.punctuatorsFirstSymbols[value[0]] = true;\r\n        return name;\r\n    }\r\n\r\n\r\n    addKeyword(value: string, name: string): string {\r\n        this.keywords[value] = name;\r\n        return name;\r\n    }\r\n\r\n\r\n    getTerminalValueByName(name: string): string {\r\n        let value = \"\";\r\n\r\n        for (value in this.punctuators) {\r\n            if (this.punctuators[value] === name) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        for (value in this.keywords) {\r\n            if (this.keywords[value] === name) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n\r\n    isLineTerminator(symbol: string): boolean {\r\n        return (symbol === \"\\n\" || symbol === \"\\r\" || symbol === \"\\u2028\" || symbol === \"\\u2029\");\r\n    }\r\n\r\n\r\n    isKeyword(value: string): boolean {\r\n        return !!(this.keywords[value]);\r\n    }\r\n\r\n\r\n    isPunctuator(value: string): boolean {\r\n        return !!(this.punctuators[value]);\r\n    }\r\n\r\n\r\n    isNumberStart(ch: string, ch1: string): boolean {\r\n        if ((ch >= \"0\") && (ch <= \"9\")) {\r\n            return true;\r\n        }\r\n\r\n        if (ch === \".\" && (ch1 >= \"0\") && (ch1 <= \"9\")) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    isCommentStart(ch: string, ch1: string): boolean {\r\n        if (ch === \"/\" && (ch1 === \"/\" || ch1 === \"*\")) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    isStringStart(ch: string): boolean {\r\n        if (ch === \"\\\"\" || ch === \"'\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isPunctuatorStart(ch: string): boolean {\r\n        if (this.punctuatorsFirstSymbols[ch]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isWhiteSpaceStart(ch: string): boolean {\r\n        if (ch === \" \" || ch === \"\\t\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isNewlineStart(ch: string): boolean {\r\n        if (ch === \"\\n\" || ch === \"\\r\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isEscapeSequenceStart(ch: string): boolean {\r\n        return ch === '\\\\';\r\n    }\r\n\r\n\r\n    isIdentifierStart(ch: string): boolean {\r\n        if ((ch === \"_\") || (ch === \"$\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    static getPunctuatorName(value: string): string {\r\n        return \"T_PUNCTUATOR_\" + value.charCodeAt(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nexport class Lexer implements ILexer {\r\n    protected index: number;\r\n    protected lineNumber: number;\r\n    protected columnNumber: number;\r\n\r\n    //\r\n    // text document\r\n    //\r\n\r\n    /* readonly */ document: ITextDocument;\r\n\r\n    //\r\n    // Setup\r\n    //\r\n\r\n    readonly engine: LexerEngine;\r\n    readonly diagnostics: LexerDiagnostics;\r\n    readonly knownTypes: Set<string>;\r\n\r\n    //\r\n    // Config\r\n    //\r\n\r\n    readonly config: {\r\n        skipComments: boolean;\r\n        allowLineTerminators: boolean;\r\n    };\r\n\r\n    constructor({ \r\n        engine = new LexerEngine,\r\n        knownTypes = new Set(),\r\n        skipComments = true,\r\n        allowLineTerminators = false,\r\n    }: ILexerConfig = {}) {\r\n        this.diagnostics = new LexerDiagnostics;\r\n        this.knownTypes = knownTypes;\r\n        this.engine = engine;\r\n        this.config = { skipComments, allowLineTerminators };\r\n    }\r\n\r\n\r\n    getPosition(): IPosition {\r\n        return this.pos();\r\n    }\r\n\r\n\r\n    setPosition(pos: IPosition): void {\r\n        assert(this.document.uri === pos.file);\r\n        this.index = pos.offset;\r\n        this.lineNumber = pos.line;\r\n        this.columnNumber = pos.column;\r\n    }\r\n\r\n    \r\n    setTextDocument(textDocument: ITextDocument): ILexer {\r\n        this.columnNumber = 0;\r\n        this.lineNumber = 0;\r\n        this.index = 0;\r\n        this.document = textDocument;\r\n        return this;\r\n    }\r\n\r\n\r\n    getDiagnosticReport(): IDiagnosticReport {\r\n        return this.diagnostics.resolve();\r\n    }\r\n\r\n    \r\n    getNextToken(): IToken {\r\n        const token = this.scanToken();\r\n        util.offset(token.loc, this.document.offset);\r\n        return token;\r\n    }\r\n\r\n\r\n    getNextLine(): IToken {\r\n        const token = this.scanThisLine();\r\n        util.offset(token.loc, this.document.offset);\r\n        return token;\r\n    }\r\n\r\n\r\n    protected scanToken(): IToken {\r\n        const ch = this.currentChar();\r\n        if (!ch) {\r\n            const pos = this.pos();\r\n            return <IToken>{\r\n                index: this.index,\r\n                name: END_SYMBOL,\r\n                value: END_SYMBOL,\r\n                loc: {\r\n                    start: pos,\r\n                    end: { ...pos }\r\n                }\r\n            };\r\n        }\r\n\r\n        switch (this.identityTokenType()) {\r\n            case ETokenType.k_NumericLiteral:\r\n                return this.scanNumber();\r\n            case ETokenType.k_SinglelineCommentLiteral:\r\n            case ETokenType.k_MultilineCommentLiteral:\r\n                if (this.config.skipComments) {\r\n                    this.scanComment();\r\n                    return this.scanToken();\r\n                }\r\n                return this.scanComment();\r\n            case ETokenType.k_StringLiteral:\r\n                return this.scanString();\r\n            case ETokenType.k_PunctuatorLiteral:\r\n                return this.scanPunctuator();\r\n            case ETokenType.k_IdentifierLiteral:\r\n                return this.scanIdentifier();\r\n            case ETokenType.k_EscapeSequence:\r\n                return this.scanEscapeSequence();\r\n            case ETokenType.k_NewlineLiteral:\r\n                if (!this.config.allowLineTerminators) {\r\n                    this.scanLineTerminators();\r\n                    return this.scanToken();\r\n                }\r\n                return this.scanLineTerminators();\r\n            case ETokenType.k_WhitespaceLiteral:\r\n                this.scanWhiteSpace();\r\n                return this.scanToken();\r\n            case ETokenType.K_MacroLiteral:\r\n                return this.scanMacro();\r\n            default:\r\n                return this.scanInvalid();\r\n        }\r\n    }\r\n\r\n\r\n    protected scanThisLine(): IToken {\r\n        let start = this.pos();\r\n        let value = '';\r\n        let ch = this.currentChar();\r\n        while (ch) {\r\n            if (ch === '\\\\') {\r\n                let chNext = this.readNextChar();\r\n                if (chNext === '\\r') {\r\n                    chNext = this.readNextChar();\r\n                }\r\n                switch (chNext) {\r\n                    case '\\n':\r\n                        ch = this.readNextChar();\r\n                        this.lineNumber++;\r\n                        this.columnNumber = 0;\r\n                        value += '\\\\\\n'; \r\n                        continue;\r\n                    case 'n':\r\n                        ch = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        ch = '\\t';\r\n                        break;\r\n                    default:\r\n                        assert(false, 'unsupported character sequence found');\r\n                }\r\n            } else if (ch === '\\n') {\r\n                break;\r\n            }\r\n\r\n            value += ch;\r\n            ch = this.readNextChar();\r\n        }\r\n\r\n        return {\r\n            index: this.index,\r\n            name: UNKNOWN_TOKEN,\r\n            value,\r\n            loc: { start, end: this.pos() }\r\n        };\r\n    }\r\n\r\n\r\n    protected pos(n: number = 0): IPosition {\r\n        return {\r\n            file: this.document.uri,\r\n            line: this.lineNumber,\r\n            column: this.columnNumber + n,\r\n            offset: this.index + n\r\n        };\r\n    }\r\n\r\n\r\n    protected emitError(code: number, token: IToken): void {\r\n        this.diagnostics.error(code, { file: `${this.document.uri}`, token });\r\n    }\r\n\r\n\r\n    protected identityTokenType(): ETokenType {\r\n        if (this.isIdentifierStart()) {\r\n            return ETokenType.k_IdentifierLiteral;\r\n        }\r\n        if (this.isWhiteSpaceStart()) {\r\n            return ETokenType.k_WhitespaceLiteral;\r\n        }\r\n        if (this.isNewlineStart()) {\r\n            return ETokenType.k_NewlineLiteral;\r\n        }\r\n        if (this.isEscapeSequenceStart()) {\r\n            return ETokenType.k_EscapeSequence;\r\n        }\r\n        if (this.isStringStart()) {\r\n            return ETokenType.k_StringLiteral;\r\n        }\r\n        if (this.isCommentStart()) {\r\n            // TODO: return exact type (separate multiline/singleline comment parsings)\r\n            return ETokenType.k_SinglelineCommentLiteral;\r\n        }\r\n        if (this.isNumberStart()) {\r\n            return ETokenType.k_NumericLiteral;\r\n        }\r\n        if (this.isPunctuatorStart()) {\r\n            return ETokenType.k_PunctuatorLiteral;\r\n        }\r\n        if (this.isMacroStart()) {\r\n            return ETokenType.K_MacroLiteral;\r\n        }\r\n        return ETokenType.k_Unknown;\r\n    }\r\n\r\n\r\n    protected isNumberStart(): boolean {\r\n        return this.engine.isNumberStart(this.currentChar(), this.nextChar());\r\n    }\r\n\r\n\r\n    protected isCommentStart(): boolean {\r\n        return this.engine.isCommentStart(this.currentChar(), this.nextChar())\r\n    }\r\n\r\n\r\n    protected isStringStart(): boolean {\r\n        return this.engine.isStringStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected isPunctuatorStart(): boolean {\r\n        return this.engine.isPunctuatorStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected isWhiteSpaceStart(): boolean {\r\n        return this.engine.isWhiteSpaceStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected isNewlineStart(): boolean {\r\n        return this.engine.isNewlineStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected isEscapeSequenceStart(): boolean {\r\n        return this.engine.isEscapeSequenceStart(this.currentChar());\r\n    }\r\n\r\n    protected isMacroStart(): boolean {\r\n        return this.currentChar() === '#';\r\n    }\r\n\r\n    protected isIdentifierStart(): boolean {\r\n        return this.engine.isIdentifierStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected nextChar(): string {\r\n        return this.document.source[this.index + 1];\r\n    }\r\n\r\n\r\n    protected currentChar(): string {\r\n        return this.document.source[<number>this.index];\r\n    }\r\n\r\n\r\n    protected readNextChar(): string {\r\n        this.index++;\r\n        this.columnNumber++;\r\n        return this.document.source[<number>this.index];\r\n    }\r\n\r\n\r\n    protected scanEscapeSequence(): IToken {\r\n        let ch = this.readNextChar();\r\n        if (ch === '\\r') {\r\n            ch = this.readNextChar();\r\n        }\r\n        assert(ch === '\\n', 'unsupported escape sequence found');\r\n        this.lineNumber++;\r\n        this.columnNumber = 0;\r\n        this.readNextChar();\r\n        return this.scanToken();\r\n    }\r\n\r\n    protected scanString(): IToken {\r\n        let chFirst = this.currentChar();\r\n        let value = chFirst;\r\n        let ch = \"\";\r\n        let chPrevious = chFirst;\r\n        let isGoodFinish = false;\r\n        let start = this.pos();\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            value += ch;\r\n            if (ch === chFirst && chPrevious !== \"\\\\\") {\r\n                isGoodFinish = true;\r\n                this.readNextChar();\r\n                break;\r\n            }\r\n            chPrevious = ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            return <IToken>{\r\n                index: this.index,\r\n                name: T_STRING,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_StringLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    protected scanInvalid(): IToken {\r\n        const start = this.pos();\r\n        \r\n        let value = '';\r\n        while (this.identityTokenType() === ETokenType.k_Unknown && this.index < this.document.source.length) {\r\n            value += this.currentChar();\r\n            this.readNextChar();\r\n        }\r\n\r\n        const token = {\r\n            index: this.index,\r\n            name: UNKNOWN_TOKEN,\r\n            value,\r\n            loc: { start, end: this.pos() }\r\n        };\r\n\r\n        this.emitError(ELexerErrors.UnknownToken, token);\r\n        return token;\r\n    }\r\n\r\n\r\n    protected scanPunctuator(): IToken {\r\n        let value = this.currentChar();\r\n        let start = this.pos();\r\n        let ch: string;\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (ch) {\r\n                value += ch;\r\n                if (!this.engine.isPunctuator(value)) {\r\n                    value = value.slice(0, value.length - 1);\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return <IToken>{\r\n            index: this.index,\r\n            name: this.engine.punctuators[value],\r\n            value,\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    protected scanNumber(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = \"\";\r\n        let isFloat = false;\r\n        let isHex = false;\r\n        let isL = false;\r\n        let chPrevious = ch;\r\n        let isGoodFinish = false;\r\n        let isE = false; // exponential\r\n        let isU = false; // unsigned\r\n        let start = this.pos();\r\n\r\n        if (ch === \".\") {\r\n            value += 0;\r\n            isFloat = true;\r\n        }\r\n\r\n        value += ch;\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (ch === \".\") {\r\n                if (isFloat || isU || isL || isHex) {\r\n                    break;\r\n                }\r\n                isFloat = true;\r\n            }\r\n            else if (ch === \"e\") {\r\n                if (isE || isU || isL) { // \"0x100e2\" is valid\r\n                    break;\r\n                }\r\n                isE = true;\r\n            }\r\n            else if (ch === \"u\" || ch === \"U\") {\r\n                if (isFloat || isU) { // \"0x02u\" or \"0x100e2u\" are valid\r\n                    break;\r\n                }\r\n                isU = true;\r\n            }\r\n            else if (ch === \"l\" || ch === \"L\") {\r\n                if (isFloat || isL) { \r\n                    break;\r\n                }\r\n                isL = true;\r\n            }\r\n            else if (ch === \"x\") {\r\n                if (isU || isL || isE || isFloat) {\r\n                    break;\r\n                }\r\n                isHex = true;\r\n            }\r\n            else if (((ch === \"+\" || ch === \"-\") && chPrevious === \"e\")) {\r\n                // nothing todo, valid case\r\n            }\r\n            else if (ch === \"f\" && (isFloat || isE)) {\r\n                isFloat = true;\r\n                ch = this.readNextChar();\r\n                // redundant check?\r\n                if ((ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                    break;\r\n                }\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            // break on any unused alphabetic character\r\n            else if ((ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                if (!isHex) {\r\n                    break;\r\n                }\r\n            }\r\n            // Handle the case when a character is read not a number (end of numeric seq.)\r\n            else if (!((ch >= \"0\") && (ch <= \"9\")) || !ch || isU || isL) {\r\n                // check that the exponent completely read\r\n                if ((isE && chPrevious !== \"+\" && chPrevious !== \"-\" && chPrevious !== \"e\") || !isE) {\r\n                    isGoodFinish = true;\r\n                }\r\n                break;\r\n            }\r\n\r\n            value += ch;\r\n            chPrevious = ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            let name = isFloat ? T_FLOAT : T_UINT;\r\n            return <IToken>{\r\n                index: this.index,\r\n                name,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_NumericLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    protected scanMacro(): IToken {\r\n        // TODO: add option config.allowMacro \r\n\r\n        const start = this.pos();\r\n        const chNext = this.nextChar();\r\n\r\n        if ((chNext >= \"a\" && chNext <= \"z\") || (chNext >= \"A\" && chNext <= \"Z\")) {\r\n            this.readNextChar();\r\n            const id = this.scanIdentifier();\r\n            return {\r\n                index: this.index,\r\n                name: T_MACRO,\r\n                value: `#${id.value}`,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        } else if (chNext === '#') {\r\n            this.readNextChar();\r\n            this.readNextChar();\r\n            \r\n            return {\r\n                index: this.index,\r\n                name: T_MACRO_CONCAT,\r\n                value: '##',\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        } \r\n        \r\n        assert(false, `unsupported macro found: ${this.document.source.substr(this.index, 20)}...`);\r\n        this.readNextChar();\r\n        return {\r\n            index: this.index,\r\n            name: UNKNOWN_TOKEN,\r\n            value: '#',\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    protected scanIdentifier(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = ch;\r\n        let start = this.pos();\r\n        let isGoodFinish = false;\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (!ch) {\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            if (!((ch === \"_\") || (ch === \"$\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\") || (ch >= \"0\" && ch <= \"9\"))) {\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            value += ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            if (this.engine.isKeyword(value)) {\r\n                return <IToken>{\r\n                    index: this.index,\r\n                    name: this.engine.keywords[value],\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                let name = this.knownTypes.has(value) ? T_TYPE_ID : T_NON_TYPE_ID;\r\n                return <IToken>{\r\n                    index: this.index,\r\n                    name,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_IdentifierLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    protected scanLineTerminators(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = '';\r\n        let start = this.pos();\r\n\r\n        while (true) {\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            if (this.engine.isLineTerminator(ch)) {\r\n                value += ch;\r\n                if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                    this.lineNumber--;\r\n                }\r\n                this.lineNumber++;\r\n                ch = this.readNextChar();\r\n                this.columnNumber = 0;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n\r\n        let name = T_LINE_TERMINATOR;\r\n        return <IToken>{\r\n            index: this.index,\r\n            name,\r\n            value,\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    protected scanWhiteSpace(): boolean {\r\n        let ch = this.currentChar();\r\n\r\n        while (true) {\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            else if (ch === \"\\t\") {\r\n                // possible way to convert tab to multiple spaces\r\n                this.columnNumber += 0;\r\n            }\r\n            else if (ch !== \" \") {\r\n                break;\r\n            }\r\n            ch = this.readNextChar();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    protected scanComment(): IToken {\r\n        let value = this.currentChar();\r\n        let ch = this.readNextChar();\r\n        let start = this.pos();\r\n        value += ch;\r\n\r\n        if (ch === \"/\") {\r\n            //Line Comment\r\n            while (true) {\r\n                ch = this.readNextChar();\r\n                if (!ch) {\r\n                    break;\r\n                }\r\n                if (this.engine.isLineTerminator(ch)) {\r\n                    if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                        this.lineNumber--;\r\n                    }\r\n                    this.lineNumber++;\r\n                    this.readNextChar();\r\n                    this.columnNumber = 0;\r\n                    break;\r\n                }\r\n                value += ch;\r\n            }\r\n\r\n            return {\r\n                index: this.index,\r\n                type: ETokenType.k_SinglelineCommentLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            //Multiline Comment\r\n            let chPrevious = ch;\r\n            let isGoodFinish = false;\r\n            let start = this.pos();\r\n\r\n            while (true) {\r\n                ch = this.readNextChar();\r\n                if (!ch) {\r\n                    break;\r\n                }\r\n                value += ch;\r\n                if (ch === \"/\" && chPrevious === \"*\") {\r\n                    isGoodFinish = true;\r\n                    this.readNextChar();\r\n                    break;\r\n                }\r\n                if (this.engine.isLineTerminator(ch)) {\r\n                    if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                        this.lineNumber--;\r\n                    }\r\n                    this.lineNumber++;\r\n                    this.columnNumber = -1;\r\n                }\r\n                chPrevious = ch;\r\n            }\r\n\r\n            if (isGoodFinish) {\r\n                return {\r\n                    index: this.index,\r\n                    type: ETokenType.k_MultilineCommentLiteral,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                if (!ch) {\r\n                    ch = EOF;\r\n                }\r\n                value += ch;\r\n\r\n                const token = {\r\n                    index: this.index,\r\n                    type: ETokenType.k_MultilineCommentLiteral,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n\r\n                this.emitError(ELexerErrors.InvalidToken, token);\r\n                return Lexer.makeUnknownToken(token);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    static makeUnknownToken(token: IToken): IToken {\r\n        return {\r\n            ...token,\r\n            type: undefined,\r\n            name: UNKNOWN_TOKEN,\r\n            loc: {\r\n                start: { ...token.loc.start },\r\n                end: { ...token.loc.end }\r\n            }\r\n        };\r\n    }\r\n}\r\n","import { IMap } from \"@lib/idl/IMap\";\r\nimport { IMacro } from \"@lib/idl/parser/IMacro\";\r\n\r\nexport class Macros {\r\n    stack: { root: IMacro, macros: IMap<IMacro>; }[] = [{ root: null, macros: {} }];\r\n\r\n    get depth() {\r\n        return this.stack.length;\r\n    }\r\n\r\n    get root(): IMacro{\r\n        return this.stack[this.depth - 1].root;\r\n    }\r\n\r\n    push(source: IMacro) {\r\n        this.stack.push({ root: source, macros: {} });\r\n    }\r\n\r\n    pop() {\r\n        this.stack.pop();\r\n    }\r\n\r\n    set(macro: IMacro): void {\r\n        this.stack[this.depth - 1].macros[macro.name] = macro;\r\n    }\r\n\r\n    unset(name: string): void {\r\n        delete this.stack[this.depth - 1].macros[name];\r\n    }\r\n\r\n    get(name: string): IMacro {\r\n        let i = this.depth - 1;\r\n        while (true) {\r\n            const { macros, root } = this.stack[i];\r\n            \r\n            // avoidance of recursive substitution\r\n            if (root?.name === name && !root.bFunction) {\r\n                return null;\r\n            }\r\n\r\n            const macro = macros[name];\r\n            if (macro) {\r\n                return macro;\r\n            }\r\n\r\n            if (i == 0) break;\r\n            i = 0;\r\n        };\r\n        return null;\r\n    }\r\n\r\n    has(name: string): boolean {\r\n        return this.get(name) !== null;\r\n    }\r\n\r\n    forEach(cb: (value: IMacro) => void): void {\r\n        let overrides = new Set;\r\n        for (let i = this.depth - 1; i >= 0; --i) {\r\n            const macros = this.stack[i].macros;\r\n            for (const macro of Object.values(macros)) {\r\n                if (!overrides.has(macro.name)) {\r\n                    overrides.add(macro.name);\r\n                    cb(macro);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    *[Symbol.iterator]() {\r\n        let overrides = new Set;\r\n        for (let i = this.depth - 1; i >= 0; --i) {\r\n            const macros = this.stack[i].macros;\r\n            for (const macro of Object.values(macros)) {\r\n                if (!overrides.has(macro.name)) {\r\n                    overrides.add(macro.name);\r\n                    yield macro;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { assert } from \"@lib/common\";\r\nimport { ENodeCreateMode, IParseNode, IParseTree, IPosition, IRange, IRule, IToken } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { extendRange } from \"./util\";\r\n\r\nexport class ParseTree implements IParseTree {\r\n    root: IParseNode;\r\n    nodes: IParseNode[];\r\n    \r\n    readonly optimized: boolean;\r\n    \r\n    private nodesCountStack: number[];\r\n\r\n\r\n    constructor(optimized: boolean, root: IParseNode = null) {\r\n        this.root = root;\r\n        this.nodes = [];\r\n        this.optimized = optimized;\r\n\r\n        this.nodesCountStack = [];\r\n    }\r\n\r\n\r\n    get lastNode(): IParseNode {\r\n        return this.nodes[this.nodes.length - 1];\r\n    }\r\n\r\n\r\n    finishTree(): void {\r\n        this.root = this.nodes.pop() || null;\r\n    }\r\n\r\n\r\n    addToken({ name, value, loc }: IToken): void {\r\n        const children = null;\r\n        const parent = null;\r\n        this.addNode({ name, value, loc, children, parent });\r\n    }\r\n\r\n    reduceByRule(rule: IRule, eCreate: ENodeCreateMode = ENodeCreateMode.k_Default): void {\r\n        let iReduceCount = 0;\r\n        let nodesCountStack = this.nodesCountStack;\r\n        let ruleLength = rule.right.length;\r\n        let nodes = this.nodes;\r\n        let optimize = this.optimized ? 1 : 0;\r\n\r\n        while (ruleLength) {\r\n            iReduceCount += nodesCountStack.pop();\r\n            ruleLength--;\r\n        }\r\n\r\n        if ((eCreate === ENodeCreateMode.k_Skip && iReduceCount > optimize) || iReduceCount === 0) {\r\n            nodes.length -= iReduceCount;\r\n            nodesCountStack.push(0);\r\n        }  else if ((eCreate === ENodeCreateMode.k_Default && iReduceCount > optimize) || \r\n            (eCreate === ENodeCreateMode.k_Necessary)) {\r\n\r\n            assert(iReduceCount > 0);\r\n            \r\n            let temp = nodes.pop();\r\n            iReduceCount--;\r\n            \r\n            const name = rule.left;\r\n            // TODO: use correct location in case of include macro. \r\n            const loc = { ...temp.loc };\r\n\r\n            const node: IParseNode = { name, children: null, parent: null, value: '', loc };\r\n\r\n            this.addLink(node, temp);\r\n\r\n            while (iReduceCount) {\r\n                assert(nodes.length > 0);\r\n                this.addLink(node, nodes.pop());\r\n                iReduceCount--;\r\n            }\r\n            \r\n            nodes.push(node);\r\n            nodesCountStack.push(1);      \r\n        }\r\n        else {\r\n            nodesCountStack.push(iReduceCount);\r\n        }\r\n    }\r\n\r\n    private addNode(node: IParseNode): void {\r\n        this.nodes.push(node);\r\n        this.nodesCountStack.push(1);\r\n    }\r\n\r\n    $pop(loc: IRange = null): void {\r\n        let count = this.nodesCountStack.pop();\r\n        while (count) {\r\n            let node = this.nodes.pop();\r\n            if (loc) {\r\n                extendRange(loc, node.loc);\r\n            }\r\n            count--;\r\n        }\r\n    }\r\n \r\n    private addLink(parent: IParseNode, child: IParseNode): void {\r\n        parent.children = parent.children || [];\r\n        \r\n        extendRange(parent.loc, child.loc);\r\n        \r\n        parent.children.push(child);\r\n        child.parent = parent;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    clone(): IParseTree {\r\n        return new ParseTree(this.optimized, this.cloneNode(this.root));\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    // FIXME: location should be clonned too\r\n    private cloneNode({ name, value, children }: IParseNode): IParseNode {\r\n        const clone: IParseNode = { name, value, children: null, parent: null };\r\n        if (children) { \r\n            children.forEach(child => this.addLink(clone, this.cloneNode(child)))\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toString(): string {\r\n        if (this.root) {\r\n            return this.toStringNode(this.root);\r\n        }\r\n\r\n        return '';\r\n    }\r\n\r\n    /** @deprecated */\r\n    private toStringNode(node: IParseNode, padding: string = \"\"): string {\r\n        let res: string = padding + \"{\\n\";\r\n        let oldPadding: string = padding;\r\n        let defaultPadding: string = \"  \";\r\n\r\n        padding += defaultPadding;\r\n\r\n        if (node.value) {\r\n            res += padding + \"name : \\\"\" + node.name + \"\\\"\" + \",\\n\";\r\n            res += padding + \"value : \\\"\" + node.value + \"\\\"\" + \"\\n\";\r\n        }\r\n        else {\r\n            res += padding + \"name : \\\"\" + node.name + \"\\\"\" + \"\\n\";\r\n            res += padding + \"children : [\";\r\n\r\n            let children: IParseNode[] = node.children;\r\n\r\n            if (children) {\r\n                res += \"\\n\";\r\n                padding += defaultPadding;\r\n\r\n                for (let i = children.length - 1; i >= 0; i--) {\r\n                    res += this.toStringNode(children[i], padding);\r\n                    res += \",\\n\";\r\n                }\r\n\r\n                res = res.slice(0, res.length - 2);\r\n                res += \"\\n\";\r\n                res += oldPadding + defaultPadding + \"]\\n\";\r\n            }\r\n            else {\r\n                res += \" ]\\n\";\r\n            }\r\n        }\r\n        res += oldPadding + \"}\";\r\n        return res;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toHTMLString(node: IParseNode, padding: string = \"\") {\r\n        node = node || this.root;\r\n        let res = padding + \"{\\n\";\r\n        let oldPadding = padding;\r\n        let defaultPadding = \"  \";\r\n        padding += defaultPadding;\r\n        if (node.value) {\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">name</b>: \\\"\" + node.name + \"\\\"\" + \",\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">value</b>: \\\"\" + node.value + \"\\\"\" + \",\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">line</b>: \\\"\" + node.loc.start.line + \"\\\" - \\\"\" + node.loc.end.line + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">column</b>: \\\"\" + node.loc.start.column + \"\\\" - \\\"\" + node.loc.end.column + \"\\\"\" + \"\\n\";\r\n            // sRes += sPadding + \"<b style=\\\"color: #458383;\\\">position</b>: \\\"\" + pNode.position + \"\\\"\" + \"\\n\";\r\n        }\r\n        else {\r\n            let i;\r\n            res += padding + \"<i style=\\\"color: #8A2BE2;\\\">name</i>: \\\"\" + node.name + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">line</b>: \\\"\" + node.loc.start.line + \"\\\" - \\\"\" + node.loc.end.line + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">column</b>: \\\"\" + node.loc.start.column + \"\\\" - \\\"\" + node.loc.end.column + \"\\\"\" + \"\\n\";\r\n            // sRes += sPadding + \"<b style=\\\"color: #458383;\\\">position</b>: \\\"\" + pNode.position + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<i style=\\\"color: #8A2BE2;\\\">children</i>: [\";\r\n            if (node.children) {\r\n                res += \"\\n\";\r\n                padding += defaultPadding;\r\n                for (i = node.children.length - 1; i >= 0; i--) {\r\n                    res += this.toHTMLString(node.children[i], padding);\r\n                    res += \",\\n\";\r\n                }\r\n                res = res.slice(0, res.length - 2);\r\n                res += \"\\n\";\r\n                res += oldPadding + defaultPadding + \"]\\n\";\r\n            }\r\n            else {\r\n                res += \" ]\\n\";\r\n            }\r\n        }\r\n        res += oldPadding + \"}\";\r\n        return res;\r\n    }\r\n}\r\n","import { isDef, isDefAndNotNull } from \"@lib/common\";\r\nimport { assert, isNull, isString } from \"@lib/common\";\r\nimport { defaultSLParser } from \"@lib/fx/SLParser\";\r\nimport { createTextDocument } from \"@lib/fx/TextDocument\";\r\nimport { EDiagnosticCategory, IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IMacro } from \"@lib/idl/parser/IMacro\";\r\nimport { ETokenType, IFile, ILexer, ILexerConfig, ILexerEngine, IncludeResolver, IPosition, IRange, IToken } from \"@lib/idl/parser/IParser\";\r\nimport * as util from '@lib/parser/util';\r\nimport * as URI from \"@lib/uri/uri\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { CachingLexer } from \"@lib/parser/CachingLexer\";\r\nimport { Lexer } from \"@lib/parser/Lexer\";\r\nimport { Macros } from \"@lib/parser/Macros\";\r\nimport { END_SYMBOL, T_MACRO, T_MACRO_CONCAT, T_NON_TYPE_ID, T_TYPE_ID } from \"@lib/parser/symbols\";\r\n\r\nlet DEBUG_MACRO = false;\r\n\r\nenum EMacroState {\r\n    k_AllowElse,\r\n    k_ForbidElse\r\n};\r\n\r\n\r\ninterface IMacroFunc {\r\n    op: (...args: IToken[]) => IToken;\r\n    length: number;\r\n}\r\n\r\n\r\nexport enum EPreprocessorErrors {\r\n    SyntaxUnknownError = 7051,\r\n    GeneralCouldNotReadFile = 7200,\r\n    MacroUnknownError,\r\n};\r\n\r\n\r\nexport enum EPreprocessorWarnings {\r\n    MacroUnknownWarning = 3000,\r\n}\r\n\r\n\r\nexport class PreprocessorDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Preprocessor diagnostics\", 'M');\r\n    }\r\n\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IMap<any>): IRange {\r\n        if (category === EDiagnosticCategory.k_Warning) {\r\n            switch (code) {\r\n                case EPreprocessorWarnings.MacroUnknownWarning:\r\n                    return desc.loc;\r\n            }\r\n        }\r\n\r\n        //\r\n        // errors\r\n        //\r\n\r\n        switch (code) {\r\n            case EPreprocessorErrors.SyntaxUnknownError:\r\n                return desc.token.loc;\r\n            case EPreprocessorErrors.GeneralCouldNotReadFile:\r\n                return desc.loc;\r\n            case EPreprocessorErrors.MacroUnknownError:\r\n                return desc.loc;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EPreprocessorErrors.SyntaxUnknownError]: \"Syntax error during parsing. Token: '{token.value}'\\n\" +\r\n                \"Line: {token.loc.start.line}. Column: {token.loc.start.column}.\",\r\n            [EPreprocessorErrors.GeneralCouldNotReadFile]: \"Could not read file '{target}'.\",\r\n        };\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: IMap<any>): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { file, loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EPreprocessorWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EPreprocessorErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n\r\n\r\n\r\n// as macro token\r\n/** @deprecated */\r\nfunction createMacroToken(value: string, loc: IRange): IToken {\r\n    assert(isString(value), value);\r\n    return { index: -1, type: ETokenType.k_Unknown, name: T_MACRO, value, loc };\r\n}\r\n\r\n\r\nfunction asMacroFunc(fn: (...args: IToken[]) => number | boolean): IMacroFunc {\r\n    return {\r\n        op: (...args: IToken[]): IToken => {\r\n            const value = String(fn(...args));\r\n            const loc = util.commonRange(...args.map(arg => arg.loc));\r\n            // TODO: use typed token like: T_BOOL, T_UINT etc.\r\n            return createMacroToken(value, loc);\r\n        },\r\n        length: fn.length\r\n    };\r\n}\r\n\r\n\r\n\r\nfunction tokenToNative(token: IToken, fallback: (token: IToken) => number = () => NaN) {\r\n    const value = token.value;\r\n\r\n    if (String(value) === 'true') {\r\n        return 1;\r\n    }\r\n\r\n    if (String(value) === 'false') {\r\n        return 0;\r\n    }\r\n\r\n    // TODO: replace this check\r\n    if (String(Number(value)) === String(value)) {\r\n        return Number(value);\r\n    }\r\n\r\n    return fallback(token)\r\n}\r\n\r\n\r\nclass MacroState {\r\n    states: EMacroState[] = [];\r\n\r\n    is(state: EMacroState): boolean {\r\n        return this.states[this.states.length - 1] === state;\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this.states.length === 0;\r\n    }\r\n\r\n    push(state: EMacroState): void {\r\n        this.states.push(state);\r\n    }\r\n\r\n    pop(): EMacroState {\r\n        return this.states.pop();\r\n    }\r\n\r\n    replace(state: EMacroState): void {\r\n        this.pop();\r\n        this.push(state);\r\n    }\r\n}\r\n\r\n\r\nenum EPPDocumentFlags {\r\n    k_None = 0x00,\r\n    k_Macro = 0x01,\r\n    k_Include = 0x02\r\n}\r\n\r\nexport interface IKnownDefine {\r\n    name: string;\r\n}\r\n\r\nexport class Preprocessor {\r\n    protected stack: {\r\n        lexer: ILexer;\r\n        tokens: IToken[];\r\n        flags: number;  // EPPDocumentFlags \r\n        loc: IRange;\r\n    }[];\r\n    protected includes: number[];\r\n\r\n    protected diagnostics: PreprocessorDiagnostics;\r\n    protected includeResolver: IncludeResolver;\r\n\r\n    /* protected */ macros: Macros;\r\n    /* protected */ macroState: MacroState;\r\n    /* protected */ unreachableCodeList: IRange[];\r\n    /* protected */ includeMap: Map<string, IRange>;\r\n\r\n    /* protected */ unresolvedMacros: IMacro[];\r\n\r\n    protected knownTypes: Set<string>;\r\n    protected lexerEngine: ILexerEngine;\r\n\r\n    protected lexerReport: IDiagnosticReport;\r\n\r\n    protected lexerOptions: { skipComments: boolean; };\r\n\r\n    document: ITextDocument;\r\n\r\n    constructor(lexerEngine: ILexerEngine, \r\n        { \r\n            knownTypes = new Set<string>(), \r\n            macros = new Macros, \r\n            diag = new PreprocessorDiagnostics, \r\n            skipComments = true,\r\n            includeResolver = null,\r\n            defines = null\r\n        } = {}) {\r\n\r\n        this.macros = macros;\r\n\r\n        if (defines) {\r\n            // set as boolean macro\r\n            (<IKnownDefine[]>defines)\r\n                .forEach(({ name }) => \r\n                    this.macros.set({name, tokens: [], bFunction: false, params: null, bRegionExpr: false}));\r\n        }\r\n\r\n        this.macroState = new MacroState;\r\n        this.includeMap = new Map;\r\n\r\n        this.unreachableCodeList = [];\r\n        this.unresolvedMacros = [];\r\n\r\n        this.knownTypes = knownTypes;\r\n        this.lexerEngine = lexerEngine;\r\n\r\n        this.diagnostics = diag;\r\n        this.includeResolver = includeResolver;\r\n        this.lexerReport = null;\r\n        this.lexerOptions = { skipComments };\r\n        // TODO: add initital document to includeList !!!\r\n\r\n        this.stack = [];\r\n        this.includes = [];\r\n    }\r\n\r\n\r\n    get lexer(): ILexer {\r\n        return this.stack[this.stack.length - 1].lexer;\r\n    }\r\n\r\n\r\n    get tokens(): IToken[] {\r\n        return this.stack[this.stack.length - 1].tokens;\r\n    }\r\n\r\n\r\n    get uri(): IFile {\r\n        return this.document.uri;\r\n    }\r\n\r\n    /** Current location stack (each location contains \".source\" property inside.) */\r\n    // get location(): IRange {\r\n    //     return this.stack[this.stack.length - 1].loc;\r\n    // }\r\n\r\n\r\n    /** Top location of the macro if presented or null otherwise. */\r\n    macroLocation(): IRange {\r\n        // return first macro location in the current document\r\n        const latestInclude = this.includes[this.includes.length - 1];\r\n        if (latestInclude < this.stack.length - 1) {\r\n            return this.stack[latestInclude + 1].loc;\r\n        }\r\n\r\n        // return null (we are alrady in the current document)\r\n        return null;\r\n    }\r\n\r\n    currentMacro(): IMacro {\r\n        return this.macros.root;\r\n    }\r\n\r\n    getDiagnosticReport(): IDiagnosticReport {\r\n        return Diagnostics.mergeReports([this.lexerReport, this.diagnostics.resolve()]);\r\n    }\r\n\r\n\r\n    readLine(): IToken {\r\n        return this.lexer.getNextLine();\r\n    }\r\n\r\n\r\n    setTextDocument(textDocument: ITextDocument): Preprocessor {\r\n        this.document = textDocument;\r\n        this.pushDocument(this.documentToLexer(textDocument), null, EPPDocumentFlags.k_Include);\r\n        return this;\r\n    }\r\n\r\n\r\n    protected pushDocument(lexer: ILexer, loc: IRange, flags: number, macro: IMacro = null): void {\r\n        const tokens = <IToken[]>[];\r\n\r\n        /// link location into chain\r\n        // if (loc) {\r\n        //     loc.source = this.stack[this.stack.length - 1].loc;\r\n        // }\r\n        \r\n        if (flags & EPPDocumentFlags.k_Macro) {\r\n            assert(isDefAndNotNull(macro));\r\n            this.macros.push(macro);\r\n        }\r\n\r\n        if (flags & EPPDocumentFlags.k_Include) {\r\n            this.includes.push(this.stack.length);\r\n\r\n            // assert(!this.includeMap.has(`${textDocument.uri}`));\r\n            this.includeMap.set(`${lexer.document.uri}`, loc);\r\n        }\r\n\r\n        this.stack.push({ lexer, tokens, flags, loc });\r\n    }\r\n\r\n\r\n    protected pop(): void {\r\n        const { flags, lexer } = this.stack.pop();\r\n\r\n        // FIXME: do not Lexer type\r\n        const diag = (lexer as Lexer).diagnostics;\r\n        if (diag && !diag.isEmpty()) {\r\n            this.lexerReport = Diagnostics.mergeReports([this.lexerReport, lexer.getDiagnosticReport()]);\r\n        }\r\n\r\n        if (flags & EPPDocumentFlags.k_Macro) {\r\n            this.macros.pop();\r\n        }\r\n\r\n        if (flags & EPPDocumentFlags.k_Include) {\r\n            this.includes.pop();\r\n        }\r\n    }\r\n\r\n    protected pushToken(...tokens: IToken[]): void {\r\n        this.tokens.push(...tokens);\r\n    }\r\n\r\n\r\n    protected popToken(): IToken {\r\n        return this.tokens.shift() || null;\r\n    }\r\n\r\n\r\n    async readToken(allowMacro: boolean = true, allowStateChanging = true): Promise<IToken> {\r\n        const token: IToken = this.popToken() || this.lexer.getNextToken();\r\n\r\n        switch (token.name) {\r\n            case T_MACRO:\r\n                if (allowMacro) {\r\n                    return this.readMacro(token);\r\n                }\r\n                break;\r\n            case END_SYMBOL:\r\n                if (allowStateChanging) {\r\n                    if (this.stack.length > 1) {\r\n                        this.pop();\r\n                        return this.readToken(allowMacro);\r\n                    }\r\n\r\n                    if (!this.macroState.isEmpty()) {\r\n                        // TODO: highlight open tag too.\r\n                        this.emitMacroError(`'endif' not found :/`, token.loc);\r\n                    }\r\n                }\r\n                break\r\n            default:\r\n                if (allowMacro) {\r\n                    return this.examMacro(token);\r\n                }\r\n        }\r\n\r\n        return token;\r\n    }\r\n\r\n    protected async readMacro(token: IToken): Promise<IToken> {\r\n        switch (token.value) {\r\n            case '#define': return this.processDefineMacro(token);\r\n            case '#ifdef': return this.processIfdefMacro(token);\r\n            case '#ifndef': return this.processIfndefMacro(token);\r\n            case '#endif': return this.processEndifMacro(token);\r\n            case '#else': return this.processElseMacro(token);\r\n            case '#elif': return this.processElifMacro(token);\r\n            case '#if': return this.processIfMacro(token);\r\n            case '#error': return this.processErrorMacro(token);\r\n            case '#include': return this.processIncludeMacro(token);\r\n            case '#undef': return this.processUndefMacro(token);\r\n            case '#pragma': {\r\n                this.readLine();\r\n                return this.readToken();\r\n            }\r\n        }\r\n\r\n        this.emitMacroWarning(`unsupported macro type found: ${token.value}`, token.loc)\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async processUndefMacro(token: IToken): Promise<IToken> {\r\n        const name = await this.readToken(false);\r\n        const text = this.readLine();\r\n\r\n        if (name.name !== T_NON_TYPE_ID) {\r\n            // TODO: emit error\r\n            assert(name.name === T_NON_TYPE_ID);\r\n            return this.readToken();\r\n        }\r\n\r\n        if (!this.macros.has(name.value)) {\r\n            this.emitMacroWarning(`target macro not found: ${name.value}`, name.loc);\r\n        } else {\r\n            this.macros.unset(name.value);\r\n        }\r\n\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async processDefineMacro(token: IToken): Promise<IToken> {\r\n        const name = await this.readToken(false);\r\n        const text = this.readLine();\r\n\r\n        if (name.name !== T_NON_TYPE_ID) {\r\n            // TODO: emit error\r\n            assert(name.name === T_NON_TYPE_ID);\r\n            return this.readToken();\r\n        }\r\n\r\n\r\n        if (this.macros.has(name.value)) {\r\n            this.emitMacroWarning(`macro redefinition found: ${name.value}`, name.loc);\r\n        }\r\n\r\n        const macro = await this.processMacro(name, text);\r\n        if (macro) {\r\n            const unresolvedMacro = this.unresolvedMacros.find(macro => macro.name === name.value);\r\n            if (unresolvedMacro) {\r\n                macro.bRegionExpr = unresolvedMacro.bRegionExpr;\r\n                // TODO: remove this hack\r\n                this.unresolvedMacros = this.unresolvedMacros.filter(macro => macro.name !== name.value);\r\n            }\r\n\r\n            this.macros.set(macro);\r\n        }\r\n\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async processMacro(name: IToken, lineToken: IToken): Promise<IMacro> {\r\n        let bFunction = false;\r\n        let bRegionExpr = false;\r\n        let params: string[] = null;\r\n        let tokens = <IToken[]>[];\r\n\r\n        if (!/^\\s*$/.test(lineToken.value)) {\r\n\r\n            //\r\n            // process macro params\r\n            //\r\n\r\n            const lexer = await this.tokenToLexer(lineToken);\r\n\r\n            let token: IToken = lexer.getNextToken();\r\n\r\n            const bOpenBracket = token.value === '(';\r\n            const bSameLine = token.loc.start.line === name.loc.end.line;\r\n            const bNoSpace = token.loc.start.column === name.loc.end.column;\r\n\r\n            // A bit tricky way to separate macro like:\r\n            // >  #define NAME(A, B)\r\n            // from the macro:\r\n            // >  #define NAME (A, B)\r\n            // and macro like:\r\n            // >  #define NAME\\\r\n            // >              (A, B)\r\n\r\n            // note: only macro like 'NAME(a, b)' is a valid function-like macro (no spaces allowed)\r\n\r\n            if (bOpenBracket && bSameLine && bNoSpace) {\r\n                params = [];\r\n                bFunction = true;\r\n                let bExpectComma = false;\r\n                token = lexer.getNextToken();\r\n                while (token.name !== END_SYMBOL && token.value !== ')') {\r\n                    if (bExpectComma) {\r\n                        if (token.value !== ',') {\r\n                            this.emitMacroError(`invalid macro, comma expected`, token.loc);\r\n                            return null;\r\n                        }\r\n                    } else {\r\n                        if (token.name !== T_NON_TYPE_ID) {\r\n                            this.emitMacroError('invalid token found. only identifiers allowed as param names', token.loc);\r\n                            return null;\r\n                        }\r\n                        params.push(token.value);\r\n                    }\r\n\r\n                    bExpectComma = !bExpectComma;\r\n                    token = lexer.getNextToken();\r\n                }\r\n\r\n                if (token.name === END_SYMBOL) {\r\n                    this.emitMacroError(`comma mismatch`, token.loc);\r\n                    return null;\r\n                }\r\n\r\n                token = lexer.getNextToken();\r\n            }\r\n\r\n            while (token.name !== END_SYMBOL) {\r\n                tokens.push(token);\r\n                token = lexer.getNextToken();\r\n            }\r\n        }\r\n        tokens.forEach(t => { (<any>t).synthetic = true; });\r\n        return { name: name.value, tokens, bFunction, params, bRegionExpr };\r\n    }\r\n\r\n\r\n    protected async processIfdefMacro(token: IToken): Promise<IToken> {\r\n        const exprValue = this.resolveDefMacro(await this.lineToLexer(this.readLine()));\r\n\r\n        if (exprValue) {\r\n            this.macroState.push(EMacroState.k_ForbidElse);\r\n            return this.readToken();\r\n        }\r\n\r\n        this.macroState.push(EMacroState.k_AllowElse);\r\n        return this.skipUnreachableCode(token);\r\n    }\r\n\r\n\r\n    protected async processIfndefMacro(token: IToken): Promise<IToken> {\r\n        const exprValue = this.resolveDefMacro(await this.lineToLexer(this.readLine()));\r\n\r\n        if (exprValue) {\r\n            this.macroState.push(EMacroState.k_AllowElse);\r\n            return this.skipUnreachableCode(token);\r\n        }\r\n\r\n        this.macroState.push(EMacroState.k_ForbidElse);\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async processIfMacro(token: IToken): Promise<IToken> {\r\n        if (this.resolveMacroInner(await this.lineToLexer(this.readLine()))) {\r\n            this.macroState.push(EMacroState.k_ForbidElse);\r\n            return this.readToken();\r\n        }\r\n\r\n        this.macroState.push(EMacroState.k_AllowElse);\r\n        return this.skipUnreachableCode(token);\r\n    }\r\n\r\n\r\n    protected async processElifMacro(token: IToken): Promise<IToken> {\r\n        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {\r\n            this.emitMacroError(`inappropriate control instruction found`, token.loc);\r\n            return this.readToken();\r\n        }\r\n\r\n        if (this.macroState.is(EMacroState.k_AllowElse)) {\r\n            if (this.resolveMacroInner(await this.lineToLexer(this.readLine()))) {\r\n                this.macroState.replace(EMacroState.k_ForbidElse);\r\n                return this.readToken();\r\n            }\r\n        }\r\n\r\n        return this.skipUnreachableCode(token);\r\n    }\r\n\r\n\r\n    protected async processElseMacro(token: IToken): Promise<IToken> {\r\n        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {\r\n            this.emitMacroError(`inappropriate control instruction found`, token.loc);\r\n            return this.readToken();\r\n        }\r\n\r\n        if (this.macroState.is(EMacroState.k_AllowElse)) {\r\n            this.macroState.replace(EMacroState.k_ForbidElse);\r\n            return this.readToken();\r\n        }\r\n\r\n        return this.skipUnreachableCode(token);\r\n    }\r\n\r\n\r\n    protected async processEndifMacro(token: IToken): Promise<IToken> {\r\n        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {\r\n            this.emitMacroError(`inappropriate control instruction found`, token.loc);\r\n            return this.readToken();\r\n        }\r\n\r\n        this.macroState.pop();\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected resolveDefMacro(lexer: ILexer): number {\r\n        const macros = this.macros;\r\n\r\n        const asRaw = (token: IToken): number => tokenToNative(token, ({ value }) => {\r\n            const macro = macros.get(value);\r\n            if (macro) {\r\n                // mark macro as a part of ifdef/else expression\r\n                macro.bRegionExpr = true;\r\n                return 1;\r\n            }\r\n            this.addUnresolvedMacro(value);\r\n            return 0;\r\n        });\r\n        const asFn = asMacroFunc;\r\n        const asValue = asFn(asRaw);\r\n\r\n        const opPriors = {\r\n            '(': 1, ')': 1,\r\n            '&&': 2,\r\n            '||': 3,\r\n            '!': 8\r\n        };\r\n\r\n        const opLogic = {\r\n            '&&': asFn((a, b) => asRaw(a) && asRaw(b)),\r\n            '||': asFn((a, b) => asRaw(a) || asRaw(b)),\r\n            '!': asFn((a) => !asRaw(a)),\r\n            'asValue': asValue\r\n        };\r\n\r\n        const exprValue = this.evaluateMacroExpr(lexer, opPriors, opLogic, {});\r\n        return exprValue;\r\n    }\r\n    \r\n\r\n    protected resolveMacroInner(lexer: ILexer): number {\r\n\r\n        const macros = this.macros;\r\n\r\n        const asRaw = (token: IToken) => this.resolveMacro(token);\r\n        const asFn = asMacroFunc;\r\n        const asValue = asFn(asRaw);\r\n\r\n        const opPriors = {\r\n            '(': 1, ')': 1,\r\n            '||': 2,\r\n            '&&': 3,\r\n            '<': 4, '>': 4, '<=': 4, '>=': 4,\r\n            '==': 5, '!=': 5,\r\n            '+': 6, '-': 6,\r\n            '*': 7, '/': 7,\r\n            '!': 8,\r\n            'defined': 9\r\n        };\r\n\r\n        // TODO: add conditional operator\r\n        // TODO: add unary '+' and unary '-' operators\r\n        const opLogic = {\r\n            '&&': asFn((a, b) => asRaw(a) && asRaw(b)),\r\n            '||': asFn((a, b) => asRaw(a) || asRaw(b)),\r\n            '!': asFn((a) => !asRaw(a)),\r\n            '+': asFn((a, b) => asRaw(a) + asRaw(b)),\r\n            '-': asFn((a, b) => asRaw(a) - asRaw(b)),\r\n            '*': asFn((a, b) => asRaw(a) * asRaw(b)),\r\n            '/': asFn((a, b) => asRaw(a) / asRaw(b)),\r\n            '<': asFn((a, b) => asRaw(a) < asRaw(b)),\r\n            '>': asFn((a, b) => asRaw(a) > asRaw(b)),\r\n            '<=': asFn((a, b) => asRaw(a) <= asRaw(b)),\r\n            '>=': asFn((a, b) => asRaw(a) >= asRaw(b)),\r\n            '==': asFn((a, b) => asRaw(a) === asRaw(b)),\r\n            '!=': asFn((a, b) => asRaw(a) !== asRaw(b)),\r\n            'asValue': asValue\r\n        };\r\n\r\n        //\r\n        // Wrap all macro functions to native \r\n        //\r\n\r\n        const macroFuncs = <IMap<IMacroFunc>>{\r\n            'defined': asFn((a: IToken) => {\r\n                const macro = macros.get(a.value);\r\n                if (macro) {\r\n                    macro.bRegionExpr = true;\r\n                    return 1;\r\n                }\r\n                this.addUnresolvedMacro(a.value);\r\n                return 0;\r\n            }),\r\n        };\r\n\r\n        // TODO: move list construction to preprocess\r\n        macros.forEach((macro: IMacro) => {\r\n            if (macro.bFunction) {\r\n                opPriors[macro.name] = 10;\r\n                macroFuncs[macro.name] = {\r\n                    op: (...args: IToken[]): IToken => {\r\n                        macros.push(macro);\r\n\r\n                        assert(macro.params.length === args.length);\r\n                        const params = macro.params;\r\n\r\n                        for (let i = 0; i < params.length; ++i) {\r\n                            if (DEBUG_MACRO) {\r\n                                console.log(`${macro.name}.${params[i]} => ${args[i].value}`, isString(args[i].value));\r\n                            }\r\n                            macros.set({\r\n                                name: params[i],\r\n                                tokens: [args[i]],\r\n                                bFunction: false,\r\n                                params: null,\r\n                                bRegionExpr: false\r\n                            });\r\n                        }\r\n\r\n                        const value = String(this.resolveMacroInner(this.macroToLexer(macro)));\r\n                        macros.pop();\r\n\r\n                        // TODO: use min/max instead?\r\n                        const loc = util.commonRange(...args.map(arg => arg.loc));\r\n                        return { index: -1, type: ETokenType.k_NumericLiteral, name: 'T_UINT', value, loc };\r\n                    },\r\n\r\n                    length: macro.params.length\r\n                };\r\n            }\r\n        });\r\n\r\n        return this.evaluateMacroExpr(lexer, opPriors, opLogic, macroFuncs);\r\n    }\r\n\r\n\r\n    protected resolveMacro(textToken: IToken): number {\r\n        return tokenToNative(textToken, (token) => {\r\n            const macro = this.macros.get(token.value);\r\n            if (!isNull(macro) && !isNull(macro.tokens)) {\r\n                const exprValue = this.resolveMacroInner(this.macroToLexer(macro));\r\n\r\n                if (DEBUG_MACRO) {\r\n                    console.log(`macro '${token.value}:${macro.tokens.map(tk => tk.value).join(' ')}' resolved to '${exprValue}''`);\r\n                }\r\n\r\n                return exprValue;\r\n            }\r\n\r\n            this.emitMacroWarning(`cannot resolve macro '${token.value}'`, textToken.loc);\r\n            this.addUnresolvedMacro(token.value);\r\n\r\n            return NaN;\r\n        });\r\n    }\r\n\r\n\r\n    protected addUnresolvedMacro(name: string): void {\r\n        if (this.unresolvedMacros.find(macro => macro.name === name)) {\r\n            return;\r\n        }\r\n\r\n        this.unresolvedMacros.push({\r\n            bFunction: false,\r\n            name,\r\n            params: null,\r\n            tokens: null,\r\n            bRegionExpr: true\r\n        });\r\n    }\r\n\r\n\r\n    protected evaluateMacroExpr(lexer: ILexer,\r\n        opPriors: IMap<number>,\r\n        opLogic: IMap<IMacroFunc>,\r\n        macroFuncs: IMap<IMacroFunc> = {}): number {\r\n\r\n        const values = <IToken[]>[];\r\n        const opStack = <IToken[]>[];\r\n\r\n        let token: IToken = lexer.getNextToken();\r\n\r\n        //\r\n        // Transform input sequence to reverse Polish notation\r\n        //\r\n\r\n        exit:\r\n        while (true) {\r\n            switch (token.name) {\r\n                case 'T_TYPE_ID':\r\n                case 'T_NON_TYPE_ID':\r\n                    // process functional macros as operators\r\n                    if (macroFuncs[token.value]) {\r\n                        opStack.push(token);\r\n                        break;\r\n                    }\r\n\r\n                    values.push(token);\r\n                    break;\r\n\r\n                case 'T_UINT':\r\n                case 'T_KW_TRUE':\r\n                case 'T_KW_FALSE':\r\n                    values.push(token);\r\n                    break;\r\n                case 'T_PUNCTUATOR_40': // '('\r\n                    opStack.push(token);\r\n                    break;\r\n                case 'T_PUNCTUATOR_41': // ')'\r\n                    {\r\n                        let op = opStack.pop();\r\n                        while (op.value !== '(') {\r\n                            values.push(op);\r\n                            op = opStack.pop();\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'T_PUNCTUATOR_44': // ','\r\n                    // ignoring of all commas\r\n                    break;\r\n                case END_SYMBOL:\r\n                    break exit;\r\n                default:\r\n                    if (opPriors[token.value]) {\r\n                        if (opStack.length) {\r\n                            const thisOp = token.value;\r\n                            const prevOp = opStack[opStack.length - 1].value;\r\n                            assert(opPriors[prevOp] && opPriors[thisOp], prevOp, thisOp);\r\n                            if (opPriors[prevOp] >= opPriors[thisOp]) {\r\n                                values.push(opStack.pop());\r\n                            }\r\n                        }\r\n                        opStack.push(token);\r\n                        break;\r\n                    }\r\n\r\n                    this.emitMacroError(`unsupported macro operator found: '${token.value}'`, token.loc);\r\n                    return NaN;\r\n            }\r\n\r\n            token = lexer.getNextToken();\r\n        }\r\n\r\n        while (opStack.length) {\r\n            values.push(opStack.pop());\r\n        }\r\n\r\n        //\r\n        // Evaluate reverse Polish notation\r\n        //\r\n\r\n        // FIXME: remove debug log\r\n        const $input = `[${values.map(token => token.value).join(', ')}]`;\r\n\r\n        const isOp = (op: IToken): boolean => isDef(opLogic[op.value]);\r\n        const asOp = (op: IToken): IMacroFunc => opLogic[op.value];\r\n        const isFn = (op: IToken): boolean => isDef(macroFuncs[op.value]);\r\n        const asFn = (op: IToken): IMacroFunc => macroFuncs[op.value];\r\n\r\n        const stack: IToken[] = [];\r\n        values.forEach(token => {\r\n            if (isOp(token)) {\r\n                const { op, length } = asOp(token);\r\n                stack.push(op(...stack.splice(-(length))));\r\n                return;\r\n            }\r\n            if (isFn(token)) {\r\n                const { op, length } = asFn(token);\r\n                stack.push(op(...stack.splice(-(length))));\r\n                return;\r\n            }\r\n            stack.push(token);\r\n        });\r\n\r\n        if (values.length === 1) {\r\n            stack[0] = opLogic.asValue.op(stack[0]);\r\n        }\r\n\r\n        if (DEBUG_MACRO) console.log(`${$input} => {${stack[0].value}}`);\r\n        // assert(asMacroNative(stack[0]) !== NaN, stack);\r\n\r\n        return tokenToNative(stack[0]);\r\n    }\r\n\r\n\r\n    protected async processErrorMacro(token: IToken): Promise<IToken> {\r\n        const text = this.readLine();\r\n        const msg = text.value.trim();\r\n        this.emitMacroError(`erroneous macro reached: \"${msg}\"`, util.commonRange(token.loc, text.loc));\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async skipUnreachableCode(startToken: IToken): Promise<IToken> {\r\n        let token: IToken = await this.readToken(false);\r\n        let nesting = 0;\r\n\r\n        while (token.name !== END_SYMBOL) {\r\n            if (token.name === T_MACRO) {\r\n                switch (token.value) {\r\n                    case '#if':\r\n                    case '#ifdef':\r\n                    case '#ifndef':\r\n                        nesting++;\r\n                        this.readLine();\r\n                        break;\r\n                    case '#elif':\r\n                    case '#else':\r\n                        if (nesting !== 0) {\r\n                            this.readLine();\r\n                            break;\r\n                        }\r\n\r\n                    /* fall throught */\r\n                    case '#endif':\r\n                        if (nesting > 0) {\r\n                            nesting--;\r\n                            this.readLine();\r\n                            break;\r\n                        }\r\n\r\n                        this.addUnreachableCode(startToken, token);\r\n                        return this.readMacro(token);\r\n                    case '#error':\r\n                        this.readLine();\r\n                }\r\n            }\r\n\r\n            token = await this.readToken(false);\r\n        }\r\n\r\n        // TODO: highlight open tag\r\n        this.emitMacroError(`'endif' non found :/`, token.loc);\r\n        return token;\r\n    }\r\n\r\n\r\n    protected addUnreachableCode(start: IToken, end: IToken): void {\r\n        const block = { start: { ...start.loc.end, column: 0 }, end: { ...end.loc.end, column: 0 } };\r\n        block.start.line++;\r\n\r\n        if (block.end.line - block.start.line > 0) {\r\n            if (DEBUG_MACRO) {\r\n                console.log(`unreachable code: [${block.start.line}, ${block.end.line})`);\r\n            }\r\n            this.unreachableCodeList.push(block);\r\n        }\r\n    }\r\n\r\n\r\n    protected async processIncludeMacro(token: IToken): Promise<IToken> {\r\n        const file = this.readLine();\r\n        //cuttin qoutes\r\n        const includeURL = file.value.trim().slice(1, -1);\r\n        const resolvedURI = URI.resolve(includeURL, `${token.loc.start.file}`);\r\n        const loc = util.commonRange(token.loc, file.loc);\r\n\r\n        if (this.includeMap.has(resolvedURI)) {\r\n            if (DEBUG_MACRO) {\r\n                const chain = this.includes.map(i => this.stack[i].lexer.document.uri.toString()).map(name => `\\t> ${name}`).join('\\n');\r\n                console.warn(`'${resolvedURI}' file has already been included previously at \"${this.includeMap.get(resolvedURI).start.file}\":\\n${chain}`);\r\n            }\r\n\r\n            // TODO: prevent recursion!\r\n            // // TODO: emit warning\r\n            // return this.readToken();\r\n        }\r\n\r\n        const textDocumentRaw = await this.includeResolver(resolvedURI);\r\n        if (!textDocumentRaw) {\r\n            this.emitFileNotFound(resolvedURI, loc);\r\n            return this.readToken();\r\n        }\r\n        \r\n        // rebuild text document in order to avoid problems if include handler was called through worker\r\n        const { uri, source } = textDocumentRaw;\r\n        const textDocument = await createTextDocument(uri, source);\r\n        this.pushDocument(this.documentToLexer(textDocument), loc, EPPDocumentFlags.k_Include);\r\n\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected emitMacroWarning(msg: string, loc: IRange): void {\r\n        this.diagnostics.warning(EPreprocessorWarnings.MacroUnknownWarning, { ...loc.start/* << FIXME: remove this */, loc, msg });\r\n    }\r\n\r\n\r\n    protected emitMacroError(msg: string, loc: IRange): void {\r\n        this.diagnostics.error(EPreprocessorErrors.MacroUnknownError, { ...loc.start/* << FIXME: remove this */, loc, msg });\r\n    }\r\n\r\n\r\n    protected emitFileNotFound(file: string, loc: IRange) {\r\n        this.diagnostics.error(EPreprocessorErrors.GeneralCouldNotReadFile, { ...loc.start/* << FIXME: remove this */, loc, target: file });\r\n    }\r\n\r\n\r\n    protected async applyMacro(token: IToken): Promise<IMacro> {\r\n        const macros = this.macros;\r\n        const macro = macros.get(token.value);\r\n\r\n        if (!macro) {\r\n            return null;\r\n        }\r\n\r\n        if (macro.bFunction) {\r\n\r\n            const $lexer = this.lexer;\r\n            const pos = this.lexer.getPosition();\r\n\r\n            const nextToken: IToken = await this.readToken();\r\n            if (nextToken.value !== '(') {\r\n                this.emitMacroWarning(`for macro '${macro.name} function call signature is expected'`, token.loc);\r\n\r\n                assert($lexer === this.lexer, 'something went wrong');\r\n                this.lexer.setPosition(pos);\r\n                return null;\r\n            }\r\n\r\n            let readTokens = [nextToken];\r\n            let argRanges = <number[]>[];\r\n\r\n            let argToken: IToken = await this.readToken();\r\n            let bracketDepth = 0;\r\n\r\n            let startPos = 1;\r\n            let endPos = 1;\r\n\r\n            readTokens.push(argToken);\r\n            while (argToken.name !== END_SYMBOL && !(argToken.value === ')' && bracketDepth == 0)) {\r\n                switch (argToken.value) {\r\n                    case '(':\r\n                        bracketDepth++;\r\n                        break;\r\n                    case ')':\r\n                        bracketDepth--;\r\n                        break;\r\n                    case ',':\r\n                        if (bracketDepth === 0) {\r\n                            assert(endPos - startPos > 0);\r\n                            // TODO: emit error\r\n                            if ((endPos - startPos) > 0) {\r\n                                argRanges.push(startPos, endPos);\r\n                            }\r\n                            startPos = endPos + 1;\r\n                        }\r\n                        break;\r\n                }\r\n\r\n                endPos++;\r\n                argToken = await this.readToken();\r\n                readTokens.push(argToken);\r\n            }\r\n\r\n\r\n            if (endPos > startPos) {\r\n                argRanges.push(startPos, endPos);\r\n            }\r\n\r\n            const nArgs = argRanges.length / 2;\r\n\r\n            if (nArgs !== macro.params.length) {\r\n                this.emitMacroError(`macro '${macro.name}' arguments mismatch, expected count is ${macro.params.length} but recived ${nArgs}`, token.loc);\r\n\r\n                assert($lexer === this.lexer, 'something went wrong');\r\n                this.lexer.setPosition(pos);\r\n                return null;\r\n            }\r\n\r\n            {\r\n                const { loc: { start } } = token;\r\n                const { loc: { end } } = argToken;\r\n                this.pushDocument(this.macroToLexer(macro), { start, end }, EPPDocumentFlags.k_Macro, macro);\r\n            }\r\n\r\n            const params = macro.params;\r\n\r\n            for (let i = 0; i < params.length; ++i) {\r\n                const i2 = i * 2;\r\n\r\n                const startPos = argRanges[i2];\r\n                const endPos = argRanges[i2 + 1];\r\n                const start = readTokens[startPos].loc.start;\r\n                const end = readTokens[endPos - 1].loc.end;\r\n                const tokens = readTokens.slice(startPos, endPos);\r\n\r\n                if (DEBUG_MACRO) {\r\n                    console.log(`${macro.name}.${params[i]} => ${tokens.map(tk => tk.value).join(' ')}`);\r\n                }\r\n\r\n                macros.set({\r\n                    name: params[i],\r\n                    tokens,\r\n                    bFunction: false,\r\n                    params: null,\r\n                    bRegionExpr: false\r\n                });\r\n            }\r\n        } else {\r\n            if (DEBUG_MACRO) {\r\n                console.log(`${macro.name} => ${macro.tokens.map(tk => tk.value).join(' ')}`);\r\n            }\r\n            this.pushDocument(this.macroToLexer(macro), token.loc, EPPDocumentFlags.k_Macro, macro);\r\n        }\r\n        return macro;\r\n    }\r\n\r\n    protected async preprocessToString(value: string, includeResolver: IncludeResolver): Promise<string> {\r\n        if (DEBUG_MACRO) {\r\n            console.info('preprocess to string', value);\r\n        }\r\n\r\n        const { knownTypes, macros, diagnostics: diag } = this;\r\n\r\n        const pp = new Preprocessor(this.lexerEngine, { knownTypes, macros, diag, includeResolver });\r\n        pp.setTextDocument(await createTextDocument('://macro', value));\r\n\r\n        let token: IToken = await pp.readToken();\r\n        let raw = null;\r\n        while (token.name !== END_SYMBOL) {\r\n            raw = (raw ? raw + ' ' : '') + token.value;\r\n            token = await pp.readToken();\r\n        }\r\n\r\n        if (DEBUG_MACRO) {\r\n            console.info(`>> \"${raw}\"`);\r\n        }\r\n\r\n        return raw;\r\n    }\r\n\r\n\r\n    // apply \"left'##'right\" operator to value and next token\r\n    protected async applyConcatMacro(left: IToken): Promise<IToken> {\r\n        assert(!this.macros.get(left.value) || !this.macros.get(left.value).bFunction);\r\n\r\n        const right = await this.readToken(false, false);\r\n        assert(right.name !== END_SYMBOL);\r\n\r\n        if (DEBUG_MACRO) {\r\n            console.info(`concat strings: \"${left.value}##${right.value}\"`);\r\n        }\r\n\r\n        const leftRaw = await this.preprocessToString(left.value, this.includeResolver);\r\n        const rightRaw = await this.preprocessToString(right.value, this.includeResolver);\r\n        const raw = `${leftRaw}${rightRaw}`;\r\n\r\n        if (DEBUG_MACRO) {\r\n            console.info(`=> \"${leftRaw}${rightRaw}\"`);\r\n        }\r\n\r\n        const loc = { start: left.loc.start, end: right.loc.end };\r\n\r\n        // multiple concatenation processing: A ## B ## C ##  etc.\r\n        const nextToken: IToken = await this.readToken(false, false);\r\n        if (nextToken.name === T_MACRO_CONCAT) {\r\n            return this.applyConcatMacro(createMacroToken(raw, loc));\r\n        }\r\n\r\n        this.pushToken(nextToken);\r\n\r\n        // we handle it as text document, because all possible macros inside are already resolved\r\n        const pos = left.loc.start;\r\n        const textDocument = await createTextDocument(pos.file, raw, pos);\r\n        this.pushDocument(this.documentToLexer(textDocument), loc, EPPDocumentFlags.k_None);\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async examMacro(token: IToken): Promise<IToken> {\r\n        const macroProcessing = this.stack[this.stack.length - 1].flags & EPPDocumentFlags.k_Macro;\r\n\r\n        if (macroProcessing) {\r\n            const nextToken: IToken = await this.readToken(false, false);\r\n            if (nextToken.name === T_MACRO_CONCAT) {\r\n                return this.applyConcatMacro(token);\r\n            }\r\n            this.pushToken(nextToken);\r\n        }\r\n\r\n        if (token.name === T_NON_TYPE_ID || token.name === T_TYPE_ID) {\r\n            const macro: IMacro = await this.applyMacro(token);\r\n            if (macro) {\r\n                return this.readToken();\r\n            }\r\n        }\r\n\r\n        return token;\r\n    }\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n\r\n    protected documentToLexer(textDocument: ITextDocument): ILexer {\r\n        const { lexerEngine: engine, knownTypes, lexerOptions: { skipComments } } = this;\r\n        const lexer = new Lexer({ engine, knownTypes, skipComments });\r\n        lexer.setTextDocument(textDocument);\r\n        return lexer;\r\n    }\r\n\r\n\r\n    protected tokensToLexer(tokens: IToken[]): ILexer {\r\n        return new CachingLexer(tokens);\r\n    }\r\n\r\n\r\n    protected macroToLexer(macro: IMacro): ILexer {\r\n        return this.tokensToLexer(macro.tokens);\r\n    }\r\n\r\n\r\n    protected async tokenToLexer(token: IToken): Promise<ILexer> {\r\n        const lexer = new Lexer({ engine: this.lexerEngine, knownTypes: this.knownTypes });\r\n        const uri = token.loc.start.file;\r\n        const source = token.value;\r\n        const offset = token.loc.start;\r\n        lexer.setTextDocument(await createTextDocument(uri, source, offset));\r\n        return lexer;\r\n    }\r\n\r\n\r\n    protected async lineToTokens(lineToken: IToken): Promise<IToken[]> {\r\n        const lexer = await this.tokenToLexer(lineToken);\r\n        let tokens = [];\r\n        let tk = lexer.getNextToken();\r\n        while (tk.name !== END_SYMBOL) {\r\n            tokens.push(tk);\r\n            tk = lexer.getNextToken();\r\n        }\r\n        return tokens;\r\n    }\r\n\r\n\r\n    protected async lineToLexer(lineToken: IToken): Promise<ILexer> {\r\n        return this.tokensToLexer(await this.lineToTokens(lineToken));\r\n    }\r\n\r\n}\r\n\r\nexport interface IPPOptions {\r\n    skipComments?: boolean;\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n}\r\n\r\n// create preprocessed document\r\nexport async function createPPDocument(textDocument: ITextDocument, \r\n        options: IPPOptions = {}): Promise<ITextDocument> {\r\n    // TODO: try to use default lexer: new LexerEngine()\r\n\r\n    const parser = defaultSLParser();\r\n    const { skipComments = true, includeResolver, defines } = options;\r\n    const pp = new Preprocessor(parser.lexerEngine, { skipComments, includeResolver, defines });\r\n    pp.setTextDocument(textDocument);\r\n\r\n    const newline = (from: number, to: number): string => Array(Math.min(to - from, 4)).fill('\\n').join('');\r\n    const padding = (length: number): string => Array(length).fill(' ').join('');\r\n\r\n    let content = '';\r\n    let tokenThis = await pp.readToken();\r\n    while (tokenThis.name !== END_SYMBOL) {\r\n        const doPadding = !content || content.substr(-1) === '\\n';\r\n        const locThis = pp.macroLocation() || tokenThis.loc;\r\n        const macroThis = pp.currentMacro();\r\n\r\n        // padding\r\n        if (doPadding) {\r\n            content += padding(locThis.start.column);// + padding(tokenThis.loc.start.column);\r\n            // note: paddings inside multiline macro are not supported\r\n        }\r\n\r\n        // place content\r\n        content = `${content}${!doPadding ? ' ' : ''}${tokenThis.value}`;\r\n\r\n        const tokenNext = await pp.readToken();\r\n        const locNext = pp.macroLocation() || tokenNext.loc;\r\n\r\n        // newline if new file\r\n        if (locThis.end.file !== locNext.start.file) {\r\n            content += '\\n\\n';\r\n        }\r\n        // newline if new global macro (or just diff lines) on a new line\r\n        else if (locThis.end.line < locNext.start.line) {\r\n            content += newline(locThis.end.line, locNext.start.line);\r\n        }\r\n        // new line if it is a multiline macro\r\n        else if (tokenThis.loc.end.line < tokenNext.loc.start.line && macroThis === pp.currentMacro()) {\r\n            content += newline(tokenThis.loc.end.line, tokenNext.loc.start.line);\r\n        }\r\n\r\n        tokenThis = tokenNext;\r\n    }\r\n\r\n    return createTextDocument(textDocument.uri, content);\r\n}\r\n","import { assert } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { EParserType, IRule } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { Item } from \"./Item\";\r\n\r\nexport class State {\r\n    index: number;\r\n    nextStates: IMap<State>;\r\n\r\n    private items: Item[];\r\n    private numBaseItems: number;\r\n    // for debug only\r\n    private numOtherItems: number;\r\n\r\n    constructor() {\r\n        this.nextStates = {};\r\n        this.index = 0;\r\n\r\n        this.items = [];\r\n        this.numBaseItems = 0;\r\n        this.numOtherItems = 0;\r\n    }\r\n\r\n\r\n    eachItem(cb: (item: Item, i?: number) => void) {\r\n        // NOTE: do not try to change this for loop\r\n        for (let i = 0; i < this.items.length; ++i) {\r\n            cb(this.items[i], i);\r\n        }\r\n    }\r\n\r\n\r\n    eachBaseItem(cb: (item: Item, i?: number) => void) {\r\n        // NOTE: do not try to change this for loop\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            cb(this.items[i], i);\r\n        }\r\n    }\r\n\r\n    \r\n    isExpected(symbol: string): boolean {\r\n        return !!this.items.find(item => item.isExpected(symbol));\r\n    }\r\n\r\n\r\n    hasItem(value: Item, type: EParserType): Item {\r\n        return this.items.find(item => item.isEqual(value, type)) || null;\r\n    }\r\n\r\n    \r\n    hasParentItem(value: Item): Item {\r\n        return this.items.find(item => item.isParentItem(value)) || null;\r\n    }\r\n\r\n    \r\n    hasChildItem(value: Item): Item {\r\n        return this.items.find(item => item.isChildItem(value)) || null;\r\n    }\r\n\r\n    \r\n    hasRule(rule: IRule, pos: number): boolean {\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            const item = this.items[i];\r\n            if (item.rule === rule && item.pos === pos) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    isEmpty(): boolean {\r\n        return !(this.items.length);\r\n    }\r\n\r\n    \r\n    isEqual(state: State, type: EParserType): boolean {\r\n        if (this.numBaseItems !== state.numBaseItems) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            const baseItemA = this.items[i];\r\n\r\n            let isEqual = false;\r\n            for (let i = 0; i < state.numBaseItems; ++i) {\r\n                const baseItemB = state.items[i];\r\n                if (baseItemA.isEqual(baseItemB, type)) {\r\n                    isEqual = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isEqual) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    push(item: Item): void {\r\n        if (this.items.length === 0 || item.pos > 0) {\r\n            assert(this.numOtherItems === 0);\r\n            this.numBaseItems++;\r\n        } else {\r\n            this.numOtherItems++;\r\n        }\r\n        this.items.push(item);\r\n    }\r\n\r\n\r\n    tryPush_LR0(rule: IRule, pos: number): boolean {\r\n        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));\r\n        if (sameItem) {\r\n            return false;\r\n        }\r\n\r\n        const item = new Item(rule, pos);\r\n        this.push(item);\r\n        return true;\r\n    }\r\n\r\n\r\n    tryPush_LR(rule: IRule, pos: number, expectedSymbol: string): boolean {\r\n        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));\r\n        if (sameItem) {\r\n            return sameItem.addExpected(expectedSymbol);\r\n        }\r\n\r\n        const item = new Item(rule, pos, [expectedSymbol]);\r\n        this.push(item);\r\n        return true;\r\n    }\r\n\r\n    \r\n    addNextState(symbol: string, state: State): boolean {\r\n        if (this.nextStates[symbol]) {\r\n            return false;\r\n        }\r\n\r\n        this.nextStates[symbol] = state;\r\n        return true;\r\n    }\r\n\r\n    \r\n    deleteNotBase(): void {\r\n        this.items.length = this.numBaseItems;\r\n    }\r\n\r\n    \r\n    toString(isBase: boolean = true, grammarSymbols: Map<string, string> = null): string {\r\n        const items = isBase? this.items.slice(0, this.numBaseItems) : this.items;\r\n        return `State ${this.index}:\\n` +\r\n            items.map(item => `\\t\\t${item.toString(grammarSymbols)}\\n`).join();\r\n    }\r\n}\r\n","import { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { ETokenType, IncludeResolver, IRange, IToken } from \"@lib/idl/parser/IParser\";\r\nimport { Lexer } from \"@lib/parser/Lexer\";\r\nimport { createPPDocument } from \"@lib/parser/Preprocessor\";\r\nimport { END_SYMBOL } from \"@lib/parser/symbols\";\r\nimport { cloneRange } from \"@lib/parser/util\";\r\n\r\n/** @deprecated Use CommentExtractor instead. */\r\nexport async function exractComments(document: ITextDocument, includeResolver?: IncludeResolver): Promise<IToken[]> {\r\n    const lexer = new Lexer({ skipComments: false });\r\n    const ppdoc = await createPPDocument(document, { skipComments: false, includeResolver });\r\n    lexer.setTextDocument(ppdoc);\r\n\r\n    let comments = [];\r\n    let token: IToken;\r\n    while((token = lexer.getNextToken()).value !== END_SYMBOL) {\r\n        if (token.type === ETokenType.k_MultilineCommentLiteral) {\r\n            comments.push(token);\r\n        }\r\n    }\r\n    return comments;\r\n}\r\n\r\n\r\n/** @deprecated Use CommentExtractor instead. */\r\nexport function parseComment(handlers: { [name: string]: (parts: string[], name: string, loc: IRange) => void; }, epilogue?: () => void, prologue?: () => void)\r\n{    \r\n    return (commentToken: IToken) => {\r\n        let comment = commentToken.value.slice(2, -2);\r\n        let list = comment\r\n            .split('\\n')\r\n            .map(str => str.replace(/^\\s*\\*{1,2}\\s*|\\s*$/g, ''));\r\n\r\n        let accum: string[] = [];\r\n        let lastRule: { line: number, content: string } = null;\r\n        let content: string;\r\n        let rules: { line: number, content: string }[] = [];\r\n        let line = -1;\r\n        while (list.length) {\r\n            line++;\r\n\r\n            [content, list] = [list[0], list.slice(1)];\r\n\r\n            if (content.match(/^\\s*$/g)) {\r\n                continue;\r\n            }\r\n\r\n            if (!content.match(/^@[\\w]+/g)) {\r\n                accum.push(content);\r\n                continue;\r\n            }\r\n\r\n            if (lastRule) {\r\n                rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line});\r\n            }\r\n\r\n            lastRule = { content, line };\r\n        };\r\n\r\n        if (lastRule && lastRule.content) {\r\n            rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line});\r\n        }\r\n\r\n        epilogue && epilogue();\r\n        for (let rule of rules) {\r\n            const { line, content } = rule;\r\n            const parts = content.split(' ');\r\n            const ruleName = parts[0].trim().toLowerCase();\r\n            const loc = cloneRange(commentToken.loc);\r\n\r\n            // FIXME: dirty hack in order to make the range correct\r\n            loc.start.line += line;\r\n            // loc.start.offset = -1;\r\n            loc.start.column = 3; // hack in order to simulate offset of beginning of the comment line => ' * '\r\n            loc.end.line = loc.start.line;\r\n            // loc.end.offset = loc.start.offset;\r\n            loc.end.column = loc.start.column + parts.join(' ').length;\r\n            handlers[ruleName](parts, ruleName, loc);\r\n        };\r\n        prologue && prologue();\r\n    };\r\n}\r\n\r\n\r\n// TODO: temp helper\r\nexport class CommentExtractor\r\n{\r\n    async parse(document: ITextDocument, includeResolver?: IncludeResolver)\r\n    {\r\n        const tokens = await exractComments(document, includeResolver);\r\n        tokens.forEach((commentToken: IToken) => {\r\n            let comment = commentToken.value.slice(2, -2);\r\n            let list = comment\r\n                .split('\\n')\r\n                .map(str => str.replace(/^\\s*\\*{1,2}\\s*|\\s*$/g, ''));\r\n    \r\n            let accum: string[] = [];\r\n            let lastRule: { line: number, content: string } = null;\r\n            let content: string;\r\n            let rules: { line: number, content: string }[] = [];\r\n            let line = -1;\r\n            while (list.length) {\r\n                line++;\r\n    \r\n                [content, list] = [list[0], list.slice(1)];\r\n    \r\n                if (content.match(/^\\s*$/g)) {\r\n                    continue;\r\n                }\r\n    \r\n                if (!content.match(/^@[\\w]+/g)) {\r\n                    accum.push(content);\r\n                    continue;\r\n                }\r\n    \r\n                if (lastRule) {\r\n                    rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line});\r\n                }\r\n    \r\n                lastRule = { content, line };\r\n            };\r\n    \r\n            if (lastRule && lastRule.content) {\r\n                rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line});\r\n            }\r\n    \r\n            this.beginComment(content);\r\n            for (let rule of rules) {\r\n                const { line, content } = rule;\r\n                const parts = content.split(' ');\r\n                const ruleName = parts[0].trim().toLowerCase();\r\n                const loc = cloneRange(commentToken.loc);\r\n    \r\n                // FIXME: dirty hack in order to make the range correct\r\n                loc.start.line += line;\r\n                // loc.start.offset = -1;\r\n                loc.start.column = 3; // hack in order to simulate offset of beginning of the comment line => ' * '\r\n                loc.end.line = loc.start.line;\r\n                // loc.end.offset = loc.start.offset;\r\n                loc.end.column = loc.start.column + parts.join(' ').length;\r\n                this.applyRule(ruleName, parts, loc);\r\n            };\r\n            this.endComment();\r\n        });\r\n    }\r\n\r\n    beginComment(content: string)\r\n    {\r\n\r\n    }\r\n\r\n    applyRule(rule: string, parts: string[], loc: IRange)\r\n    {\r\n\r\n    }\r\n\r\n    endComment()\r\n    {\r\n\r\n    }\r\n}\r\n\r\n","export const END_POSITION               = 'END';                 // item, parser\r\nexport const T_EMPTY                    = 'EMPTY';               // item, parser\r\nexport const UNKNOWN_TOKEN              = 'UNKNOWN';             // lexer\r\nexport const START_SYMBOL               = 'S';                   // parser\r\nexport const UNUSED_SYMBOL              = '##';                  // parser\r\nexport const INLINE_COMMENT_SYMBOL      = '#';                   // parser\r\n// TODO: do not use ambigious name 'ERROR'\r\nexport const ERROR                      = 'ERROR';               // parser\r\nexport const END_SYMBOL                 = '$';                   // lexer, parser\r\nexport const LEXER_RULES                = '--LEXER--';           // parser\r\nexport const FLAG_RULE_CREATE_NODE      = '--add';                // parser\r\nexport const FLAG_RULE_SKIP_NODE        = '--skip';              // parser\r\nexport const FLAG_RULE_EXPOSE_NODE      = '--expose';            // parser\r\nexport const FLAG_RULE_FUNCTION         = '--F';                 // parser\r\nexport const EOF                        = 'EOF';                 // lexer\r\nexport const T_STRING                   = 'T_STRING';            // lexer\r\nexport const T_FLOAT                    = 'T_FLOAT';             // lexer\r\nexport const T_UINT                     = 'T_UINT';              // lexer\r\nexport const T_TYPE_ID                  = 'T_TYPE_ID';           // lexer\r\nexport const T_NON_TYPE_ID              = 'T_NON_TYPE_ID';       // lexer\r\nexport const T_LINE_TERMINATOR          = 'T_LINE_TERMINATOR';   // lexer\r\n\r\nexport const T_MACRO                    = 'T_MACRO';             // lexer '#define', '#ifdef' etc.\r\nexport const T_MACRO_CONCAT             = 'T_MACRO_CONCAT';      // lexer '##'\r\n","import { assert } from \"@lib/common\";\r\nimport { IPosition, IRange } from \"@lib/idl/parser/IParser\";\r\n\r\nexport function positionMin(a: IPosition, b: IPosition): IPosition {\r\n    assert(a.file === b.file);\r\n    return {\r\n        offset: Math.min(a.offset, b.offset),\r\n        line: Math.min(a.line, b.line),\r\n        column: Math.min(a.column, b.column),\r\n        file: a.file\r\n    };\r\n}\r\n\r\nexport function positionMax(a: IPosition, b: IPosition): IPosition {\r\n    assert(a.file === b.file);\r\n    return {\r\n        offset: Math.max(a.offset, b.offset),\r\n        line: Math.max(a.line, b.line),\r\n        column: Math.max(a.column, b.column),\r\n        file: a.file\r\n    };\r\n}\r\n\r\n\r\nexport function cloneRange(range: IRange): IRange {\r\n    return { start: { ...range.start }, end: { ...range.end } };\r\n}\r\n\r\n// export function extendRange(parent: IRange, child: IRange): IRange {\r\n//     if (child.start.file !== parent.start.file) {\r\n//         return parent;\r\n//     }\r\n\r\n//     assert(parent.end.file === child.end.file);\r\n\r\n//     if (child.start.line < parent.start.line) {\r\n        \r\n//         parent.start.column = child.start.column;\r\n//         parent.start.line = child.start.line;\r\n//         parent.start.file = child.start.file;\r\n//         parent.start.offset = child.start.offset;\r\n\r\n//     } else if (child.start.line === parent.start.line) {\r\n//         // parent.start = positionMin(child.start, parent.start);\r\n\r\n//         parent.start.column = Math.min(child.start.column, parent.start.column);\r\n//         parent.start.line = Math.min(child.start.line, parent.start.line);\r\n//         parent.start.offset = Math.min(child.start.offset, parent.start.offset);\r\n//     }\r\n\r\n//     if (child.end.line > parent.end.line) {\r\n\r\n//         parent.end.column = child.end.column;\r\n//         parent.end.line = child.end.line;\r\n//         parent.end.file = child.end.file;\r\n//         parent.end.offset = child.end.offset;\r\n\r\n//     } else if (child.end.line === parent.end.line) {\r\n//         // parent.end = positionMax(child.end, parent.end);\r\n\r\n//         parent.end.column = Math.max(child.end.column, parent.end.column);\r\n//         parent.end.line = Math.max(child.end.line, parent.end.line);\r\n//         parent.end.offset = Math.max(child.end.offset, parent.end.offset);\r\n//     }\r\n\r\n//     return parent;\r\n// }\r\n\r\nexport function extendRange(parent: IRange, child: IRange): IRange {\r\n    if (child.start.file !== parent.start.file) {\r\n        return parent;\r\n    }\r\n\r\n    if (child.start.line < parent.start.line) {\r\n        parent.start = { ...child.start };\r\n    } else if (child.start.line === parent.start.line) {\r\n        parent.start = positionMin(child.start, parent.start);\r\n    }\r\n\r\n    if (child.end.line > parent.end.line) {\r\n        parent.end = { ...child.end };\r\n    } else if (child.end.line === parent.end.line) {\r\n        parent.end = positionMax(child.end, parent.end);\r\n    }\r\n\r\n    return parent;\r\n}\r\n\r\nexport function commonRange(...rangeList: IRange[]): IRange {\r\n    const MAX_I32 = Number.MAX_SAFE_INTEGER;\r\n    const MIN_I32 = Number.MIN_SAFE_INTEGER;\r\n\r\n    const file = rangeList[0].start.file;\r\n\r\n    let start: IPosition = { offset: MAX_I32, column: MAX_I32, line: MAX_I32, file };\r\n    let end: IPosition = { offset: MIN_I32, column: MIN_I32, line: MIN_I32, file };\r\n\r\n    rangeList.forEach(range => start = positionMin(start, range.start));\r\n    rangeList.forEach(range => end = positionMax(end, range.end));\r\n\r\n    return { start, end };\r\n}\r\n\r\nexport function offset(source: IRange, offset: IPosition): IRange {\r\n    if (offset) {\r\n        // TODO: check that URIs the same\r\n        const { start, end } = source;\r\n\r\n        if (start.line === 0) {\r\n            start.column += offset.column;\r\n        }\r\n\r\n        if (end.line === 0) {\r\n            end.column += offset.column;\r\n        }\r\n\r\n        start.line += offset.line;\r\n        end.line += offset.line;\r\n    }\r\n\r\n    return source;\r\n}\r\n\r\nexport const checkRange = (range: IRange, offset: number) => range.start.offset <= offset && range.end.offset > offset;\r\n\r\n// export function stringifyRange(range: IRange, depth = 0) {\r\n//     if (!range) {\r\n//         return '';\r\n//     }\r\n\r\n//     const offset = Array(depth).fill('---').join('') + (depth? ' ' : '');\r\n//     const { start, end, source } = range;\r\n//     const filename = String(start.file).split('/').reverse()[0];\r\n//     return `${offset}${filename}:${start.line}:${start.column}-${end.line}:${end.column}\\n${stringifyRange(source, depth + 1)}`;\r\n// } \r\n","import { isString, isDef, isNull } from \"../common\";\r\n\r\nclass Pathinfo {\r\n    private _dirname: string = null;\r\n    private _extension: string = null;\r\n    private _filename: string = null;\r\n\r\n    get path(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    set path(path: string) {\r\n        this.set(path);\r\n    }\r\n\r\n    get dirname(): string {\r\n        return this._dirname;\r\n    }\r\n\r\n    set dirname(dirname: string) {\r\n        this._dirname = dirname;\r\n    }\r\n\r\n    get filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    set filename(filename: string) {\r\n        this._filename = filename;\r\n    }\r\n\r\n    get ext(): string {\r\n        return this._extension;\r\n    }\r\n\r\n    set ext(extension: string) {\r\n        this._extension = extension;\r\n    }\r\n\r\n    get basename(): string {\r\n        return (this._filename ? this._filename + (this._extension ? \".\" + this._extension : \"\") : \"\");\r\n    }\r\n\r\n    set basename(basename: string) {\r\n        var nPos: number = basename.lastIndexOf(\".\");\r\n\r\n        if (nPos < 0) {\r\n            this._filename = basename.substr(0);\r\n            this._extension = null;\r\n        }\r\n        else {\r\n            this._filename = basename.substr(0, nPos);\r\n            this._extension = basename.substr(nPos + 1);\r\n        }\r\n    }\r\n\r\n\r\n    constructor(path: Pathinfo);\r\n    constructor(path: string);\r\n    constructor(path?: any) {\r\n        if (isDef(path)) {\r\n            this.set(<string>path);\r\n        }\r\n    }\r\n\r\n\r\n    set(path: string): void;\r\n    set(path: Pathinfo): void;\r\n    set(path?: any) {\r\n        if (isString(path)) {\r\n            var pParts: string[] = path.replace('\\\\', '/').split('/');\r\n\r\n            this.basename = (pParts.pop());\r\n\r\n            this._dirname = pParts.join('/');\r\n        }\r\n        else if (path instanceof Pathinfo) {\r\n            this._dirname = path.dirname;\r\n            this._filename = path.filename;\r\n            this._extension = path.ext;\r\n        }\r\n        else if (isNull(path)) {\r\n            return null;\r\n        }\r\n        else {\r\n            //critical_error\r\n            throw new Error(`Unexpected data type was used: ${path}`);\r\n        }\r\n    }\r\n\r\n    replaceExt(ext: string): Pathinfo\r\n    {\r\n        this.ext = ext;\r\n        return this;\r\n    }\r\n\r\n    isAbsolute(): boolean { return !!(this._dirname?.[0] === \"/\"); }\r\n\r\n\r\n    toString(): string {\r\n        return (this._dirname ? this._dirname + \"/\" : \"\") + (this.basename);\r\n    }\r\n}\r\n\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n    // if the path tries to go above the root, `up` ends up > 0\r\n    var up = 0;\r\n    for (var i = parts.length - 1; i >= 0; i--) {\r\n        var last = parts[i];\r\n        if (last === '.') {\r\n            parts.splice(i, 1);\r\n        } else if (last === \"..\") {\r\n            parts.splice(i, 1);\r\n            up++;\r\n        } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n        }\r\n    }\r\n\r\n    // if the path is allowed to go above the root, restore leading ..s\r\n    if (allowAboveRoot) {\r\n        for (; up--;) {\r\n            parts.unshift(\"..\");\r\n        }\r\n    }\r\n\r\n    return parts;\r\n}\r\n\r\n\r\nexport function normalize(path: string): string {\r\n    var info: Pathinfo = parse(path);\r\n    var isAbsolute: boolean = info.isAbsolute();\r\n    var tail: string = info.dirname;\r\n    var trailingSlash: boolean = /[\\\\\\/]$/.test(tail);\r\n\r\n    tail = normalizeArray(tail.split(/[\\\\\\/]+/).filter(function (p) {\r\n        return !!p;\r\n    }), !isAbsolute).join(\"/\");\r\n\r\n    if (tail && trailingSlash) {\r\n        tail += \"/\";\r\n    }\r\n\r\n    info.dirname = ((isAbsolute ? \"/\" : \"\") + tail);\r\n\r\n    return info.toString();\r\n}\r\n\r\nexport function parse(path: Pathinfo): Pathinfo;\r\nexport function parse(path: string): Pathinfo;\r\nexport function parse(path?): Pathinfo {\r\n    return new Pathinfo(path);\r\n}\r\n\r\nexport function dirname(path: string)\r\n{\r\n    return parse(path).dirname;\r\n}\r\n\r\nexport function ext(path)\r\n{\r\n    return parse(path).ext;\r\n}\r\n","import { isString, isNull, isDef } from \"../common\";\r\nimport * as path from \"../path/path\"\r\nimport { IDataURI } from \"../idl/IDataURI\";\r\n\r\nclass URI {\r\n    private _scheme: string = null;\r\n    private _userinfo: string = null;\r\n    private _host: string = null;\r\n    private _port: number = 0;\r\n    private _path: string = null;\r\n    private _query: string = null;\r\n    private _fragment: string = null;\r\n\r\n    get urn(): string {\r\n        return (this._path ? this._path : \"\") +\r\n            (this._query ? '?' + this._query : \"\") +\r\n            (this._fragment ? '#' + this._fragment : \"\");\r\n    }\r\n\r\n    get url(): string {\r\n        return (this._scheme ? this._scheme + '//' : \"\") + this.authority;\r\n    }\r\n\r\n    get authority(): string {\r\n        return (this._host ? (this._userinfo ? this._userinfo + '@' : \"\") +\r\n            this._host + (this._port ? ':' + this._port : \"\") : \"\");\r\n    }\r\n\r\n    get scheme(): string {\r\n        return this._scheme;\r\n    }\r\n\r\n    get protocol(): string {\r\n        if (!this._scheme) {\r\n            return this._scheme;\r\n        }\r\n\r\n        return (this._scheme.substr(0, this._scheme.lastIndexOf(':')));\r\n    }\r\n\r\n    get userInfo(): string {\r\n        return this._userinfo;\r\n    }\r\n\r\n    get host(): string {\r\n        return this._host;\r\n    }\r\n\r\n    set host(sHost: string) {\r\n        //TODO: check host format\r\n        this._host = sHost;\r\n    }\r\n\r\n    get port(): number {\r\n        return this._port;\r\n    }\r\n\r\n    set port(iPort: number) {\r\n        this._port = iPort;\r\n    }\r\n\r\n    get path(): string {\r\n        return this._path;\r\n    }\r\n\r\n    set path(sPath: string) {\r\n        // debug_assert(!isNull(sPath.match(new RegExp(\"^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$\"))), \r\n        //     \"invalid path used: \" + sPath);\r\n        //TODO: check path format\r\n        this._path = sPath;\r\n    }\r\n\r\n    get query(): string {\r\n        //TODO: check query format\r\n        return this._query;\r\n    }\r\n\r\n    set query(sQuery: string) {\r\n        this._query = sQuery;\r\n    }\r\n\r\n    get fragment(): string {\r\n        return this._fragment;\r\n    }\r\n\r\n\r\n    constructor(uri: URI);\r\n    constructor(uri: string);\r\n    constructor(uri?) {\r\n        if (uri) {\r\n            this.set(uri);\r\n        }\r\n    }\r\n\r\n    set(uri: URI);\r\n    set(uri: string);\r\n    set(data?): URI {\r\n        if (isString(data)) {\r\n            var uri: RegExpExecArray = URI.uriExp.exec(<string>data);\r\n\r\n            console.assert(uri !== null, 'Invalid URI format used.\\nused uri: ' + data);\r\n\r\n            if (!uri) {\r\n                return null;\r\n            }\r\n\r\n            this._scheme = uri[1] || null;\r\n            this._userinfo = uri[2] || null;\r\n            this._host = uri[3] || null;\r\n            this._port = parseInt(uri[4]) || null;\r\n            this._path = uri[5] || uri[6] || null;\r\n            this._query = uri[7] || null;\r\n            this._fragment = uri[8] || null;\r\n\r\n            return this;\r\n\r\n        }\r\n        else if (data instanceof URI) {\r\n            return this.set(data.toString());\r\n        }\r\n\r\n        console.error('Unexpected data type was used.');\r\n\r\n        return null;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.url + this.urn;\r\n    }\r\n\r\n    //------------------------------------------------------------------//\r\n    //----- Validate a URI -----//\r\n    //------------------------------------------------------------------//\r\n    //- The different parts are kept in their own groups and can be recombined\r\n    //  depending on the scheme:\r\n    //  - http as $1://$3:$4$5?$7#$8\r\n    //  - ftp as $1://$2@$3:$4$5\r\n    //  - mailto as $1:$6?$7\r\n    //- groups are as follows:\r\n    //  1   == scheme\r\n    //  2   == userinfo\r\n    //  3   == host\r\n    //  4   == port\r\n    //  5,6 == path (5 if it has an authority, 6 if it doesn't)\r\n    //  7   == query\r\n    //  8   == fragment\r\n\r\n\r\n    private static uriExp: RegExp = new RegExp(\"^([a-z0-9+.-]+:)?(?:\\\\/\\\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\\\d*))?(\\\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$\", \"i\");\r\n\r\n    /*\r\n     composed as follows:\r\n     ^\r\n     ([a-z0-9+.-]+):                            #scheme\r\n     (?:\r\n     //                            #it has an authority:\r\n     (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?    #userinfo\r\n     ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)        #host\r\n     (?::(\\d*))?                        #port\r\n     (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?    #path\r\n     |\r\n     #it doesn't have an authority:\r\n     (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?    #path\r\n     )\r\n     (?:\r\n     \\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)    #query string\r\n     )?\r\n     (?:\r\n     #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)    #fragment\r\n     )?\r\n     $\r\n     */\r\n}\r\n\r\n\r\nfunction normalizeURIPath(file: URI): URI {\r\n    if (!isNull(file.path)) {\r\n        if (file.scheme === \"filesystem:\") {\r\n            var uri = parse(file.path);\r\n\r\n            uri.path = path.normalize(uri.path);\r\n            file.path = uri.toString();\r\n        }\r\n        else {\r\n            file.path = path.normalize(file.path);\r\n        }\r\n    }\r\n\r\n    return file;\r\n}\r\n\r\n\r\n\r\nexport function resolve(from: string, to: string = document.location.href): string {\r\n    var currentPath = parse(to);\r\n    var file = parse(from);\r\n    var dirname: string;\r\n\r\n    normalizeURIPath(file);\r\n    normalizeURIPath(currentPath);\r\n\r\n    if (!isNull(file.scheme) || !isNull(file.host) || path.parse(file.path).isAbsolute()) {\r\n        //another server or absolute path\r\n        return from;\r\n    }\r\n\r\n    dirname = path.parse(currentPath.path).dirname;\r\n    currentPath.path = dirname ? (dirname + \"/\" + from) : from;\r\n\r\n    return normalizeURIPath(currentPath).toString();\r\n}\r\n\r\n\r\nexport function parseDataURI(uri: string): IDataURI {\r\n    var re: RegExp = /^data:([\\w\\d\\-\\/]+)?(;charset=[\\w\\d\\-]*)?(;base64)?,(.*)$/;\r\n    var m: string[] = uri.match(re);\r\n\r\n    return {\r\n        //like [text/plain]\r\n        mediatype: m[1] || null,\r\n        //like [;charset=windows-1251]\r\n        charset: isString(m[2]) ? m[2].substr(9) : null,\r\n        //like [;base64]\r\n        base64: isDef(m[3]),\r\n        data: m[4] || null\r\n    };\r\n}\r\n\r\n\r\nexport function parse(uri: string | URI): URI {\r\n    return new URI(String(uri));\r\n}\r\n\r\n\r\nexport function currentScript(): HTMLScriptElement {\r\n    if (isDef(document['currentScript'])) {\r\n        return <HTMLScriptElement>document['currentScript'];\r\n    }\r\n\r\n    var scripts: HTMLCollectionOf<HTMLScriptElement> = document.getElementsByTagName(\"script\");\r\n    return scripts[scripts.length - 1];\r\n}\r\n\r\n\r\nexport function currentPath(): string {\r\n    var uri = parse(currentScript().src);\r\n    let dirname = path.parse(uri.path).dirname;\r\n    return uri.url + dirname + \"/\";\r\n}\r\n\r\n\r\nexport function here(): URI {\r\n    return new URI(document.location.href);\r\n}\r\n\r\n\r\nexport function fromLocalPath(filepath: string | ReturnType<typeof path.parse>) {\r\n    return `file:///${String(filepath).replaceAll('\\\\', '/')}`;\r\n}\r\n\r\nexport function toLocalPath(uri: string | URI): string {\r\n    return parse(uri).path?.substring(1) || '';\r\n}\r\n","import { isString } from \"@lib/common\";\r\nimport { EDiagnosticCategory, IDiagnosticEntry, IDiagnosticMessage, IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\n\r\nimport { IMap } from \"../idl/IMap\";\r\nimport { IPosition, IRange } from \"../idl/parser/IParser\";\r\n\r\nfunction locToString(loc: IPosition) {\r\n    return `${loc.line},${loc.column}`;\r\n}\r\n\r\n\r\nfunction rangeToString(range: IRange) {\r\n    return `${locToString(range.start)}:${locToString(range.end)}`;\r\n}\r\n\r\n\r\nfunction readKey(desc: Object, key: string) {\r\n    let keyParts: string[] = key.split('.');\r\n    if (keyParts.length > 1) {\r\n        return readKey(desc[keyParts[0]], keyParts.splice(1).join('.'));\r\n    }\r\n    return desc[keyParts[0]];\r\n}\r\n\r\n\r\nfunction fillPattern(pattern: string, desc: Object): string {\r\n    return pattern.replace(/{([a-zA-Z.]+)}/g, (match, key) => {\r\n        return readKey(desc, key);\r\n    });\r\n}\r\n\r\nexport class DiagnosticException<DESC_T> extends Error {\r\n    host: Diagnostics<DESC_T>;\r\n\r\n    constructor(host: Diagnostics<DESC_T>, mesg: IDiagnosticMessage) {\r\n        super(mesg.content);\r\n        Error.captureStackTrace(this, DiagnosticException);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Diagnostics <DESC_T>{\r\n    protected _name: string;\r\n    protected _codePrefix: string;\r\n    protected _entries: IDiagnosticEntry<DESC_T>[];\r\n\r\n    constructor(name: string, codePrefix: string) {\r\n        this._name = name;\r\n        this._codePrefix = (codePrefix || '').toUpperCase();\r\n        this.reset();\r\n    }\r\n\r\n    protected emitException(): void {\r\n        throw new DiagnosticException<DESC_T>(this, this.getLastError());\r\n    }\r\n\r\n    reset() {\r\n        this._entries = [];\r\n    }\r\n\r\n    resolve(): IDiagnosticReport {\r\n        let report: IDiagnosticReport = { errors: 0, warnings: 0, messages: [] };\r\n\r\n        for (let entry of this._entries) {\r\n            let message = this.resolveEntry(entry);\r\n\r\n            switch(message.category) {\r\n                case EDiagnosticCategory.k_Warning:\r\n                    report.warnings ++;\r\n                    break;\r\n                case EDiagnosticCategory.k_Error:\r\n                    report.errors ++;\r\n                    break;\r\n            }\r\n            report.messages.push(message);\r\n        }\r\n\r\n        return report;\r\n    }\r\n\r\n    private resolveEntry(entry: IDiagnosticEntry<DESC_T>): IDiagnosticMessage {\r\n        // let { category, desc } = entry;\r\n\r\n        // let categoryName = (EDiagnosticCategory[category]).toLowerCase();\r\n        let loc: string = null;\r\n        let range: IRange;\r\n        let start: IPosition;\r\n        let end: IPosition;\r\n        let file = this.resolveFilename(entry.category, entry.code, entry.desc);\r\n\r\n        if (range = this.resolveRange(entry.category, entry.code, entry.desc)) {\r\n            ({ start, end } = range);\r\n            loc = rangeToString(range);\r\n        } \r\n        else {\r\n            start = this.resolvePosition(entry.category, entry.code, entry.desc);\r\n            loc = locToString(start);\r\n        }\r\n\r\n        let content = `${this.resolveDescription(entry.code, entry.category, entry.desc)}`;\r\n        let code = `${this._codePrefix}${entry.code}`;\r\n        let category = entry.category;\r\n        return { code, category, content, file, start, end };\r\n    }\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: DESC_T): string {\r\n        return '[unknown]';\r\n    }\r\n\r\n    protected resolvePosition(category: EDiagnosticCategory, code: number, desc: DESC_T): IPosition {\r\n        return { file: null, line: 0, column: 0 };\r\n    }\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: DESC_T): IRange {\r\n        return null;\r\n    }\r\n\r\n    protected resolveDescription(code:number, category: EDiagnosticCategory, desc: DESC_T): string {\r\n        let diagMesgs = this.diagnosticMessages();\r\n        if (!diagMesgs) {\r\n            console.error(`Diagnostic messages of '${this._name}' not found.`);\r\n            return '[no description found]';\r\n        }\r\n\r\n        if (!diagMesgs[code]) {\r\n            return `[no description found for code '${code}']`;\r\n        }\r\n\r\n        if (isString(diagMesgs[code])) {\r\n            return fillPattern(<string>diagMesgs[code], desc);\r\n        }\r\n\r\n        return (<((desc: DESC_T) => string)>diagMesgs[code])(desc);\r\n    }\r\n\r\n    protected diagnosticMessages(): IMap<string | ((desc: DESC_T) => string)> {\r\n        return null;\r\n    }\r\n\r\n    error(code: number, desc: DESC_T) { \r\n        this._entries.push({ category: EDiagnosticCategory.k_Error, code, desc });\r\n    }\r\n\r\n    warning(code: number, desc: DESC_T) { \r\n        this._entries.push({ category: EDiagnosticCategory.k_Warning, code, desc });\r\n    }\r\n\r\n    // add error and emit an exception in order to interrupt processing\r\n    critical(code: number, desc: DESC_T) {\r\n        this.error(code, desc);\r\n        this.emitException();\r\n    }\r\n\r\n    prettyPrint(): string {\r\n        return null;//JSON.stringify(this._errors, null, '\\t');\r\n    }\r\n\r\n    hasErrors(): boolean {\r\n        return this._entries.filter(entry => entry.category === EDiagnosticCategory.k_Error).length > 0;\r\n    }\r\n\r\n    getLastError(): IDiagnosticMessage {\r\n        for (let i = this._entries.length - 1; i >= 0; --i) {\r\n            if (this._entries[i].category === EDiagnosticCategory.k_Error) {\r\n                return this.resolveEntry(this._entries[i]);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this._entries.length === 0;\r\n    }\r\n\r\n    static mergeReports(reportList: IDiagnosticReport[]): IDiagnosticReport {\r\n        let result: IDiagnosticReport = { errors: 0, warnings: 0, messages: [] };\r\n\r\n        reportList.forEach((report) => {\r\n            if (!report) return;\r\n            result.errors += report.errors;\r\n            result.warnings += report.warnings;\r\n            result.messages = result.messages.concat(report.messages);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    static stringify(report: IDiagnosticReport): string {\r\n        return report.messages.map(mesg => mesg.content).join('\\n');\r\n    }\r\n\r\n    static asRange(mesg: IDiagnosticMessage): IRange {\r\n        let range: IRange = { start: mesg.start, end: mesg.end };\r\n\r\n        if (!range.end) {\r\n            range.end = { ...range.start };\r\n        }\r\n\r\n        const { start, end } = range;\r\n\r\n        if (end.line == start.line && end.column == start.column) {\r\n            end.column +=1;\r\n        }\r\n\r\n        return range;\r\n    }\r\n}","class DistinctColor {\r\n    static list = [\r\n        0xe6194b, 0x3cb44b, 0xffe119, 0x4363d8, 0xf58231, 0x911eb4, \r\n        0x46f0f0, 0xf032e6, 0xbcf60c, 0xfabebe, 0x008080, 0xe6beff, \r\n        0x9a6324, 0xfffac8, 0x800000, 0xaaffc3, 0x808000, 0xffd8b1, \r\n        0x000075, 0x808080  //, 0xffffff, 0x000000\r\n    ];\r\n\r\n    private _curIdx: number;\r\n\r\n    constructor(idx = 0) {\r\n        this._curIdx = idx;\r\n    }\r\n\r\n\r\n    value(): number {\r\n        return this._curIdx;\r\n    }\r\n\r\n\r\n    pickNext(): number {\r\n        this._curIdx = (this._curIdx + 1) % DistinctColor.list.length;\r\n        return this.value();\r\n    }\r\n\r\n\r\n    toRGBAString() {\r\n        return DistinctColor.toRGBAString(DistinctColor.resolveColor(this.value()));\r\n    }\r\n\r\n\r\n    static resolveColor(idx: number) {\r\n        return DistinctColor.list[idx % DistinctColor.list.length];\r\n    }\r\n\r\n\r\n    static toRGBAString(val: number) {\r\n        let r = ((val >> 16) & 0xff);\r\n        let g = ((val >> 8) & 0xff);\r\n        let b = ((val >> 0) & 0xff);\r\n        return `rgb(${r}, ${g}, ${b})`;\r\n    }\r\n    \r\n\r\n    static make(idx: number) {\r\n        return new DistinctColor(idx);\r\n    }\r\n\r\n    static buildVariousClasses(prefix = 'dc') {\r\n        return DistinctColor.list.reduce((styles, color) => (\r\n            styles[`${prefix}_${color}`] = { \r\n                opacity: 0.3, \r\n                backgroundColor: `${DistinctColor.toRGBAString(color)}`\r\n            }, styles), {});\r\n\r\n        // [`dc_${0xe6194b}`]: { opacity: 0.3, backgroundColor: '#e6194b' },\r\n        // [`dc_${0x3cb44b}`]: { opacity: 0.3, backgroundColor: '#3cb44b' },\r\n        // ...\r\n        // ...\r\n        // [`dc_${0x000075}`]: { opacity: 0.3, backgroundColor: '#000075' },\r\n        // [`dc_${0x808080}`]: { opacity: 0.3, backgroundColor: '#808080' }\r\n    }\r\n}\r\n\r\nexport default DistinctColor;\r\n\r\n","import { isString } from \"@lib/common\";\r\n\r\n// helper class to always pass strings by pointer and not by value;\r\nexport class StringRef {\r\n    constructor(readonly content: string) {\r\n\r\n    }\r\n\r\n    valueOf(): string {\r\n        return this.content;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.content;\r\n    }\r\n\r\n    toSource(): string {\r\n        return this.content;\r\n    }\r\n\r\n    static make(val: string | StringRef): StringRef {\r\n        if (!val) {\r\n            return null;\r\n        }\r\n\r\n        if (!isString(val)) {\r\n            if (val instanceof StringRef)\r\n                return <StringRef>val;\r\n            // IP: sometimes it can be useful to restore string ref after worker transfer and so on\r\n            if (isString(val['content']))\r\n                return StringRef.make(val['content']);\r\n        }\r\n\r\n        const sval = val as string;\r\n        \r\n        let ref = StringRef.storage[sval];\r\n        if (ref) {\r\n            return ref;\r\n        }\r\n\r\n        ref = new StringRef(sval);\r\n        StringRef.storage[sval] = ref;\r\n        return ref;\r\n    }\r\n\r\n    static storage: { [val: string]: StringRef; } = {};\r\n}\r\n\r\n","import { exec } from \"child_process\";\r\nimport * as React from \"react\";\r\n// import { Button, OverlayTrigger, Tooltip } from 'react-bootstrap';\r\n\r\n\r\nimport p4 from 'node-perforce';\r\n\r\n\r\nexport function run(command: string, done?: (e: Error, stdout: string) => void): Promise<any>;\r\nexport function run(command: string, args: string, done?: (e: Error, stdout: string) => void): Promise<any>;\r\nexport function run(command: string, args?, done?): Promise<any> {\r\n    if (typeof args === \"function\") {\r\n        done = args;\r\n        args = \"\";\r\n    }\r\n\r\n    let p4cmd = '\"C:\\\\Program Files\\\\Perforce\\\\p4.exe\"';\r\n\r\n    done = done || ((e: Error, stdout: string) => { });\r\n\r\n    return new Promise((resolve, reject) => {\r\n        // console.log(p4cmd + \" \" + command + \" \" + (args || \"\"));\r\n        exec(p4cmd + \" \" + command + \" \" + (args || \"\"), (err, stdOut, stdErr) => {\r\n            if (err) {\r\n                reject(err);\r\n                return done(err);\r\n            }\r\n\r\n            if (stdErr) {\r\n                // reject(new Error(stdErr));\r\n                // return done(new Error(stdErr));\r\n                console.warn(stdErr);\r\n                // IP: handle properly\r\n            }\r\n\r\n            resolve(stdOut);\r\n            done(null, stdOut);\r\n        });\r\n    });\r\n}\r\n\r\nexport function edit(changelist, file, cb: () => void) {\r\n    if (changelist < 0) return cb();\r\n\r\n    p4.edit({ changelist: changelist, files: [file] }, function (err) {\r\n        if (err) {\r\n            // MessageBox('Error:: Could not add files to p4 changelist. See console for details.', { type: 'warning' });\r\n            return console.error(err);\r\n        }\r\n\r\n        cb();\r\n    });\r\n}\r\n\r\nexport function add(changelist, file, cb: () => void) {\r\n    p4.add({ changelist: changelist, files: [file] }, function (err) {\r\n        if (err) {\r\n            // MessageBox('Error:: Could not add files to p4 changelist. See console for details.', { type: 'warning' });\r\n            return console.error(err);\r\n        }\r\n\r\n        cb();\r\n    });\r\n}\r\n\r\nexport function createChangelist(description: string, cb: (changelist: number) => void) {\r\n    p4.changelist.create({ description: description }, (e, changelist) => {\r\n        if (e) {\r\n            // MessageBox('Error:: Could not create p4 changelist. See console for details.', { type: 'warning' });\r\n            cb(-1);\r\n            console.error(e);\r\n            return;\r\n        }\r\n\r\n        cb(changelist);\r\n    });\r\n}\r\n\r\nexport function revert(file: string, cb: () => void) {\r\n    p4.revert({files: [ file ]}, function(err) {\r\n        if (err) return console.log(err);\r\n        cb();\r\n    });\r\n}\r\n","import * as fs from \"fs\";\r\nimport * as path from \"path\";\r\nimport * as type from \"@lib/common\";\r\n\r\nfunction ReadFile(filename: string) {\r\n    return fs.readFileSync(filename, 'utf8');\r\n}\r\n\r\nfunction IsFileExists(filename: string) {\r\n    return fs.existsSync(filename);\r\n}\r\n\r\nfunction IsDirectory(filename: string) {\r\n    return fs.lstatSync(filename).isDirectory();\r\n}\r\n\r\nexport class ProjectEnv {\r\n    // static ApplicationSettingsTpl = \"scope/{0}\";\r\n    static DefaultProjectName = \".project\";\r\n    static DefaultSubprojectName = \".subproject\";\r\n    static LocalProjectSuffix = \"-local\";\r\n\r\n    props: Object = {};\r\n\r\n    constructor(projectPath: string) {\r\n        this.Load(projectPath);\r\n    }\r\n\r\n    Load(projectPath: string) {\r\n        this.LoadPrjenv(path.join(projectPath, ProjectEnv.DefaultProjectName));\r\n    }\r\n\r\n    static IsLocal(filename: string) {\r\n        return filename.substr(-ProjectEnv.LocalProjectSuffix.length) == ProjectEnv.LocalProjectSuffix;\r\n    }\r\n\r\n    static IsDefault(filename: string) {\r\n        return filename.substr(-ProjectEnv.DefaultProjectName.length) == ProjectEnv.DefaultProjectName;\r\n    }\r\n\r\n    private LoadPrjenv(filename: string) {\r\n        if (!IsFileExists(filename)) {\r\n            if (!ProjectEnv.IsLocal(filename)) {\r\n                console.error(`could not find project env file '${path.normalize(filename)}'`);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (IsDirectory(filename)) {\r\n            return this.LoadPrjenv(path.join(filename, ProjectEnv.DefaultSubprojectName));\r\n        }\r\n\r\n        if (ProjectEnv.IsDefault(filename)) {\r\n            this.props[`project-dir`] = path.dirname(filename);\r\n            this.props[`project-name`] = path.basename(this.props[`project-dir`]);\r\n        }\r\n\r\n        let prjenv = require(\"js-yaml\").load(ReadFile(filename));\r\n\r\n        if (!prjenv) {\r\n            console.error(`could not read prjenv: ${filename}`);\r\n            return;\r\n        }\r\n\r\n        this.ReadProperties(prjenv, this.props, filename);\r\n\r\n        if (!ProjectEnv.IsLocal(filename)) {\r\n            this.LoadPrjenv(filename + ProjectEnv.LocalProjectSuffix);\r\n        }\r\n    }\r\n\r\n    private ReadProperties(prjenv: Object, dest: Object, filename: string) {\r\n        if (!prjenv) {\r\n            return;\r\n        }\r\n\r\n        Object.keys(prjenv).forEach((propName: string) => {\r\n            if (propName == 'references') {\r\n                return;\r\n            }\r\n\r\n            let prop = prjenv[propName];\r\n\r\n            if (type.isString(prop) || type.isNumber(prop) || type.isBoolean(prop)) {\r\n                dest[propName] = prop;\r\n            } else if (type.isArray(prop)) {\r\n                dest[propName] = dest[propName] || [];\r\n\r\n                (prop as Array<any>).forEach((val: string) => {\r\n                    dest[propName].push(val);\r\n                });\r\n            } else {\r\n                // TODO: remove this workaround for scopes\r\n                if (propName == 'scope' && dest[propName]) {\r\n                    return;\r\n                }\r\n\r\n                dest[propName] = dest[propName] || {};\r\n                this.ReadProperties(prop, dest[propName], filename);\r\n            }\r\n        });\r\n\r\n        this.LoadReferences(prjenv, path.dirname(filename));\r\n    }\r\n\r\n    private LoadReferences(prjenv: Object, cwd: string) {\r\n        let references: Array<any> = prjenv['references'];\r\n\r\n        if (references) {\r\n            references.forEach((ref: any) => {\r\n                if (type.isString(ref)) {\r\n                    this.LoadPrjenv(path.join(cwd, ref));\r\n                } else if (type.isObject(ref)) {\r\n                    Object.keys(ref).forEach((refName: string) => {\r\n                        if (type.isString(ref[refName])) {\r\n                            let prjenvPath = path.join(cwd, ref[refName]);\r\n\r\n                            if (IsFileExists(prjenvPath))\r\n                            {\r\n                                // creating inner reference dir name\r\n                                this.props[`${refName}-dir`] = IsDirectory(prjenvPath) ? path.normalize(prjenvPath) : path.dirname(prjenvPath);\r\n                                this.LoadPrjenv(path.join(cwd, ref[refName]));\r\n                            } else {\r\n                                console.warn(`Reference '${prjenvPath}' is not found.`);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    Get(propName: string) {\r\n        // convert from 'root/subdir/path' to '$(root)/subdir/path'\r\n        let parts = propName.split(/[\\\\\\/]/);\r\n        parts[0] = `$(${parts[0]})`;\r\n        return this.Resolve(parts.join('/'));\r\n    }\r\n\r\n    private Resolve(val: any) {\r\n        if (type.isArray(val)) {\r\n            val = val.map((v: any) => {\r\n                return this.Resolve(v);\r\n            });\r\n            return val;\r\n        }\r\n\r\n        if (type.isObject(val)) {\r\n            Object.keys(val).forEach((key: string) => {\r\n                val[key] = this.Resolve(val[key]);\r\n            });\r\n            return val;\r\n        }\r\n\r\n        if (type.isNumber(val)) {\r\n            return val;\r\n        }\r\n\r\n        let parts = val.split(/[\\\\\\/]/);\r\n\r\n        // handle as path\r\n        if (parts.length > 1) {\r\n            let prop = this.ResolveObject(parts[0]);\r\n\r\n            // assemble as string path\r\n            if (type.isString(prop)) {\r\n                for (let i = 1; i < parts.length; ++i) {\r\n                    prop = path.join(prop, this.ResolveString(parts[i]));\r\n                }\r\n                return path.normalize(prop);\r\n            }\r\n\r\n            if (!prop) {\r\n                console.error(`could not resolve '${parts[0]}'`);\r\n                return val;\r\n            }\r\n\r\n            // load from object\r\n            for (let i = 1; i < parts.length; ++i) {\r\n                prop = prop[this.ResolveString(parts[i])];\r\n            }\r\n\r\n            return prop;\r\n        }\r\n\r\n        return this.ResolveObject(val);\r\n    }\r\n\r\n\r\n    private ResolveString(val: string) {\r\n        try {\r\n            return val.replace(/\\$\\(([\\w\\d\\-\\_]+)\\)/g, (match, propName: string) => {\r\n                let pices = propName.split('/');\r\n\r\n                let prop: any = this.props;\r\n                while (pices.length) {\r\n                    prop = prop[pices.shift()];\r\n                }\r\n\r\n                if (type.isString(prop) || type.isNumber(prop)) {\r\n                    return prop as string;\r\n                }\r\n\r\n                console.error(`could not resolve '${propName}' property`);\r\n                throw null;\r\n            });\r\n        } catch (e) { }\r\n\r\n        return val;\r\n    }\r\n\r\n    private ResolveObject(val: string) {\r\n        try {\r\n            let m = val.match(/^\\$\\(([\\w\\d\\-\\_]+)\\)$/);\r\n\r\n            if (m) {\r\n                return this.Resolve(this.props[m[1]]);\r\n            }\r\n\r\n            return this.ResolveString(val);\r\n        } catch (e) { }\r\n        return val;\r\n    }\r\n}\r\n\r\n","\r\nexport function isNull(x) { return x === null; }\r\nexport function isDef(x) { return x !== undefined; }\r\nexport function isDefAndNotNull(x) { return x != null; }\r\nexport function isString(x) { return typeof x === 'string'; }\r\nexport function isFunction(fn) { return typeof fn === \"function\"; }\r\nexport function isBoolean(x) { return x === !!x; }\r\nexport function isArray(x) { return typeof x === \"object\" && x instanceof Array; }\r\nexport function isObject(x) { return typeof x === \"object\" && x !== null && !isArray(x); }\r\nexport function isNumber(x) { return typeof x === \"number\"; }\r\nexport function isEmpty(x: any) {\r\n    if (x == null) {\r\n        return true;\r\n    }\r\n\r\n    if (typeof x !== \"object\") {\r\n        return false;\r\n    }\r\n\r\n    for (let key in x) {\r\n        if (x.hasOwnProperty(key)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function clone (obj: any): any {\r\n    var copy;\r\n\r\n    // Handle the 3 simple types, and null or undefined\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n\r\n    // Handle Array\r\n    if (obj instanceof Array) {\r\n        copy = [];\r\n        for (var i = 0, len = obj.length; i < len; i++) {\r\n            copy[i] = clone(obj[i]);\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    // Handle Object\r\n    if (obj instanceof Object) {\r\n        copy = {};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    throw new Error(\"Unable to copy obj! Its type isn't supported.\");\r\n}","export const SOURCE_FILE_REQUEST                    = 'source-file-request';\r\nexport const SOURCE_FILE_LOADED                     = 'source-file-loaded';\r\nexport const SOURCE_FILE_LOADING_FAILED             = 'source-file-loading-failed';\r\nexport const SOURCE_FILE_DROP_STATE                 = 'source-file-drop-state';\r\n\r\nexport const GRAMMAR_CONTENT_SPECIFIED              = 'grammar-content-specified';\r\nexport const PARSER_PARAMS_CHANGED                  = 'parser-params-changed';\r\nexport const PARSING_PARAMS_CHANGED                 = 'parsing-params-changed';\r\n\r\nexport const SOURCE_CODE_MODIFED                    = 'source-code-modified';\r\nexport const SOURCE_CODE_PARSING_COMPLETE           = 'source-code-parsing-complete';\r\nexport const SOURCE_CODE_ANALYSIS_COMPLETE          = 'source-code-analysis-complete';\r\nexport const SOURCE_CODE_ADD_MARKER                 = 'source-code-add-marker';\r\nexport const SOURCE_CODE_ADD_MARKER_BATCH           = 'source-code-add-marker-batch';\r\nexport const SOURCE_CODE_REMOVE_MARKER              = 'source-code-remove-marker';\r\nexport const SOURCE_CODE_REMOVE_MARKER_BATCH        = 'source-code-remove-marker-batch';\r\nexport const SOURCE_CODE_ADD_BREAKPOINT             = 'source-code-add-breakpoint';\r\nexport const SOURCE_CODE_REMOVE_BREAKPOINT          = 'source-code-remove-breakpoint';\r\nexport const SOURCE_CODE_SET_DEFINE                 = 'source-code-set-define';\r\nexport const SOURCE_CODE_REMOVE_DEFINE              = 'source-code-remove-define';\r\n\r\nexport const SOURCE_CODE_PREPROCESSING_COMPLETE     = 'source-code-preprocessing-complete';\r\n\r\nexport const DEBUGGER_COMPILE                       = 'debugger-compile';\r\nexport const DEBUGGER_START_DEBUG                   = 'debugger-start-debug';\r\n// cancel compilation or jut clean up all previous results from store\r\nexport const DEBUGGER_RESET                         = 'debugger-reset';\r\nexport const DEBUGGER_COLORIZE                      = 'debugger-colorize';\r\nexport const DEBUGGER_OPTIONS_CHANGED               = 'debugger-options-changed';\r\n\r\nexport const PLAYGROUND_TECHNIQUE_UPDATE            = 'playground-technique-update';\r\nexport const PLAYGROUND_SELECT_EFFECT               = 'playground-select-effect';\r\nexport const PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME    = 'playground-force-destroy-and-switch-technique-runtime-type';\r\nexport const PLAYGROUND_SWITCH_VM_RUNTIME           = 'playground-force-destroy-and-switch-vm-runtime';\r\nexport const PLAYGROUND_EFFECT_SAVE_REQUEST         = 'playground-effect-save-request';\r\nexport const PLAYGROUND_EFFECT_AUTOSAVE_REQUEST     = 'playground-effect-autosave-request';\r\nexport const PLAYGROUND_EFFECT_HAS_BEEN_SAVED       = 'playground-effect-has-been-saved';\r\nexport const PLAYGROUND_EFFECT_HAS_BEEN_DROPPED     = 'playground-effect-has-been-dropped';\r\nexport const PLAYGROUND_SET_OPTION_AUTOSAVE         = 'playground-set-option-autosave';\r\nexport const PLAYGROUND_SET_SHADER_FORMAT           = 'playground-set-shader-format';\r\n\r\nexport const GRAPH_LOADED                           = 'graph-loaded';                   // serialized content of graph has been provided\r\nexport const GRAPH_RESET                            = 'graph-reset';                    // nothing \r\nexport const GRAPH_COMPILE                          = 'graph-compile';                  // requst to generate and recompile (via default pipline with source content) code from graph\r\nexport const GRAPH_MODIFIED                         = 'graph-modified';                  \r\nexport const GRAPH_NODE_DOCS_PROVIDED               = 'graph-node-docs-provided';       // update floating docs of selected graph node\r\nexport const GRAPH_CHANGE_LAYOUT                    = 'graph-change-layout';            // update 'Part' structure\r\nexport const GRAPH_ADD_CONSTANT                     = 'graph-add-constant';\r\nexport const GRAPH_REMOVE_CONSTANT                  = 'graph-remove-constant';\r\nexport const GRAPH_SET_CONSTANT                     = 'graph-set-constant';\r\nexport const GRAPH_SET_CAPACITY                     = 'graph-set-capacity';\r\n\r\nexport const S3D_INIT_ENV                           = 's3d-init-env';\r\nexport const S3D_INIT_ENV_SUCCESSED                 = 's3d-init-env-successed';\r\nexport const S3D_INIT_ENV_FAILED                    = 's3d-init-env-failed';\r\nexport const S3D_CONNECT_P4                         = 's3d-connect-p4';\r\nexport const S3D_CONNECT_P4_SUCCESSED               = 's3d-connect-p4-successed';\r\n\r\nexport const DEPOT_UPDATE_REQUEST                   = 'depot-update-request';\r\nexport const DEPOT_UPDATE_COMPLETE                  = 'depot-update-complete';\r\n","import { MakeOptional } from '@lib/common';\r\nimport { EParserType } from '@lib/idl/parser/IParser';\r\nimport { store } from '@sandbox/store';\r\nimport IStoreState, { IDebuggerState, INodeConstant, IPlaygroundState } from '@sandbox/store/IStoreState';\r\nimport { bindActionCreators, Dispatch } from 'redux';\r\n\r\nimport * as evt from './ActionTypeKeys';\r\nimport { IMarkerDesc } from './ActionTypes';\r\n\r\nexport type IDispatch = Dispatch<any>;\r\nexport type IActionCreator = (dispatch: IDispatch, getState?: () => IStoreState) => Promise<any>;\r\n\r\nexport const parser = {\r\n    setGrammar(content: string) {\r\n        return { type: evt.GRAMMAR_CONTENT_SPECIFIED, payload: { content } };\r\n    },\r\n\r\n    setParams(type: EParserType, flags: number) {\r\n        return { type: evt.PARSER_PARAMS_CHANGED, payload: { type, flags } };\r\n    },\r\n\r\n    setParsingParams(flags: number) {\r\n        return { type: evt.PARSING_PARAMS_CHANGED, payload: { flags } };\r\n    }\r\n};\r\n\r\nexport const sourceCode = {\r\n    openFile(filename: string) {\r\n        return { type: evt.SOURCE_FILE_REQUEST, payload: { filename } };\r\n    },\r\n\r\n    setContent(content: string, filename?: string) {\r\n        return { type: evt.SOURCE_CODE_MODIFED, payload: { content, filename } };\r\n    },\r\n\r\n    // setContent (content): IActionCreator {\r\n    //     return async (dispatch: IDispatch, getState) => {\r\n    //         await dispatch({ type: evt.SOURCE_CODE_MODIFED, payload: { content } });\r\n    //         return getState();\r\n    //     };\r\n    // },\r\n\r\n    // IP: Just an incredible example of a AC power!!\r\n    // someRoutine (...argv): IActionCreator {\r\n    //     return async (dispatch: IDispatch, getState) => {\r\n    //         await dispatch({ type: 'some routine', payload: argv });\r\n    //         return getState();\r\n    //     };\r\n    // },\r\n\r\n    //\r\n    // markers api\r\n    //\r\n\r\n    addMarker(marker: IMarkerDesc) {\r\n        return { type: evt.SOURCE_CODE_ADD_MARKER, payload: marker };\r\n    },\r\n\r\n    removeMarker(name: string) {\r\n        return { type: evt.SOURCE_CODE_REMOVE_MARKER, payload: { name } };\r\n    },\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    addBreakpoint(line: number) {\r\n        return { type: evt.SOURCE_CODE_ADD_BREAKPOINT, payload: { line } }\r\n    },\r\n\r\n    removeBreakpoint(line: number) {\r\n        return { type: evt.SOURCE_CODE_REMOVE_BREAKPOINT, payload: { line } }\r\n    },\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    compile(query: string, type: 'expression' | 'pass' = 'expression') {\r\n        return { type: evt.DEBUGGER_COMPILE, payload: { query, type } };\r\n    },\r\n\r\n    specifyOptions(options: MakeOptional<IDebuggerState['options']>) {\r\n        return { type: evt.DEBUGGER_OPTIONS_CHANGED, payload: { options } };\r\n    },\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    resetDebugger() {\r\n        return { type: evt.DEBUGGER_RESET };\r\n    },\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    setDefine(name: string) {\r\n        return { type: evt.SOURCE_CODE_SET_DEFINE, payload: { name } };\r\n    },\r\n\r\n    removeDefine(name: string) {\r\n        return { type: evt.SOURCE_CODE_REMOVE_DEFINE, payload: { name } };\r\n    }\r\n};\r\n\r\nexport const playground = {\r\n    selectEffect(name: string) {\r\n        return { type: evt.PLAYGROUND_SELECT_EFFECT, payload: { name } };\r\n    },\r\n\r\n    switchRuntime() {\r\n        return { type: evt.PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME };\r\n    },\r\n\r\n    saveFileAs() {\r\n        return { type: evt.PLAYGROUND_EFFECT_SAVE_REQUEST, payload: {} };\r\n    },\r\n\r\n    setAutosave(enabled: boolean) {\r\n        return { type: evt.PLAYGROUND_SET_OPTION_AUTOSAVE, payload: { enabled } };\r\n    },\r\n\r\n    setShaderFormat(format: IPlaygroundState['shaderFormat']) {\r\n        return { type: evt.PLAYGROUND_SET_SHADER_FORMAT, payload: { format } };\r\n    }\r\n};\r\n\r\nexport const nodes = {\r\n    // is not being used at the moment\r\n    reset() {\r\n        return { type: evt.GRAPH_RESET, payload: {} };\r\n    },\r\n\r\n    // request full recompilationIGraph\r\n    recompile() {\r\n        return { type: evt.GRAPH_COMPILE, payload: {} };\r\n    },\r\n\r\n    changed() {\r\n        return { type: evt.GRAPH_MODIFIED, payload: {} };\r\n    },\r\n\r\n    load(content: string) {\r\n        return { type: evt.GRAPH_LOADED, payload: { content } };\r\n    },\r\n\r\n    provideNodeDocs(docs: string) {\r\n        return { type: evt.GRAPH_NODE_DOCS_PROVIDED, payload: { docs } };\r\n    },\r\n\r\n    changeLayout(layout: string) {\r\n        return { type: evt.GRAPH_CHANGE_LAYOUT, payload: { layout } };\r\n    },\r\n\r\n    addConstant(value: INodeConstant) {\r\n        return { type: evt.GRAPH_ADD_CONSTANT, payload: { value } }\r\n    },\r\n\r\n    removeConstant(name: string) {\r\n        return { type: evt.GRAPH_REMOVE_CONSTANT, payload: { name } }\r\n    },\r\n\r\n    setConstant(name: string, value: string) {\r\n        return { type: evt.GRAPH_SET_CONSTANT, payload: { name, value } }\r\n    },\r\n\r\n    setCapacity(value: number) {\r\n        return { type: evt.GRAPH_SET_CAPACITY, payload: { value } }\r\n    }\r\n}\r\n\r\nexport const s3d = {\r\n    initEnv(projectRoot) {\r\n        return { type: evt.S3D_INIT_ENV, payload: { projectRoot } };\r\n    }\r\n}\r\n\r\nexport const depot = {\r\n    rescan() {\r\n        return { type: evt.DEPOT_UPDATE_REQUEST, payload: {} };\r\n    }\r\n}\r\n\r\n// hack to avoid looped imports\r\nexport function nodesProvideDocs(docs: string) {\r\n    store.dispatch(nodes.provideNodeDocs(docs));\r\n}\r\n\r\n// hack to avoid looped imports\r\nexport function nodesForceRecompile() {\r\n    store.dispatch(nodes.recompile());\r\n}\r\n\r\nexport type mapDispatchToProps<T> = (dispatch: IDispatch) => { actions: any; $dispatch: IDispatch; $rowActions: T };\r\nexport function mapActions(actions): mapDispatchToProps<typeof actions> {\r\n    return (dispatch: IDispatch) => {\r\n        return {\r\n            actions: bindActionCreators(actions, dispatch),\r\n\r\n            // debug functionality\r\n            $dispatch: dispatch,\r\n            $rowActions: actions\r\n        };\r\n    };\r\n}\r\n","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { BoolInstruction } from \"@lib/fx/analisys/instructions/BoolInstruction\";\r\nimport { ConstructorCallInstruction } from \"@lib/fx/analisys/instructions/ConstructorCallInstruction\";\r\nimport { FloatInstruction } from \"@lib/fx/analisys/instructions/FloatInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\nimport { INodeInputSlot, INodeOutputSlot, LLink } from \"litegraph.js\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { types } from \"@lib/fx/analisys/helpers\";\r\n\r\n\r\nimport { CodeEmitterNode, LGraphNodeFactory, GraphContext } from \"./GraphNode\";\r\nimport { CastExprInstruction } from \"@lib/fx/analisys/instructions/CastExprInstruction\";\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const nodes = <LGraphNodeFactory>{};\r\n\r\n    [\r\n        'float', 'float2', 'float3', 'float4',\r\n        'half', 'half2', 'half3', 'half4',\r\n        'int', 'int2', 'int3', 'int4',\r\n        'uint', 'uint2', 'uint3', 'uint4',\r\n        'bool', 'bool2', 'bool3', 'bool4'\r\n    ].forEach(typeName => {\r\n        const match = typeName.match(/(float|half|bool|uint|int)(2|3|4)?/);\r\n        const desc = [typeName[0].toUpperCase(), ...typeName.slice(1)].join('');\r\n        const count = Number(match[2] || 1);\r\n        const type = match[1];\r\n\r\n        let prettify = (raw: number | boolean): any => {\r\n            const value = Number(raw);\r\n            switch (type) {\r\n                case 'bool': return !!value;\r\n                case 'uint': return value >>> 0;\r\n                case 'int': return value << 0;\r\n                default: return value;\r\n            }\r\n        };\r\n\r\n        class Node extends CodeEmitterNode {\r\n            static desc = desc;\r\n\r\n            private inputNames: string[] = [];\r\n\r\n            constructor() {\r\n                super(desc);\r\n                this.addOutput(\"out\", typeName);\r\n\r\n\r\n                [...'xyzw'].slice(0, count).forEach(name => {\r\n                    if (count == 1) {\r\n                        this.addInput(name, 'float,bool,int,uint,half');\r\n                    } else {\r\n                        this.addInput(name, type);\r\n                    }\r\n                    this.inputNames.push(name);\r\n\r\n                    if (type == 'bool')\r\n                        this.addProperty<Boolean>(name, false, 'boolean');\r\n                    else // int/uint/float/half\r\n                        this.addProperty<Number>(name, 0.0, 'number');\r\n                });\r\n                this.size = [180, 25 * count];\r\n            }\r\n\r\n            override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n                return [...Array(count).keys()].map(i => \r\n                    this.getInputNode(i)?.compute(context, program) || []).flat();\r\n            }\r\n\r\n            override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n                const sourceNode = null as IParseNode;\r\n                const scope = program.currentScope;\r\n                const type = scope.findType(typeName);\r\n\r\n                const ctor = new VariableTypeInstruction({ type, scope: null });\r\n                const args = [...Array(count).keys()].map(i => {\r\n                    const input = this.getInputNode(i);\r\n                    const name = this.inputNames[i];\r\n                    if (!input) {\r\n                        switch (match[1]) {\r\n                            case 'bool':\r\n                                return new BoolInstruction({ scope, sourceNode, value: !!this.properties[name] });\r\n                            default:\r\n                                return new FloatInstruction({ scope, sourceNode, value: prettify(this.properties[name]) })\r\n                        }\r\n                    }\r\n                    return input.exec(context, program, this.getOriginalSlot(i));\r\n                });\r\n                // avoid float(float(t)) expressions\r\n                if (count == 1) {\r\n                    if (types.equals(type, args[0].type)) {\r\n                        return args[0];\r\n                    }\r\n                }\r\n                return new ConstructorCallInstruction({ scope, sourceNode, ctor, args });\r\n            }\r\n\r\n            updateInputNames() {\r\n                for (let i in this.inputs) {\r\n                    let input = this.inputs[i];\r\n                    input.name = !input.link ? `${this.inputNames[i]} = ${prettify(this.properties[this.inputNames[i]])}` : this.inputNames[i];\r\n                }\r\n            }\r\n\r\n            onConnectionsChange(type: number, slotIndex: number, isConnected: boolean, link: LLink, ioSlot: INodeInputSlot | INodeOutputSlot): void {\r\n                super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);\r\n                this.updateInputNames();\r\n            }\r\n\r\n            onPropertyChanged(name: string, value: number, prevValue: number): boolean {\r\n                super.onPropertyChanged(name, value, prevValue);\r\n                this.updateInputNames();\r\n                return true;\r\n            }\r\n\r\n            getDocs(): string {\r\n                return `Constructor of ${typeName}() type.`\r\n            }\r\n\r\n            getTitle(): string {\r\n                if (this.flags.collapsed && this.inputs.filter(i => i.link).length === 0) {\r\n                    return `(${this.inputNames.map(name => prettify(this.properties[name])).join(' ,')})`;\r\n                }\r\n                return super.getTitle();\r\n            }\r\n        }\r\n\r\n        nodes[`constructors/${typeName}`] = Node;\r\n\r\n        class Cast extends CodeEmitterNode {\r\n            static desc = `${desc} (cast)`;\r\n\r\n            private inputNames: string[] = [];\r\n\r\n            constructor() {\r\n                super(desc);\r\n                this.addOutput(\"out\", typeName);\r\n                this.addInput('x', 'float,bool,int,uint,half'.split(',').map(x => `${x}${count}`).join(','));\r\n                this.size = this.computeSize();\r\n            }\r\n\r\n            override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n                return this.getInputNode(0)?.compute(context, program);\r\n            }\r\n\r\n            override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n                const scope = program.currentScope;\r\n                const type = scope.findType(typeName);\r\n                const sourceExpr = this.getInputNode(0).exec(context, program, this.getOriginalSlot(0));\r\n                if (types.equals(sourceExpr.type, type)) {\r\n                    return sourceExpr;\r\n                }\r\n                return new CastExprInstruction({ scope, sourceExpr, type });\r\n            }\r\n\r\n            getDocs(): string {\r\n                return `Cast to ${typeName}() type.`\r\n            }\r\n\r\n            // getTitle(): string {\r\n            //     if (this.flags.collapsed && this.inputs.filter(i => i.link).length === 0) {\r\n            //         return `(${this.inputNames.map(name => prettify(this.properties[name])).join(' ,')})`;\r\n            //     }\r\n            //     return super.getTitle();\r\n            // }\r\n        }\r\n\r\n        nodes[`constructors/${typeName} (cast)`] = Cast;\r\n    });\r\n\r\n    return nodes;\r\n}\r\n\r\nexport default producer;","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { IdExprInstruction } from \"@lib/fx/analisys/instructions/IdExprInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { PostfixPointInstruction } from \"@lib/fx/analisys/instructions/PostfixPointInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { extendSLDocument } from \"@lib/fx/SLDocument\";\r\nimport { createTextDocument } from \"@lib/fx/TextDocument\";\r\nimport { EInstructionTypes, IExprInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\nimport { INodeInputSlot, INodeOutputSlot, LiteGraph, LLink } from \"litegraph.js\";\r\n\r\n\r\nimport { PART_LOCAL_NAME, PART_TYPE } from \"./common\";\r\nimport { CodeEmitterNode, GraphContext, LGraphNodeFactory } from \"./GraphNode\";\r\n\r\n/** @deprecated */\r\nfunction asGraphContext(ctx: Context): GraphContext\r\n{\r\n    // temp hack for compartibility\r\n    let varNum = 0;\r\n    (<any>ctx).addLocal = () => `t${varNum++}`;\r\n    return ctx as GraphContext;\r\n}\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory\r\n{\r\n    class Node extends CodeEmitterNode {\r\n        static desc = 'Decomposer';\r\n\r\n        constructor() \r\n        {\r\n            super('Decomposer');\r\n            this.addInput('in', null);\r\n            this.size = [ 180, 25 ];\r\n        }\r\n\r\n        override exec(context: GraphContext, program: ProgramScope, slot: number): IExprInstruction\r\n        {\r\n            const name = this.getOutputInfo(slot).name;\r\n            const element = this.getInputNode(0).exec(context, program, this.getOriginalSlot(0));  \r\n            const scope = program.currentScope;\r\n            const decl = element.type.getField(name);\r\n            const id = new IdInstruction({ scope, name });\r\n            const postfix = new IdExprInstruction({ scope, id, decl });\r\n            return new PostfixPointInstruction({ scope, element, postfix });\r\n        }\r\n\r\n        onConnectInput(inputIndex: number, outputType: string | -1, outputSlot: INodeOutputSlot, outputNode: CodeEmitterNode, outputIndex: number): boolean \r\n        {\r\n            const self = this;\r\n            async function wrapper () {\r\n                // part argument has been added in order to handle corner case related to 'fx' pipeline\r\n                const source = `auto anonymous(${PART_TYPE} ${PART_LOCAL_NAME}, int partId) { return ($complexExpr); }`;\r\n                const textDocument = await createTextDocument(`://decompose-node`, source);\r\n\r\n                let type: ITypeInstruction = null;\r\n                \r\n                // quick analisys inside of virtual enviroment in order to compute on fly expression type\r\n                let documentEx = await extendSLDocument(textDocument, env(), {\r\n                    $complexExpr: (context, program, sourceNode): IExprInstruction => {\r\n                        const gctx = asGraphContext(context);\r\n                        outputNode.onBeforeExecution(gctx, program);\r\n                        outputNode.compute(gctx, program);\r\n                        const expr = outputNode.exec(context, program, outputIndex);\r\n                        type = expr.type;\r\n                        return expr;\r\n                    }\r\n                });\r\n\r\n                if (documentEx.diagnosticReport.errors) {\r\n                    console.error(Diagnostics.stringify(documentEx.diagnosticReport));\r\n                    \r\n                }\r\n                if (type.isComplex()) {\r\n                    type.fields.forEach(field => self.addOutput(field.name, field.type.name));\r\n                    return true;\r\n                }\r\n\r\n                // IP: probably not really valid hack to handle variable decl type\r\n                if (!type.isNotBaseArray() && \r\n                type.baseType.instructionType === EInstructionTypes.k_SystemType) {\r\n\r\n                    type = type.baseType;\r\n                }\r\n\r\n                // corner case for system types    \r\n                if (type.instructionType === EInstructionTypes.k_SystemType)\r\n                {\r\n                    const match = type.name.match(/(float|half|bool|uint|int)(2|3|4)/);\r\n                    if (match)\r\n                    {\r\n                        [...'xyzw'].slice(0, Number(match[2])).forEach(name => self.addOutput(name, match[1]));\r\n                        return true;\r\n                    }            \r\n                }\r\n\r\n                console.error(`unsupported type for decomposition '${type.name}'`);\r\n                self.dropInput();\r\n                return false;\r\n            }\r\n\r\n            wrapper();\r\n            return true;\r\n        }\r\n\r\n        dropInput()\r\n        {\r\n            this.disconnectInput(0);\r\n        }\r\n\r\n        dropOutputs()\r\n        {\r\n            while (this.outputs.length)\r\n            {\r\n                this.disconnectOutput(0);\r\n                this.removeOutput(0);\r\n            } \r\n        }\r\n\r\n        onConnectionsChange( \r\n            type: number,\r\n            slotIndex: number,\r\n            isConnected: boolean,\r\n            link: LLink,\r\n            ioSlot: (INodeOutputSlot | INodeInputSlot))\r\n        {\r\n            if (type == LiteGraph.INPUT && !isConnected)\r\n            {\r\n                this.dropOutputs();\r\n            }\r\n        }\r\n\r\n        onBeforeConnectInput(inputIndex: number): number\r\n        {\r\n            this.dropOutputs();\r\n            return inputIndex;\r\n        }\r\n\r\n        getTitle(): string {\r\n            let outs = this.outputs.filter(out => out.links?.length);\r\n            if (this.inputs.length && outs.length === 1)\r\n            {\r\n                return `*.${outs[0].name}`;\r\n            }\r\n            return super.getTitle();\r\n        }\r\n\r\n        getDocs(): string {\r\n            return 'Auxiliary node to decompose complex ty to components.';\r\n        }\r\n    }\r\n\r\n    return { [`helpers/decomposer`]: Node };\r\n}\r\n\r\nexport default producer;\r\n","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { FloatInstruction } from \"@lib/fx/analisys/instructions/FloatInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IWidget, LGraphCanvas } from \"litegraph.js\";\r\n\r\nimport { CodeEmitterNode, LGraphNodeFactory } from \"./GraphNode\";\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    class Float extends CodeEmitterNode {\r\n        static desc = \"Float\";\r\n\r\n        private widget: IWidget;\r\n\r\n        constructor() {\r\n            super(\"Float\");\r\n            this.addOutput(\"value\", \"float\");\r\n            this.addProperty<Number>(\"value\", 0.0, \"number\");\r\n            this.widget = this.addWidget(\"number\", \"value\", 0, \"value\", { precision: 5 });\r\n            this.widgets_up = true; // draw number widget in the middle of node (by default it's placed under node)\r\n            this.size = this.computeSize();\r\n        }\r\n\r\n        override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n            const scope = program.currentScope;\r\n            return new FloatInstruction({ scope, value: Number(Number(this.properties[\"value\"]).toFixed(3)) });\r\n        }\r\n\r\n        override getTitle(): string {\r\n            if (this.flags.collapsed) {\r\n                return this.properties.value.toFixed(2);\r\n            }\r\n            return super.getTitle();\r\n        }\r\n\r\n        onDrawBackground(ctx: CanvasRenderingContext2D, graphcanvas: LGraphCanvas, canvas, mouse): void {\r\n            super.onDrawBackground(ctx, graphcanvas, canvas, mouse);\r\n            this.outputs[0].label = this.properties[\"value\"].toFixed(2);\r\n        }\r\n    }\r\n\r\n    return { [`constants/float`]: Float };\r\n}\r\nexport default producer;\r\n","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { FunctionCallInstruction } from \"@lib/fx/analisys/instructions/FunctionCallInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction, IFunctionDeclInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\n\r\n\r\nimport { AST, CodeEmitterNode, GraphContext, LGraphNodeFactory } from \"./GraphNode\";\r\n\r\n\r\ninterface INodeDesc {\r\n    func: IFunctionDeclInstruction;\r\n    desc: string;\r\n    name: string;\r\n    inputs: { name: string, type: string }[];\r\n    outputs: { name: string, type: string }[];\r\n}\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory\r\n{\r\n\r\n    const nodes = <LGraphNodeFactory>{};\r\n\r\n    function loadLibrary(slDocument: ISLDocument) {\r\n        let scope = slDocument.root.scope; // scope => current global scope, scope.parent => system scope\r\n\r\n        let nodes: INodeDesc[] = [];\r\n\r\n        while (scope) {\r\n            for (let [name, funcList] of Object.entries(scope.functions)) {\r\n                for (let func of funcList) {\r\n                    let isSupported = func.def.params.every(p => p.type.usages.every(u => u != \"inout\" && u != \"out\" && u != \"uniform\"));\r\n                    if (!isSupported) {\r\n                        continue;\r\n                    }\r\n\r\n                    let inputs = func.def.params.map(p => ({ name: p.id.name, type: p.type.name }));\r\n                    let outputs = [{ name: 'out', type: func.def.returnType.name }];\r\n                    let desc = func.def.toCode();\r\n                    let name = func.def.id.name;\r\n                    nodes.push({ func, name, desc, inputs, outputs });\r\n                }\r\n            }\r\n\r\n            scope = scope.parent;\r\n        }\r\n\r\n        return nodes;\r\n    }\r\n\r\n    function autogenNode(node: INodeDesc) {\r\n        class Node extends CodeEmitterNode {\r\n            static desc = node.desc;\r\n            constructor() {\r\n                super(node.name);\r\n                node.inputs.forEach(i => this.addInput(i.name, i.type));\r\n                node.outputs.forEach(o => this.addOutput(o.name, o.type));\r\n                this.size = [180, 25 * Math.max(node.inputs.length, node.outputs.length)];\r\n            }\r\n\r\n            override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n                if (this.locals || \r\n                    !this.inputs.every((x, i) => this.isInputConnected(i))) {\r\n                    return [];\r\n                }\r\n\r\n                const deps = super.compute(context, program);\r\n                const scope = program.currentScope;\r\n                const decl = node.func;\r\n                const type = decl.def.returnType;\r\n                const args = node.inputs\r\n                    .map((V, i) => this.getInputNode(i)?.exec(context, program, this.getOriginalSlot(i))) || null;\r\n                const expr = new FunctionCallInstruction({ scope, type, decl, args });\r\n\r\n                return [ ...deps, ...this.addLocal(context, program, type.name, expr) ];\r\n            }\r\n    \r\n\r\n            override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n                if (!this.locals)\r\n                    return null;\r\n                return AST(context, program).idexpr(this.locals[slot]);\r\n            }\r\n        }\r\n\r\n        nodes[`functions/${node.desc}`] = Node;\r\n    }\r\n\r\n    loadLibrary(env()).forEach(node => autogenNode(node));\r\n    return nodes;\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { isNull, isString } from \"@lib/common\";\r\nimport { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { FxContext } from \"@lib/fx/analisys/FxAnalyzer\";\r\nimport { AssignmentExprInstruction } from \"@lib/fx/analisys/instructions/AssignmentExprInstruction\";\r\nimport { BoolInstruction } from \"@lib/fx/analisys/instructions/BoolInstruction\";\r\nimport { ConstructorCallInstruction } from \"@lib/fx/analisys/instructions/ConstructorCallInstruction\";\r\nimport { DeclStmtInstruction } from \"@lib/fx/analisys/instructions/DeclStmtInstruction\";\r\nimport { ExprStmtInstruction } from \"@lib/fx/analisys/instructions/ExprStmtInstruction\";\r\nimport { FloatInstruction } from \"@lib/fx/analisys/instructions/FloatInstruction\";\r\nimport { FunctionDeclInstruction } from \"@lib/fx/analisys/instructions/FunctionDeclInstruction\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdExprInstruction } from \"@lib/fx/analisys/instructions/IdExprInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { PostfixPointInstruction } from \"@lib/fx/analisys/instructions/PostfixPointInstruction\";\r\nimport { ReturnStmtInstruction } from \"@lib/fx/analisys/instructions/ReturnStmtInstruction\";\r\nimport { StmtBlockInstruction } from \"@lib/fx/analisys/instructions/StmtBlockInstruction\";\r\nimport { VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { parseUintLiteral } from \"@lib/fx/analisys/system/utils\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EInstructionTypes, EScopeType, IDeclInstruction, IExprInstruction, IFunctionDeclInstruction, IIdInstruction, IStmtInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { nodesForceRecompile, nodesProvideDocs } from \"@sandbox/actions\";\r\nimport { INodeInputSlot, INodeOutputSlot, LGraphCanvas, LGraphNode, LiteGraph, LLink } from \"litegraph.js\";\r\n\r\nexport type LGraphNodeFactory = IMap<new () => LGraphNode>;\r\n\r\n\r\nexport class GraphContext extends FxContext {\r\n    varNum = 0;\r\n\r\n    addLocal() { return `t${this.varNum++}`; }\r\n}\r\n\r\nexport interface INodeDocs {\r\n    name: string;\r\n    desc?: string;\r\n    title?: string;\r\n    params?: any;\r\n}\r\n\r\nexport const AST = <T extends Context>(context: T, program: ProgramScope) => ({\r\n\r\n    variable(name: string, typeName: string, usages = []): IVariableDeclInstruction {\r\n        const scope = program.currentScope;\r\n        const id = new IdInstruction({ scope, name });\r\n        const type = new VariableTypeInstruction({ scope, type: scope.findType(typeName), usages });\r\n        const varDecl = new VariableDeclInstruction({ scope, type, id });\r\n        scope.addVariable(varDecl);\r\n        return varDecl;\r\n    },\r\n\r\n    stmt(declList: IDeclInstruction[]): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        return new DeclStmtInstruction({ scope, declList });\r\n    },\r\n\r\n    assigment(left: IExprInstruction, right: IExprInstruction): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n\r\n        if (!right.type.readable) {\r\n            context.error(right.sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n        const expr = new AssignmentExprInstruction({ scope, left, right, operator: '=' });\r\n        return new ExprStmtInstruction({ scope, expr });\r\n    },\r\n\r\n    bool(value: boolean): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        return new BoolInstruction({ scope, value });\r\n    },\r\n\r\n    int(value: number): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const { base, signed, heximal, exp } = parseUintLiteral(value.toFixed(0));\r\n        return new IntInstruction({ scope, base, exp, signed, heximal });\r\n    },\r\n\r\n    float(x: number): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        return new FloatInstruction({ scope, value: x });\r\n    },\r\n\r\n    float2(x: number, y: number): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const args = [...arguments].map(x => this.float(x));\r\n        const ctor = new VariableTypeInstruction({ type: SystemScope[`T_FLOAT${args.length}`], scope: null });\r\n        return new ConstructorCallInstruction({ scope, args, ctor });\r\n    },\r\n\r\n    float3(x: number, y: number, z: number): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const args = [...arguments].map(x => this.float(x));\r\n        const ctor = new VariableTypeInstruction({ type: SystemScope[`T_FLOAT${args.length}`], scope: null });\r\n        return new ConstructorCallInstruction({ scope, args, ctor });\r\n    },\r\n\r\n    float4(x: number, y: number, z: number, w: number): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const args = [...arguments].map(x => this.float(x));\r\n        const ctor = new VariableTypeInstruction({ type: SystemScope[`T_FLOAT${args.length}`], scope: null });\r\n        return new ConstructorCallInstruction({ scope, args, ctor });\r\n    },\r\n\r\n    id(name: string): IIdInstruction {\r\n        const scope = program.currentScope;\r\n        return new IdInstruction({ scope, name });\r\n    },\r\n\r\n    idexpr(name: string): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const decl = scope.findVariable(name);\r\n        if (isNull(decl)) {\r\n            //context.error(sourceNode, EErrors.UnknownVarName, { varName: name });\r\n            return null;\r\n        }\r\n        const id = new IdInstruction({ scope, name });\r\n        return new IdExprInstruction({ scope, id, decl });\r\n    },\r\n\r\n    postfixpoint(ppname: string) {\r\n        const [elementName, fieldName] = ppname.split('.');\r\n        const scope = program.currentScope;\r\n        const element = this.idexpr(elementName);\r\n        const postfix = new IdExprInstruction({\r\n            scope,\r\n            id: new IdInstruction({ scope, name: fieldName }),\r\n            decl: element.type.getField(fieldName)\r\n        });\r\n        return new PostfixPointInstruction({ scope, element, postfix });\r\n    },\r\n\r\n    return(expr: IExprInstruction): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        return new ReturnStmtInstruction({\r\n            scope,\r\n            expr\r\n        });\r\n    },\r\n\r\n    // bool foo(int x)\r\n    func(signature: string,\r\n        content: () => IStmtInstruction[]): IFunctionDeclInstruction {\r\n\r\n        const regex = /(?<typeName>\\w+)\\s(?<funcName>\\w+)\\(\\s*(?<paramStr>.*)\\)/mg;\r\n        const match = regex.exec(signature);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        const ast = AST(context, program);\r\n        const { funcName, typeName, paramStr } = match.groups;\r\n        const paramList = paramStr\r\n            .split(',')\r\n            .map(x => x.trim())\r\n            .map(p => p.split(/\\s+/).reverse())\r\n            .map(([name, type, usage]) => ast.variable(name, type, usage ? [usage] : []))\r\n\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n\r\n        program.push(EScopeType.k_Default);\r\n\r\n        const returnType = VariableTypeInstruction.wrap(scope.findType(typeName), SystemScope.SCOPE);\r\n        const id = ast.id(funcName)\r\n        const def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n        context.funcDef = def;\r\n\r\n        const stmtList = [...content()];\r\n\r\n        if (!stmtList.length || stmtList[stmtList.length - 1].instructionType != EInstructionTypes.k_ReturnStmt) {\r\n            let returnExpr = null;\r\n            switch (typeName) {\r\n                case 'bool':\r\n                    returnExpr = ast.bool(true);\r\n                    break;\r\n                case 'uint':\r\n                case 'int':\r\n                    returnExpr = ast.int(0);\r\n                    break;\r\n                case 'void':\r\n                    break;\r\n                default:\r\n                    console.error('unsupported type of return expression');\r\n            }\r\n\r\n            stmtList.push(ast.return(returnExpr));\r\n        }\r\n\r\n        const impl = new StmtBlockInstruction({ scope, stmtList });\r\n\r\n        program.pop();\r\n\r\n        let func = new FunctionDeclInstruction({ scope, def, impl });\r\n        globalScope.addFunction(func);\r\n\r\n        return func;\r\n    }\r\n});\r\n\r\nexport class CodeEmitterNode extends LGraphNode {\r\n    // docs provided outside from autogenDocumentation() method;\r\n    static nodesDocs: IMap<INodeDocs> = {};\r\n\r\n    // names of local variables\r\n    protected locals: string[];\r\n    protected localsCache: IExprInstruction[];\r\n\r\n    // constructor(name) {\r\n    //     super(name);\r\n    // }\r\n\r\n    //\r\n    // Helpers \r\n    //\r\n\r\n    protected resolveInput(id: number | string): number {\r\n        let slot: number = -1;\r\n        if (isString(id)) {\r\n            slot = this.inputs.findIndex(i => i.name == id)\r\n        } else {\r\n            slot = id as number;\r\n        }\r\n        return slot;\r\n    }\r\n\r\n    protected resolveOutput(id: number | string): number {\r\n        let slot: number = -1;\r\n        if (isString(id)) {\r\n            slot = this.outputs.findIndex(i => i.name == id)\r\n        } else {\r\n            slot = id as number;\r\n        }\r\n        return slot;\r\n    }\r\n\r\n    getInputLink(id: number | string): LLink {\r\n        const ii = this.getInputInfo(id);\r\n        if (!ii) return null;\r\n        const link = ii.link;\r\n        if (!link) return null;\r\n        return this.graph.links[link];\r\n    }\r\n\r\n    getOutputLinks(id: number | string): LLink[] {\r\n        const ii = this.getOutputInfo(id);\r\n        if (!ii) return null;\r\n        const links = ii.links;\r\n        if (!links) return null;\r\n        return links.map(link => this.graph.links[link]);\r\n    }\r\n\r\n    getOriginalSlot(id: number | string): number {\r\n        let link = this.getInputLink(id);\r\n        if (!link) return -1;\r\n        return link.origin_slot;\r\n    }\r\n\r\n\r\n    getInputNode(id: number | string): CodeEmitterNode {\r\n        let slot = this.resolveInput(id);\r\n        return super.getInputNode(slot) as CodeEmitterNode;\r\n    }\r\n\r\n\r\n    getInputInfo(id: number | string) {\r\n        let slot = this.resolveInput(id);\r\n        return super.getInputInfo(slot);\r\n    }\r\n\r\n    getOutputInfo(id: number | string) {\r\n        let slot = this.resolveOutput(id);\r\n        return super.getOutputInfo(slot);\r\n    }\r\n\r\n    getOutputNodes(id: number | string): CodeEmitterNode[] {\r\n        let slot = this.resolveOutput(id);\r\n        return super.getOutputNodes(slot) as CodeEmitterNode[];\r\n    }\r\n\r\n\r\n    // todo: move to litegraph.js\r\n    getInputNodes(): CodeEmitterNode[] {\r\n        return this.inputs\r\n            .filter(i => i && i.link !== null)  // filter valid inputs\r\n            .map(i => this.graph.links[i.link]) // conver inputs to link infos\r\n            .filter(li => !!li)                 // filter valid links\r\n            .map(li => this.graph.getNodeById(li.origin_id) as CodeEmitterNode);\r\n    }\r\n\r\n    //\r\n    // Execution api\r\n    //\r\n\r\n    async run(env: ISLDocument): Promise<ISLDocument> {\r\n        return null\r\n    }\r\n\r\n\r\n    protected local(slot: number) {\r\n        return this.locals[0];\r\n    }\r\n\r\n    protected localCache(slot: number) {\r\n        return this.localsCache?.[0] || null;\r\n    }\r\n\r\n    protected addLocal(context: GraphContext, program: ProgramScope, type: string, expr: IExprInstruction): IStmtInstruction[] {\r\n        const t = context.addLocal();\r\n        this.locals = [t];\r\n        this.localsCache = [expr];\r\n\r\n        const ast = AST(context, program);\r\n        return [\r\n            ast.stmt([ast.variable(t, type)]),\r\n            ast.assigment(ast.idexpr(t), expr)\r\n        ];\r\n    }\r\n\r\n    // be careful, this function cane be called more than once per node because of multiple connections\r\n    // it has to be fixed\r\n    onBeforeExecution(context: GraphContext, program: ProgramScope): void {\r\n        this.locals = null; // clean up precached names\r\n        this.localsCache = null;\r\n        this.inputs.forEach((n, i) =>\r\n            n.type != LiteGraph.ACTION && this.getInputNode(i)?.onBeforeExecution(context, program));\r\n        this.outputs.forEach((n, i) =>\r\n            n.type == LiteGraph.EVENT && this.getOutputNodes(i)?.forEach(node => node.onBeforeExecution(context, program)));\r\n    }\r\n\r\n\r\n    compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n        return this.inputs.map((n, i) => n.type == LiteGraph.ACTION\r\n            ? []\r\n            : this.getInputNode(i)?.compute(context, program) || []).flat();\r\n    }\r\n\r\n\r\n    exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        return new BoolInstruction({ scope, value: false });\r\n    }\r\n\r\n    //\r\n    // Docs api\r\n    //\r\n\r\n    getDocs(): string {\r\n        return CodeEmitterNode.nodesDocs[this.title]?.desc || null;\r\n    }\r\n\r\n\r\n    getTitle(): string {\r\n        const titleEx = CodeEmitterNode.nodesDocs[this.title];\r\n        return titleEx?.title || this.title;\r\n    }\r\n\r\n\r\n    onSelected(): void {\r\n        const docs = this.getDocs();\r\n        if (docs) {\r\n            nodesProvideDocs(docs);\r\n        }\r\n    }\r\n\r\n\r\n    onDeselected(): void {\r\n        const docs = this.getDocs();\r\n        if (docs) {\r\n            nodesProvideDocs(null);\r\n        }\r\n    }\r\n\r\n\r\n    onPropertyChanged(name: string, value: number, prevValue: number): boolean {\r\n        nodesForceRecompile();\r\n        return true;\r\n    }\r\n\r\n\r\n    emitError(desc?: string) {\r\n        if (desc) console.error(desc);\r\n        this.color = 'red';\r\n    }\r\n\r\n\r\n    emitNoError() {\r\n        this.color = null;\r\n    }\r\n\r\n\r\n    onConnectionsChange(type: number, slotIndex: number, isConnected: boolean, link: LLink, ioSlot: INodeInputSlot | INodeOutputSlot): void {\r\n        this.emitNoError(); // clean up errors on every change\r\n    }\r\n\r\n    onDrawBackground(\r\n        ctx: CanvasRenderingContext2D,\r\n        graphcanvas: LGraphCanvas,\r\n        canvas: HTMLCanvasElement,\r\n        mouse: [number, number]\r\n    ) {\r\n\r\n        if (this.flags.collapsed)\r\n            return;\r\n\r\n        if (this.mouseOver) {\r\n            const docs = this.getDocs();\r\n            if (docs) {\r\n                ctx.save();\r\n                ctx.font = \"12px sans-serif\";\r\n                ctx.fillStyle = \"#AAA\";\r\n                ctx.fillText(this.getDocs(), 0, this.size[1] + 18);\r\n                ctx.restore();\r\n            }\r\n        }\r\n    }\r\n\r\n    // IP: uncomment to render selection around hint\r\n    // onBounding(rect) {\r\n    //     if (!this.flags.collapsed && this.mouseOver) {\r\n    //         const docs = this.getDocs();\r\n    //         if (docs) {\r\n    //             rect[3] = this.size[1] + 45;\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n    ////\r\n\r\n    setOutputSlotType(type: string, slot: number): void {}\r\n    setInputSlotType(type: string, slot: number): void {}\r\n}\r\n\r\nexport class CodeEmitterParam extends CodeEmitterNode {\r\n    getName(): string { return null; }\r\n    getType(): string { return null; }\r\n}\r\n\r\nexport class CodeEmitterStmt extends CodeEmitterNode {\r\n\r\n    protected readyToAccept = false;\r\n\r\n    protected dependentNodes() {\r\n        return this.getOutputNodes(0); // 'stmts' ?\r\n    }\r\n\r\n    protected update() {\r\n        const dx = 7;\r\n        const dy = 5;\r\n        const dh_title = 35;\r\n        const dh_notitle = 5;\r\n        const dh_post = 10;\r\n\r\n        let [w, h] = this.computeSize();\r\n        let [x, y] = [dx, h - (this.inputs.find(i => i.pos?.[1] < 0) || this.outputs?.[0]?.visible === false ? 26 : 0)]; // fixme!!!\r\n\r\n        const nodes = this.dependentNodes();\r\n        if (nodes) {\r\n            for (let node of nodes) {\r\n                const noTitle = (node.constructor as typeof LGraphNode).title_mode == LiteGraph.NO_TITLE;\r\n\r\n                const px = this.pos[0] + x;\r\n                const py = this.pos[1] + y + (noTitle ? dh_notitle : dh_title);\r\n\r\n                if (node.pos[0] != px || node.pos[1] != py) {\r\n                    node.pos = [px, py];\r\n                    (node as CodeEmitterStmt).onReposition?.();\r\n                }\r\n\r\n                w = Math.max(w, node.size[0] + dx * 2);\r\n                y = y +\r\n                    node.size[1] +\r\n                    (!noTitle ? LiteGraph.NODE_TITLE_HEIGHT : 0) +\r\n                    dy;\r\n            }\r\n        }\r\n\r\n        w = Math.max(100, w);\r\n        h = Math.max(30, y + dh_post);\r\n\r\n        if (this.size[0] != w || this.size[1] != h) {\r\n            this.size = [w, h];\r\n            this.onResize();\r\n        }\r\n\r\n        return nodes;\r\n    }\r\n\r\n    onResize() {\r\n        (this.getInputNode(\"context\") as CodeEmitterStmt)?.update?.();\r\n    }\r\n\r\n    onReposition() {\r\n        (this.getInputNode(\"context\") as CodeEmitterStmt)?.update?.();\r\n    }\r\n\r\n    protected highlight(value) {\r\n        this.readyToAccept = value;\r\n    }\r\n\r\n\r\n    onDropEnter(node) {\r\n        this.highlight(true);\r\n        this.update();\r\n    }\r\n\r\n\r\n    onDropLeave(node) {\r\n        this.highlight(false);\r\n\r\n        const graph = this.graph;\r\n        const links = this.outputs[0].links || [];\r\n\r\n        // trying to find incoming node within our connections\r\n        // and disconnect if possible\r\n        links.forEach(link_id => {\r\n            let link = graph.links[link_id];\r\n            let targetNode = graph.getNodeById(link.target_id);\r\n            if (node == targetNode) {\r\n                this.disconnectOutput(0, targetNode);\r\n            }\r\n        });\r\n\r\n        this.update();\r\n    }\r\n\r\n\r\n    onDrag(graphcanvas) {\r\n        const nodes = this.update();\r\n        if (nodes) {\r\n            nodes.forEach(node => {\r\n                graphcanvas.bringToFront(node)\r\n                if (node.onDrag) node.onDrag(graphcanvas);\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    onConnectionsChange() {\r\n        this.update();\r\n        // force update parent twice in order to validate that all nodes in positions\r\n        this.onResize();\r\n    }\r\n\r\n\r\n    onBringToFront(canvas) {\r\n        const nodes = this.dependentNodes();\r\n        if (nodes) {\r\n            nodes.forEach(node => {\r\n                canvas.bringToFront(node);\r\n                if (node.onBringToFront)\r\n                    node.onBringToFront(canvas);\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport interface ISpawner extends CodeEmitterNode {\r\n    // indicates that spawner/initializer doesn't \r\n    // have dependencies and can be call inside per frame routine\r\n    get pure(): boolean;        \r\n\r\n    findParamsDependencies(): CodeEmitterParam[];\r\n} \r\n\r\nexport interface ICodeMaterialNode extends CodeEmitterNode {\r\n    get sorting(): boolean;     // pass options\r\n    get geometry(): string;     // pass options\r\n}\r\n\r\n\r\nexport class PartRoutine extends CodeEmitterStmt {\r\n        \r\n    // render as fully transparent by default (only with custom design)\r\n    // static title_mode = LiteGraph.TRANSPARENT_TITLE;\r\n    // static color = 'transparent';\r\n    // static bgcolor = 'transparent';\r\n\r\n    static can_accept_drop = true;\r\n    static collapsable = false;\r\n    // static title_offset_x = 5;\r\n\r\n    onDrawBackground(\r\n        ctx         /* CanvasRenderingContext2D */,\r\n        gcanvas     /* LGraphCanvas */,\r\n        canvas      /* HTMLCanvasElement */,\r\n        mouse\r\n    ) {\r\n        super.onDrawBackground(ctx, gcanvas, canvas, mouse);\r\n\r\n        if (this.flags.collapsed)\r\n            return;\r\n\r\n        let [w, h] = this.size;\r\n\r\n        if (this.readyToAccept) {\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.lineWidth = 2;\r\n            ctx.strokeStyle = 'orange';\r\n            ctx.roundRect(0, 0, w + 1, h, [0, 0, 0, 0], 0);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            ctx.restore();\r\n        }\r\n    }\r\n\r\n\r\n    // onDrawTitleBar(\r\n    //     ctx: CanvasRenderingContext2D, \r\n    //     titleHeight: number,\r\n    //     size: number[],\r\n    //     scale: number,\r\n    //     fgColor: string\r\n    // ) {\r\n    //     ctx.beginPath();\r\n    //     ctx.shadowBlur = 0;\r\n    //     ctx.lineWidth = 2;\r\n    //     ctx.rect(-1, -titleHeight-1, size[0] + 1 + 2, titleHeight);\r\n    //     ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\r\n    //     ctx.fill();\r\n    //     ctx.closePath();\r\n    // }\r\n\r\n    // onDrawTitleBox(\r\n    //     ctx, \r\n    //     titleHeight, \r\n    //     size, \r\n    //     scale\r\n    // ) {\r\n    //     // do not render title pin\r\n    // }\r\n\r\n    // onDrawTitleText(\r\n    //     ctx, \r\n    //     titleHeight, \r\n    //     size, \r\n    //     scale,\r\n    //     font,\r\n    //     selected\r\n    // ) {\r\n    //     console.log(`onDrawTitleText`, arguments);\r\n    // }\r\n}\r\n","import { IfStmtInstruction } from \"@lib/fx/analisys/instructions/IfStmtInstruction\";\r\nimport { StmtBlockInstruction } from \"@lib/fx/analisys/instructions/StmtBlockInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IStmtInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IWidget, LiteGraph } from \"litegraph.js\";\r\n\r\n\r\nimport { CodeEmitterStmt, GraphContext, LGraphNodeFactory } from \"./GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const desc = \"Action\"; // \"If\";\r\n    const name = \"Action\"; // \"If\";\r\n\r\n    const HIDDEN_CONNECTION = { visible: false };\r\n\r\n    class If extends CodeEmitterStmt {\r\n        static desc = desc;\r\n\r\n        // render as fully transparent by default (only with custom design)\r\n        // static title_mode = LiteGraph.TRANSPARENT_TITLE;\r\n        static color = 'transparent';\r\n        static bgcolor = 'transparent';\r\n\r\n        static can_be_dropped = true;\r\n        static can_accept_drop = true; \r\n        static collapsable = false;\r\n\r\n        // toggle: IWidget;\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addInput(\"cond\", \"bool\", { pos: [13, -13], label: \"\" });\r\n            this.addInput(\"context\", LiteGraph.ACTION, HIDDEN_CONNECTION);\r\n            this.addOutput(\"true\", LiteGraph.EVENT, HIDDEN_CONNECTION);\r\n            this.addOutput(\"false\", LiteGraph.EVENT, HIDDEN_CONNECTION);\r\n\r\n            // this.addProperty<boolean>(\"value\", true, \"boolean\");\r\n            // this.toggle = this.addWidget<IWidget>(\"toggle\", null, true, \"value\", { on: \"fwd\", off: \"bck\" } );\r\n            // (this.toggle as any).width = 100;\r\n            // this.widgets_start_y = -13;\r\n            // this.serialize_widgets = true;\r\n            this.update();\r\n        }\r\n\r\n        protected dependentNodes() {\r\n            return [...(this.getOutputNodes(0) || []), ...(this.getOutputNodes(1) || [])];\r\n        }\r\n\r\n\r\n        computeSize(): [number, number] {\r\n            return [120, 26];\r\n        }\r\n\r\n\r\n        onDrawTitleBox(\r\n            ctx, \r\n            titleHeight, \r\n            size, \r\n            scale\r\n        ) {\r\n            // skip render of title pin\r\n        }\r\n        \r\n\r\n        onDrawBackground(\r\n            ctx         /* CanvasRenderingContext2D */,\r\n            gcanvas     /* LGraphCanvas */,\r\n            canvas      /* HTMLCanvasElement */,\r\n            mouse\r\n        ) {\r\n            super.onDrawBackground(ctx, gcanvas, canvas, mouse);\r\n    \r\n            if (this.flags.collapsed)\r\n                return;\r\n    \r\n            let [w, h] = this.size;\r\n    \r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = this.readyToAccept ? 'orange' : 'rgba(255, 255, 255, 0)';\r\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';\r\n            ctx.shadowColor = \"#000\";\r\n            ctx.shadowOffsetX = 0;\r\n            ctx.shadowOffsetY = 0;\r\n            ctx.shadowBlur = 6;\r\n            ctx.roundRect(0, 0, w + 1, h, [0, 0, 5, 5], 5);\r\n            ctx.stroke();\r\n            ctx.fill();\r\n            ctx.closePath();\r\n            ctx.restore();\r\n        }\r\n\r\n\r\n        onDropLeave(node) {\r\n            this.highlight(false);\r\n\r\n            const graph = this.graph;\r\n            for (let i of [0, 1]) {\r\n                const links = this.outputs[i].links;\r\n\r\n                if (links) {\r\n                    // trying to find incoming node within our connections\r\n                    // and disconnect if possible\r\n                    links.forEach(link_id => {\r\n                        let link = graph.links[link_id];\r\n                        let targetNode = graph.getNodeById(link.target_id);\r\n                        if (node == targetNode) {\r\n                            this.disconnectOutput(i, targetNode);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n            // true is disconnected and false is connected\r\n            const conseq = this.outputs[0].links;\r\n            const contrary = this.outputs[1].links;\r\n            if (!conseq?.length && contrary?.length) {\r\n                // move false to true\r\n                let link = graph.links[contrary[0]];\r\n                let contraryNode = graph.getNodeById(link.target_id);\r\n                this.disconnectOutput(1);\r\n                this.connect(0, contraryNode, 'context');\r\n            }\r\n\r\n            this.update();\r\n        }\r\n\r\n\r\n        onDrop(node) {\r\n            // todo: validate node\r\n            const slotName = this.isOutputConnected(0) \r\n                ? this.isOutputConnected(1) \r\n                    ? null \r\n                    : 'false'\r\n                : 'true';\r\n            if (slotName) {\r\n                this.connect(slotName, node, 'context');\r\n            }\r\n            this.highlight(false);\r\n            this.update();\r\n        }\r\n\r\n        override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n            const deps = super.compute(context, program);\r\n\r\n            const scope = program.currentScope;\r\n            const cond = this.getInputNode('cond')?.exec(context, program, this.getOriginalSlot('cond')) ||\r\n                this.exec(context, program, 0)/* false */;\r\n            const conseqStmts = this.getOutputNodes('true')?.map(node => node.compute(context, program)).flat();\r\n            const conseq = conseqStmts ? new StmtBlockInstruction({ scope, stmtList: conseqStmts }) : null;\r\n            const contraryStmts = this.getOutputNodes('false')?.map(node => node.compute(context, program)).flat();\r\n            const contrary = contraryStmts ? new StmtBlockInstruction({ scope, stmtList: contraryStmts }) : null;\r\n\r\n            return [...deps, new IfStmtInstruction({ scope, cond, conseq, contrary })];\r\n        }\r\n    }\r\n\r\n    return { [`fx/${desc}`]: If };\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { BoolInstruction } from \"@lib/fx/analisys/instructions/BoolInstruction\";\r\nimport { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { parseUintLiteral } from \"@lib/fx/analisys/system/utils\";\r\nimport { IExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\nimport { IWidget, LGraphCanvas } from \"litegraph.js\";\r\n\r\n\r\nimport { CodeEmitterNode, LGraphNodeFactory } from \"./GraphNode\";\r\n\r\n// notes:\r\n//  processNodeWidgets handles clicks and events\r\n//  drawNodeWidgets handles drawning\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const nodes = <LGraphNodeFactory>{};\r\n    class Int extends CodeEmitterNode {\r\n        static desc = \"Int\";\r\n\r\n        private widget: IWidget;\r\n\r\n        constructor() {\r\n            super(\"Int\");\r\n            this.addOutput(\"value\", \"int\");\r\n            this.addProperty<Number>(\"value\", 0.0, \"number\");\r\n            this.widget = this.addWidget(\"number\", \"value\", 0, \"value\", { precision: 0, step: 10 });\r\n            this.widgets_up = true; // draw number widget in the middle of node (by default it's placed under node)\r\n            this.size = [150, 30];\r\n        }\r\n\r\n        exec(context: Context, program: ProgramScope): IExprInstruction {\r\n            let sourceNode = null as IParseNode;\r\n            let scope = program.currentScope;\r\n            // return new FloatInstruction({ scope, sourceNode, value: Number(this.properties[\"value\"]) });\r\n            let value = this.properties.value;\r\n            let { base, signed, heximal, exp } = parseUintLiteral(Math.abs(value).toFixed(0));\r\n            if (value < 0) base = -base;\r\n            return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n        }\r\n\r\n        getTitle(): string {\r\n            if (this.flags.collapsed) {\r\n                return this.properties.value.toFixed(0);\r\n            }\r\n            return super.getTitle();\r\n        }\r\n\r\n        onDrawBackground(ctx: CanvasRenderingContext2D, graphcanvas: LGraphCanvas, canvas, mouse): void {\r\n            super.onDrawBackground(ctx, graphcanvas, canvas, mouse);\r\n            this.outputs[0].label = this.properties[\"value\"].toFixed(2);\r\n        }\r\n    }\r\n\r\n    nodes[`constants/int`] = Int;\r\n\r\n    class Uint extends CodeEmitterNode {\r\n        static desc = \"Uint\";\r\n\r\n        private widget: IWidget;\r\n\r\n        constructor() {\r\n            super(\"Uint\");\r\n            this.addOutput(\"value\", \"uint\");\r\n            this.addProperty<Number>(\"value\", 0.0, \"number\");\r\n            this.widget = this.addWidget(\"number\", \"value\", 0, \"value\", { precision: 0, step: 10, min: 0 });\r\n            this.widgets_up = true; // draw number widget in the middle of node (by default it's placed under node)\r\n            this.size = [150, 30];\r\n        }\r\n\r\n        exec(context: Context, program: ProgramScope): IExprInstruction {\r\n            let sourceNode = null as IParseNode;\r\n            let scope = program.currentScope;\r\n            let { base, signed, heximal, exp } = parseUintLiteral(this.properties.value.toFixed(0));\r\n            signed = false; // force \"unsigned\"\r\n            return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n        }\r\n\r\n        getTitle(): string {\r\n            if (this.flags.collapsed) {\r\n                return this.properties.value.toFixed(0);\r\n            }\r\n            return super.getTitle();\r\n        }\r\n\r\n        onDrawBackground(ctx: CanvasRenderingContext2D, graphcanvas: LGraphCanvas, canvas, mouse): void {\r\n            super.onDrawBackground(ctx, graphcanvas, canvas, mouse);\r\n            this.outputs[0].label = this.properties[\"value\"].toFixed(2);\r\n        }\r\n    }\r\n\r\n    nodes[`constants/uint`] = Uint;\r\n\r\n    class Bool extends CodeEmitterNode {\r\n        static desc = \"Bool\";\r\n\r\n        private widget: IWidget;\r\n\r\n        constructor() { \r\n            super(\"Bool\");\r\n            this.addOutput(\"value\", \"bool\");\r\n            this.addProperty<boolean>(\"value\", false, \"bool\");\r\n            this.widget = this.addWidget(\"toggle\", \"value\", false, \"value\");\r\n            this.widgets_up = true; // draw number widget in the middle of node (by default it's placed under node)\r\n            this.size = [150, 30];\r\n        }\r\n\r\n        exec(context: Context, program: ProgramScope): IExprInstruction {\r\n            let sourceNode = null as IParseNode;\r\n            let scope = program.currentScope;\r\n            let value = this.properties.value;\r\n            return new BoolInstruction({ scope, sourceNode, value });\r\n        }\r\n\r\n        getTitle(): string {\r\n            if (this.flags.collapsed) {\r\n                return this.properties.value;\r\n            }\r\n            return super.getTitle();\r\n        }\r\n\r\n        onDrawBackground(ctx: CanvasRenderingContext2D, graphcanvas: LGraphCanvas, canvas, mouse): void {\r\n            super.onDrawBackground(ctx, graphcanvas, canvas, mouse);\r\n            this.outputs[0].label = this.properties[\"value\"];\r\n        }\r\n    }\r\n\r\n    nodes[`constants/bool`] = Bool;\r\n\r\n    return nodes;\r\n}\r\n\r\nexport default producer;\r\n","import { Analyzer, Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { ArithmeticExprInstruction } from \"@lib/fx/analisys/instructions/ArithmeticExprInstruction\";\r\nimport { RelationalExprInstruction, RelationOperator } from \"@lib/fx/analisys/instructions/RelationalExprInstruction\";\r\nimport { ConditionalExprInstruction } from \"@lib/fx/analisys/instructions/ConditionalExprInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IArithmeticOperator, IExprInstruction, ILogicalOperator, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { INodeInputSlot, INodeOutputSlot, INodeSlot, LGraph, LGraphCanvas, LGraphNode, LiteGraph, LLink, SerializedLGraphNode } from \"litegraph.js\";\r\n\r\nimport { AST, CodeEmitterNode, GraphContext, LGraphNodeFactory } from \"./GraphNode\";\r\nimport { LogicalExprInstruction } from \"@lib/fx/analisys/instructions/LogicalExprInstruction\";\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const nodes = <LGraphNodeFactory>{};\r\n\r\n    class Operator extends CodeEmitterNode {\r\n        protected get a(): CodeEmitterNode {\r\n            return this.getInputNode('a');\r\n        }\r\n\r\n        protected get b(): CodeEmitterNode {\r\n            return this.getInputNode('b');\r\n        }\r\n    }\r\n\r\n    const TYPES = ['float', 'int', 'uint', 'float3'];\r\n\r\n    const ARITHMETIC = [\r\n        { name: \"Summ\", operator: \"+\", search: \"summ '+'\" },\r\n        { name: \"Subtraction\", operator: \"-\", search: \"subtraction '-'\" },\r\n        { name: \"Mult\", operator: \"*\", search: \"multiply '*'\" },\r\n        { name: \"Div\", operator: \"/\", search: \"division '/'\" },\r\n        { name: \"Mod\", operator: \"%\", search: \"modulo '%'\" }\r\n    ];\r\n\r\n    const TYPE_LIST = TYPES.join(',');\r\n\r\n    ARITHMETIC.forEach(desc => {\r\n            class Arithmetic extends Operator {\r\n                static desc = desc.name;\r\n\r\n                constructor() {\r\n                    super(desc.name);\r\n                    this.addInput(\"a\", TYPE_LIST);\r\n                    this.addInput(\"b\", TYPE_LIST);\r\n                    this.addOutput(\"value\", TYPE_LIST);\r\n                    this.size = [100, 50];\r\n                    this.shape = LiteGraph.ROUND_SHAPE;\r\n                }\r\n\r\n        \r\n                override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n                    if (this.locals || \r\n                        !this.inputs.every((x, i) => this.isInputConnected(i))) {\r\n                        return [];\r\n                    }\r\n    \r\n                    const deps = super.compute(context, program);\r\n                    const scope = program.currentScope;\r\n                    const operator = desc.operator as IArithmeticOperator;\r\n                    const left = this.a.exec(context, program, this.getOriginalSlot('a'));\r\n                    const right = this.b.exec(context, program, this.getOriginalSlot('b'));\r\n                    // IP: todo - calc proper type\r\n                   \r\n                    const type = Analyzer.checkTwoOperandExprTypes(context, operator, left.type, right.type);\r\n\r\n                    for (const name of ['a', 'b']) {\r\n                        this.getInputInfo(name).type = left.type.name;\r\n                        this.getInputLink(name).type = left.type.name;\r\n                    }\r\n                    this.getOutputInfo('value').type = type.name;\r\n\r\n                    const expr = new ArithmeticExprInstruction({ scope, left, right, operator, type });\r\n                    return [ ...deps, ...this.addLocal(context, program, expr.type.name, expr) ];\r\n                }\r\n\r\n\r\n                override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n                    let leftNode = this.a;\r\n                    let rightNode = this.b;\r\n    \r\n                    if (!leftNode || !rightNode) {\r\n                        this.emitError(`All inputs must be conected.`);\r\n                        return null;\r\n                    }\r\n    \r\n                    if (!this.locals)\r\n                        return null;\r\n                    return AST(context, program).idexpr(this.locals[slot]);\r\n                }\r\n\r\n               \r\n                override getTitle(): string {\r\n                    const title = `${this.getInputInfo('a').name} ${desc.operator} ${this.getInputInfo('b').name}`;\r\n                    return this.flags.collapsed? desc.operator : title;\r\n                }\r\n                \r\n\r\n                override getDocs(): string {\r\n                    return `Operator '${desc.search}'.`\r\n                }\r\n\r\n                override onConnectionsChange(type: number, slotIndex: number, isConnected: boolean, link: LLink, ioSlot: INodeInputSlot | INodeOutputSlot) {\r\n                    for (let name of ['a', 'b']) {\r\n                        let slot = this.getInputInfo(name);\r\n                        if (!slot.link) slot.type = TYPE_LIST;\r\n                    }\r\n                    super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);\r\n                }\r\n            }\r\n\r\n            nodes[`operators/${desc.search}`] = Arithmetic;\r\n    });\r\n\r\n    const relations = [\r\n        { name: \"Equal\", operator: \"==\", search: \"equal '=='\" },\r\n        { name: \"NotEqual\", operator: \"!=\", search: \"not equal '!='\" },\r\n        { name: \"Less\", operator: \"<\", search: \"less '<'\" },\r\n        { name: \"Greater\", operator: \">\", search: \"greater '>'\" },\r\n        { name: \"LessThan\", operator: \"<=\", search: \"less than '<='\" },\r\n        { name: \"GreaterThan\", operator: \">=\", search: \"greater than '>='\" }\r\n    ];\r\n\r\n    // todo: add support of different types\r\n    relations.forEach(desc => {\r\n        class Relation extends Operator {\r\n            static desc = desc.name;\r\n\r\n            constructor() {\r\n                super(desc.name);\r\n                this.addInput(\"a\", TYPES.join(','));\r\n                this.addInput(\"b\", TYPES.join(','));\r\n                this.addOutput(\"value\", \"bool\");\r\n                this.size = [100, 50];\r\n            }\r\n\r\n            override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n                if (this.locals || \r\n                    !this.inputs.every((x, i) => this.isInputConnected(i))) {\r\n                    return [];\r\n                }\r\n\r\n                const deps = super.compute(context, program);\r\n                const scope = program.currentScope;\r\n                const operator = desc.operator as RelationOperator;\r\n\r\n                let leftNode = this.a;\r\n                let rightNode = this.b;\r\n\r\n                const left = leftNode.exec(context, program, this.getOriginalSlot('a'));\r\n                const right = rightNode.exec(context, program, this.getOriginalSlot('b'));\r\n\r\n                for (const name of ['a', 'b']) {\r\n                    this.getInputInfo(name).type = left.type.name;\r\n                    this.getInputLink(name).type = left.type.name;\r\n                }\r\n\r\n                const expr = new RelationalExprInstruction({ scope, left, right, operator });\r\n                return [ ...deps, ...this.addLocal(context, program, expr.type.name, expr) ];\r\n            }\r\n\r\n\r\n            override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n                let leftNode = this.a;\r\n                let rightNode = this.b;\r\n\r\n                if (!leftNode || !rightNode) {\r\n                    this.emitError(`All inputs must be conected.`);\r\n                    return null;\r\n                }\r\n\r\n                if (!this.locals)\r\n                    return null;\r\n                return AST(context, program).idexpr(this.locals[slot]);\r\n            }\r\n\r\n\r\n            override getTitle(): string {\r\n                const title = `${this.getInputInfo('a').name} ${desc.operator} ${this.getInputInfo('b').name}`;\r\n                return this.flags.collapsed? desc.operator : title;\r\n            }\r\n\r\n            override getDocs(): string {\r\n                return `Operator '${desc.search}'.`\r\n            }\r\n\r\n            override onConnectionsChange(type: number, slotIndex: number, isConnected: boolean, link: LLink, ioSlot: INodeInputSlot | INodeOutputSlot) {\r\n                for (let name of ['a', 'b']) {\r\n                    let slot = this.getInputInfo(name);\r\n                    if (!slot.link) slot.type = TYPE_LIST;\r\n                }\r\n                super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);\r\n            }\r\n        }\r\n\r\n        nodes[`operators/${desc.search}`] = Relation;\r\n    });\r\n\r\n\r\n    const logic = [\r\n        { name: \"And\", operator: \"&&\", search: \"and '&&'\" },\r\n        { name: \"Or\", operator: \"||\", search: \"or '||'\" },\r\n    ];\r\n\r\n    logic.forEach(desc => {\r\n        class Logic extends Operator {\r\n            static desc = desc.name;\r\n\r\n            constructor() {\r\n                super(desc.name);\r\n                this.addInput(\"a\", 'bool');\r\n                this.addInput(\"b\", 'bool');\r\n                this.addOutput(\"value\", \"bool\");\r\n                this.size = [100, 50];\r\n            }\r\n\r\n            override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n                if (this.locals || \r\n                    !this.inputs.every((x, i) => this.isInputConnected(i))) {\r\n                    return [];\r\n                }\r\n\r\n                const deps = super.compute(context, program);\r\n                const scope = program.currentScope;\r\n                const operator = desc.operator as ILogicalOperator;\r\n\r\n                let leftNode = this.a;\r\n                let rightNode = this.b;\r\n\r\n                const left = leftNode.exec(context, program, this.getOriginalSlot('a'));\r\n                const right = rightNode.exec(context, program, this.getOriginalSlot('b'));\r\n\r\n                const expr = new LogicalExprInstruction({ scope, left, right, operator });\r\n                return [ ...deps, ...this.addLocal(context, program, expr.type.name, expr) ];\r\n            }\r\n\r\n\r\n            override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n                let leftNode = this.a;\r\n                let rightNode = this.b;\r\n\r\n                if (!leftNode || !rightNode) {\r\n                    this.emitError(`All inputs must be conected.`);\r\n                    return null;\r\n                }\r\n\r\n                if (!this.locals)\r\n                    return null;\r\n                return AST(context, program).idexpr(this.locals[slot]);\r\n            }\r\n\r\n\r\n            override getTitle(): string {\r\n                const title = `${this.getInputInfo('a').name} ${desc.operator} ${this.getInputInfo('b').name}`;\r\n                return this.flags.collapsed? desc.operator : title;\r\n            }\r\n\r\n            override getDocs(): string {\r\n                return `Operator '${desc.search}'.`\r\n            }\r\n        }\r\n\r\n        nodes[`operators/${desc.search}`] = Logic;\r\n    });\r\n\r\n\r\n    class Conditional extends Operator {\r\n        static desc = 'Conditional';\r\n\r\n        constructor() {\r\n            super('Conditional');\r\n            this.addInput(\"cond\", 'bool');\r\n            this.addInput(\"a\", TYPE_LIST);\r\n            this.addInput(\"b\", TYPE_LIST);\r\n            this.addOutput(\"value\", TYPE_LIST);\r\n            this.size = this.computeSize();\r\n        }\r\n\r\n        protected get cond(): CodeEmitterNode {\r\n            return this.getInputNode('cond');\r\n        }\r\n\r\n        override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n            if (this.locals || \r\n                !this.inputs.every((x, i) => this.isInputConnected(i))) {\r\n                return [];\r\n            }\r\n\r\n            const deps = super.compute(context, program);\r\n            const scope = program.currentScope;\r\n\r\n            let leftNode = this.a;\r\n            let rightNode = this.b;\r\n            let condNode = this.cond;\r\n\r\n            const left = leftNode.exec(context, program, this.getOriginalSlot('a'));\r\n            const right = rightNode.exec(context, program, this.getOriginalSlot('b'));\r\n            const cond = condNode.exec(context, program, this.getOriginalSlot('cond'));\r\n\r\n            const expr = new ConditionalExprInstruction({ scope, cond, left, right });\r\n\r\n            for (const name of ['a', 'b']) {\r\n                this.getInputInfo(name).type = left.type.name;\r\n                this.getInputLink(name).type = left.type.name;\r\n            }\r\n            this.getOutputInfo('value').type = expr.type.name;\r\n\r\n            return [ ...deps, ...this.addLocal(context, program, expr.type.name, expr) ];\r\n        }\r\n\r\n\r\n        override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n            let leftNode = this.a;\r\n            let rightNode = this.b;\r\n\r\n            if (!leftNode || !rightNode) {\r\n                this.emitError(`All inputs must be conected.`);\r\n                return null;\r\n            }\r\n\r\n            if (!this.locals)\r\n                return null;\r\n            return AST(context, program).idexpr(this.locals[slot]);\r\n        }\r\n\r\n\r\n        override getTitle(): string {\r\n            const title = `${this.getInputInfo('cond').name} ? ${this.getInputInfo('a').name} : ${this.getInputInfo('b').name}`;\r\n            return title;\r\n        }\r\n\r\n        override getDocs(): string {\r\n            return `Conditional operator '?'.`\r\n        }\r\n\r\n        override onConnectionsChange(type: number, slotIndex: number, isConnected: boolean, link: LLink, ioSlot: INodeInputSlot | INodeOutputSlot) {\r\n            for (let name of ['a', 'b']) {\r\n                let slot = this.getInputInfo(name);\r\n                if (!slot.link) slot.type = TYPE_LIST;\r\n            }\r\n            super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);\r\n        }\r\n    }\r\n\r\n    nodes[`operators/conditional '?'`] = Conditional;\r\n\r\n    return nodes;\r\n}\r\n\r\nexport default producer;\r\n\r\n","import { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IStmtInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { LiteGraph } from \"litegraph.js\";\r\n\r\n\r\nimport { CodeEmitterStmt, GraphContext, LGraphNodeFactory } from \"./GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const desc = \"Statements\";\r\n    const name = \"Statements\";\r\n\r\n    const HIDDEN_CONNECTION = { visible: false };\r\n\r\n    class StmtList extends CodeEmitterStmt {\r\n        static desc = desc;\r\n\r\n        static color = 'transparent';\r\n        static bgcolor = 'transparent';\r\n\r\n        static can_be_dropped = true;\r\n        static can_accept_drop = true; \r\n        static collapsable = false;\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addInput(\"context\", LiteGraph.ACTION, HIDDEN_CONNECTION);\r\n            this.addOutput(\"stmts\", LiteGraph.EVENT, HIDDEN_CONNECTION);\r\n            this.update();\r\n        }\r\n\r\n        computeSize(): [number, number] {\r\n            return [120, 26];\r\n        }\r\n\r\n        onDrawTitleBox(\r\n            ctx, \r\n            titleHeight, \r\n            size, \r\n            scale\r\n        ) {\r\n            // skip render of title pin\r\n        }\r\n        \r\n\r\n        onDrawBackground(\r\n            ctx         /* CanvasRenderingContext2D */,\r\n            gcanvas     /* LGraphCanvas */,\r\n            canvas      /* HTMLCanvasElement */,\r\n            mouse\r\n        ) {\r\n            super.onDrawBackground(ctx, gcanvas, canvas, mouse);\r\n    \r\n            if (this.flags.collapsed)\r\n                return;\r\n    \r\n            let [w, h] = this.size;\r\n    \r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = this.readyToAccept ? 'orange' : 'rgba(255, 255, 255, 0)';\r\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';\r\n            ctx.shadowColor = \"#000\";\r\n            ctx.shadowOffsetX = 0;\r\n            ctx.shadowOffsetY = 0;\r\n            ctx.shadowBlur = 6;\r\n            ctx.roundRect(0, 0, w + 1, h, [0, 0, 5, 5], 5);\r\n            ctx.stroke();\r\n            ctx.fill();\r\n            ctx.closePath();\r\n            ctx.restore();\r\n        }\r\n\r\n\r\n        onDrop(node) {\r\n            this.connect('stmts', node, 'context');\r\n            this.highlight(false);\r\n            this.update();\r\n        }\r\n\r\n        override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n            const deps = super.compute(context, program);\r\n            const scope = program.currentScope;\r\n            const stmts = this.getOutputNodes('stmts')?.map(node => node.compute(context, program)).flat();\r\n            return [...deps, ...stmts];\r\n        }\r\n    }\r\n\r\n    return { [`fx/${desc}`]: StmtList };\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\n\r\nimport { AST, CodeEmitterNode, LGraphNodeFactory } from \"./GraphNode\";\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const nodes = <LGraphNodeFactory>{};\r\n\r\n    const vars = env().root.scope.variables;\r\n    for (let name in vars) {\r\n        let v = vars[name];\r\n        if (v.type.isUniform()) {\r\n            class Node extends CodeEmitterNode {\r\n                static desc = `Uniform '${name}'`;\r\n                static collapsable = false;\r\n                static color = 'transparent';\r\n\r\n                constructor() {\r\n                    super(`${name}`);\r\n                    this.addOutput('out', v.type.name, { label: '' });\r\n                    this.size = this.computeSize();\r\n                    this.size[1] = 0;\r\n                    this.size[0] = Math.max(180, this.size[0]);\r\n                    this.outputs[0].pos = [ this.size[0] - 13, -13 ];\r\n                }\r\n\r\n                onDrawTitleBox(ctx, titleHeight, size, scale) {\r\n                    // skip render of title pin\r\n                }\r\n\r\n                exec(context: Context, program: ProgramScope): IExprInstruction {\r\n                    return AST(context, program).idexpr(name);\r\n                }\r\n            }\r\n\r\n            nodes[`constants/${name} (uniform)`] = Node;\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\nexport default producer;\r\n","export const PART_TYPE = \"Part\";\r\nexport const PART_LOCAL_NAME = \"part\";\r\n","import { ComplexTypeInstruction } from \"@lib/fx/analisys/instructions/ComplexTypeInstruction\";\r\nimport { InstructionCollector } from \"@lib/fx/analisys/instructions/InstructionCollector\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { IWidget } from \"litegraph.js\";\r\nimport { AST, CodeEmitterNode, GraphContext, ICodeMaterialNode, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory\r\n{\r\n    const DEFAULT_MATERIAL = 'DefaultShaderInput';\r\n    const type = env().root.scope.types[DEFAULT_MATERIAL] as ComplexTypeInstruction;\r\n    const inputs = type.fields.map((decl: IVariableDeclInstruction) => ({ name: decl.name, type: decl.type.name }));\r\n    const desc = \"DefaultMaterial\";\r\n    const name = \"DefaultMaterial\";\r\n\r\n    class DefaultMaterial extends CodeEmitterNode implements ICodeMaterialNode {\r\n        static desc = desc;\r\n\r\n        private sortingWidget: IWidget<boolean>;\r\n        private geometryWidget: IWidget<string>;\r\n        \r\n        get sorting(): boolean {\r\n            return this.sortingWidget.value;\r\n        }\r\n\r\n        get geometry(): string {\r\n            return this.geometryWidget.value;\r\n        }\r\n\r\n\r\n        constructor() {\r\n            super(name);\r\n            // float3 pos : POSITION;\r\n            // float4 color : COLOR0;\r\n            // float  size : SIZE;\r\n            inputs.forEach(i => this.addInput(i.name, i.type));\r\n            this.addInput('sort', 'int');\r\n            this.size = [180, 25 * (inputs.length + 1) + 50 * 2];\r\n\r\n            this.addProperty(\"Sorting\", true, \"bool\");\r\n            this.sortingWidget = this.addWidget<IWidget>(\"toggle\", \"Sorting\", true, \"value\");\r\n            this.addProperty(\"Geometry\", \"Box\", \"string\");\r\n            this.geometryWidget = this.addWidget<IWidget>(\"text\", \"Geometry\", \"Box\", \"value\");\r\n            this.serialize_widgets = true;\r\n        }\r\n\r\n\r\n        private extend(env: ISLDocument): ISLDocument {\r\n            const uri = env.uri;\r\n            const scope = env.root.scope;\r\n            const program = new ProgramScope(scope);\r\n            const context = new GraphContext(uri);\r\n\r\n            this.onBeforeExecution(context, program);\r\n\r\n            const ast = AST(context, program);\r\n\r\n            const execInput = id => this.getInputNode(id).exec(context, program, this.getOriginalSlot(id));\r\n            const computeInput = id => this.getInputNode(id).compute(context, program);\r\n\r\n            context.beginFunc();\r\n            const fdecl = ast.func(`int PrerenderRoutine${this.id}(inout Part part, out DefaultShaderInput input)`, \r\n                () => \r\n                [ \r\n                    ...computeInput('pos'),\r\n                    ...computeInput('size'),\r\n                    ...computeInput('color'),\r\n                    ...computeInput('sort'),\r\n\r\n                    ast.assigment(ast.postfixpoint('input.pos'), execInput('pos')),\r\n                    ast.assigment(ast.postfixpoint('input.size'), execInput('size')),\r\n                    ast.assigment(ast.postfixpoint('input.color'), execInput('color')),\r\n\r\n                    ast.return(execInput('sort'))\r\n                ]\r\n            );\r\n            context.endFunc();\r\n    \r\n            const diagnosticReport = Diagnostics.mergeReports([env.diagnosticReport, context.diagnostics.resolve()]);\r\n            const instructions = env.root.instructions.concat([ fdecl ]);\r\n            const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n            return { root, diagnosticReport, uri };\r\n        }\r\n    \r\n        async run(env: ISLDocument): Promise<ISLDocument>\r\n        {\r\n            return this.extend(env);\r\n        }\r\n\r\n        getTitle(): string { return 'Default Material'; }\r\n        getDocs(): string { return 'Render particles with default material shader.'; }\r\n    }\r\n\r\n    return { [`fx/${desc}`]: DefaultMaterial };\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IStmtInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { LiteGraph } from \"litegraph.js\";\r\n\r\n\r\nimport { AST, CodeEmitterNode, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory\r\n{\r\n    const desc = \"Kill\";\r\n    const name = \"Kill\";\r\n\r\n    const HIDDEN_CONNECTION = { visible: false };\r\n\r\n    class Kill extends CodeEmitterNode {\r\n        static desc = desc;\r\n\r\n        static color = 'transparent';\r\n        // static bgcolor = 'transparent';\r\n\r\n        static can_be_dropped = true;\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addInput(\"context\", LiteGraph.ACTION, HIDDEN_CONNECTION);\r\n            this.size = [100, 0];\r\n        }\r\n\r\n        override compute(context: Context, program: ProgramScope): IStmtInstruction[] {\r\n            const scope = program.currentScope;\r\n            const ast = AST(context, program);\r\n            return [ ast.return(ast.bool(false)) ];\r\n        }\r\n    }\r\n\r\n    return { [`fx/${desc}`]: Kill };\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { IfStmtInstruction } from \"@lib/fx/analisys/instructions/IfStmtInstruction\";\r\nimport { StmtBlockInstruction } from \"@lib/fx/analisys/instructions/StmtBlockInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IStmtInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { LiteGraph } from \"litegraph.js\";\r\n\r\n\r\nimport { AST, CodeEmitterNode, GraphContext, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const desc = \"Kill By\";\r\n    const name = \"Kill By\";\r\n\r\n    const HIDDEN_CONNECTION = { visible: false };\r\n\r\n    class KillBy extends CodeEmitterNode {\r\n        static desc = desc;\r\n        static color = 'transparent';\r\n        static can_be_dropped = true; \r\n        static collapsable = false;\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addInput(\"cond\", \"bool\", { pos: [13, -13], label: \"\" });\r\n            this.addInput(\"context\", LiteGraph.ACTION, HIDDEN_CONNECTION);\r\n            this.size = [100, 0];\r\n        }\r\n\r\n        onDrawTitleBox(ctx, titleHeight, size, scale) {\r\n            // skip render of title pin\r\n        }\r\n        \r\n        override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n            const deps = super.compute(context, program);\r\n            const ast = AST(context, program);\r\n            const scope = program.currentScope;\r\n            const cond = this.getInputNode('cond')?.exec(context, program, this.getOriginalSlot('cond')) ||\r\n                this.exec(context, program, 0)/* false */;\r\n            const conseqStmts = [ ast.return(ast.bool(false)) ];\r\n            const conseq = conseqStmts ? new StmtBlockInstruction({ scope, stmtList: conseqStmts }) : null;\r\n\r\n            return [...deps, new IfStmtInstruction({ scope, cond, conseq })];\r\n        }\r\n    }\r\n\r\n    return { [`fx/${desc}`]: KillBy };\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { ComplexTypeInstruction } from \"@lib/fx/analisys/instructions/ComplexTypeInstruction\";\r\nimport { InstructionCollector } from \"@lib/fx/analisys/instructions/InstructionCollector\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\n\r\nimport { IWidget } from \"litegraph.js\";\r\nimport { PART_TYPE } from \"../common\";\r\nimport { AST, CodeEmitterNode, GraphContext, ICodeMaterialNode, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const layout = env().root.scope.types[PART_TYPE] as ComplexTypeInstruction;\r\n    const desc = \"LwiMaterial\";\r\n    const name = \"Lwi Material\";\r\n\r\n    class LwiMaterial extends CodeEmitterNode implements ICodeMaterialNode {\r\n        static desc = desc;\r\n\r\n        private map = { transform: 0, template: 1 };\r\n        private sortingWidget: IWidget<boolean>;\r\n        private geometryWidget: IWidget<string>;\r\n        \r\n\r\n        get sorting(): boolean {\r\n            return this.sortingWidget.value;\r\n        }\r\n\r\n        get geometry(): string {\r\n            return this.geometryWidget.value;\r\n        }\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addInput('transform', 'float3x4');\r\n            this.addInput('template', 'int');\r\n            this.size = [180, 25 * (2) + 50 * 2];\r\n\r\n            this.addProperty(\"Sorting\", true, \"bool\");\r\n            this.sortingWidget = this.addWidget<IWidget>(\"toggle\", \"Sorting\", true, \"value\");\r\n            this.addProperty(\"Geometry\", \"Box\", \"string\");\r\n            this.geometryWidget = this.addWidget<IWidget>(\"text\", \"Geometry\", \"Box\", \"value\");\r\n            this.serialize_widgets = true;\r\n            // this.widgets_up = true;\r\n        }\r\n\r\n\r\n        private extend(env: ISLDocument): ISLDocument {\r\n            const uri = env.uri;\r\n            const scope = env.root.scope;\r\n            const program = new ProgramScope(scope);\r\n            const context = new GraphContext(uri);\r\n\r\n            this.onBeforeExecution(context, program);\r\n\r\n            const ast = AST(context, program);\r\n            const execInput = id => this.getInputNode(id).exec(context, program, this.getOriginalSlot(id));\r\n    \r\n            context.beginFunc();\r\n            const fdecl = ast.func(`int PrerenderRoutine${this.id}(inout Part part, inout LwiInstance input)`, \r\n                () => \r\n                [ \r\n                    ...this.getInputNode('transform').compute(context, program),\r\n                    ...this.getInputNode('template').compute(context, program),\r\n                    \r\n                    // input.worldMatrPrev[0] = input.worldMatr[0];\r\n                    // input.worldMatrPrev[1] = input.worldMatr[1];\r\n                    // input.worldMatrPrev[2] = input.worldMatr[2];\r\n                    ast.assigment(ast.postfixpoint('input.worldMatrPrev'), ast.postfixpoint('input.worldMatr')),\r\n                \r\n                    // input.worldMatr[0] = transform[0];\r\n                    // input.worldMatr[1] = transform[1];\r\n                    // input.worldMatr[2] = transform[2];\r\n                    ast.assigment(ast.postfixpoint('input.worldMatr'), execInput('transform')),\r\n                    ast.return(execInput('template'))\r\n                ]\r\n            );\r\n            context.endFunc();\r\n    \r\n            const diagnosticReport = Diagnostics.mergeReports([env.diagnosticReport, context.diagnostics.resolve()]);\r\n            const instructions = env.root.instructions.concat([ fdecl ]);\r\n            const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n            return { root, diagnosticReport, uri };\r\n        }\r\n    \r\n        async run(env: ISLDocument): Promise<ISLDocument>\r\n        {\r\n            return this.extend(env);\r\n        }\r\n\r\n        getDocs(): string { return 'Render particles as lwi templates.'; }\r\n\r\n    }\r\n\r\n    return { [`fx/${desc}`]: LwiMaterial };\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\n\r\nimport { AST, CodeEmitterParam, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const nodes = <LGraphNodeFactory>{};\r\n    \r\n    let types: IMap<ITypeInstruction> = {};\r\n    let scope = env().root.scope;\r\n    while (scope) {\r\n        types = { ...types, ...scope.types };\r\n        scope = scope.parent;\r\n    }\r\n\r\n    for (let name in types) {\r\n        let t = types[name];\r\n\r\n        class Param extends CodeEmitterParam {\r\n            static desc = `${name} param`;\r\n            static title_color = `rgba(255, 170, 0, 0.7)`;\r\n            static collapsable = false;\r\n            static color = 'transparent';\r\n\r\n            constructor() {\r\n                super(`${name}`);\r\n                this.addOutput('out', t.name);\r\n                this.title = `${this.getType()} ${this.getName()}`;\r\n                this.size = this.computeSize();\r\n                this.size[1] = 0;\r\n                this.outputs[0].pos = [ this.size[0] - 13, -13 ];\r\n                this.outputs[0].label = '';\r\n            }\r\n\r\n            onDrawTitleBox(ctx, titleHeight, size, scale) {\r\n                // skip render of title pin\r\n            }\r\n\r\n            override getName(): string {\r\n                return `p${this.id}`;\r\n            }\r\n\r\n            override getType(): string {\r\n                return t.name;\r\n            }\r\n\r\n            exec(context: Context, program: ProgramScope): IExprInstruction {\r\n                return AST(context, program).idexpr(this.getName());\r\n            }\r\n        }\r\n\r\n        nodes[`params/${name}`] = Param;\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\nexport default producer;\r\n","import { isNull } from \"@lib/common\";\r\nimport { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { AssignmentExprInstruction } from \"@lib/fx/analisys/instructions/AssignmentExprInstruction\";\r\nimport { ComplexTypeInstruction } from \"@lib/fx/analisys/instructions/ComplexTypeInstruction\";\r\nimport { ExprStmtInstruction } from \"@lib/fx/analisys/instructions/ExprStmtInstruction\";\r\nimport { IdExprInstruction } from \"@lib/fx/analisys/instructions/IdExprInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { PostfixPointInstruction } from \"@lib/fx/analisys/instructions/PostfixPointInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { LiteGraph } from \"litegraph.js\";\r\n\r\n\r\nimport { PART_LOCAL_NAME, PART_TYPE } from \"../common\";\r\nimport { CodeEmitterNode, GraphContext, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory\r\n{\r\n    const nodes = <LGraphNodeFactory>{};\r\n\r\n    const type = env().root.scope.types[PART_TYPE] as ComplexTypeInstruction;\r\n\r\n    const name = `${PART_LOCAL_NAME}`;\r\n    const desc = `${name} (previous value).`;\r\n\r\n    function evaluatePartExpr(context: Context, program: ProgramScope): IExprInstruction {\r\n        const sourceNode = null as IParseNode;\r\n        const callee = null as IExprInstruction;\r\n        const scope = program.currentScope;\r\n\r\n        const decl = scope.findVariable(name);\r\n\r\n        if (isNull(decl)) {\r\n            //context.error(sourceNode, EErrors.UnknownVarName, { varName: name });\r\n            // TODO: autogen graph error\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        return new IdExprInstruction({ scope, sourceNode, id, decl });\r\n    }\r\n\r\n    const HIDDEN_CONNECTION = { visible: false };\r\n\r\n    type.fields.forEach(field => {\r\n        // todo: add suppor of complex types\r\n        if (field.type.isComplex()) {\r\n            return;\r\n        }\r\n\r\n        const name = `${PART_LOCAL_NAME}.${field.name}`;\r\n        const desc = `${name} (previous value).`;\r\n\r\n\r\n        class Part extends CodeEmitterNode {\r\n            static desc = desc;\r\n            static color = 'transparent';\r\n            static can_be_dropped = true;\r\n            static collapsable = false;\r\n\r\n            constructor() {\r\n                super(name);\r\n                this.addInput(name, field.type.name, { pos: [13, -13], label: \"\" });\r\n                this.addInput(\"context\", LiteGraph.ACTION, HIDDEN_CONNECTION);\r\n                this.size = this.computeSize();\r\n                this.size[1] = 0;\r\n            }\r\n\r\n            onDrawTitleBox(ctx, titleHeight, size, scale) {\r\n                // skip render of title pin\r\n            }\r\n\r\n            override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n                if (!this.isInputConnected(0)) return [];\r\n                const deps = super.compute(context, program);\r\n                \r\n                const scope = program.currentScope;\r\n                const right = this.getInputNode(0).exec(context, program, this.getOriginalSlot(0));\r\n                const element = evaluatePartExpr(context, program);\r\n                const postfix = new IdExprInstruction({ \r\n                    scope,\r\n                    id: new IdInstruction({ scope, name: field.name }), \r\n                    decl: element.type.getField(field.name) \r\n                });\r\n                const left = new PostfixPointInstruction({ scope, element, postfix });\r\n                const expr = new AssignmentExprInstruction({ scope, left, right, operator: '=' });\r\n\r\n                \r\n                if (!right.type.readable) {\r\n                    context.error(right.sourceNode, EErrors.InvalidTypeForReading);\r\n                }\r\n\r\n                if (!left.type.writable) {\r\n                    context.error(left.sourceNode, EErrors.InvalidTypeForWriting);\r\n                }\r\n\r\n                return [ ...deps, new ExprStmtInstruction({ scope, expr }) ];   \r\n            }\r\n        }\r\n\r\n        nodes[`fx/out ${name}`] = Part;\r\n    });\r\n\r\n\r\n    class Part extends CodeEmitterNode {\r\n        static desc = desc;\r\n        static color = 'transparent';\r\n        static can_be_dropped = true;\r\n        static collapsable = false;\r\n\r\n        constructor() {\r\n            super(name);\r\n            \r\n            type.fields.forEach(field => {\r\n                // todo: add suppor of complex types\r\n                if (field.type.isComplex()) {\r\n                    return;\r\n                }\r\n        \r\n                const name = `${field.name}`;\r\n                this.addInput(name, field.type.name);\r\n            });\r\n\r\n            this.addInput(\"context\", LiteGraph.ACTION, HIDDEN_CONNECTION);\r\n            this.size = this.computeSize();\r\n        }\r\n\r\n        override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n            if (!this.isInputConnected(0)) return [];\r\n\r\n            const deps = super.compute(context, program);\r\n            const scope = program.currentScope;\r\n\r\n            return [ ...deps, ...this.inputs\r\n                    .map((v, i) => i)\r\n                    .slice(0, -1)\r\n                    .map((input, i) => {\r\n                        const right = this.getInputNode(i).exec(context, program, this.getOriginalSlot(i));\r\n                        const element = evaluatePartExpr(context, program);\r\n                        const postfix = new IdExprInstruction({ \r\n                            scope,\r\n                            id: new IdInstruction({ scope, name: type.fields[i].name }), \r\n                            decl: element.type.getField(type.fields[i].name) \r\n                        });\r\n                        const left = new PostfixPointInstruction({ scope, element, postfix });\r\n                        const expr = new AssignmentExprInstruction({ scope, left, right, operator: '=' });\r\n                        return new ExprStmtInstruction({ scope, expr });   \r\n                    })];\r\n        }\r\n    }\r\n\r\n    nodes[`fx/out ${name}`] = Part;\r\n    return nodes;\r\n}\r\n\r\nexport default producer;","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\n\r\nimport { AST, CodeEmitterNode, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    class PartId extends CodeEmitterNode {\r\n        static desc = 'Autogenerated particle ID.';\r\n        static collapsable = false;\r\n        static color = 'transparent';\r\n\r\n        constructor() {\r\n            super('Part ID');\r\n            this.addOutput('id', 'int', { label: '' });\r\n            this.size = this.computeSize();\r\n            this.size[1] = 0;\r\n            this.size[0] = Math.max(180, this.size[0]);\r\n            this.outputs[0].pos = [ this.size[0] - 13, -13 ];\r\n        }\r\n\r\n        onDrawTitleBox(ctx, titleHeight, size, scale) {\r\n            // skip render of title pin\r\n        }\r\n\r\n        override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n            const scope = program.currentScope;\r\n            const name = 'partId';\r\n            const decl = scope.findVariable(name);\r\n            const ast = AST(context, program);\r\n\r\n            if (!decl) {\r\n                this.emitError(`Part ID has not been found.`);\r\n                return null;\r\n            }\r\n\r\n            return ast.idexpr(name);\r\n        }\r\n    }\r\n\r\n    return { [`fx/partId`]: PartId };\r\n}\r\n\r\nexport default producer;","import { InstructionCollector } from \"@lib/fx/analisys/instructions/InstructionCollector\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\nimport { LGraph, LGraphNode, LGraphNodeConstructor, LiteGraph } from \"litegraph.js\";\r\nimport SpawnOp from '@sandbox/components/graphEx/fx/SpawnOp';\r\n\r\nimport { AST, CodeEmitterParam, CodeEmitterStmt, GraphContext, ISpawner, LGraphNodeFactory, PartRoutine } from \"../GraphNode\";\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory {\r\n    const desc = \"InitRoutine\";\r\n    const name = \"Init Routine\";\r\n\r\n    const HIDDEN_CONNECTION = { visible: false };\r\n\r\n    class PartInit extends PartRoutine implements ISpawner {\r\n        static desc = desc;\r\n\r\n        pure: boolean = false;\r\n\r\n        private operators: LGraphNodeFactory = null;\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addOutput(\"stmts\", LiteGraph.EVENT, HIDDEN_CONNECTION);\r\n            this.update();\r\n        }\r\n\r\n\r\n        onDrop(node) {\r\n            // todo: validate node\r\n            if (this.connect('stmts', node, 'context')) {\r\n                this.update();\r\n                this.highlight(false);\r\n            }\r\n        }\r\n\r\n    \r\n        findParamsDependencies(): CodeEmitterParam[] {\r\n            function filterParams(node: LGraphNode, params: CodeEmitterParam[] = []): CodeEmitterParam[] {\r\n                let checkLink = (id, output) => {\r\n                    let link = node.graph.links[id];\r\n                    if (!link) return;\r\n                    let targetNode = node.graph.getNodeById(output ? link.target_id : link.origin_id);\r\n                    filterParams(targetNode, params);\r\n                    if (targetNode instanceof CodeEmitterParam) {\r\n                        params.push(targetNode);\r\n                    } \r\n                };\r\n\r\n                node.inputs?.filter(slot => slot.type !== LiteGraph.ACTION && slot.link !== null).forEach(({ link }) => \r\n                    checkLink(link, false));\r\n                node.outputs?.filter(slot => slot.type == LiteGraph.EVENT).forEach(({ links }) => \r\n                    links?.forEach(id => checkLink(id, true)));\r\n\r\n                return params;\r\n            }\r\n\r\n            return [...new Set(filterParams(this))];\r\n        }\r\n\r\n\r\n        private extend(env: ISLDocument): ISLDocument {\r\n            const uri = env.uri;\r\n            const scope = env.root.scope;\r\n            const program = new ProgramScope(scope);\r\n            const context = new GraphContext(uri);\r\n\r\n            this.onBeforeExecution(context, program);\r\n\r\n            \r\n            let params = this.findParamsDependencies().map(node => `${node.getType()} ${node.getName()}`).join(', ');\r\n            params = params && `, ${params}`;\r\n\r\n            // cache info whether we have dependencies (can be used as regular per frame routine)\r\n            this.pure = !params;\r\n\r\n            const ast = AST(context, program);\r\n            context.beginFunc();\r\n            const fdecl = ast.func(`void InitRoutine${this.id}(out Part part, int partId ${params})`,\r\n                () => (this.getOutputNodes(0) || []).map(node => node.compute(context, program)).flat());\r\n            context.endFunc();\r\n\r\n            const diagnosticReport = Diagnostics.mergeReports([env.diagnosticReport, context.diagnostics.resolve()]);\r\n            const instructions = env.root.instructions.concat([fdecl]);\r\n            const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n            return { root, diagnosticReport, uri };\r\n        }\r\n\r\n\r\n        async run(env: ISLDocument): Promise<ISLDocument> {\r\n            return this.extend(env);\r\n        }\r\n\r\n        onAdded(graph: LGraph): void {\r\n            this.operators = SpawnOp(env, this);\r\n\r\n            // register all available nodes\r\n            Object.keys(this.operators).forEach(link =>\r\n                LiteGraph.registerNodeType(link, this.operators[link]));\r\n        }\r\n\r\n        onRemoved(): void {\r\n            Object.keys(this.operators)\r\n                .map(link => this.graph.findNodesByType(link))\r\n                .flat()\r\n                .forEach(node => this.graph.remove(node));\r\n\r\n            Object.keys(this.operators).forEach(link =>\r\n                LiteGraph.unregisterNodeType(link));\r\n        }\r\n        \r\n        getDocs(): string { return 'Determines initial state of each particle.'; }\r\n    }\r\n\r\n    return { [`fx/${desc}`]: PartInit };\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { Analyzer, Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { ComplexTypeInstruction } from \"@lib/fx/analisys/instructions/ComplexTypeInstruction\";\r\nimport { IdExprInstruction } from \"@lib/fx/analisys/instructions/IdExprInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { PostfixPointInstruction } from \"@lib/fx/analisys/instructions/PostfixPointInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\n\r\nimport { PART_LOCAL_NAME, PART_TYPE } from \"../common\";\r\nimport { CodeEmitterNode, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory\r\n{\r\n    const nodes = <LGraphNodeFactory>{};\r\n\r\n    const type = env().root.scope.types[PART_TYPE] as ComplexTypeInstruction;\r\n\r\n    const name = `${PART_LOCAL_NAME}`;\r\n    const desc = `${name} (previous value).`;\r\n\r\n    function evaluatePartExpr(context: Context, program: ProgramScope): IExprInstruction {\r\n        const sourceNode = null as IParseNode;\r\n        const callee = null as IExprInstruction;\r\n        const scope = program.currentScope;\r\n\r\n        const decl = scope.findVariable(name);\r\n\r\n        if (isNull(decl)) {\r\n            //context.error(sourceNode, EErrors.UnknownVarName, { varName: name });\r\n            // TODO: autogen graph error\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        return new IdExprInstruction({ scope, sourceNode, id, decl });\r\n    }\r\n\r\n    type.fields.forEach(field => {\r\n        // todo: add suppor of complex types\r\n        if (field.type.isComplex()) {\r\n            return;\r\n        }\r\n\r\n        const name = `${PART_LOCAL_NAME}.${field.name}`;\r\n        const desc = `${name} (previous value).`;\r\n\r\n        class PartPrevous extends CodeEmitterNode {\r\n            static desc = desc;\r\n            static collapsable = false;\r\n            static color = 'transparent';\r\n\r\n            constructor() {\r\n                super(name);\r\n                this.addOutput(name, field.type.name);\r\n                this.size = this.computeSize();\r\n                this.size[1] = 0;\r\n                this.outputs[0].pos = [ this.size[0] - 13, -13 ];\r\n                this.outputs[0].label = '';\r\n            }\r\n\r\n            onDrawTitleBox(ctx, titleHeight, size, scale) {\r\n                // skip render of title pin\r\n            }\r\n\r\n            override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n                const sourceNode = null as IParseNode;\r\n                const scope = program.currentScope;\r\n                const element = evaluatePartExpr(context, program);\r\n\r\n                const name = field.name;\r\n                const decl = Analyzer.createFieldDecl(element.type, name);\r\n                const id = new IdInstruction({ scope, sourceNode, name });\r\n                const postfix = new IdExprInstruction({ scope, sourceNode, id, decl });\r\n\r\n                return new PostfixPointInstruction({ sourceNode, scope, element, postfix });\r\n            }\r\n        }\r\n\r\n        nodes[`fx/${name}`] = PartPrevous;\r\n    });\r\n\r\n\r\n    class PartPrevous extends CodeEmitterNode {\r\n        static desc = desc;\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addOutput(PART_LOCAL_NAME, PART_TYPE);\r\n            this.size = [100, 25];\r\n        }\r\n\r\n        override exec(context: Context, program: ProgramScope, slot: number): IExprInstruction {\r\n            return evaluatePartExpr(context, program);\r\n        }\r\n\r\n    }\r\n\r\n    nodes[`fx/${name}`] = PartPrevous;\r\n    return nodes;\r\n}\r\n\r\nexport default producer;","import { isNumber } from \"@lib/common\";\r\nimport { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { extendSLDocument } from \"@lib/fx/SLDocument\";\r\nimport { createTextDocument } from \"@lib/fx/TextDocument\";\r\nimport { IExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { INodeInputSlot, INodeOutputSlot, LLink } from \"litegraph.js\";\r\nimport { CodeEmitterNode, GraphContext, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\ninterface Plugs\r\n{\r\n    count?: number;\r\n}\r\n\r\nfunction spawnCode(env: ISLDocument, plugs: Plugs = {})\r\n{\r\n    return(`int SpawnRoutine() { return ${ isNumber(plugs.count) ? String(plugs.count) : '$count' }; }`);\r\n}\r\n\r\n/** @deprecated */\r\nfunction asGraphContext(ctx: Context): GraphContext\r\n{\r\n    // temp hack for compartibility\r\n    let varNum = 0;\r\n    (<any>ctx).addLocal = () => `t${varNum++}`;\r\n    return ctx as GraphContext;\r\n}\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory\r\n{\r\n    const desc = \"SpawnRoutine\";\r\n    const name = \"SpawnRoutine\";\r\n    const propName = 'count';\r\n\r\n    class Node extends CodeEmitterNode {\r\n        static desc = desc;\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addInput(propName, \"int\");\r\n            this.addProperty(propName, 1, \"number\");\r\n            this.size = [180, 30];\r\n\r\n            this.updateInputNames();\r\n        }\r\n\r\n        async run(env: ISLDocument): Promise<ISLDocument> {\r\n            // hack to be compartible, this function must be rewritten same way as PartUpdate.\r\n            this.onBeforeExecution(null, null);\r\n            \r\n            const inputNode = this.getInputNode(0);\r\n            const plugs: Plugs = {};\r\n\r\n            if (!inputNode) {\r\n                plugs.count = +this.properties[propName].toFixed(0);\r\n            }\r\n\r\n            const textDocument = await createTextDocument(\"://SpawnRoutine.hlsl\", spawnCode(env, plugs));\r\n            return extendSLDocument(textDocument, env, {\r\n                '$count': (context, program, sourceNode): IExprInstruction => {\r\n                    inputNode.compute(asGraphContext(context), program);\r\n                    return inputNode.exec(context, program, this.getOriginalSlot(0)) as IExprInstruction;\r\n                }\r\n            });\r\n        }\r\n\r\n        getTitle(): string { return 'Spawn routine'; }\r\n        getDocs(): string { return 'Determines number of particles spawnd per second.'; }\r\n\r\n        updateInputNames()\r\n        {\r\n            const input = this.inputs[0];\r\n            input.name = !input.link ? `${propName} = ${ this.properties[propName] }` : propName;\r\n        }\r\n\r\n        onConnectionsChange(type: number, slotIndex: number, isConnected: boolean, link: LLink, ioSlot: INodeInputSlot | INodeOutputSlot): void {\r\n            super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);\r\n            this.updateInputNames();\r\n        }\r\n\r\n        onPropertyChanged(name: string, value: number, prevValue: number): boolean {\r\n            super.onPropertyChanged(name, value, prevValue);\r\n            this.updateInputNames();\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return { [`fx/${desc}`]: Node };\r\n}\r\n\r\nexport default producer;","import { InstructionCollector } from \"@lib/fx/analisys/instructions/InstructionCollector\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\nimport { LGraphCanvas, LGraphNode, LiteGraph } from \"litegraph.js\";\r\n\r\nimport { AST, CodeEmitterNode, CodeEmitterStmt, GraphContext, LGraphNodeFactory, PartRoutine } from \"../GraphNode\";\r\n\r\n\r\nfunction producer(env: () => ISLDocument): LGraphNodeFactory\r\n{\r\n    const desc = \"UpdateRoutine\";\r\n    const name = \"UpdateRoutine\";\r\n\r\n    const HIDDEN_CONNECTION = { visible: false };\r\n\r\n\r\n    class PartUpdate extends PartRoutine {\r\n        static desc = desc;\r\n\r\n        constructor() {\r\n            super(name);\r\n            this.addOutput(\"stmts\", LiteGraph.EVENT, HIDDEN_CONNECTION);\r\n            this.update();\r\n        }\r\n\r\n        \r\n        onDrop(node) {\r\n            // todo: validate node\r\n            if (this.connect('stmts', node, 'context')) {\r\n                this.update();\r\n                this.highlight(false);\r\n            }\r\n        }\r\n\r\n        private extend(env: ISLDocument): ISLDocument {\r\n            const uri = env.uri;\r\n            const scope = env.root.scope;\r\n            const program = new ProgramScope(scope);\r\n            const context = new GraphContext(uri)\r\n            \r\n            this.onBeforeExecution(context, program);\r\n\r\n            const ast = AST(context, program);\r\n            context.beginFunc();\r\n            const fdecl = ast.func(`bool UpdateRoutine(inout Part part, int partId)`, \r\n                () => (this.getOutputNodes(0) || []).map(node => node.compute(context, program)).flat());\r\n            context.endFunc();\r\n    \r\n            const diagnosticReport = Diagnostics.mergeReports([env.diagnosticReport, context.diagnostics.resolve()]);\r\n            const instructions = env.root.instructions.concat([ fdecl ]);\r\n            const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n            return { root, diagnosticReport, uri };\r\n        }\r\n    \r\n        async run(env: ISLDocument): Promise<ISLDocument>\r\n        {\r\n            return this.extend(env);\r\n        }\r\n\r\n        getTitle(): string { return 'Update routine'; }\r\n        getDocs(): string { return 'Determines state of particle after each update.'; }\r\n    }\r\n\r\n    return { [`fx/${desc}`]: PartUpdate };\r\n}\r\n\r\n\r\nexport default producer;\r\n\r\n","import { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { SpawnInstruction } from \"@lib/fx/analisys/instructions/part/SpawnInstruction\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { parseUintLiteral } from \"@lib/fx/analisys/system/utils\";\r\nimport { IExprInstruction, IStmtInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { LiteGraph } from \"litegraph.js\";\r\nimport { AST, CodeEmitterStmt, GraphContext, ISpawner, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\nfunction def(type: IVariableTypeInstruction, ast: ReturnType<typeof AST>): IExprInstruction\r\n{\r\n    switch(type.name) {\r\n        case 'float': return ast.float(0);\r\n        case 'float2': return ast.float2(0, 0);\r\n        case 'float3': return ast.float3(0, 0, 0);\r\n        case 'float4': return ast.float4(0, 0, 0, 0);\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction producer(env: () => ISLDocument, spawner: ISpawner): LGraphNodeFactory\r\n{\r\n    const desc = `Spawn '${spawner.title} (${spawner.id})'`;\r\n    const HIDDEN_CONNECTION = { visible: false };\r\n\r\n    class SpawnOp extends CodeEmitterStmt {\r\n        static desc = desc;\r\n\r\n        static color = 'transparent';\r\n        static can_be_dropped = true;\r\n        static collapsable = false;\r\n\r\n        constructor() {\r\n            super(`Spawn '${spawner.title}'`);\r\n\r\n            const params = spawner.findParamsDependencies();\r\n            this.addInput('count', 'int');\r\n            params.forEach(param => this.addInput(param.getName(), param.getType()));\r\n            this.addInput(\"context\", LiteGraph.ACTION, HIDDEN_CONNECTION);\r\n            this.update();\r\n        }\r\n\r\n        override onBeforeExecution(context: GraphContext, program: ProgramScope): void {\r\n            const inputs = this.inputs.slice(1, -1).map((f, i) => i).filter(i => this.isInputConnected(i));\r\n            \r\n            if (!inputs.length) {\r\n                return;\r\n            }\r\n\r\n            super.onBeforeExecution(context, program);\r\n        }\r\n\r\n        override compute(context: GraphContext, program: ProgramScope): IStmtInstruction[] {\r\n            const fields = spawner.findParamsDependencies();\r\n            const inputs = fields.map((f, i) => i + 1).filter(i => this.isInputConnected(i));\r\n\r\n            fields.forEach((field, i) => this.inputs[i + 1].name = fields[i].title);\r\n            \r\n            // if (!inputs.length) {\r\n            //     return [];\r\n            // }\r\n\r\n            const deps = super.compute(context, program);\r\n            const scope = program.currentScope;\r\n            const ast = AST(context, program);\r\n\r\n            let count = this.getInputNode('count')?.exec(context, program, this.getOriginalSlot('count'));\r\n            if (!count) {\r\n                const { base, signed, heximal, exp } = parseUintLiteral('1');\r\n                count = new IntInstruction({ scope, base, exp, signed, heximal });\r\n            }\r\n\r\n\r\n            const name = `InitRoutine${spawner.id}`;\r\n            const args = inputs.map(i => this.getInputNode(i)?.exec(context, program, this.getOriginalSlot(i)));\r\n    \r\n            const spawnStmt = new SpawnInstruction({ scope, name, args, count });\r\n            const params = inputs.map(i => scope.findType(fields[i - 1].getType()));\r\n            // spawnStmt.$resolve(null, scope.findFunction(name, [ /Part/, /int/, ...params ]));\r\n            context.spawnStmts.push(spawnStmt);\r\n            return [ ...deps, spawnStmt ];\r\n        }\r\n\r\n        onDrawTitleBox(\r\n            ctx, \r\n            titleHeight, \r\n            size, \r\n            scale\r\n        ) {\r\n            // skip render of title pin\r\n        }\r\n    }\r\n\r\n    return { [`fx/actions/${desc}`]: SpawnOp };\r\n}\r\n\r\nexport default producer;","import { Context } from \"@lib/fx/analisys/Analyzer\";\r\nimport { ProgramScope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { IExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { INodeConstant } from \"@sandbox/store/IStoreState\";\r\n\r\nimport { AST, CodeEmitterNode, LGraphNodeFactory } from \"../GraphNode\";\r\n\r\n\r\n\r\nfunction producer(env: () => ISLDocument, constants: INodeConstant[]): LGraphNodeFactory {\r\n    const nodes = <LGraphNodeFactory>{};\r\n\r\n    for (let desc of constants) {\r\n        const { name, type: typeName, value } = desc;\r\n\r\n        class UserConst extends CodeEmitterNode {\r\n            static desc = `${name} (user const)`;\r\n            static collapsable = false;\r\n            static color = 'transparent';\r\n\r\n            constructor() {\r\n                super(`${name} (user const)`);\r\n                this.addOutput('out', typeName, { label: '' });\r\n                this.size = this.computeSize();\r\n                this.size[1] = 0;\r\n                this.size[0] = Math.max(180, this.size[0]);\r\n                this.outputs[0].pos = [ this.size[0] - 13, -13 ];\r\n            }\r\n\r\n            // override onBeforeExecution(context: GraphContext, program: ProgramScope): void {\r\n            //     super.onBeforeExecution(context, program);\r\n            // }\r\n\r\n            onDrawTitleBox(ctx, titleHeight, size, scale) {\r\n                // skip render of title pin\r\n            }\r\n\r\n            exec(context: Context, program: ProgramScope): IExprInstruction {\r\n                return AST(context, program).idexpr(name);\r\n            }\r\n        }\r\n\r\n        nodes[`user constants/${name}`] = UserConst;\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\nexport default producer;\r\n","import { IMap } from \"@lib/idl/IMap\";\r\nimport { IRange } from \"@lib/idl/parser/IParser\";\r\nimport { CommentExtractor } from \"@lib/parser/helpers\";\r\nimport { INodeDocs } from \"../GraphNode\";\r\n\r\nexport class LibLoader extends CommentExtractor\r\n{\r\n    nodes: IMap<INodeDocs> = {};\r\n    node: INodeDocs = null;\r\n\r\n    beginComment(content: string): void {\r\n        this.node = { name: null };\r\n    }\r\n\r\n    applyRule(rule: string, parts: string[], loc: IRange): void {\r\n        let value = parts.slice(1).join(' ');\r\n        switch(rule)\r\n        {\r\n            case '@node':\r\n            {\r\n                this.node.name = value.match(/\\{([^\\{\\}]*)\\}/)[1].trim();\r\n                break;\r\n            }\r\n            case '@desc':\r\n            {\r\n                this.node.desc = value.trim();\r\n                break;\r\n            }\r\n            case '@title':\r\n            {\r\n                this.node.title = value.trim();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    endComment(): void {\r\n        if (this.node.name) {\r\n            this.nodes[this.node.name] = this.node;\r\n        }\r\n    }\r\n}\r\n","import { createTextDocument } from \"@lib/fx/TextDocument\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { CodeEmitterNode } from \"@sandbox/components/graphEx/GraphNode\";\r\nimport { LibLoader } from \"./LibLoader\";\r\n\r\nasync function XHRResolveFile(uri: string): Promise<ITextDocument> {\r\n    try {\r\n        const request = new XMLHttpRequest();\r\n        request.open('GET', uri, false);\r\n        request.send(null);\r\n\r\n        if (request.status !== 200) {\r\n            console.error(`unable to request file ''${uri}`);\r\n            return null;\r\n        }\r\n\r\n        return createTextDocument(uri, request.responseText);\r\n    } catch (e) {\r\n        console.error(e);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nasync function loader(lib: ITextDocument) {\r\n    const docs = [\r\n        lib, \r\n        // ...\r\n    ];\r\n\r\n    let ll = new LibLoader();\r\n\r\n    for (let doc of docs) {\r\n        await ll.parse(doc, XHRResolveFile)\r\n    }\r\n\r\n    for (let node in ll.nodes) {\r\n        CodeEmitterNode.nodesDocs[node] = ll.nodes[node];\r\n    }\r\n}\r\n\r\nexport default loader;\r\n","import * as Techniques from '@lib/fx/techniques';\r\nimport * as Timeline from '@lib/fx/timeline';\r\nimport * as ipc from '@sandbox/ipc';\r\nimport * as fs from 'fs';\r\nimport React from 'react';\r\nimport FxScene from '@sandbox/containers/playground/FxScene';\r\nimport { IEmitter } from '@lib/idl/emitter';\r\nimport Technique9Scene from './playground/Technique9Scene';\r\nimport { ITechnique9 } from '@lib/idl/ITechnique9';\r\nimport { decodeBundleControls } from '@lib/fx/bundles/utils';\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\nimport { BundleMetaT } from '@lib/idl/bundles/auto/fx/bundle-meta';\r\nimport { Bundle } from '@lib/idl/bundles/auto/fx/bundle';\r\n\r\n\r\nconst style: React.CSSProperties = {\r\n    height: 'calc(100vh)',\r\n    width: 'calc(100vw)',\r\n    position: 'relative',\r\n    left: '0',\r\n    right: '0',\r\n    margin: '0'\r\n};\r\n\r\ninterface IProps {\r\n    name: string;\r\n};\r\n\r\nfunction decodeBundleMeta(data: Uint8Array): BundleMetaT {\r\n    let meta = new BundleMetaT();\r\n    let buf = new flatbuffers.ByteBuffer(data);\r\n    Bundle.getRootAsBundle(buf).meta().unpackTo(meta);\r\n    return meta;\r\n}\r\n\r\n\r\nclass Preview extends React.Component<IProps> {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    componentDidMount(): void {\r\n        // custom request to hide prevew window and show main when it's completely ready\r\n        ipc.async.notifyAppReady();\r\n    }\r\n\r\n    render() {\r\n        // TODO: add support of material's preview\r\n        const name = this.props.name;\r\n        const data = new Uint8Array(fs.readFileSync(name));\r\n        const controls = decodeBundleControls(data);\r\n        const tech = Techniques.createTechnique(data);\r\n        const timeline = Timeline.make();\r\n        timeline.start();\r\n        console.log(`source: ${decodeBundleMeta(data).source}`);\r\n        if (tech.getType() == 'emitter')\r\n            return <FxScene style={style} emitter={tech as IEmitter} timeline={timeline} controls={controls} />\r\n        else\r\n            // todo: pass technique\r\n            return <Technique9Scene style={style} material={tech as ITechnique9} timeline={timeline} controls={controls} />\r\n    }\r\n}\r\n\r\nexport default Preview;\r\n","import { assert, isDefAndNotNull, verbose } from '@lib/common';\r\nimport * as React from 'react';\r\nimport { Progress } from 'semantic-ui-react';\r\nimport * as THREE from 'three';\r\nimport ThreeScene, { IThreeSceneState, ITreeSceneProps } from './ThreeScene';\r\n\r\nimport { IEmitter, IEmitterPass } from '@lib/idl/emitter';\r\n\r\nimport { asNativeRaw, typeAstToTypeLayout } from '@lib/fx/bytecode/VM/native';\r\nimport { createSLDocument } from '@lib/fx/SLDocument';\r\nimport * as Techniques from '@lib/fx/techniques';\r\nimport { createTextDocument } from '@lib/fx/TextDocument';\r\nimport UniformHelper, { IUniformHelper } from '@lib/fx/UniformHelper';\r\nimport { Color, IPlaygroundControlsState, Vector2, Vector3, Vector4 } from '@sandbox/store/IStoreState';\r\nimport * as GLSL from './shaders/fx';\r\n\r\nimport { ControlValueType } from '@lib/fx/bundles/utils';\r\nimport { ITimeline } from '@lib/fx/timeline';\r\nimport { ITexture, ITrimesh } from '@lib/idl/emitter/IEmitter';\r\nimport { ERenderStates } from '@lib/idl/ERenderStates';\r\nimport { ERenderStateValues } from '@lib/idl/ERenderStateValues';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { Uniforms } from '@lib/idl/Uniforms';\r\nimport { prepareTrimesh } from './utils/adjacency';\r\nimport { Deps, IDeps } from './utils/deps';\r\nimport { GuiView } from './utils/gui';\r\nimport { GroupedUniforms } from './utils/GroupedUniforms';\r\nimport { SingleUniforms } from './utils/SingleUniforms';\r\n\r\nimport '@sandbox/styles/custom/dat-gui.css';\r\nimport HDRScene from './HDRScene';\r\n\r\n\r\n\r\ninterface IFxSceneProps extends ITreeSceneProps {\r\n    controls?: IPlaygroundControlsState;\r\n    emitter: IEmitter;\r\n}\r\n\r\n\r\ninterface IFxSceneState extends IThreeSceneState {\r\n    emitter: IEmitter;  // completly loaded emitter\r\n    loading: IEmitter;  // pointer to the currently loaded emitter\r\n    nParticles: number; // aux. state for UI force reload\r\n    time: string;\r\n}\r\n\r\nlet desc = `\r\nstruct PartLight {\r\n    float3 pos;\r\n    float radius;\r\n    float3 color;\r\n    float attenuation;\r\n    float viewZ;\r\n    int camIdx;\r\n    bool isFpView;\r\n    bool isAdaptiveIntensity;\r\n };\r\n`;\r\n\r\ninterface IPartLight {\r\n    pos: [number, number, number];\r\n    radius: number;\r\n    color: [number, number, number];\r\n    attenuation: number;\r\n}\r\n\r\nconst textDocument = await createTextDocument('://raw', desc);\r\nconst slDocument = await createSLDocument(textDocument);\r\nconst PartLightT = typeAstToTypeLayout(slDocument.root.scope.findType('PartLight'));\r\nconst Shaders = (id: string) => GLSL[id];\r\nconst statsStyleFix: React.CSSProperties = {\r\n    position: 'absolute',\r\n    color: 'white',\r\n    padding: '2px 5px',\r\n    fontFamily: 'consolas, monospace',\r\n    fontSize: '10px',\r\n    right: '0',\r\n    lineHeight: '11px',\r\n    textShadow: '0 0 1px grey',\r\n    whiteSpace: 'pre'\r\n};\r\n\r\nconst progressStyleFix: React.CSSProperties = {\r\n    background: '#eee',\r\n    borderRadius: '0'\r\n};\r\n\r\n\r\nfunction UnpackCanvasImageSource(img: CanvasImageSource): Uint8ClampedArray {\r\n    const width = img.width as number;\r\n    const height = img.height as number;\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    canvas.getContext('2d').drawImage(img, 0, 0, width, height);\r\n    return canvas.getContext('2d').getImageData(0, 0, width, height).data;\r\n}\r\n\r\n\r\nfunction setUniformValue(helper: IUniformHelper, name: string, type: string, value: ControlValueType) {\r\n    switch (type) {\r\n        case 'int':\r\n        case 'uint':\r\n            helper.set(name).int(value as number);\r\n            break;\r\n        case 'float':\r\n            helper.set(name).float(value as number);\r\n            break;\r\n        case 'float2':\r\n            let v2 = value as Vector2;\r\n            helper.set(name).float2(v2.x, v2.y);\r\n            break;\r\n        case 'float3':\r\n            let v3 = value as Vector3;\r\n            helper.set(name).float3(v3.x, v3.y, v3.z);\r\n            break;\r\n        case 'float4':\r\n            let v4 = value as Vector4;\r\n            helper.set(name).float4(v4.x, v4.y, v4.z, v4.w);\r\n            break;\r\n        case 'color':\r\n            let color = value as Color;\r\n            helper.set(name).float4(color.r, color.g, color.b, color.a);\r\n            break;\r\n    }\r\n}\r\n\r\n// prerecord uniforms for bytecode bundle\r\nfunction prerecordUniforms(\r\n    camera: THREE.PerspectiveCamera,\r\n    timeline: ITimeline, \r\n    controls?: IPlaygroundControlsState,\r\n    presetName?: string,\r\n    ): Uniforms {\r\n\r\n    const constants = timeline.getConstants();\r\n    const helper = UniformHelper();\r\n    helper.set('elapsedTime').float(constants.elapsedTime);\r\n    helper.set('elapsedTimeLevel').float(constants.elapsedTimeLevel);\r\n    helper.set('elapsedTimeThis').float(constants.elapsedTimeLevel);\r\n    helper.set('parentPosition').float3(0, 0, 0);\r\n    helper.set('cameraPosition').float3.apply(null, camera.position.toArray());\r\n    helper.set('instanceTotal').int(2);\r\n    helper.set('frameNumber').int(constants.frameNumber);\r\n\r\n    if (controls) {\r\n        if (presetName) {\r\n            const preset = controls?.presets.find(p => p.name == presetName);\r\n            preset?.data.forEach(entry => setUniformValue(helper, entry.name, entry.type, entry.value));\r\n        }\r\n\r\n        for (const name in controls.values) {\r\n            const type = controls.controls[name].type;\r\n            const value = controls.values[name];\r\n            setUniformValue(helper, name, type, value);\r\n        }\r\n    }\r\n\r\n    return helper.finish();\r\n}\r\n\r\nclass TriangleGeometry extends THREE.BufferGeometry {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.type = 'TriangleGeometry';\r\n\r\n\t\tconst indices = [0, 1, 2];\r\n\t\tconst vertices = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\r\n\t\tconst normals = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\r\n\t\tconst uvs = [ 0, 0, 0, 0, 0, 0 ];\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\r\n\t}\r\n}\r\n\r\n\r\nclass FxScene extends HDRScene<IFxSceneProps, IFxSceneState> {\r\n    private passes: {\r\n        meshes: (THREE.Mesh | THREE.LineSegments)[];\r\n        instancedBuffer: THREE.InstancedInterleavedBuffer | THREE.InterleavedBuffer;\r\n    }[];\r\n\r\n    private env: {\r\n        floor?: THREE.Mesh,\r\n        leftWall?: THREE.Mesh,\r\n        rightWall?: THREE.Mesh,\r\n        backWall?: THREE.Mesh,\r\n        ceiling?: THREE.Mesh\r\n    } = null;\r\n    \r\n    private helperGeom?: THREE.Object3D[] = [];\r\n\r\n    // bytecode resources\r\n    private textures: IMap<ITexture>;\r\n    private meshes: IMap<ITrimesh>;\r\n\r\n    protected gui = new GuiView;\r\n    protected uniformGroups: GroupedUniforms = new GroupedUniforms;\r\n    protected uniforms: IMap<THREE.IUniform>;\r\n    protected deps = new Deps;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            emitter: null,\r\n            loading: null,\r\n            nParticles: 0,\r\n            time: '0.00',\r\n            ...this.stateInitials()\r\n        };\r\n    }\r\n\r\n\r\n    componentDidMount() {\r\n        super.componentDidMount();\r\n\r\n        this.gui.mount(this.mount);\r\n        this.gui.create(this.props.controls);\r\n\r\n        this.uniformGroups.create9(this.props.emitter);\r\n        this.uniforms = SingleUniforms.create(this.props.controls, this.deps);\r\n\r\n        this.createEmitter(this.props.emitter);\r\n        this.start();\r\n    }\r\n\r\n\r\n    shouldComponentUpdate(nextProps: IFxSceneProps, nextState: IFxSceneState) {\r\n        return this.state.emitter !== nextProps.emitter \r\n            || this.state.nParticles !== nextState.nParticles \r\n            || this.state.time !== nextState.time;\r\n    }\r\n\r\n\r\n    // this function is called because of ant state change\r\n    // including part count\r\n    componentDidUpdate(prevProps, prevState) {\r\n        super.componentDidUpdate?.(prevProps, prevState);\r\n\r\n        // loading still in process - nothing todo\r\n        if (this.state.loading === this.props.emitter) {\r\n            return;\r\n        }\r\n\r\n        // new emitter has been passed - reload required\r\n        if (this.props.emitter !== this.state.emitter) {\r\n            // reload emitter\r\n            this.createEmitter(this.props.emitter);\r\n            return;\r\n        }\r\n\r\n        // if emitter is just loaded or update\r\n        const isLoaded = prevState.loading == this.state.emitter;\r\n        const isUpdated = prevState.emitter === this.state.emitter;\r\n        // ....\r\n    }\r\n\r\n\r\n    componentWillUnmount() {\r\n        this.removeEmitter();\r\n        super.componentWillUnmount();\r\n    }\r\n\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                style={this.props.style}\r\n                ref={(mount) => { this.mount = mount; }}\r\n            >\r\n                <Progress\r\n                    value={this.state.nParticles}\r\n                    total={this.props.emitter.getCapacity()}\r\n                    attached='top'\r\n                    size='medium'\r\n                    indicating\r\n                    style={progressStyleFix}\r\n                />\r\n                <div style={statsStyleFix}>\r\n                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: <span>{this.state.nParticles}</span><br />\r\n                    simulation: CPU<br />\r\n                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fps: <span>{Math.round(this.state.fps.value)}</span><br />\r\n                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time: <span>{this.state.time}</span><br />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    private addPassLine(pass: IEmitterPass, passId: number) {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const instanceData = Techniques.memoryToF32Array(pass.getData());\r\n        const desc = pass.getDesc();\r\n        const instancedBuffer = new THREE.InstancedInterleavedBuffer(\r\n            new Float32Array(instanceData.buffer, instanceData.byteOffset, instanceData.byteLength >> 2), \r\n            desc.stride\r\n        );\r\n        \r\n        //\r\n        // Instance data\r\n        //\r\n\r\n        desc.instanceLayout.forEach(attr => {\r\n            const interleavedAttr = new THREE.InterleavedBufferAttribute(instancedBuffer, attr.size, attr.offset);\r\n            geometry.setAttribute(attr.name, interleavedAttr);\r\n        });\r\n\r\n        const uniforms = this.uniforms;\r\n        const material = new THREE.RawShaderMaterial({\r\n            uniforms,\r\n            vertexShader: desc.vertexShader,\r\n            fragmentShader: desc.pixelShader,\r\n            transparent: true,\r\n            blending: THREE.NormalBlending,\r\n            depthTest: false,\r\n            // wireframeLinewidth: 5\r\n        });\r\n\r\n        \r\n        (material as any).uniformsGroups = this.uniformGroups.data()[passId];\r\n\r\n\r\n        geometry.setDrawRange(0, pass.getNumRenderedParticles());\r\n\r\n        const mesh = new THREE.LineSegments(geometry, material);\r\n        this.scene.add(mesh);\r\n        this.passes.push({ meshes: [mesh], instancedBuffer });\r\n    }\r\n\r\n    private addPass(pass: IEmitterPass, passId: number) {\r\n        const desc = pass.getDesc();\r\n        const instanceData = Techniques.memoryToF32Array(pass.getData());\r\n        if (desc.geometry === \"line\") {\r\n            this.addPassLine(pass, passId);\r\n            return;\r\n        }\r\n\r\n        const { stride, instanceLayout, vertexShader, pixelShader, renderStates } = desc;\r\n\r\n        // tslint:disable-next-line:max-line-length\r\n        const instancedBuffer = new THREE.InstancedInterleavedBuffer(\r\n            new Float32Array(instanceData.buffer, instanceData.byteOffset, instanceData.byteLength >> 2), \r\n            stride\r\n        );\r\n\r\n        const attrs = instanceLayout.map(attr => {\r\n            return {\r\n                name: attr.name,\r\n                data: new THREE.InterleavedBufferAttribute(instancedBuffer, attr.size, attr.offset)\r\n            };\r\n        });\r\n\r\n        const uniforms = this.uniforms;\r\n        const material = new THREE.RawShaderMaterial({\r\n            uniforms,\r\n            vertexShader: vertexShader,\r\n            fragmentShader: pixelShader,\r\n            transparent: true,\r\n            blending: THREE.NormalBlending,\r\n            depthTest: false,\r\n            // TODO: do not use for billboards\r\n            side: THREE.DoubleSide\r\n        });\r\n\r\n\r\n        // todo: add support to technique.cpp\r\n        if (renderStates?.[ERenderStates.ZENABLE]) {\r\n            material.depthTest = renderStates[ERenderStates.ZENABLE] === ERenderStateValues.TRUE;\r\n        }\r\n\r\n        // todo: add support to technique.cpp\r\n        if (renderStates?.[ERenderStates.BLENDENABLE]) {\r\n            material.transparent = renderStates[ERenderStates.BLENDENABLE] === ERenderStateValues.TRUE;\r\n        }\r\n\r\n        (material as any).uniformsGroups = this.uniformGroups.data()[passId];\r\n\r\n        const meshes = this.createInstinceGeometry(desc.geometry).map(instanceGeometry => {\r\n            const geometry = new THREE.InstancedBufferGeometry();\r\n            attrs.forEach(({ name, data }) => { geometry.setAttribute(name, data); });\r\n            // FIXME: do not use hardcoded layout\r\n            const geometryFixedLayout = {\r\n                a_position0: instanceGeometry.attributes.position,\r\n                a_normal0: instanceGeometry.attributes.normal,\r\n                a_texcoord0: instanceGeometry.attributes.uv\r\n            };\r\n            if (instanceGeometry.index) {\r\n                geometry.setIndex(instanceGeometry.index);\r\n            } else {\r\n                geometry.setIndex(Array(instanceGeometry.attributes.position.array.length / 3).fill(0).map((x, i) => i));\r\n            }\r\n            // geometry.index = instanceGeometry.index;\r\n            for (const attrName in geometryFixedLayout) {\r\n                geometry.attributes[attrName] = geometryFixedLayout[attrName];\r\n            }\r\n            const mesh = new THREE.Mesh(geometry, material);\r\n            mesh.name = `pass-${passId}-${desc.geometry}`;\r\n            return mesh;\r\n        });\r\n\r\n        this.scene.add(...meshes);\r\n        this.passes.push({ meshes, instancedBuffer });\r\n    }\r\n\r\n\r\n    private showEnv() {\r\n        if (!this.env) this.addEnv();\r\n        Object.keys(this.env).forEach(objName => (this.env[objName].visible = true));\r\n    }\r\n\r\n\r\n    private hideEnv() {\r\n        if (!this.env) return;\r\n        Object.keys(this.env).forEach(objName => (this.env[objName].visible = false));\r\n    }\r\n\r\n\r\n    private addEnv() {\r\n        if (this.env) {\r\n            return;\r\n        }\r\n\r\n        this.env = {};\r\n\r\n        const scene = this.scene;\r\n        this.env.floor = (_ => {\r\n            const geo = new THREE.PlaneGeometry(20, 20);\r\n            const mat = new THREE.MeshPhongMaterial({ shininess: 10, color: \"#fff\" });\r\n            const mesh = new THREE.Mesh(geo, mat);\r\n            mesh.rotation.x = Math.PI * -.5;\r\n            mesh.receiveShadow = true;\r\n            scene.add(mesh);\r\n            return mesh;\r\n        })();\r\n\r\n        this.env.leftWall = (_ => {\r\n            const geo = new THREE.PlaneGeometry(20, 15);\r\n            const mat = new THREE.MeshPhongMaterial({ shininess: 10, color: \"#fff\" });\r\n            const mesh = new THREE.Mesh(geo, mat);\r\n            mesh.rotation.y = Math.PI * 0.5;\r\n            mesh.position.set(-10, 7.5, 0);\r\n            mesh.receiveShadow = true;\r\n            scene.add(mesh);\r\n            return mesh;\r\n        })();\r\n\r\n        this.env.rightWall = (_ => {\r\n            const geo = new THREE.PlaneGeometry(20, 15);\r\n            const mat = new THREE.MeshPhongMaterial({ shininess: 10, color: \"#fff\" });\r\n            const mesh = new THREE.Mesh(geo, mat);\r\n            mesh.rotation.y = Math.PI * -0.5;\r\n            mesh.position.set(10, 7.5, 0);\r\n            mesh.receiveShadow = true;\r\n            scene.add(mesh);\r\n            return mesh;\r\n        })();\r\n\r\n        this.env.backWall = (_ => {\r\n            const geo = new THREE.PlaneGeometry(15, 20);\r\n            const mat = new THREE.MeshPhongMaterial({ shininess: 10, color: \"#fff\" });\r\n            const mesh = new THREE.Mesh(geo, mat);\r\n            mesh.rotation.z = Math.PI * -0.5;\r\n            mesh.position.set(0, 7.5, -10);\r\n            mesh.receiveShadow = true;\r\n            scene.add(mesh);\r\n            return mesh;\r\n        })();\r\n\r\n        this.env.ceiling = (_ => {\r\n            const geo = new THREE.PlaneGeometry(20, 20);\r\n            const mat = new THREE.MeshPhongMaterial({ shininess: 10, color: \"#fff\" });\r\n            const mesh = new THREE.Mesh(geo, mat);\r\n            mesh.rotation.x = Math.PI * 0.5;\r\n            mesh.position.set(0, 15, 0);\r\n            mesh.receiveShadow = true;\r\n            scene.add(mesh);\r\n            return mesh;\r\n        })();\r\n    }\r\n\r\n\r\n    private addPassLight(passId: number) {\r\n        this.showEnv();\r\n        this.passes.push({ meshes: null, instancedBuffer: null });\r\n    }\r\n\r\n\r\n    private addPassLWI(pass: IEmitterPass, passId: number) {\r\n        const desc = pass.getDesc();\r\n        const instanceData = Techniques.memoryToF32Array(pass.getData());\r\n\r\n        // desc.instanceName == \"LwiInstance\" || desc.instanceName == \"LwiColoredInstance\"\r\n        const GLSLMat = {\r\n            \"LwiInstance\": {\r\n                vertexShader: Shaders('lwiMatVS'),\r\n                fragmentShader: Shaders('lwiMatFS')\r\n            },\r\n            \"LwiColoredInstance\": {\r\n                vertexShader: Shaders('lwiColoredMatVS'),\r\n                fragmentShader: Shaders('lwiColoredMatFS')\r\n            },\r\n        }\r\n\r\n        // tslint:disable-next-line:max-line-length\r\n        const instancedBuffer = new THREE.InstancedInterleavedBuffer(\r\n            new Float32Array(instanceData.buffer, instanceData.byteOffset, instanceData.byteLength >> 2), \r\n            desc.stride\r\n        );\r\n        instancedBuffer.setUsage(THREE.DynamicDrawUsage);\r\n        const a_dynData_0 = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 0);\r\n        const a_dynData_1 = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 4);\r\n        const a_worldMat_0 = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 8);\r\n        const a_worldMat_1 = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 12);\r\n        const a_worldMat_2 = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 16);\r\n        const a_worldMatPrev_0 = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 20);\r\n        const a_worldMatPrev_1 = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 24);\r\n        const a_worldMatPrev_2 = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 28);\r\n\r\n        \r\n\r\n        const uniforms = this.uniforms;\r\n        const material = new THREE.RawShaderMaterial({\r\n            uniforms,\r\n            ...GLSLMat[desc.instanceName],\r\n            transparent: true,\r\n            blending: THREE.NormalBlending,\r\n            depthTest: true,\r\n            // TODO: do not use for billboards\r\n            side: THREE.DoubleSide\r\n        });\r\n\r\n        (material as any).uniformsGroups = this.uniformGroups.data()[passId];\r\n\r\n        const meshes = this.createInstinceGeometry(desc.geometry, \"box\").map(instanceGeometry => {\r\n            const geometry = new THREE.InstancedBufferGeometry();\r\n            geometry.index = instanceGeometry.index;\r\n            geometry.attributes.position = instanceGeometry.attributes.position;\r\n            geometry.attributes.normal = instanceGeometry.attributes.normal;\r\n            geometry.attributes.uv = instanceGeometry.attributes.uv;\r\n            geometry.attributes.a_dynData_0 = a_dynData_0;\r\n            geometry.attributes.a_dynData_1 = a_dynData_1;\r\n            geometry.attributes.a_worldMat_0 = a_worldMat_0;\r\n            geometry.attributes.a_worldMat_1 = a_worldMat_1;\r\n            geometry.attributes.a_worldMat_2 = a_worldMat_2;\r\n            geometry.attributes.a_worldMatPrev_0 = a_worldMatPrev_0;\r\n            geometry.attributes.a_worldMatPrev_1 = a_worldMatPrev_1;\r\n            geometry.attributes.a_worldMatPrev_2 = a_worldMatPrev_2;\r\n            geometry.instanceCount = pass.getNumRenderedParticles();\r\n            const mesh = new THREE.Mesh(geometry, material);\r\n            mesh.name = `pass-lwi-${passId}-${desc.geometry}`;\r\n            return mesh;\r\n        });\r\n        this.scene.add(...meshes);\r\n        this.passes.push({ meshes: meshes, instancedBuffer });\r\n    }\r\n\r\n\r\n    private addPassDefaultMat(pass: IEmitterPass, passId: number) {\r\n        const desc = pass.getDesc();\r\n        const instanceData = Techniques.memoryToF32Array(pass.getData());\r\n        // tslint:disable-next-line:max-line-length\r\n        const instancedBuffer = new THREE.InstancedInterleavedBuffer(\r\n            new Float32Array(instanceData.buffer, instanceData.byteOffset, instanceData.byteLength >> 2), \r\n            desc.stride\r\n        );\r\n        instancedBuffer.setUsage(THREE.DynamicDrawUsage);\r\n        // instancedBuffer.setDynamic(true);\r\n        // todo: remove hardcoded layout or check it's validity.\r\n        const offset = new THREE.InterleavedBufferAttribute(instancedBuffer, 3, 0);\r\n        const color = new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 3);\r\n        const size = new THREE.InterleavedBufferAttribute(instancedBuffer, 1, 7);\r\n\r\n        const uniforms = this.uniforms;\r\n        const material = new THREE.RawShaderMaterial({\r\n            uniforms,\r\n            vertexShader: Shaders('defMatVS'),\r\n            fragmentShader: Shaders('defMatFS'),\r\n            transparent: true,\r\n            blending: THREE.NormalBlending,\r\n            depthTest: false\r\n        });\r\n\r\n        (material as any).uniformsGroups = this.uniformGroups.data()[passId];\r\n\r\n        const meshes = this.createInstinceGeometry(desc.geometry).map(instanceGeometry => {\r\n            const geometry = new THREE.InstancedBufferGeometry();\r\n            geometry.index = instanceGeometry.index;\r\n            geometry.attributes.position = instanceGeometry.attributes.position;\r\n            geometry.attributes.normal = instanceGeometry.attributes.normal;\r\n            geometry.attributes.uv = instanceGeometry.attributes.uv;\r\n            geometry.attributes.offset = offset;\r\n            geometry.attributes.color = color;\r\n            geometry.attributes.size = size;\r\n            geometry.instanceCount = pass.getNumRenderedParticles();\r\n            const mesh = new THREE.Mesh(geometry, material);\r\n            mesh.name = `pass-def-${passId}-${desc.geometry}`;\r\n            return mesh;\r\n        });\r\n\r\n        this.scene.add(...meshes);\r\n        this.passes.push({ meshes, instancedBuffer });\r\n    }\r\n\r\n\r\n    private createInstinceGeometry(geometry: string, fallback = \"billboard\"): THREE.BufferGeometry[] {\r\n        let instanceGeometry: THREE.BufferGeometry[] = null;\r\n        switch (geometry) {\r\n            case \"box\":\r\n                instanceGeometry = [new THREE.BoxGeometry()];\r\n                break;\r\n            case \"sphere\":\r\n                instanceGeometry = [new THREE.SphereGeometry(0.5)];\r\n                break;\r\n            case \"cylinder\":\r\n                instanceGeometry = [new THREE.CylinderGeometry(0.5, 0.5, 1.0)];\r\n                break;\r\n            case \"line\":\r\n                console.assert(false, \"line should have been handled using different code branch\");\r\n                break;\r\n            case \"billboard\":\r\n                instanceGeometry = [new THREE.PlaneGeometry()];\r\n                break;\r\n            case \"triangle\":\r\n                instanceGeometry = [ new TriangleGeometry() ];\r\n                break;\r\n            default:\r\n                let objName = Object.keys(this.deps.models).find(name => name.includes(geometry));\r\n                if (objName) {\r\n                    let meshes = this.deps.models[objName];\r\n                    if (meshes) {\r\n                        return meshes.map(mesh => mesh.geometry);\r\n                    }\r\n                }\r\n                return this.createInstinceGeometry(fallback);\r\n        }\r\n        return instanceGeometry;\r\n    }\r\n\r\n\r\n    private removeEmitter() {\r\n        this.passes?.forEach(pass => {\r\n            if (pass.meshes) {\r\n                this.scene.remove(...pass.meshes);\r\n            }\r\n            // verbose('emitter\\'s pass removed.');\r\n        });\r\n\r\n        Object.values(this.textures || {}).forEach(tex => {\r\n            Techniques.destroyTexture(tex);\r\n        });\r\n\r\n        Object.values(this.meshes || {}).forEach(mesh => {\r\n            Techniques.destroyTrimesh(mesh);\r\n        });\r\n\r\n        this.meshes = {};\r\n        this.textures = {};\r\n    }\r\n\r\n\r\n    private createPasses(emitter: IEmitter) {\r\n        this.passes = [];\r\n        // tslint:disable-next-line:max-func-body-length\r\n        let nPass = emitter.getPassCount();\r\n        this.hideEnv();\r\n        for (let i = 0; i < nPass; ++i) {\r\n            let pass = emitter.getPass(i);\r\n            let desc = pass.getDesc();\r\n            if (desc.vertexShader && desc.pixelShader) {\r\n                this.addPass(pass, i);\r\n            } else if (desc.instanceName == \"DefaultShaderInput\") {\r\n                this.addPassDefaultMat(pass, i);\r\n            } else if (desc.instanceName == \"LwiInstance\" || desc.instanceName == \"LwiColoredInstance\") {\r\n                this.addPassLWI(pass, i);\r\n            } else if (desc.instanceName == \"PartLight\") {\r\n                this.addPassLight(i);\r\n            }\r\n        }\r\n\r\n        this.setState({ emitter, loading: null });\r\n        verbose(`emitter '${emitter.getName()}' has been loaded.`);\r\n    }\r\n\r\n\r\n    private createEmitter(emitter: IEmitter) {\r\n        this.removeEmitter();\r\n\r\n        if (!isDefAndNotNull(emitter)) {\r\n            return;\r\n        }\r\n\r\n        verbose(`emitter '${emitter.getName()}' loading in process...`);\r\n        this.setState({ loading: emitter, emitter: null });\r\n\r\n        const controls = this.props.controls;\r\n        const doLoadTexture = true;//Object.values(controls?.controls).map(ctrl => ctrl.type).includes('texture2d');\r\n        const doLoadMeshes = Object.values(controls?.controls).map(ctrl => ctrl.type).includes('mesh');\r\n\r\n        this.deps.resolve(doLoadTexture, doLoadMeshes, (deps: IDeps) => {\r\n            this.createPasses(emitter);\r\n        });\r\n    }\r\n\r\n\r\n    // setup resource for simulation\r\n    // all except uniforms\r\n    private setupResources() {\r\n        const emitter = this.state.emitter;\r\n\r\n        const createTextureFromSource = (dep: THREE.Texture) => {\r\n            let img = dep.source.data;\r\n            let width = img.width as number;\r\n            let height = img.height as number;\r\n            let data = null;\r\n\r\n            // return Techniques.createTexture({ width: 1, height: 1 }, new Uint8Array([0,0,0,0]));\r\n            if (img instanceof HTMLImageElement) {\r\n                data = UnpackCanvasImageSource(img as CanvasImageSource);\r\n            } else {\r\n                data = img.data;\r\n            }\r\n\r\n            return Techniques.createTexture({ width, height }, data);\r\n        };\r\n\r\n\r\n        const createMeshFromSource = (dep: THREE.Mesh[]) => {\r\n            const { geometry } = dep[0];\r\n            assert(geometry);\r\n\r\n            const { vertCount, faceCount, vertices, faces, indicesAdj, facesAdj } = prepareTrimesh(geometry);\r\n            return Techniques.createTrimesh(\r\n                {\r\n                    vertCount,\r\n                    faceCount\r\n                },\r\n                new Float32Array(vertices),\r\n                new Uint32Array(faces),\r\n                new Uint32Array(indicesAdj),\r\n                new Uint32Array(facesAdj));\r\n        };\r\n\r\n        const controls = this.props.controls;\r\n        for (const name in controls.values) {\r\n            // todo: skip textrues and meshes\r\n            const type = controls.controls[name].type;\r\n            const value = controls.values[name] as string;\r\n\r\n            if (type == 'texture2d') {\r\n                // all the sources must be preloaded in advance (!)\r\n                const source = this.deps.textures[value];\r\n\r\n                // if (!source) {\r\n                //     const value = 'TEXTURE_PLACEHOLDER_WHITE_1X1';\r\n                //     if (!this.textures[value]) {\r\n                //         this.textures[value] = createTextureFromSource(TEXTURE_PLACEHOLDER_WHITE_1X1);\r\n                //     }\r\n                //     emitter.setTexture(name, this.textures[value]);\r\n                //     continue;\r\n                // }\r\n\r\n                if (!this.textures[value]) {\r\n                    this.textures[value] = createTextureFromSource(source);\r\n                }\r\n\r\n                emitter.setTexture(name, this.textures[value]);\r\n            }\r\n\r\n            if (type == 'mesh') {\r\n                // all the sources must be preloaded in advance (!)\r\n                const source = this.deps.models[value];\r\n\r\n                if (!this.meshes[value]) {\r\n                    this.meshes[value] = createMeshFromSource(source);\r\n                }\r\n\r\n                // temp solution until geom is not rendered from effect\r\n                if (this.gui.debugDraw()[name]) {\r\n                    this.helperGeom.push(...source.map(obj => {\r\n                        const mesh = obj.clone();\r\n                        // mesh.material = new THREE.MeshBasicMaterial({ \r\n                        //     color: 0xFF0000, \r\n                        //     wireframe: true, \r\n                        //     wireframeLinewidth: 3, \r\n                        //     transparent: true,\r\n                        //     opacity: 0.25\r\n                        // });\r\n\r\n                        mesh.material = new THREE.MeshNormalMaterial();\r\n                        // mesh.material = new THREE.MeshStandardMaterial({ map: this.deps.textures['skull.jpg'] });\r\n                        return mesh;\r\n                    }));\r\n\r\n                //     {\r\n                //         const color = 0xFFFFFF;\r\n                //         const intensity = 0.2;\r\n                //         const light = new THREE.AmbientLight(color, intensity);\r\n                //         this.helperGeom.push(light);\r\n                //     }\r\n\r\n                //     {\r\n                //         const color = 0xFFFFFF;\r\n                //         const intensity = 0.8;\r\n                //         const light = new THREE.PointLight(color, intensity, 10);\r\n                //         light.position.set(3, 3, 3);\r\n                //         this.helperGeom.push(light);\r\n                //     }\r\n                }\r\n\r\n                emitter.setTrimesh(name, this.meshes[value]);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    protected createLights(): THREE.Object3D[] {\r\n        const emitter = this.state.emitter;\r\n        const lights: THREE.Object3D[] = [];\r\n\r\n        for (let iPass = 0; iPass < this.passes.length; ++iPass) {\r\n            const rendPass = this.passes[iPass];\r\n            const emitPass = emitter.getPass(iPass);\r\n            const passDesc = emitPass.getDesc();\r\n\r\n            if (!rendPass.meshes) {\r\n                console.assert(emitPass.getDesc().instanceName == \"PartLight\");\r\n\r\n                // is light pass\r\n                const instanceData = Techniques.memoryToU8Array(emitPass.getData());\r\n\r\n                for (let iPart = 0; iPart < emitPass.getNumRenderedParticles(); ++iPart) {\r\n                    const pl = asNativeRaw(instanceData.subarray(PartLightT.size * iPart, (iPart + 1) * PartLightT.size), PartLightT) as IPartLight;\r\n                    const ci = Math.max(...pl.color);\r\n                    const c = Math.floor(pl.color[0] / ci * 255) | (Math.floor(pl.color[1] / ci * 255) << 8) | (Math.floor(pl.color[2] / ci * 255) << 16);\r\n                    const light = new THREE.PointLight(c, 10, pl.radius, pl.attenuation == 0 ? 4 : pl.attenuation);\r\n                    const helper = new THREE.PointLightHelper(light);\r\n                    light.position.set(...pl.pos);\r\n                    lights.push(light, helper);\r\n                    // console.log(`${iPart}/${emitPass.getNumRenderedParticles()}`, partLight);\r\n                }\r\n\r\n                continue;\r\n            }\r\n        }\r\n\r\n        return lights;\r\n    }\r\n\r\n\r\n    // update instance count for every pass geometry\r\n    protected setGeometryInstanceCouts() {\r\n        const emitter = this.state.emitter;\r\n        for (let iPass = 0; iPass < this.passes.length; ++iPass) {\r\n            const rendPass = this.passes[iPass];\r\n            const emitPass = emitter.getPass(iPass);\r\n            const passDesc = emitPass.getDesc();\r\n            if (rendPass.instancedBuffer)\r\n                rendPass.instancedBuffer.needsUpdate = true;\r\n            rendPass.meshes?.forEach(mesh => {\r\n                const geometry = mesh.geometry as THREE.BufferGeometry;\r\n                if (passDesc.geometry === \"line\") {\r\n                    geometry.setDrawRange(0, emitPass.getNumRenderedParticles());\r\n                } else {\r\n                    (geometry as THREE.InstancedBufferGeometry).instanceCount = emitPass.getNumRenderedParticles();\r\n                }\r\n            });\r\n            // emitPass.dump();\r\n        }\r\n    }\r\n\r\n\r\n    protected override beginFrame() {\r\n        const emitter = this.state.emitter;\r\n        const timeline = this.props.timeline;\r\n        const controls = this.props.controls;\r\n        const tech9 = this.props.emitter;\r\n        const camera = this.camera;\r\n        const viewport = this.mount;\r\n        const deps = this.deps;\r\n        const preset = this.gui.preset();\r\n\r\n        if (!emitter) {\r\n            return;\r\n        }\r\n\r\n        // IP: including textures\r\n        this.uniformGroups.update9(camera, viewport, controls, timeline, deps, tech9);\r\n        SingleUniforms.update(controls, timeline, deps, this.uniforms);\r\n\r\n        // dedicated way to setup bytecode bundle resource\r\n        // todo: generalize with uniforms?\r\n        this.setupResources();\r\n        const uniforms = prerecordUniforms(camera, timeline, controls, preset);\r\n\r\n        if (!timeline.isStopped() && !timeline.isPaused()) {\r\n            timeline.tick();\r\n            emitter.simulate(uniforms);\r\n        }\r\n\r\n        emitter.prerender(uniforms);\r\n        // do nothing if there is no sorting\r\n        emitter.serialize(); // feed render buffer with instance data\r\n\r\n        this.setGeometryInstanceCouts();\r\n        this.helperGeom.push(...this.createLights());\r\n        if (this.helperGeom.length)\r\n            this.scene.add(...this.helperGeom);\r\n\r\n        this.setState({ \r\n            nParticles: emitter.getNumParticles(),\r\n            time: timeline.getConstants().elapsedTimeLevel.toFixed(2)\r\n         });\r\n\r\n\r\n        // emitter.dump();\r\n        // do not call beginFrame() here (!)\r\n        // super.beginFrame();\r\n    }\r\n\r\n\r\n\r\n    protected override endFrame(): void {\r\n        this.scene.remove(...this.helperGeom);\r\n        this.helperGeom = [];\r\n    }\r\n\r\n}\r\n\r\nexport default FxScene;\r\n","import { GUI } from 'dat.gui';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';\r\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';\r\nimport { TAARenderPass } from 'three/examples/jsm/postprocessing/TAARenderPass';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass';\r\nimport { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader';\r\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';\r\nimport { GammaCorrectionShader } from 'three/examples/jsm/shaders/GammaCorrectionShader';\r\n\r\nimport { isString } from '@lib/common';\r\nimport autobind from 'autobind-decorator';\r\nimport * as THREE from 'three';\r\nimport ThreeScene, { IThreeSceneState, ITreeSceneProps } from './ThreeScene';\r\n\r\ntype Tonemap = \"No\"| \"Linear\"| \"Reinhard\"| \"Cineon\"| \"ACESFilmic\"| \"Custom\";\r\n\r\ninterface HdrParams {\r\n    bloom: boolean;\r\n    toneMappingExposure: number;\r\n    toneMappingType: Tonemap;\r\n    bloomStrength: number;\r\n    bloomThreshold: number;\r\n    bloomRadius: number;\r\n}\r\n\r\nfunction dumpHdrParams(params: HdrParams) {\r\n    Object.keys(params).forEach(prop => localStorage[prop] = params[prop]);\r\n}\r\n\r\nfunction size(div: HTMLDivElement, pixelRatio: number) {\r\n    return {\r\n        width: (div.clientWidth * pixelRatio),// + 0.5) >>> 0,\r\n        height: (div.clientHeight * pixelRatio),// + 0.5) >>> 0,\r\n    }\r\n}\r\n\r\n\r\nfunction restoreHdrParams(): HdrParams {\r\n    const params: HdrParams = {        \r\n        bloom: true,\r\n        toneMappingType: 'Linear',\r\n        toneMappingExposure: 1.0,\r\n        bloomStrength: 2.0,\r\n        bloomThreshold: 1.0,\r\n        bloomRadius: 1.0\r\n    };\r\n\r\n    params.bloom = isString(localStorage.bloom) ? localStorage.bloom === 'true' : params.bloom;\r\n    params.toneMappingType = localStorage.toneMappingType || 'ACESFilmic';\r\n    params.toneMappingExposure = Number(localStorage.toneMappingExposure || params.toneMappingExposure);\r\n    params.bloomThreshold = Number(localStorage.bloomThreshold || params.bloomThreshold);\r\n    params.bloomStrength = Number(localStorage.bloomStrength || params.bloomStrength);\r\n    params.bloomRadius = Number(localStorage.bloomRadius || params.bloomRadius);\r\n    return params;\r\n}\r\n\r\n\r\nclass HDRScene<P extends ITreeSceneProps, S extends IThreeSceneState> extends ThreeScene<P, S> {\r\n    protected composer: EffectComposer;\r\n    protected hdrControls: GUI;\r\n    protected hdrParams: HdrParams;\r\n\r\n    protected override createRenderer(width, height): THREE.WebGLRenderer {\r\n        const renderer = new THREE.WebGLRenderer({\r\n            antialias: true,\r\n            preserveDrawingBuffer: true // screenshots\r\n        });\r\n        renderer.setPixelRatio( window.devicePixelRatio );\r\n        renderer.setSize( width, height );\r\n        // renderer.outputEncoding = THREE.sRGBEncoding;\r\n        // renderer.toneMapping = ReinhardToneMapping;\r\n        // renderer.toneMapping = THREE.ACESFilmicToneMapping;\r\n        return renderer;\r\n    }\r\n\r\n\r\n    private createSceneControls(bloomPass: UnrealBloomPass, renderer: THREE.WebGLRenderer): GUI {\r\n        const params = this.hdrParams;\r\n        const gui = new GUI({ autoPlace: false });\r\n\r\n        // gui.name = 'Tonemapping';\r\n        GUI.TEXT_OPEN = 'Show Options';\r\n\r\n        this.mount.appendChild(gui.domElement);\r\n        gui.domElement.style.position = 'absolute';\r\n        gui.domElement.style.bottom = '20px';\r\n\r\n        let tonemap = gui.addFolder('tonemapping');\r\n\r\n        tonemap.add(params, 'bloom').onChange(value => {\r\n            dumpHdrParams(this.hdrParams);\r\n        });\r\n\r\n        tonemap.add(params, 'toneMappingExposure', 0.1, 2.0).onChange((value) => {\r\n            renderer.toneMappingExposure = Math.pow(value, 4.0);\r\n            dumpHdrParams(this.hdrParams);\r\n        }).name('exposure');\r\n\r\n        tonemap.add(params, 'bloomThreshold', 0.0, 1.0).onChange((value) => {\r\n            bloomPass.threshold = Number(value);\r\n            dumpHdrParams(this.hdrParams);\r\n        });\r\n\r\n        tonemap.add(params, 'bloomStrength', 0.0, 3.0).onChange((value) => {\r\n            bloomPass.strength = Number(value);\r\n            dumpHdrParams(this.hdrParams);\r\n        });\r\n\r\n        tonemap.add(params, 'bloomRadius', 0.0, 1.0).step(0.01).onChange((value) => {\r\n            bloomPass.radius = Number(value);\r\n            dumpHdrParams(this.hdrParams);\r\n        });\r\n\r\n        // tonemap.add(params, 'toneMappingType', [ \"No\", \"Linear\", \"Reinhard\", \"Cineon\", \"ACESFilmic\", \"Custom\" ])\r\n        // .name('type').onChange((value) => {\r\n        //     this.renderer.toneMapping = THREE[`${value}ToneMapping`];\r\n        //     dumpHdrParams(this.hdrParams);\r\n        // });\r\n\r\n        tonemap.open();\r\n        gui.close();\r\n\r\n        return gui;\r\n    }\r\n\r\n\r\n    componentDidMount() {\r\n        super.componentDidMount({ grid: true, fog: true });\r\n\r\n        // this.scene.background = new THREE.Color(0x333333);\r\n        // this.fog.color = new THREE.Color(0x333333);\r\n        \r\n        const scene = this.scene;\r\n        const camera = this.camera;\r\n        const renderer = this.renderer;\r\n        const mount = this.mount;\r\n\r\n        const pixelRatio = this.renderer.getPixelRatio();\r\n        const { width, height } = size(mount, pixelRatio);\r\n        const renderScene = new RenderPass(scene, camera);\r\n        const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);\r\n        const smaaPass = new SMAAPass(width, height);\r\n\r\n        // const fxaaPass = new ShaderPass(FXAAShader);\r\n        // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / width;\r\n        // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / height;\r\n       \r\n        this.hdrParams = restoreHdrParams();\r\n        this.renderer.toneMapping = THREE[`${this.hdrParams.toneMappingType}ToneMapping`];\r\n\r\n        renderer.toneMappingExposure = this.hdrParams.toneMappingExposure;\r\n        bloomPass.threshold = this.hdrParams.bloomThreshold;\r\n        bloomPass.strength = this.hdrParams.bloomStrength;\r\n        bloomPass.radius = this.hdrParams.bloomRadius;\r\n\r\n        const parameters = {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.LinearFilter,\r\n            format: THREE.RGBAFormat,\r\n            type: THREE.FloatType\r\n        };\r\n        \r\n        const renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);\r\n        this.composer = new EffectComposer(renderer, renderTarget);\r\n        \r\n        const composer = this.composer;\r\n        composer.setPixelRatio(pixelRatio);\r\n        composer.addPass(renderScene);\r\n        composer.addPass(bloomPass);\r\n        // composer.addPass(new ShaderPass(GammaCorrectionShader));\r\n        composer.addPass(smaaPass);\r\n        // composer.addPass(fxaaPass);\r\n\r\n        this.hdrControls = this.createSceneControls(bloomPass, renderer);\r\n    }\r\n\r\n\r\n\r\n    protected renderFrame() {\r\n        if (this.hdrParams.bloom) {\r\n            this.composer.render();\r\n        } else {\r\n            super.renderFrame();\r\n        }\r\n    }\r\n\r\n\r\n    @autobind\r\n    onWindowResize() {\r\n        super.onWindowResize(); // << update renderer size and camera aspect\r\n        const { mount, renderer } = this;\r\n        const { width, height } = size(mount, renderer.getPixelRatio());\r\n        this.composer.setSize(width, height);\r\n        // todo: change resolution of bloom pass here?\r\n    }\r\n}\r\n\r\nexport default HDRScene;\r\n","import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\r\n\r\nimport { ERenderStates } from '@lib/idl/ERenderStates';\r\nimport { ERenderStateValues } from '@lib/idl/ERenderStateValues';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ITechnique9 } from '@lib/idl/ITechnique9';\r\nimport { IPlaygroundControlsState } from '@sandbox/store/IStoreState';\r\nimport * as THREE from 'three';\r\nimport HDRScene from './HDRScene';\r\nimport { IThreeSceneState, ITreeSceneProps } from './ThreeScene';\r\nimport { Deps } from './utils/deps';\r\nimport { GroupedUniforms } from './utils/GroupedUniforms';\r\nimport { GuiView } from './utils/gui';\r\nimport { SingleUniforms } from './utils/SingleUniforms';\r\n\r\n\r\ninterface IProps extends ITreeSceneProps {\r\n    controls?: IPlaygroundControlsState;\r\n    material: ITechnique9;\r\n}\r\n\r\n\r\ninterface IState extends IThreeSceneState {\r\n    // todo\r\n}\r\n\r\n/** @deprecated */\r\nclass Technique9Scene extends HDRScene<IProps, IState> {\r\n    protected groups: THREE.Group[];\r\n    protected params: { model: string } = { model: 'probe' };\r\n\r\n    protected gui = new GuiView;\r\n    protected uniformGroups: GroupedUniforms = new GroupedUniforms;\r\n    protected uniforms: IMap<THREE.IUniform>;\r\n    protected deps = new Deps;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            // todo\r\n            ...this.stateInitials()\r\n        };\r\n    }\r\n\r\n\r\n    private reloadModel() {\r\n        const loader = new OBJLoader();\r\n        const params = this.params;\r\n        const passCount = this.props.material.getPassCount();\r\n        const scene = this.scene;\r\n\r\n        this.scene.remove(...(this.groups || []));\r\n\r\n        switch (params.model) {\r\n            case 'plane':\r\n                {\r\n                    const geom = new THREE.PlaneGeometry(2, 2);\r\n                    const mesh = new THREE.Mesh(geom, null);\r\n                    const group = new THREE.Group();\r\n                    group.add(mesh);\r\n\r\n                    this.groups = [group];\r\n                    scene.add(...this.groups);\r\n                    this.reloadMaterial();\r\n                    return;\r\n                }\r\n                break;\r\n        }\r\n\r\n        loader.load(\r\n            `./assets/models/${params.model}.obj`,\r\n            (group: THREE.Group) => {\r\n\r\n                this.groups = Array(passCount).fill(null).map(x => group.clone(true));\r\n                this.groups.forEach(g => {\r\n                    g.children.forEach(c => {\r\n                        const m = c as THREE.Mesh;\r\n                        const g = m.geometry;\r\n                        // prepareTrimesh(g);\r\n                    });\r\n                });\r\n                scene.add(...this.groups);\r\n\r\n                this.reloadMaterial();\r\n            },\r\n            (xhr) => {\r\n                console.log((xhr.loaded / xhr.total * 100) + '% loaded');\r\n            },\r\n            (error) => {\r\n                console.log('An error happened');\r\n                this.groups = null;\r\n            }\r\n        );\r\n    }\r\n\r\n\r\n    componentDidMount() {\r\n        super.componentDidMount();\r\n\r\n        this.gui.mount(this.mount);\r\n        this.gui.create(this.props.controls);\r\n\r\n        this.hdrControls.add(this.params, 'model', ['probe', 'cube', 'plane']).onChange((value) => {\r\n            this.reloadModel();\r\n        });\r\n\r\n        this.uniforms = SingleUniforms.create(this.props.controls, this.deps);\r\n        this.uniformGroups.create9(this.props.material);\r\n\r\n        this.reloadModel();\r\n        this.start();\r\n    }\r\n\r\n\r\n    shouldComponentUpdate(nextProps: IProps, nexState) {\r\n        return this.props.material !== nextProps.material;\r\n    }\r\n\r\n\r\n    componentDidUpdate(prevProps: any, prevState: any): void {\r\n        super.componentDidUpdate(prevProps, prevState);\r\n\r\n        this.gui.create(this.props.controls);\r\n\r\n        const passCount = this.props.material.getPassCount();\r\n\r\n        this.scene.remove(...this.groups);\r\n        if (passCount > 0) {\r\n            this.groups = Array(passCount).fill(null).map(x => this.groups[0].clone(true) || null);\r\n            this.scene.add(...this.groups);\r\n        }\r\n\r\n        this.reloadMaterial();\r\n    }\r\n\r\n\r\n    protected reloadMaterial() {\r\n        const groups = this.groups;\r\n        const controls = this.props.controls;\r\n\r\n        const doLoadTexture = Object.values(controls?.controls).map(ctrl => ctrl.type).includes('texture2d');\r\n        const doLoadMeshes = Object.values(controls?.controls).map(ctrl => ctrl.type).includes('mesh');\r\n        this.deps.resolve(doLoadTexture, doLoadMeshes);\r\n\r\n        this.uniformGroups.create9(this.props.material); // hack to avoid error: GL_INVALID_OPERATION: It is undefined behaviour to use a uniform buffer that is too small.\r\n\r\n        for (let p = 0; p < this.props.material.getPassCount(); ++p) {\r\n            const group = groups[p];\r\n            const { vertexShader, pixelShader, renderStates } = this.props.material.getPass(p).getDesc();\r\n            const uniforms = this.uniforms;\r\n\r\n            const material = new THREE.RawShaderMaterial({\r\n                uniforms,\r\n                vertexShader: vertexShader,\r\n                fragmentShader: pixelShader,\r\n                blending: THREE.NormalBlending,\r\n                transparent: false,\r\n                depthTest: true\r\n            });\r\n\r\n            (material as any).uniformsGroups = this.uniformGroups.data()[p];\r\n\r\n            if (renderStates[ERenderStates.ZENABLE]) {\r\n                material.depthTest = renderStates[ERenderStates.ZENABLE] === ERenderStateValues.TRUE;\r\n            }\r\n\r\n            if (renderStates[ERenderStates.BLENDENABLE]) {\r\n                material.transparent = renderStates[ERenderStates.BLENDENABLE] === ERenderStateValues.TRUE;\r\n            }\r\n\r\n            if (renderStates[ERenderStates.CULLFACE]) {\r\n                switch (renderStates[ERenderStates.CULLFACE]) {\r\n                    case ERenderStateValues.FRONT:\r\n                        material.side = THREE.FrontSide;\r\n                        break;\r\n                    case ERenderStateValues.BACK:\r\n                        material.side = THREE.BackSide;\r\n                        break;\r\n                    case ERenderStateValues.FRONT_AND_BACK:\r\n                        material.side = THREE.DoubleSide;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            for (const object of group.children) {\r\n                const mesh = object as THREE.Mesh;\r\n                mesh.material = material;\r\n\r\n                // IP: hack to support default geom layout like:\r\n                // struct Geometry {\r\n                //  float3 position: POSITION0;\r\n                //  float3 normal: NORMAL0;\r\n                //  float2 uv: TEXCOORD0;\r\n                // };\r\n                // console.log(mesh.geometry.attributes);\r\n                // sandbox\r\n                mesh.geometry.attributes['a_position0'] = mesh.geometry.attributes.position;\r\n                mesh.geometry.attributes['a_normal0'] = mesh.geometry.attributes.normal;\r\n                mesh.geometry.attributes['a_texcoord0'] = mesh.geometry.attributes.uv;\r\n                // husky\r\n                mesh.geometry.attributes['a_v_position'] = mesh.geometry.attributes.position;\r\n                mesh.geometry.attributes['a_v_normal'] = mesh.geometry.attributes.normal;\r\n                mesh.geometry.attributes['a_v_texcoord0'] = mesh.geometry.attributes.uv;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    protected override beginFrame(): void {\r\n        const { timeline, controls, material } = this.props;\r\n        const { deps, camera, mount } = this;\r\n\r\n        SingleUniforms.update(controls, timeline, deps, this.uniforms);\r\n        this.uniformGroups.update9(camera, mount, controls, timeline, deps, material);\r\n\r\n        super.beginFrame();\r\n    }\r\n}\r\n\r\nexport default Technique9Scene;\r\n","import { verbose } from '@lib/common';\r\nimport { ITimeline } from '@lib/fx/timeline';\r\nimport { IPlaygroundControlsState } from '@sandbox/store/IStoreState';\r\nimport { OrbitControls } from '@three-ts/orbit-controls';\r\nimport autobind from 'autobind-decorator';\r\nimport * as React from 'react';\r\nimport * as THREE from 'three';\r\n\r\n\r\n\r\nexport interface ITreeSceneProps {\r\n    style?: React.CSSProperties;\r\n    timeline: ITimeline;\r\n\r\n    canvasRef?: (canvas: HTMLCanvasElement) => void;\r\n}\r\n\r\n\r\nexport interface IThreeSceneState {\r\n    fps: { min: number, max: number, value: number };\r\n}\r\n\r\n\r\nclass ThreeScene<P extends ITreeSceneProps, S extends IThreeSceneState> extends React.Component<P, S> {\r\n    private frames = 0;      // fps stats\r\n    private prevTime = 0;    // fps stats\r\n    private frameId: number; // animation loop\r\n\r\n    protected renderer: THREE.WebGLRenderer;\r\n    protected camera: THREE.PerspectiveCamera;\r\n    protected scene: THREE.Scene;\r\n    protected fog: THREE.FogBase;\r\n    protected orbitControls: OrbitControls;\r\n    protected mount: HTMLDivElement;\r\n\r\n\r\n    protected stateInitials(): IThreeSceneState {\r\n        return {\r\n            fps: { min: 0, max: 0, value: 0 }\r\n        };\r\n    }\r\n\r\n\r\n    componentDidMount({ grid, fog } = { grid: true, fog: true }) {\r\n        const width = this.mount.clientWidth;\r\n        const height = this.mount.clientHeight;\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.scene.background = new THREE.Color(0xCCCCCC);\r\n        this.camera = this.createCamera(width, height);\r\n        this.fog = null;\r\n\r\n        if (fog) {\r\n            const color = 0xCCCCCC;  // white\r\n            this.fog = new THREE.FogExp2(color, 0.035);\r\n        }\r\n\r\n        this.scene.fog = this.fog;\r\n\r\n        this.renderer = this.createRenderer(width, height);\r\n        this.renderer.setSize(width, height);\r\n        this.renderer.setPixelRatio(window.devicePixelRatio);\r\n        this.renderer.domElement.id = \"playground-main-canvas\";\r\n        // FIXME: remove this ui hack\r\n        this.renderer.domElement.style.borderBottomLeftRadius = '3px';\r\n        this.renderer.domElement.style.borderBottomRightRadius = '3px';\r\n        this.mount.appendChild(this.renderer.domElement);\r\n\r\n        this.props.canvasRef?.(this.renderer.domElement);\r\n\r\n        this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);\r\n        this.orbitControls.enabled = false;\r\n        // temp solution in order to not moving text cursor during movement\r\n        this.orbitControls.enableKeys = false;\r\n\r\n        if (grid) {\r\n            this.createGridHelper();\r\n        }\r\n\r\n        window.addEventListener('resize', this.onWindowResize, false);\r\n\r\n        // small hack for disabling arrow keys actings during the typing\r\n        this.canvas.addEventListener('mouseover', e => { this.orbitControls.enabled = true; });\r\n        this.canvas.addEventListener('mouseout', e => { this.orbitControls.enabled = false; });\r\n        document.addEventListener(\"visibilitychange\", this.handleVisibilityChange, false);\r\n    }\r\n\r\n\r\n    componentWillUnmount() {\r\n        this.stop();\r\n        this.mount.removeChild(this.renderer.domElement);\r\n        window.removeEventListener('resize', this.onWindowResize, false);\r\n        document.removeEventListener(\"visibilitychange\", this.handleVisibilityChange, false);\r\n    }\r\n\r\n\r\n    @autobind\r\n    handleVisibilityChange() {\r\n        const timeline = this.props.timeline;\r\n        if (document[\"hidden\"]) {\r\n            timeline.pause();\r\n            verbose('pause timeline');\r\n        } else {\r\n            timeline.unpause();\r\n            verbose('unpause timeline');\r\n        }\r\n    }\r\n\r\n    get canvas(): HTMLCanvasElement {\r\n        return this.renderer.domElement;\r\n    }\r\n\r\n\r\n    private createCamera(width, height): THREE.PerspectiveCamera {\r\n        const camera = new THREE.PerspectiveCamera(\r\n            75,\r\n            width / height,\r\n            0.1,\r\n            10000\r\n        );\r\n        camera.position.z = 3;\r\n        camera.position.y = 2;\r\n        camera.position.x = 2;\r\n        camera.lookAt(new THREE.Vector3(0, 0, 0));\r\n        return camera;\r\n    }\r\n\r\n\r\n    protected createRenderer(width, height): THREE.WebGLRenderer {\r\n        // let WEBGL_DEBUG = false;\r\n        // if (WEBGL_DEBUG) {\r\n        //     let WebGLDebugUtils = require('webgl-debug');\r\n\r\n        //     function throwOnGLError(err, funcName, args) {\r\n        //         throw WebGLDebugUtils.glEnumToString(err)\r\n        //         + \"was caused by call to \"\r\n        //         + funcName;\r\n        //     };\r\n\r\n        //     const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas') as HTMLCanvasElement;\r\n        //     canvas.style.display = 'block';\r\n\r\n        //     const contextAttributes: WebGLContextAttributes = {\r\n        //         alpha: true,\r\n        //         antialias: true,\r\n        //         depth: true,\r\n        //         failIfMajorPerformanceCaveat: false,\r\n        //         powerPreference: \"default\",\r\n        //         premultipliedAlpha: true,\r\n        //         preserveDrawingBuffer: true,\r\n        //         stencil: true\r\n        //     };\r\n\r\n        //     let context = canvas.getContext(\"webgl2\", contextAttributes);\r\n        //     // context = WebGLDebugUtils.makeDebugContext(context, throwOnGLError);\r\n        //     const renderer = new THREE.WebGLRenderer({\r\n        //         context,\r\n        //         canvas,\r\n        //         antialias: true,\r\n        //         preserveDrawingBuffer: true /* to be able to save screenshots */\r\n        //     });\r\n        //     // console.log(context, renderer.getContext());\r\n        //     return renderer;\r\n        // }\r\n        \r\n        return new THREE.WebGLRenderer({\r\n            antialias: true,\r\n            preserveDrawingBuffer: true /* to be able to save screenshots */\r\n        });\r\n    }\r\n    \r\n\r\n    private createGridHelper(size = 200, divisions = 200) {\r\n        const gridHelper = new THREE.GridHelper(size, divisions);\r\n        this.scene.add(gridHelper);\r\n    }\r\n\r\n\r\n    @autobind\r\n    onWindowResize() {\r\n        this.camera.aspect = this.mount.clientWidth / this.mount.clientHeight;\r\n        this.camera.updateProjectionMatrix();\r\n        this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight);\r\n    }\r\n\r\n\r\n\r\n    start = () => {\r\n        if (!this.frameId) {\r\n            this.frameId = requestAnimationFrame(this.animate);\r\n        }\r\n    }\r\n\r\n\r\n    stop = () => {\r\n        cancelAnimationFrame(this.frameId);\r\n    }\r\n\r\n\r\n    protected begin() {\r\n        // nothing todo\r\n    }\r\n\r\n\r\n    protected end() {\r\n        this.frames++;\r\n        const time = (performance || Date).now();\r\n\r\n        if (time > this.prevTime + 1000) {\r\n            this.updateFps((this.frames * 1000) / (time - this.prevTime), 100);\r\n            this.prevTime = time;\r\n            this.frames = 0;\r\n        }\r\n\r\n        return time;\r\n    }\r\n\r\n\r\n    private updateFps(value, maxValue) {\r\n        const fps = this.state.fps;\r\n        const min = Math.min(fps.min, value);\r\n        const max = Math.max(fps.max, value);\r\n        this.setState({ fps: { min, max, value } });\r\n    }\r\n\r\n\r\n    @autobind\r\n    protected animate(time: DOMHighResTimeStamp) {\r\n        this.begin();\r\n\r\n        this.orbitControls.update();\r\n        this.beginFrame();\r\n        this.renderFrame();\r\n        this.endFrame();\r\n        this.frameId = requestAnimationFrame(this.animate);\r\n\r\n        this.end();\r\n    }\r\n\r\n\r\n    protected beginFrame() {\r\n        const timeline = this.props.timeline;\r\n        timeline.tick();\r\n    }\r\n\r\n    protected renderFrame() { this.renderer.render(this.scene, this.camera); }\r\n    protected endFrame() { }\r\n\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                style={this.props.style}\r\n                ref={(mount) => { this.mount = mount; }}\r\n            />\r\n        );\r\n    }\r\n\r\n}\r\n\r\nexport default ThreeScene;\r\n","import { ITimeline } from \"@lib/fx/timeline\";\r\nimport { IConstanBufferField, IConstantBuffer, ITechnique9 } from \"@lib/idl/ITechnique9\";\r\nimport { IPlaygroundControlsState } from \"@sandbox/store/IStoreState\";\r\nimport * as THREE from 'three';\r\nimport { IDeps } from \"./deps\";\r\nimport { controlValueToThreeValue, typedNumberToF32Num } from \"./controls\";\r\nimport { AUTOGEN_CONTROLS, AUTOGEN_GLOBALS } from \"@lib/fx/translators/FxTranslator\";\r\n\r\ninterface IViewport {\r\n    clientWidth: number;\r\n    clientHeight: number;\r\n}\r\n\r\nfunction copyVec4({ padding }: IConstanBufferField, v: THREE.Vector4, group: THREE.UniformsGroup) {\r\n    const pos = (padding / 16) >>> 0; // in vector\r\n    const pad = (padding % 16) / 4;\r\n    (group.uniforms[pos + 0].value as THREE.Vector4).fromArray(v.toArray(), 0);\r\n}\r\n\r\nfunction copyVec3({ padding }: IConstanBufferField, src: THREE.Vector3, group: THREE.UniformsGroup) {\r\n    const pos = (padding / 16) >>> 0; // in vector\r\n    const pad = (padding % 16) / 4;\r\n    const dst = group.uniforms[pos + 0].value as THREE.Vector4;\r\n    src.toArray().forEach((x, i) => dst.setComponent(pad + i, x));\r\n}\r\n\r\nfunction copyVec2({ padding }: IConstanBufferField, { x, y }: THREE.Vector2, group: THREE.UniformsGroup) {\r\n    const pos = (padding / 16) >>> 0; // in vector\r\n    const pad = (padding % 16) / 4;\r\n    console.assert(pad == 0, 'non zero paddings are not supported');\r\n    (group.uniforms[pos + 0].value as THREE.Vector4).fromArray([x, y], 0);\r\n}\r\n\r\nfunction copyMat4x4({ padding }: IConstanBufferField, mat: THREE.Matrix4, group: THREE.UniformsGroup) {\r\n    const pos = (padding / 16) >>> 0; // in vector\r\n    (group.uniforms[pos + 0].value as THREE.Vector4).fromArray(mat.elements, 0);\r\n    (group.uniforms[pos + 1].value as THREE.Vector4).fromArray(mat.elements, 4);\r\n    (group.uniforms[pos + 2].value as THREE.Vector4).fromArray(mat.elements, 8);\r\n    (group.uniforms[pos + 3].value as THREE.Vector4).fromArray(mat.elements, 12);\r\n}\r\n\r\n\r\nfunction copyMat4x3({ padding }: IConstanBufferField, mat: THREE.Matrix4, group: THREE.UniformsGroup) {\r\n    const pos = (padding / 16) >>> 0; // in vector\r\n    (group.uniforms[pos + 0].value as THREE.Vector4).fromArray(mat.elements, 0);\r\n    (group.uniforms[pos + 1].value as THREE.Vector4).fromArray(mat.elements, 4);\r\n    (group.uniforms[pos + 2].value as THREE.Vector4).fromArray(mat.elements, 8);\r\n}\r\n\r\n/** Write constan buffer entry to uniform group. */\r\nfunction copyControl(\r\n    state: IPlaygroundControlsState,\r\n    field: IConstanBufferField,\r\n    i: number,\r\n    deps: IDeps,\r\n    group: THREE.UniformsGroup) {\r\n    const name = `${field.name}${i >= 0 ? `[${i}]` : ``}`;\r\n    let offset = 0;\r\n    if (field.length != -1) {\r\n        const step = (field.size / field.length) >>> 0;\r\n        console.assert(step * field.length === field.size, 'padding?!');\r\n        offset = step * i;\r\n    }\r\n    const pos = ((field.padding + offset) / 16) >>> 0;\r\n    const pad = ((field.padding + offset) % 16) / 4;\r\n\r\n    const ctrl = state.controls[name];\r\n    const val = state.values[name];\r\n    if (['uint', 'int', 'uint', 'float'].indexOf(ctrl.type) !== -1) {\r\n        const f32Num = typedNumberToF32Num(controlValueToThreeValue(val, ctrl.type, deps) as number, ctrl.type);\r\n        (group.uniforms[pos].value as THREE.Vector4).setComponent(pad, f32Num);\r\n    } else {\r\n        group.uniforms[pos].value = controlValueToThreeValue(val, ctrl.type, deps);\r\n    }\r\n}\r\n\r\nfunction copyFloat32({ padding }: IConstanBufferField, value: number, group: THREE.UniformsGroup) {\r\n    const pos = (padding / 16) >>> 0;\r\n    const pad = (padding % 16) / 4;\r\n    (group.uniforms[pos].value as THREE.Vector4).setComponent(pad, value);\r\n}\r\n\r\n\r\nfunction transpose(mat: THREE.Matrix4): THREE.Matrix4 {\r\n    return (new THREE.Matrix4).copy(mat).transpose();\r\n}\r\n\r\nexport class GroupedUniforms {\r\n    // per pass x per buffer\r\n    private uniformGroups: THREE.UniformsGroup[][];\r\n\r\n    data() {\r\n        return this.uniformGroups;\r\n    }\r\n\r\n    /** @deprecated */\r\n    create9(tech9: ITechnique9): void {\r\n        this.uniformGroups?.forEach(gs => gs.forEach(g => g.dispose()));\r\n        this.uniformGroups = [];\r\n\r\n        // create uniform groups for each pass\r\n        for (let i = 0; i < tech9.getPassCount(); ++i) {\r\n            const cbuffers = tech9.getPass(i).getDesc().cbuffers;\r\n            this.uniformGroups.push(GroupedUniforms.create(cbuffers));\r\n        }\r\n    }\r\n\r\n\r\n    static create(cbuffers: IConstantBuffer[]): THREE.UniformsGroup[] {\r\n        const groups: THREE.UniformsGroup[] = [];\r\n        for (let cbuf of cbuffers) {\r\n            let { name, size, usage } = cbuf;\r\n\r\n            const nVec4 = size / 16;\r\n            const group = new THREE.UniformsGroup();\r\n            group.setName(name);\r\n\r\n            for (let i = 0; i < nVec4; ++i) {\r\n                group.add(new THREE.Uniform(new THREE.Vector4(0, 0, 0, 0)));\r\n            }\r\n\r\n            groups.push(group);\r\n        }\r\n\r\n        return groups;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    update9(camera: THREE.PerspectiveCamera,\r\n        viewport: IViewport,\r\n        controls: IPlaygroundControlsState,\r\n        timeline: ITimeline,\r\n        deps: IDeps,\r\n        tech9: ITechnique9\r\n    ): void {\r\n        for (let iPass = 0; iPass < tech9.getPassCount(); ++iPass) {\r\n            const cbuffers = tech9.getPass(iPass).getDesc().cbuffers;\r\n            const groups = this.uniformGroups[iPass];\r\n            GroupedUniforms.update(camera, viewport, controls, timeline, deps, groups, cbuffers);\r\n        }\r\n    }\r\n\r\n\r\n    static update(\r\n        camera: THREE.PerspectiveCamera,\r\n        viewport: IViewport,\r\n        controls: IPlaygroundControlsState,\r\n        timeline: ITimeline,\r\n        deps: IDeps,\r\n        groups: THREE.UniformsGroup[],\r\n        cbuffers: IConstantBuffer[]\r\n    ) {\r\n\r\n        /*\r\n        uniform mat4 modelMatrix;       // = object.matrixWorld\r\n        uniform mat4 modelViewMatrix;   // = camera.matrixWorldInverse * object.matrixWorld\r\n        uniform mat4 projectionMatrix;  // = camera.projectionMatrix\r\n        uniform mat4 viewMatrix;        // = camera.matrixWorldInverse\r\n        uniform mat3 normalMatrix;      // = inverse transpose of modelViewMatrix\r\n        uniform vec3 cameraPosition;    // = camera position in world space\r\n        */\r\n\r\n        const identityMatrix = new THREE.Matrix4();\r\n        // todo: move out model matrix from global uniforms\r\n        const modelMatrix = (new THREE.Matrix4).copy(identityMatrix);\r\n        const viewMatrix = (new THREE.Matrix4).copy(camera.matrixWorldInverse);\r\n        const projMatrix = (new THREE.Matrix4).copy(camera.projectionMatrix);\r\n        const modelViewMatrix = (new THREE.Matrix4).multiplyMatrices(viewMatrix, modelMatrix);\r\n        const modelViewProjMatrix = (new THREE.Matrix4).multiplyMatrices(projMatrix, modelViewMatrix);\r\n        const viewProjMatrix = (new THREE.Matrix4).multiplyMatrices(projMatrix, viewMatrix);\r\n\r\n        const { clientWidth, clientHeight } = viewport;\r\n        const constants = timeline.getConstants();\r\n\r\n        for (let c = 0; c < cbuffers.length; ++c) {\r\n            let cbuf = cbuffers[c];\r\n            let group = groups[c];\r\n            let { name, size, usage } = cbuf;\r\n\r\n            switch (name) {\r\n                case AUTOGEN_CONTROLS:\r\n                    {\r\n\r\n                        for (let field of cbuf.fields) {\r\n                            if (field.length == -1) {\r\n                                copyControl(controls, field, -1, deps, group);\r\n                            } else {\r\n                                for (let i = 0; i < field.length; ++i) {\r\n                                    copyControl(controls, field, i, deps, group);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                case AUTOGEN_GLOBALS:\r\n                    for (let field of cbuf.fields) {\r\n                        switch (field.semantic) {\r\n                            case 'ELAPSED_TIME_LEVEL':\r\n                                copyFloat32(field, constants.elapsedTimeLevel, group);\r\n                                break;\r\n                            case 'ELAPSED_TIME':\r\n                                copyFloat32(field, constants.elapsedTime, group);\r\n                                break;\r\n                            case 'FRAME_NUMBER':\r\n                                copyFloat32(field, constants.frameNumber, group);\r\n                                break;\r\n                            // todo: move to locals\r\n                            case 'MODEL_MATRIX':\r\n                                copyMat4x4(field, modelMatrix, group);\r\n                                break;\r\n                            // todo: move to locals\r\n                            case 'MODEL_VIEW_MATRIX':\r\n                                copyMat4x4(field, modelViewMatrix, group);\r\n                                break;\r\n                            case 'MODEL_VIEW_PROJECTION_MATRIX':\r\n                                // TODO: fixme me, the only one user is technique11.fx at the moment (!)\r\n                                copyMat4x4(field, transpose(modelViewProjMatrix), group);\r\n                                break;\r\n                            case 'VIEW_MATRIX':\r\n                                copyMat4x4(field, viewMatrix, group);\r\n                                break;\r\n                            case 'PROJECTION_MATRIX':\r\n                                copyMat4x4(field, projMatrix, group);\r\n                                break;\r\n                            case 'CAMERA_POSITION':\r\n                                copyVec3(field, camera.position, group);\r\n                                break;\r\n                            default:\r\n                                // todo: emit once (!)\r\n                                console.error(`GLOBAL_UNIFORMS: unknown semantic <${field.semantic}> found.`);\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    for (let field of cbuf.fields) {\r\n                        switch (field.semantic) {\r\n                            case 'COMMON_VIEWPROJ_MATRIX':\r\n                                // note: husky uses transposed matrices (!)\r\n                                copyMat4x4(field, transpose(viewProjMatrix), group);\r\n                                break;\r\n                            case 'COMMON_VP_PARAMS':\r\n                                {\r\n                                    const pos = (field.padding / 16) >>> 0; // in vector\r\n                                    (group.uniforms[pos + 0].value as THREE.Vector4).fromArray([1.0 / clientWidth, 1.0 / clientHeight, 0.5 / clientWidth, 0.5 / clientHeight]);\r\n                                }\r\n                                break;\r\n                            case 'VS_REG_COMMON_OBJ_WORLD_MATRIX_DEBUG':\r\n                                copyMat4x3(field, identityMatrix, group);\r\n                                break;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}","import { ITimeline } from \"@lib/fx/timeline\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { IPlaygroundControlsState } from \"@sandbox/store/IStoreState\";\r\nimport * as THREE from 'three';\r\nimport { controlValueToThreeValue } from \"./controls\";\r\nimport { IDeps } from \"./deps\";\r\n\r\ntype IUniform = THREE.IUniform<THREE.Texture | THREE.Vector4 | THREE.Vector3 | THREE.Vector2 | Number>;\r\n\r\nexport class SingleUniforms {\r\n    static create(controls: IPlaygroundControlsState, deps: IDeps): IMap<THREE.IUniform> {\r\n        const uniforms: IMap<IUniform> = {\r\n            elapsedTime: { value: 0 },\r\n            elapsedTimeLevel: { value: 0 },\r\n            // elapsedTimeThis: { value: 0 }\r\n        };\r\n\r\n        if (controls) {\r\n            for (let name in controls.values) {\r\n                let value = controls.values[name];\r\n                let ctrl = controls.controls[name];\r\n                uniforms[name] = { value: controlValueToThreeValue(value, ctrl.type, deps) };\r\n            }\r\n        }\r\n\r\n        return uniforms;\r\n    }\r\n\r\n\r\n    static update(controls: IPlaygroundControlsState, timeline: ITimeline, deps: IDeps, uniforms: IMap<IUniform>) {\r\n        const constants = timeline.getConstants();\r\n        uniforms.elapsedTime.value = constants.elapsedTime;\r\n        uniforms.elapsedTimeLevel.value = constants.elapsedTimeLevel;\r\n\r\n        if (controls) {\r\n            for (let name in controls.values) {\r\n                let val = controls.values[name];\r\n                let ctrl = controls.controls[name];\r\n                if (uniforms[name])\r\n                    uniforms[name].value = controlValueToThreeValue(val, ctrl.type, deps);\r\n            }\r\n        }\r\n    }\r\n}","import { assert } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport * as THREE from 'three';\r\n\r\nconst UNUSED32 = -1 >>> 0;\r\n\r\n\r\nclass vertexHashEntry {\r\n    v: THREE.Vector3;\r\n    index: number;\r\n    next: vertexHashEntry;\r\n};\r\n\r\n\r\n// <algorithm> std::make_heap doesn't match D3DX10 so we use the same algorithm here\r\nfunction MakeXHeap(\r\n    positions: ArrayLike<number>, nVerts: number) {\r\n    const index: number[] = new Array(nVerts);\r\n\r\n    const pos = vert => new THREE.Vector3(positions[vert * 3 + 0], positions[vert * 3 + 1], positions[vert * 3 + 2]);\r\n\r\n    for (let vert = 0; vert < nVerts; ++vert) {\r\n        index[vert] = vert;\r\n    }\r\n\r\n    if (nVerts > 1) {\r\n        // Create the heap\r\n        let iulLim = nVerts >>> 0;\r\n\r\n        for (let vert = (nVerts >> 1) >>> 0; ((--vert) >>> 0) != (-1 >>> 0);) {\r\n            // Percolate down\r\n            let iulI = vert;\r\n            let iulJ = vert + vert + 1;\r\n            const ulT = index[iulI];\r\n\r\n            while (iulJ < iulLim) {\r\n                let ulJ = index[iulJ];\r\n\r\n                if (iulJ + 1 < iulLim) {\r\n                    const ulJ1 = index[iulJ + 1];\r\n                    if (pos(ulJ1).x <= pos(ulJ).x) {\r\n                        iulJ++;\r\n                        ulJ = ulJ1;\r\n                    }\r\n                }\r\n\r\n                if (pos(ulJ).x > pos(ulT).x)\r\n                    break;\r\n\r\n                index[iulI] = index[iulJ];\r\n                iulI = iulJ;\r\n                iulJ += iulJ + 1;\r\n            }\r\n\r\n            index[iulI] = ulT;\r\n        }\r\n\r\n        // Sort the heap\r\n        while (((--iulLim) >>> 0) != (-1 >>> 0)) {\r\n            const ulT = index[iulLim];\r\n            index[iulLim] = index[0];\r\n\r\n            // Percolate down\r\n            let iulI = 0;\r\n            let iulJ = 1;\r\n\r\n            while (iulJ < iulLim) {\r\n                let ulJ = index[iulJ];\r\n\r\n                if (iulJ + 1 < iulLim) {\r\n                    const ulJ1 = index[iulJ + 1];\r\n                    if (pos(ulJ1).x <= pos(ulJ).x) {\r\n                        iulJ++;\r\n                        ulJ = ulJ1;\r\n                    }\r\n                }\r\n\r\n                if (pos(ulJ).x > pos(ulT).x)\r\n                    break;\r\n\r\n                index[iulI] = index[iulJ];\r\n                iulI = iulJ;\r\n                iulJ += iulJ + 1;\r\n            }\r\n\r\n            assert(iulI < nVerts);\r\n            index[iulI] = ulT;\r\n        }\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\nexport function GeneratePointReps(\r\n    indices: number[], nFaces: number,\r\n    positions: ArrayLike<number>, nVerts: number, epsilon: number = 0) {\r\n    const pointRep: number[] = new Array(nVerts);\r\n    const vertexToCorner = new Array<number>(nVerts);\r\n    const vertexCornerList = (new Array<number>(nFaces * 3));\r\n\r\n    vertexToCorner.fill(UNUSED32);\r\n    vertexCornerList.fill(UNUSED32);\r\n\r\n    // build initial lists and validate indices\r\n    for (let j = 0; j < (nFaces * 3); ++j) {\r\n        let k = indices[j];\r\n        if (k === -1)\r\n            continue;\r\n\r\n        if (k >= nVerts) {\r\n            assert(false);\r\n            return null;\r\n        }\r\n\r\n        vertexCornerList[j] = vertexToCorner[k];\r\n        vertexToCorner[k] = j;\r\n    }\r\n\r\n\r\n    const hashTable: IMap<vertexHashEntry> = {};\r\n    const pos = vert => new THREE.Vector3(positions[vert * 3 + 0], positions[vert * 3 + 1], positions[vert * 3 + 2]);\r\n\r\n    if (epsilon == 0) {\r\n        for (let vert = 0; vert < nVerts; ++vert) {\r\n            let px = pos(vert).x;\r\n            let py = pos(vert).y;\r\n            let pz = pos(vert).z;\r\n\r\n            const hashKey = `${px.toFixed(3)}:${py.toFixed(3)}:${pz.toFixed(3)}`;\r\n\r\n\r\n            let found = UNUSED32;\r\n\r\n            for (let current = hashTable[hashKey]; current != null; current = current.next) {\r\n                if (current.v.x == pos(vert).x\r\n                    && current.v.y == pos(vert).y\r\n                    && current.v.z == pos(vert).z) {\r\n                    let head = vertexToCorner[vert];\r\n\r\n                    let ispresent = false;\r\n\r\n                    while (head != UNUSED32) {\r\n                        const face = head / 3;\r\n                        if ((indices[face * 3] == current.index) || (indices[face * 3 + 1] == current.index) || (indices[face * 3 + 2] == current.index)) {\r\n                            ispresent = true;\r\n                            break;\r\n                        }\r\n\r\n                        head = vertexCornerList[head];\r\n                    }\r\n\r\n                    if (!ispresent) {\r\n                        found = current.index;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (found != UNUSED32) {\r\n                pointRep[vert] = found;\r\n            }\r\n            else {\r\n                let newEntry = new vertexHashEntry;\r\n\r\n                newEntry.v = pos(vert);\r\n                newEntry.index = vert;\r\n                newEntry.next = hashTable[hashKey];\r\n                hashTable[hashKey] = newEntry;\r\n\r\n                pointRep[vert] = vert;\r\n            }\r\n        }\r\n    } else {\r\n        const xorder = MakeXHeap(positions, nVerts);\r\n        pointRep.fill(UNUSED32)\r\n        \r\n        const vepsilon = epsilon * epsilon;\r\n\r\n        let head = 0;\r\n        let tail = 0;\r\n\r\n        while (tail < nVerts) {\r\n            // move head until just out of epsilon\r\n            while ((head < nVerts)\r\n                && ((pos(tail).x - pos(head).x) <= epsilon)) {\r\n                ++head;\r\n            }\r\n\r\n\r\n            // check new tail against all points up to the head\r\n            let tailIndex = xorder[tail];\r\n            assert(tailIndex < nVerts);\r\n            if (pointRep[tailIndex] == UNUSED32) {\r\n                pointRep[tailIndex] = tailIndex;\r\n\r\n                const outer = pos(tailIndex);\r\n\r\n                for (let current = tail + 1; current < head; ++current) {\r\n                    let curIndex = xorder[current];\r\n                    assert(curIndex < nVerts);\r\n\r\n                    // if the point is already assigned, ignore it\r\n                    if (pointRep[curIndex] == UNUSED32) {\r\n                        const inner = pos(curIndex);\r\n                        const diff = inner.sub(outer).lengthSq();\r\n\r\n                        if (diff < vepsilon) {\r\n                            let headvc = vertexToCorner[tailIndex];\r\n\r\n                            let ispresent = false;\r\n\r\n                            while (headvc != UNUSED32) {\r\n                                const face = headvc / 3;\r\n                                assert(face < nFaces);\r\n\r\n                                assert((indices[face * 3] == tailIndex) || (indices[face * 3 + 1] == tailIndex) || (indices[face * 3 + 2] == tailIndex));\r\n\r\n                                if ((indices[face * 3] == curIndex) || (indices[face * 3 + 1] == curIndex) || (indices[face * 3 + 2] == curIndex)) {\r\n                                    ispresent = true;\r\n                                    break;\r\n                                }\r\n\r\n                                headvc = vertexCornerList[headvc];\r\n                            }\r\n\r\n                            if (!ispresent) {\r\n                                pointRep[curIndex] = tailIndex;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            ++tail;\r\n        }\r\n    }\r\n\r\n    return pointRep;\r\n}\r\n\r\n\r\nclass edgeHashEntry {\r\n    v1: number;\r\n    v2: number;\r\n    vOther: number;\r\n    face: number;\r\n    next: edgeHashEntry;\r\n};\r\n\r\n//---------------------------------------------------------------------------------\r\n// Convert PointRep to Adjacency\r\n//---------------------------------------------------------------------------------\r\n\r\nexport function ConvertPointRepsToAdjacencyImpl(\r\n    indices: ArrayLike<number>, nFaces: number,\r\n    positions: ArrayLike<number>, nVerts: number,\r\n    pointRep: ArrayLike<number>) {\r\n    const adjacency: number[] = new Array(nFaces * 3);\r\n    const hashTable: IMap<edgeHashEntry> = {};\r\n\r\n    const pos = vert => new THREE.Vector3(positions[vert * 3 + 0], positions[vert * 3 + 1], positions[vert * 3 + 2]);\r\n\r\n    // add face edges to hash table and validate indices\r\n    for (let face = 0; face < nFaces; ++face) {\r\n        let i0 = indices[face * 3];\r\n        let i1 = indices[face * 3 + 1];\r\n        let i2 = indices[face * 3 + 2];\r\n\r\n        if (i0 == -1\r\n            || i1 == -1\r\n            || i2 == -1)\r\n            continue;\r\n\r\n        if (i0 >= nVerts\r\n            || i1 >= nVerts\r\n            || i2 >= nVerts)\r\n            return null;\r\n\r\n        const v1 = pointRep[i0];\r\n        const v2 = pointRep[i1];\r\n        const v3 = pointRep[i2];\r\n\r\n        // filter out degenerate triangles\r\n        if (v1 == v2 || v1 == v3 || v2 == v3)\r\n            continue;\r\n\r\n        for (let point = 0; point < 3; ++point) {\r\n            const va = pointRep[indices[face * 3 + point]];\r\n            const vb = pointRep[indices[face * 3 + ((point + 1) % 3)]];\r\n            const vOther = pointRep[indices[face * 3 + ((point + 2) % 3)]];\r\n\r\n            const hashKey = `${va}`;\r\n\r\n            let newEntry = new edgeHashEntry;\r\n            newEntry.v1 = va;\r\n            newEntry.v2 = vb;\r\n            newEntry.vOther = vOther;\r\n            newEntry.face = face;\r\n            newEntry.next = hashTable[hashKey];\r\n            hashTable[hashKey] = newEntry;\r\n        }\r\n    }\r\n\r\n    adjacency.fill(UNUSED32)\r\n\r\n    for (let face = 0; face < nFaces; ++face) {\r\n        let i0 = indices[face * 3];\r\n        let i1 = indices[face * 3 + 1];\r\n        let i2 = indices[face * 3 + 2];\r\n\r\n        // filter out unused triangles\r\n        if (i0 == -1\r\n            || i1 == -1\r\n            || i2 == -1)\r\n            continue;\r\n\r\n        const v1 = pointRep[i0];\r\n        const v2 = pointRep[i1];\r\n        const v3 = pointRep[i2];\r\n\r\n        // filter out degenerate triangles\r\n        if (v1 == v2 || v1 == v3 || v2 == v3)\r\n            continue;\r\n\r\n        for (let point = 0; point < 3; ++point) {\r\n            if (adjacency[face * 3 + point] != UNUSED32)\r\n                continue;\r\n\r\n            // see if edge already entered, if not then enter it\r\n            const va = pointRep[indices[face * 3 + ((point + 1) % 3)]];\r\n            const vb = pointRep[indices[face * 3 + point]];\r\n            const vOther = pointRep[indices[face * 3 + ((point + 2) % 3)]];\r\n\r\n            const hashKey = `${va}`;\r\n\r\n            let current = hashTable[hashKey];\r\n            let prev = null;\r\n\r\n            let foundFace = UNUSED32;\r\n\r\n            while (current != null) {\r\n                if ((current.v2 == vb) && (current.v1 == va)) {\r\n                    foundFace = current.face;\r\n                    break;\r\n                }\r\n\r\n                prev = current;\r\n                current = current.next;\r\n            }\r\n\r\n            let found = current;\r\n            let foundPrev = prev;\r\n\r\n            let bestDiff = -2.0;\r\n\r\n            // Scan for additional matches\r\n            if (current) {\r\n                prev = current;\r\n                current = current.next;\r\n\r\n                // find 'better' match\r\n                while (current != null) {\r\n                    if ((current.v2 == vb) && (current.v1 == va)) {\r\n                        const pB1 = pos(vb);\r\n                        const pB2 = pos(va);\r\n                        const pB3 = pos(vOther);\r\n\r\n                        let v12 = (new THREE.Vector3).subVectors(pB1, pB2);\r\n                        let v13 = (new THREE.Vector3).subVectors(pB1, pB3);\r\n\r\n                        const bnormal = v12.cross(v13).normalize();\r\n\r\n                        if (bestDiff == -2.0) {\r\n                            const pA1 = pos(found.v1);\r\n                            const pA2 = pos(found.v2);\r\n                            const pA3 = pos(found.vOther);\r\n\r\n                            v12 = (new THREE.Vector3).subVectors(pA1, pA2);\r\n                            v13 = (new THREE.Vector3).subVectors(pA1, pA3);\r\n\r\n                            const anormal = (new THREE.Vector3).crossVectors(v12, v13).normalize();\r\n\r\n                            bestDiff = anormal.dot(bnormal);\r\n                        }\r\n\r\n                        const pA1 = pos(current.v1);\r\n                        const pA2 = pos(current.v2);\r\n                        const pA3 = pos(current.vOther);\r\n\r\n                        v12 = (new THREE.Vector3).subVectors(pA1, pA2);\r\n                        v13 = (new THREE.Vector3).subVectors(pA1, pA3);\r\n\r\n                        const anormal = (new THREE.Vector3).crossVectors(v12, v13).normalize();\r\n\r\n                        const diff = anormal.dot(bnormal);\r\n\r\n                        // if face normals are closer, use new match\r\n                        if (diff > bestDiff) {\r\n                            found = current;\r\n                            foundPrev = prev;\r\n                            foundFace = current.face;\r\n                            bestDiff = diff;\r\n                        }\r\n                    }\r\n\r\n                    prev = current;\r\n                    current = current.next;\r\n                }\r\n            }\r\n\r\n            if (foundFace != UNUSED32) {\r\n                assert(found != null);\r\n\r\n                // remove found face from hash table\r\n                if (foundPrev != null) {\r\n                    foundPrev.next = found.next;\r\n                }\r\n                else {\r\n                    hashTable[hashKey] = found.next;\r\n                }\r\n\r\n                assert(adjacency[face * 3 + point] == UNUSED32);\r\n                adjacency[face * 3 + point] = foundFace;\r\n\r\n                // Check for other edge\r\n                const hashKey2 = `${vb}`;\r\n\r\n                current = hashTable[hashKey2];\r\n                prev = null;\r\n\r\n                while (current != null) {\r\n                    if ((current.face == face) && (current.v2 == va) && (current.v1 == vb)) {\r\n                        // trim edge from hash table\r\n                        if (prev != null) {\r\n                            prev.next = current.next;\r\n                        }\r\n                        else {\r\n                            hashTable[hashKey2] = current.next;\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    prev = current;\r\n                    current = current.next;\r\n                }\r\n\r\n                // mark neighbor to point back\r\n                let linked = false;\r\n\r\n                for (let point2 = 0; point2 < point; ++point2) {\r\n                    if (foundFace == adjacency[face * 3 + point2]) {\r\n                        linked = true;\r\n                        adjacency[face * 3 + point] = UNUSED32;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!linked) {\r\n                    let point2 = 0;\r\n                    for (; point2 < 3; ++point2) {\r\n                        let k = indices[foundFace * 3 + point2];\r\n                        if (k == -1)\r\n                            continue;\r\n\r\n                        if (pointRep[k] == va)\r\n                            break;\r\n                    }\r\n\r\n                    if (point2 < 3) {\r\n                        // update neighbor to point back to this face match edge\r\n                        adjacency[foundFace * 3 + point2] = face;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return adjacency;\r\n}\r\n\r\n\r\n\r\nfunction GenerateGSAdjacencyImpl(\r\n    indices: ArrayLike<number>, nFaces: number,\r\n    pointRep: ArrayLike<number>,\r\n    adjacency: ArrayLike<number>, nVerts: number) {\r\n    const indicesAdj: number[] = new Array(nFaces * 6);\r\n\r\n    let inputi = 0;\r\n    let outputi = 0;\r\n\r\n    for (let face = 0; face < nFaces; ++face) {\r\n        for (let point = 0; point < 3; ++point) {\r\n            indicesAdj[outputi] = indices[inputi];\r\n            ++outputi;\r\n            ++inputi;\r\n\r\n            assert(outputi < (nFaces * 6));\r\n\r\n            const a = adjacency[face * 3 + point];\r\n            if (a == UNUSED32) {\r\n                indicesAdj[outputi] = indices[face * 3 + ((point + 2) % 3)];\r\n            }\r\n            else {\r\n                let v1 = indices[face * 3 + point];\r\n                let v2 = indices[face * 3 + ((point + 1) % 3)];\r\n\r\n                if (v1 == -1 || v2 == -1) {\r\n                    indicesAdj[outputi] = -1;\r\n                }\r\n                else {\r\n                    if (v1 >= nVerts || v2 >= nVerts) {\r\n                        assert(false);\r\n                        return null;\r\n                    }\r\n\r\n                    v1 = pointRep[v1];\r\n                    v2 = pointRep[v2];\r\n\r\n                    let vOther = UNUSED32;\r\n\r\n                    // find other vertex\r\n                    for (let k = 0; k < 3; ++k) {\r\n                        const ak = indices[a * 3 + k];\r\n                        if (ak == -1)\r\n                            break;\r\n\r\n                        if (ak >= nVerts) {\r\n                            assert(false);\r\n                            return null;\r\n                        }\r\n\r\n                        if (pointRep[ak] == v1)\r\n                            continue;\r\n\r\n                        if (pointRep[ak] == v2)\r\n                            continue;\r\n\r\n                        vOther = ak;\r\n                    }\r\n\r\n                    if (vOther == UNUSED32) {\r\n                        indicesAdj[outputi] = indices[face * 3 + ((point + 2) % 3)];\r\n\r\n                    }\r\n                    else {\r\n                        indicesAdj[outputi] = vOther;\r\n                    }\r\n                }\r\n            }\r\n            ++outputi;\r\n        }\r\n    }\r\n\r\n    return indicesAdj;\r\n}\r\n\r\nexport function prepareTrimesh(g: THREE.BufferGeometry) {\r\n    // g.setIndex(Array(g.attributes.position.count).fill(0).map((x, i) => i < g.attributes.position.count / 2 ? i : 0));\r\n\r\n    assert(g.attributes.position);\r\n    assert(g.attributes.normal);\r\n    assert(g.attributes.uv);\r\n    assert(!g.index);\r\n\r\n    const positions = g.attributes.position.array;\r\n    const normals = g.attributes.normal.array;\r\n    const uvs = g.attributes.uv.array;\r\n    const vertCount = g.attributes.position.count;\r\n    const faceCount = vertCount / 3;\r\n    const indices: number[] = Array(vertCount).fill(0).map((x, i) => i);\r\n\r\n    const pointReps = GeneratePointReps(indices, faceCount, positions, vertCount);//, 0.0001);\r\n    const facesAdj = ConvertPointRepsToAdjacencyImpl(indices, faceCount, positions, vertCount, pointReps);\r\n    const indicesAdj = GenerateGSAdjacencyImpl(indices, faceCount, pointReps, facesAdj, vertCount);\r\n    // console.log(pointReps, adjacency);\r\n\r\n    // pos, norm, uv\r\n    const vertices = new Array<number>(vertCount * (3 + 3 + 2));\r\n    for (let i = 0; i < vertCount; ++i) {\r\n        for (let j = 0; j < 3; ++j) {\r\n            vertices[8 * i + 0 + j] = positions[3 * i + j];\r\n        }\r\n\r\n        for (let j = 0; j < 3; ++j) {\r\n            vertices[8 * i + 3 + j] = normals[3 * i + j];\r\n        }\r\n\r\n        for (let j = 0; j < 2; ++j) {\r\n            vertices[8 * i + 6 + j] = uvs[2 * i + j];\r\n        }\r\n    }\r\n\r\n    const faces = indices;\r\n    return {\r\n        vertCount,\r\n        faceCount,\r\n        vertices,\r\n        faces,\r\n        facesAdj,\r\n        indicesAdj\r\n    };\r\n\r\n    // let ind = [];\r\n    // [3].forEach(iFace => {\r\n    //     let i0 = adjacency[iFace * 3 + 0];\r\n    //     let i1 = adjacency[iFace * 3 + 1];\r\n    //     let i2 = adjacency[iFace * 3 + 2];\r\n\r\n    //     //ind.push(indices[iFace * 3 + 0], indices[iFace * 3 + 1], indices[iFace * 3 + 2]);\r\n\r\n    //     [i0, i1, i2].filter(i => i != UNUSED32).forEach(iFace => {\r\n    //         ind.push(indices[iFace * 3 + 0], indices[iFace * 3 + 1], indices[iFace * 3 + 2]);\r\n    //     });\r\n    // });\r\n\r\n    // g.setIndex(ind);\r\n}\r\n","import { ControlValueType } from \"@lib/fx/bundles/utils\";\r\nimport { Vector4, Vector3, Vector2, Color } from \"@sandbox/store/IStoreState\";\r\nimport * as THREE from 'three';\r\nimport { IDeps } from \"./deps\";\r\n\r\nfunction createPlaceholderTexture(width = 512, height = 512) {\r\n    const size = width * height;\r\n    const data = new Uint8Array(4 * size);\r\n    const color = new THREE.Color(0xffffff);\r\n\r\n    const r = Math.floor(color.r * 255);\r\n    const g = Math.floor(color.g * 255);\r\n    const b = Math.floor(color.b * 255);\r\n\r\n    for (let i = 0; i < size; i++) {\r\n        const stride = i * 4;\r\n\r\n        data[stride] = r;\r\n        data[stride + 1] = g;\r\n        data[stride + 2] = b;\r\n        data[stride + 3] = 255;\r\n    }\r\n\r\n    // used the buffer to create a DataTexture\r\n    const texture = new THREE.DataTexture(data, width, height);\r\n    texture.needsUpdate = true;\r\n    return texture;\r\n}\r\n\r\nexport const TEXTURE_PLACEHOLDER_WHITE_1X1 = createPlaceholderTexture(1, 1);\r\n\r\nexport function controlValueToThreeValue(ctrl: ControlValueType, type: string, deps: IDeps): THREE.Vector4 | THREE.Vector3 | THREE.Vector2 | Number | THREE.Texture {\r\n    let ab = new ArrayBuffer(4);\r\n    let dv = new DataView(ab);\r\n    switch (type) {\r\n        case 'color': {\r\n            const { r, g, b, a } = ctrl as Color;\r\n            return new THREE.Vector4(r, g, b, a);\r\n        }\r\n        case 'float4': {\r\n            const { x, y, z, w } = ctrl as Vector4;\r\n            return new THREE.Vector4(x, y, z, w);\r\n        }\r\n        case 'float3': {\r\n            const { x, y, z } = ctrl as Vector3;\r\n            return new THREE.Vector3(x, y, z);\r\n        }\r\n        case 'float2': {\r\n            const { x, y } = ctrl as Vector2;\r\n            return new THREE.Vector2(x, y);\r\n        }\r\n        case 'mesh':\r\n            // nothing todo: meshes are not supported in vs/ps shaders\r\n            return null;\r\n        case 'texture2d':\r\n            return deps.textures[ctrl as string] || TEXTURE_PLACEHOLDER_WHITE_1X1;\r\n        case 'uint':\r\n        case 'int':\r\n        case 'float':\r\n            return ctrl as Number;\r\n        default:\r\n            console.error('unsupported type found');\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\n\r\nexport function typedNumberToF32Num(num: number, type: string): number {\r\n    let ab = new ArrayBuffer(4);\r\n    let dv = new DataView(ab);\r\n    switch (type) {\r\n        case 'float':\r\n            return num;\r\n        case 'int':\r\n            dv.setInt32(0, num);\r\n            return dv.getFloat32(0);\r\n        case 'uint':\r\n            dv.setUint32(0, num);\r\n            return dv.getFloat32(0);\r\n        default:\r\n            console.error('unsupported type found');\r\n    }\r\n    return null;\r\n}\r\n","import { isString } from '@lib/common';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport * as ipc from '@sandbox/ipc';\r\nimport { ASSETS_MANIFEST, ASSETS_PATH } from '@sandbox/logic/common';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport * as THREE from 'three';\r\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\r\nimport { TGALoader } from 'three/examples/jsm/loaders/TGALoader';\r\n\r\nexport interface IDeps {\r\n    models: IMap<THREE.Mesh[]>;\r\n    textures: IMap<THREE.Texture>;\r\n}\r\n\r\n\r\nfunction GetAssetsTexturesPath() {\r\n    return `${ASSETS_PATH}/textures`;\r\n}\r\n\r\nfunction GetAssetsModelsPath() {\r\n    return `${ASSETS_PATH}/models`;\r\n}\r\n\r\n\r\nfunction currentPath() {\r\n    if (window.navigator.platform.includes('Mac')) {\r\n        return window.location.pathname;\r\n    }\r\n    return window.location.pathname.substr(1);\r\n}\r\n\r\n\r\nexport function GetAssetsTextures() {\r\n    if (!ipc.isElectron()) {\r\n        return <string[]>Object.values(ASSETS_MANIFEST['textures'])\r\n        .filter(file => isString(file))\r\n        .map(file => path.basename(<string>file)) \r\n        .sort();\r\n    } else {\r\n        const sandboxPath = path.dirname(currentPath());\r\n        const texturePath = path.join(sandboxPath, GetAssetsTexturesPath());\r\n        return fs.readdirSync(texturePath);\r\n    }\r\n}\r\n\r\n\r\nexport function GetAssetsModels() {\r\n    if (!ipc.isElectron()) {\r\n        return <string[]>Object.values(ASSETS_MANIFEST['models'])\r\n        .filter(file => isString(file))\r\n        .map(file => path.basename(<string>file)) \r\n        .sort();\r\n    } else {\r\n        const sandboxPath = path.dirname(currentPath());\r\n        const texturePath = path.join(sandboxPath, GetAssetsModelsPath());\r\n        return fs.readdirSync(texturePath).filter(fname => path.extname(fname) === '.obj');\r\n    }\r\n}\r\n\r\n\r\nfunction loadObjModel(name: string): Promise<THREE.Mesh[]> {\r\n    const loader = new OBJLoader();\r\n    return new Promise<THREE.Mesh[]>((resolve, reject) => {\r\n        loader.load(\r\n            `${GetAssetsModelsPath()}/${name}`,\r\n            (group: THREE.Group) => {\r\n                console.log(`model '${GetAssetsModelsPath()}/${name}.obj' is loaded.`);\r\n                resolve(group.children as THREE.Mesh[]);\r\n            },\r\n            (xhr) => {\r\n                // console.log((xhr.loaded / xhr.total * 100) + '% loaded');\r\n            },\r\n            (error) => {\r\n                console.log('An error happened');\r\n                reject();\r\n            }\r\n        );\r\n    });\r\n}\r\n\r\nfunction loadTGATexture(name: string): Promise<THREE.DataTexture> {\r\n    const loader = new TGALoader();\r\n    return new Promise<THREE.DataTexture>((resolve, reject) => {\r\n        loader.load(\r\n            `${GetAssetsTexturesPath()}/${name}`,\r\n            (texture: THREE.DataTexture) => {\r\n                console.log(`texture '${GetAssetsTexturesPath()}/${name}' is loaded.`);\r\n                resolve(texture);\r\n            },\r\n            (xhr) => {\r\n                // console.log( `${GetAssetsTexturesPath()}/${name}` + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );\r\n            },\r\n            (error) => {\r\n                console.log('An error happened');\r\n                reject();\r\n            }\r\n        );\r\n    });\r\n}\r\n\r\nfunction loadTexture(name: string): Promise<THREE.Texture> {\r\n    if (path.extname(name) === '.tga') return loadTGATexture(name);\r\n\r\n    const loader = new THREE.TextureLoader();\r\n    return new Promise<THREE.Texture>((resolve, reject) => {\r\n        loader.load(\r\n            `${GetAssetsTexturesPath()}/${name}`,\r\n            (texture: THREE.Texture) => {\r\n                // texture.encoding = THREE.sRGBEncoding;\r\n                console.log(`texture '${GetAssetsTexturesPath()}/${name}' is loaded.`);\r\n                resolve(texture);\r\n            },\r\n            (xhr) => {\r\n                // console.log( `${GetAssetsTexturesPath()}/${name}` + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );\r\n            },\r\n            (error) => {\r\n                console.log('An error happened');\r\n                reject();\r\n            }\r\n        );\r\n    });\r\n}\r\n\r\n\r\n\r\nfunction resolveExternalDependencies(\r\n    preloadTextures: boolean,\r\n    preloadMeshes: boolean,\r\n    deps: IDeps,\r\n    onComplete?: (deps: IDeps) => void) {\r\n\r\n    const geoms: Set<string> = new Set();\r\n    const textures: Set<string> = new Set();\r\n\r\n    if (preloadTextures) {\r\n        // IP: quick solution - request all possible textures as sub resources\r\n        // if resource requires at least one texture.\r\n        GetAssetsTextures().forEach(fname => textures.add(fname));\r\n    }\r\n\r\n    if (preloadMeshes || true /* ?? */) {\r\n        // IP: quick solution - request all possible textures as sub resources\r\n        // if resource requires at least one texture.\r\n        GetAssetsModels().forEach(fname => geoms.add(fname));\r\n    }\r\n\r\n    let depNum = 1;\r\n    let tryFinish = () => {\r\n        depNum--;\r\n        if (depNum == 0) {\r\n            onComplete?.(deps);\r\n        }\r\n    }\r\n\r\n    for (let name of geoms.values()) {\r\n        if (!deps.models[name]) {\r\n            depNum++;\r\n            loadObjModel(name).then(meshes => {\r\n                deps.models[name] = meshes;\r\n                tryFinish();\r\n            });\r\n        }\r\n    }\r\n\r\n    for (let name of textures.values()) {\r\n        if (!deps.textures[name]) {\r\n            depNum++;\r\n            loadTexture(name).then(texture => {\r\n                deps.textures[name] = texture;\r\n                tryFinish();\r\n            });\r\n        }\r\n    }\r\n\r\n    tryFinish();\r\n}\r\n\r\n\r\nexport class Deps implements IDeps {\r\n    models = {};\r\n    textures = {};\r\n\r\n    resolve(preloadTextures: boolean, preloadMeshes: boolean, onComplete?: (deps: IDeps) => void) {\r\n        resolveExternalDependencies(preloadTextures, preloadMeshes, this, onComplete);\r\n    }\r\n}\r\n\r\n","import { isString } from \"@lib/common\";\r\nimport { cloneValue, colorToUint, encodePlaygroundControlsToString, uintToColor } from \"@lib/fx/bundles/utils\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { Color, IPlaygroundControlsState } from \"@sandbox/store/IStoreState\";\r\nimport { GUI } from \"dat.gui\";\r\nimport { GetAssetsModels, GetAssetsTextures } from \"./deps\";\r\nimport { toast } from 'react-semantic-toasts';\r\nimport copy from 'copy-to-clipboard';\r\n\r\nexport class GuiView {\r\n    protected gui: GUI = null;\r\n    protected mountEl: HTMLDivElement;\r\n    protected hash: string;\r\n    protected presetName: string = null;\r\n    protected meshDebugDraw: IMap<boolean> = {};\r\n\r\n    mount(el: HTMLDivElement) {\r\n        this.mountEl = el;\r\n    }\r\n\r\n    detach() {\r\n        this.mountEl.removeChild(this.gui.domElement);\r\n    }\r\n\r\n    attach() {\r\n        this.mountEl.appendChild(this.gui.domElement);\r\n    }\r\n\r\n    debugDraw() {\r\n        return this.meshDebugDraw;\r\n    }\r\n\r\n    preset(): string {\r\n        return this.presetName;\r\n    }\r\n    \r\n    static hash(controls: IPlaygroundControlsState): string {\r\n        return JSON.stringify(controls.controls) +\r\n            JSON.stringify(controls.presets) +\r\n            // IP: hack to handle update of textures\r\n            JSON.stringify(Object.values(controls.values).filter(isString));\r\n    }\r\n\r\n\r\n    remove() {\r\n        if (this.gui) {\r\n            this.detach();\r\n            this.gui.destroy();\r\n            this.gui = null;\r\n            this.hash = null;\r\n        }\r\n    }\r\n\r\n\r\n    create(controls: IPlaygroundControlsState) {\r\n        if (!controls) {\r\n            return;\r\n        }\r\n\r\n        const hash = GuiView.hash(controls);\r\n        if (this.hash != hash) {\r\n            this.remove();\r\n        }\r\n\r\n        if (Object.keys(controls.values).length == 0) {\r\n            // empty controls are valid ?\r\n            return null;\r\n        }\r\n\r\n        if (this.gui) {\r\n            // nothing todo, same controls have been requested\r\n            return;\r\n        }\r\n\r\n        // remove active preset if it doesn't exist anymore\r\n        if (this.presetName && !controls.presets.find(p => p.name === this.presetName)) {\r\n            this.presetName = null;\r\n        }\r\n\r\n        const gui = new GUI({ autoPlace: false });\r\n\r\n        for (let name in controls.values) {\r\n            let ctrl = controls.controls[name];\r\n            let viewType = ctrl.properties[\"__type\"] as string || ctrl.type;\r\n            let caption = ctrl.properties[\"__caption\"] as string || ctrl.name;\r\n            let guiCtrl = null;\r\n            switch (viewType) {\r\n                case 'int':\r\n                case 'uint':\r\n                case 'float':\r\n                    guiCtrl = gui.add(controls.values, name);\r\n                    break;\r\n                case 'slider':\r\n                    let min = ctrl.properties[\"__min\"] as number;\r\n                    let max = ctrl.properties[\"__max\"] as number;\r\n                    let step = ctrl.properties[\"__step\"] as number;\r\n                    guiCtrl = gui.add(controls.values, name, min, max, step);\r\n                    break;\r\n                case 'color':\r\n                    let colorFolder = gui.addFolder(caption);\r\n                    let clr = controls.values[name] as Color;\r\n                    colorFolder.addColor({ color: colorToUint(clr) }, 'color').onChange(value => uintToColor(value, clr));\r\n                    colorFolder.add({ opacity: clr.a }, 'opacity', 0, 1).onChange(value => clr.a = value);\r\n                    colorFolder.open();\r\n                    break;\r\n                case 'float2':\r\n                    let vec2Folder = gui.addFolder(caption);\r\n                    vec2Folder.add(controls.values[name], 'x');\r\n                    vec2Folder.add(controls.values[name], 'y');\r\n                    vec2Folder.close();\r\n                    break;\r\n                case 'float3':\r\n                    let vec3Folder = gui.addFolder(caption);\r\n                    vec3Folder.add(controls.values[name], 'x');\r\n                    vec3Folder.add(controls.values[name], 'y');\r\n                    vec3Folder.add(controls.values[name], 'z');\r\n                    vec3Folder.close();\r\n                    break;\r\n                case 'float4':\r\n                    let vec4Folder = gui.addFolder(caption);\r\n                    vec4Folder.add(controls.values[name], 'x');\r\n                    vec4Folder.add(controls.values[name], 'y');\r\n                    vec4Folder.add(controls.values[name], 'z');\r\n                    vec4Folder.add(controls.values[name], 'w');\r\n                    vec4Folder.close();\r\n                    break;\r\n                case 'texture2d':\r\n                    {\r\n                        const list = GetAssetsTextures();\r\n                        let def = controls.values[name] as string;\r\n                        if (!list.includes(def)) {\r\n                            def = list[0];\r\n                        }\r\n                        // override initial value if it does not suit available resources\r\n                        gui.add(controls.values, name, list).setValue(def);\r\n                    }\r\n                    break;\r\n                case 'mesh':\r\n                    {\r\n                        let def = controls.values[name] as string;\r\n                        const list = GetAssetsModels();\r\n                        if (!list.includes(def)) {\r\n                            def = list[0];\r\n                        }\r\n                        // override initial value if it does not suit available resources\r\n                        const folder = gui.addFolder(caption);\r\n                        folder.add(controls.values, name, list).setValue(def);\r\n                        \r\n                        {\r\n                            this.meshDebugDraw[name] ||= false;\r\n                            folder.add(this.meshDebugDraw, name).name('show (debug)');\r\n                        }\r\n                        \r\n                        folder.open();\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if (guiCtrl) {\r\n                guiCtrl.name(caption);\r\n            }\r\n        }\r\n\r\n        if (controls.presets?.length) {\r\n            gui.add(this, 'presetName', ['', ...controls.presets.map(p => p.name)]).onChange(name => {\r\n                console.log('apply preset', name);\r\n                const preset = controls.presets.find(p => p.name == name);\r\n                if (preset) {\r\n                    preset.data.forEach(entry => {\r\n                        let control = controls.controls[entry.name];\r\n                        if (control) {\r\n                            controls.values[entry.name] = cloneValue(entry.type, entry.value);\r\n                        }\r\n                    });\r\n                    setTimeout(() => {\r\n                        this.remove();\r\n                        this.create(controls);\r\n                    }, 10);\r\n                }\r\n            }).name('preset');\r\n        }\r\n\r\n        const copyToClipboard = '<center>copy to clipboard</center>';\r\n        // todo: show notification\r\n        gui.add({\r\n            [copyToClipboard]: () => {\r\n                copy(encodePlaygroundControlsToString(controls), { debug: true });\r\n                toast({\r\n                    size: 'tiny',\r\n                    type: 'info',\r\n                    title: `Copied to clipboard`,\r\n                    animation: 'bounce',\r\n                    time: 2000\r\n                });\r\n            }\r\n        }, copyToClipboard);\r\n\r\n        // gui.close();\r\n        gui.open();\r\n\r\n        gui.domElement.style.position = 'absolute';\r\n        gui.domElement.style.top = '2px';\r\n        \r\n        this.gui = gui;\r\n        this.hash = hash;\r\n\r\n        this.attach();\r\n    }\r\n}\r\n","\r\nimport isElectronRuntime from 'is-electron';\r\n    \r\nexport function isElectron () {\r\n    return isElectronRuntime();\r\n};\r\n\r\nconst ipcRenderer = isElectron() ? require('electron').ipcRenderer : null;\r\n\r\nexport const sync = {\r\n    argv() {\r\n        return ipcRenderer?.sendSync('argv', {});\r\n    },    \r\n\r\n    // returns saved file name\r\n    saveFile(name: string, data: any): string {\r\n        return ipcRenderer?.sendSync('process-save-file-silent', { name, data });\r\n    },\r\n\r\n    // save file using file dialog\r\n    // returns saved file name\r\n    saveFileDialog(options: any, data: any): string {\r\n        options = { \r\n            title: \"Save File\",\r\n            defaultPath: \"\",\r\n            buttonLabel: \"Save\",\r\n            filters: [],\r\n            ...options \r\n        };\r\n        return ipcRenderer?.sendSync('process-save-file-dialog', \r\n            { data, options });\r\n    },\r\n\r\n    // readFile(name: string): string {\r\n\r\n    // }\r\n};\r\n\r\n\r\nexport const async = {\r\n    notifyAppReady() {\r\n        ipcRenderer?.send('app-ready', {});\r\n    }\r\n}\r\n","import * as path from '@lib/path/path';\r\nimport * as URI from '@lib/uri/uri';\r\nimport { sourceCode as sourceActions } from '@sandbox/actions';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { ISourceFileRequest } from '@sandbox/actions/ActionTypes';\r\nimport * as ipc from '@sandbox/ipc';\r\nimport * as Depot from '@sandbox/reducers/depot';\r\nimport { history } from '@sandbox/reducers/router';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport { LocationChangeAction, LOCATION_CHANGE } from 'connected-react-router';\r\nimport { matchPath } from 'react-router';\r\nimport { toast } from 'react-semantic-toasts';\r\nimport { createLogic } from 'redux-logic';\r\n\r\nimport 'react-semantic-toasts/styles/react-semantic-alert.css';\r\n\r\n// hack to resolve unexisting files\r\nconst fetchVirtual = (fname) =>\r\n{\r\n    if (fname === URI.fromLocalPath(DEFAULT_FILENAME))\r\n        return { status: 200, async text() { return `/* created: ${new Date()} */\\n\\n`; } }\r\n    return null;\r\n}\r\n\r\nconst readFile = fname => {\r\n    return fetchVirtual(fname) || fetch(fname);\r\n}\r\n\r\nconst fetchSourceFileLogic = createLogic<IStoreState, ISourceFileRequest['payload']>({\r\n    type: evt.SOURCE_FILE_REQUEST,\r\n    latest: true,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        // drop autosave params\r\n        dispatch({ type: evt.SOURCE_FILE_DROP_STATE });\r\n        dispatch({ type: evt.PLAYGROUND_EFFECT_HAS_BEEN_DROPPED, payload: { } });\r\n\r\n        const filename = action.payload.filename;\r\n\r\n        try {\r\n            const response = await readFile(filename);\r\n            if (response.status !== 200) {\r\n                console.warn(`Could not find file ${filename}.`);\r\n                dispatch({ type: evt.SOURCE_FILE_LOADING_FAILED, payload: { } });\r\n            } else {\r\n                const ext = path.ext(filename);\r\n                const content = await response.text();\r\n\r\n                if (ext === 'xfx')    \r\n                {\r\n                    dispatch({ type: evt.GRAPH_LOADED, payload: { filename, content } });\r\n                }\r\n                else {\r\n                    dispatch({ type: evt.SOURCE_FILE_LOADED, payload: { filename, content } });\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.warn(`Could not find file ${filename}.`);\r\n            dispatch({ type: evt.SOURCE_FILE_LOADING_FAILED, payload: { error } });\r\n        } finally {\r\n            done();\r\n        }\r\n    }\r\n});\r\n\r\n\r\nexport const LOCATION_NOT_FOUND = '/NotFound';\r\nexport const LOCATION_PATTERN = '/:view/:fx?/:name?/:pass?/:property?';\r\nexport const DEFAULT_FILENAME = 'unnamed';\r\n\r\nexport const PLAYGROUND_VIEW = 'playground';\r\nexport const BYTECODE_VIEW = 'bytecode';\r\nexport const PROGRAM_VIEW = 'program';\r\nexport const AST_VIEW = 'ast';\r\nexport const PREPROCESSOR_VIEW = 'preprocessor';\r\nexport const GRAPH_VIEW = 'graph';\r\n\r\nexport const RAW_KEYWORD = '@preprocessed';\r\nexport const CODE_KEYWORD = '@formatted';\r\nexport const GRAPH_KEYWORD = '@graph';\r\n\r\nexport const LOCAL_SESSION_ID = 'last-session-id';\r\nexport const LOCAL_SESSION_AUTOSAVE = 'local-session-autosave';\r\n\r\nexport const EXT_FILTER = ['.fx', '.xfx', '.vsh', '.psh', '.csh', '.vs', '.ps', '.hlsl' ];\r\n\r\nexport const ASSETS_PATH = ipc.isElectron() ? './assets' : '/assets';\r\nexport const LIB_PATH = `${ASSETS_PATH}/graph`; // todo: move to more suitable place\r\n\r\n// manifest.json is auto generated file created by webpack.sandbox\r\nexport let ASSETS_MANIFEST = await (await fetch(`${ASSETS_PATH}/manifest.json`)).json();\r\n\r\nexport const SUPPORTED_VIEWS = [ PLAYGROUND_VIEW, BYTECODE_VIEW, PROGRAM_VIEW, AST_VIEW, PREPROCESSOR_VIEW, GRAPH_VIEW ];\r\n\r\nexport type PATH_PARAMS_TYPE = { view: string; fx?: string; name?: string; pass?: string; property?: string };\r\n\r\nconst navigationLogic = createLogic<IStoreState, LocationChangeAction['payload']>({\r\n    type: LOCATION_CHANGE,\r\n    latest: true,\r\n    debounce: 10,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const location = action.payload.location.pathname;\r\n        const { sourceFile, depot } = getState()\r\n        const defaultFilename = localStorage.getItem(LOCAL_SESSION_ID) || DEFAULT_FILENAME;\r\n        \r\n        if (location === '/') {\r\n            if (defaultFilename !== DEFAULT_FILENAME)\r\n                setTimeout(() => {\r\n                    toast({\r\n                        type: 'warning',\r\n                        title: `Last session`,\r\n                        description: `Last session has been loaded.`,\r\n                        animation: 'fade up',\r\n                        time: 2000\r\n                    });\r\n                }, 2000);\r\n                \r\n            history.push(`/${PLAYGROUND_VIEW}/${defaultFilename}`);\r\n            return done();\r\n        }\r\n\r\n        const match = matchPath<PATH_PARAMS_TYPE>(location, {\r\n            path: LOCATION_PATTERN,\r\n            exact: false\r\n        });\r\n\r\n        if (match) {\r\n            const { view, fx, name } = match.params;\r\n\r\n            const supportedViews = SUPPORTED_VIEWS;\r\n            if (supportedViews.indexOf(view) !== -1) {\r\n                if (!fx) {\r\n                    history.push(`/${view}/${DEFAULT_FILENAME}`);\r\n                    return done();\r\n                }\r\n                \r\n                const fxRequest = await Depot.resolveName(depot, fx);\r\n                if (sourceFile.uri !== fxRequest) {\r\n                    dispatch(sourceActions.openFile(fxRequest));\r\n                }\r\n            }\r\n\r\n            return done();\r\n        }\r\n\r\n        if (location !== LOCATION_NOT_FOUND) {\r\n            history.push(LOCATION_NOT_FOUND);\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * Redirect to default source (DEFAULT_FILENAME) if requested file was not found.\r\n */\r\nconst sourceFileNotFoundLogic = createLogic<IStoreState>({\r\n    type: evt.SOURCE_FILE_LOADING_FAILED,\r\n    async process({ getState }, dispatch, done) {\r\n        const location = getState().router.location.pathname;\r\n        const match = matchPath<PATH_PARAMS_TYPE>(location, {\r\n            path: LOCATION_PATTERN,\r\n            exact: false\r\n        });\r\n\r\n        if (match) {\r\n            const { view, fx } = match.params;\r\n            if (!fx) {\r\n                // something went wrong\r\n                history.push(`/${view}/${DEFAULT_FILENAME}`);\r\n            } else {\r\n                // show special page if request fx is not found\r\n                history.push(LOCATION_NOT_FOUND);\r\n            }\r\n        }\r\n\r\n        return done();\r\n    }\r\n});\r\n\r\nexport default [\r\n    fetchSourceFileLogic,\r\n    navigationLogic,\r\n    sourceFileNotFoundLogic\r\n];\r\n","import * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport IStoreState, { IDepotFolder } from '@sandbox/store/IStoreState';\r\nimport { createLogic } from 'redux-logic';\r\nimport * as URI from '@lib/uri/uri';\r\nimport * as ipc from '@sandbox/ipc';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { ASSETS_MANIFEST, ASSETS_PATH, DEFAULT_FILENAME, EXT_FILTER, LIB_PATH } from './common';\r\nimport { isString } from '@lib/common';\r\n\r\nasync function feedFakeDepot(root: IDepotFolder) {\r\n    let demos = depotNode();\r\n    demos.files = <string[]>Object.values(ASSETS_MANIFEST['fx']['demos'])\r\n    .filter(file => isString(file))\r\n    .map(file => `/${file}`) \r\n    .sort();\r\n    demos.path = '/demos';\r\n    demos.totalFiles = demos.files.length;\r\n\r\n    let graph = depotNode();\r\n    graph.files = <string[]>Object.values(ASSETS_MANIFEST['graph'])\r\n    .filter(file => isString(file))\r\n    .map(file => `/${file}`) \r\n    .sort();\r\n    graph.path = '/graph';\r\n    graph.totalFiles = graph.files.length;\r\n\r\n    root.folders = [ demos, graph ];\r\n    root.path = '/';\r\n    root.totalFiles = demos.totalFiles + graph.totalFiles;\r\n}\r\n\r\n\r\n\r\nfunction scan(dir: string, node: IDepotFolder, filters?: string[], excludes?: string[]) {\r\n    try {\r\n        node.path = URI.fromLocalPath(dir);\r\n\r\n        let stats = fs.statSync(dir);\r\n        if (!stats.isDirectory()) {\r\n            return;\r\n        }\r\n        if (excludes?.includes(path.basename(dir))) {\r\n            return;\r\n        }\r\n\r\n        fs.readdirSync(dir).forEach(async filename => {\r\n            let filepath = path.join(dir, filename);\r\n            let filestats = fs.statSync(filepath);\r\n\r\n            if (filestats.isFile()) {\r\n                if (!filters || filters.indexOf(path.extname(filename)) != -1) {\r\n                    node.files = node.files || [];\r\n                    node.files.push(URI.fromLocalPath(filepath));\r\n                    node.totalFiles++;\r\n                }\r\n            }\r\n\r\n            if (filestats.isDirectory()) {\r\n                node.folders = node.folders || [];\r\n\r\n                let subfolder = { path: URI.fromLocalPath(filepath), totalFiles: 0 };\r\n                scan(filepath, subfolder, filters, excludes);\r\n\r\n                node.folders.push(subfolder);\r\n                node.totalFiles += subfolder.totalFiles;\r\n            }\r\n        });\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}\r\n\r\nconst depotNode = (): IDepotFolder => ({ path: null, files: [], folders: [], totalFiles: 0 });\r\n\r\nfunction currentPath() {\r\n    // mac locations looks like:\r\n    //  '/influx/dist/electron/sandbox-electron.html'\r\n    if (window.navigator.platform.includes('Mac')) {\r\n        return window.location.pathname;\r\n    }\r\n    // windows locations looks like:\r\n    //  '/C:/Influx/dist/electron/sandbox-electron.html'\r\n    return window.location.pathname.substr(1);\r\n}\r\n\r\nconst depotUpdateRequestLogic = createLogic<IStoreState>({\r\n    type: evt.DEPOT_UPDATE_REQUEST,\r\n    latest: true,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const { s3d: { env } } = getState();\r\n        const root = depotNode();\r\n        const sandboxPath = path.dirname(currentPath());\r\n\r\n        if (!ipc.isElectron()) {\r\n            await feedFakeDepot(root);\r\n        } else {\r\n            if (env) {\r\n                let sfxFolder = depotNode();\r\n                await scan(env.Get('influx-sfx-dir'), sfxFolder, EXT_FILTER);\r\n\r\n                let shaderFolder = depotNode();\r\n                await scan(env.Get('sdrproj-dir'), shaderFolder, EXT_FILTER, ['maya_fx', 'deploy_test', 'nrd']);\r\n\r\n                let libFolder = depotNode();\r\n                let sandboxLibPath = path.join(sandboxPath, LIB_PATH); \r\n                await scan(sandboxLibPath, libFolder, EXT_FILTER);\r\n\r\n                root.path = URI.fromLocalPath(path.dirname(env.Get('project-dir')));\r\n                root.folders = [ sfxFolder, shaderFolder, libFolder ];\r\n                root.totalFiles = sfxFolder.totalFiles + shaderFolder.totalFiles;\r\n            } else {\r\n                let rootPath = path.join(sandboxPath, `${ASSETS_PATH}/fx/demos`); \r\n                await scan(rootPath, root, EXT_FILTER);\r\n            }\r\n\r\n            root.files.push(URI.fromLocalPath(DEFAULT_FILENAME));\r\n        }\r\n        \r\n        dispatch({ type: evt.DEPOT_UPDATE_COMPLETE, payload: { root } });\r\n        done();\r\n    }\r\n});\r\n\r\nconst depotUpdateCompleteLogic = createLogic<IStoreState>({\r\n    type: evt.DEPOT_UPDATE_COMPLETE,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        // ...\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nexport default [\r\n    depotUpdateRequestLogic,\r\n    depotUpdateCompleteLogic\r\n];\r\n","// tslint:disable:no-for-in\r\n// tslint:disable:forin\r\n\r\nimport { isNull, verbose } from '@lib/common';\r\nimport * as FxBundle from '@lib/fx/bundles/Bundle';\r\nimport * as FxBundle11 from '@lib/fx/bundles/Bundle11';\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\nimport * as Techniques from '@lib/fx/techniques';\r\nimport { ITechnique } from '@lib/idl/ITechnique';\r\nimport * as Path from '@lib/path/path';\r\nimport * as URI from '@lib/uri/uri';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IPlaygroundEffectSaveRequest, IPlaygroundSelectEffect, IPlaygroundSetOptionAutosave } from '@sandbox/actions/ActionTypes';\r\nimport * as ipc from '@sandbox/ipc';\r\nimport * as Depot from '@sandbox/reducers/depot';\r\nimport { filterTechniques, filterTechniques11, getPlaygroundState } from '@sandbox/reducers/playground';\r\nimport { asConvolutionPack, getFileState, getScope } from '@sandbox/reducers/sourceFile';\r\nimport { IPlaygroundControlsState, IStoreState } from '@sandbox/store/IStoreState';\r\nimport { createLogic } from 'redux-logic';\r\n\r\nimport { decodeBundleControls } from '@lib/fx/bundles/utils';\r\nimport { asFxTranslatorOprions } from '@sandbox/reducers/translatorParams';\r\nimport path from 'path';\r\nimport { toast } from 'react-semantic-toasts';\r\nimport 'react-semantic-toasts/styles/react-semantic-alert.css';\r\n\r\nfunction downloadByteBuffer(data: Uint8Array, fileName: string, mimeType: 'application/octet-stream') {\r\n    downloadBlob(new Blob([data], { type: mimeType }), fileName);\r\n};\r\n\r\nfunction downloadBlob(blob: Blob, fileName: string) {\r\n    let url;\r\n    url = window.URL.createObjectURL(blob);\r\n    downloadURL(url, fileName);\r\n    setTimeout(() => window.URL.revokeObjectURL(url), 1000);\r\n};\r\n\r\nfunction downloadURL(data: string, fileName: string) {\r\n    let a;\r\n    a = document.createElement('a');\r\n    a.href = data;\r\n    a.download = fileName;\r\n    document.body.appendChild(a);\r\n    a.style = 'display: none';\r\n    a.click();\r\n    a.remove();\r\n};\r\n\r\nasync function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nconst playgroundUpdateLogic = createLogic<IStoreState, IPlaygroundSelectEffect['payload']>({\r\n    type: [\r\n        evt.SOURCE_CODE_ANALYSIS_COMPLETE,\r\n        evt.PLAYGROUND_SELECT_EFFECT,\r\n        evt.PLAYGROUND_SWITCH_VM_RUNTIME,\r\n        evt.PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME\r\n    ],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const state = getState();\r\n        const file = getFileState(state);\r\n        const playground = getPlaygroundState(state);\r\n        const timeline = playground.timeline;\r\n        const depot = Depot.getDepot(state);\r\n        const translator = asFxTranslatorOprions(state);\r\n\r\n        const scope = getScope(file);\r\n        /** @deprecated */\r\n        const list = filterTechniques(scope);\r\n        const list11 = filterTechniques11(scope);\r\n\r\n        let active = action.type === evt.PLAYGROUND_SELECT_EFFECT ? action.payload.name : null;\r\n        let technique = playground.technique;\r\n        let controls = playground.controls;\r\n\r\n        if (!isNull(technique) && isNull(active)) {\r\n            if (list.map(fx => fx.name).indexOf(technique.getName()) !== -1) {\r\n                active = technique.getName();\r\n            }\r\n        }\r\n\r\n        /** @deprecated */\r\n        if (!active) {\r\n            for (const fx of list) {\r\n                if (fx.isValid()) {\r\n                    active = fx.name;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!active) {\r\n            for (const fx of list11) {\r\n                if (fx.isValid()) {\r\n                    active = fx.name;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        async function destroy(technique: ITechnique) {\r\n            Techniques.destroyTechnique(technique);\r\n            // verbose('previous technique has been dropped.');\r\n        }\r\n\r\n        async function copy(next: ITechnique, prev: ITechnique) {\r\n            Techniques.copyTechnique(next, prev);\r\n        }\r\n\r\n        async function create11(forceRestart = true): Promise<[ ITechnique, IPlaygroundControlsState ]> {\r\n            const i = list11.map(fx => fx.name).indexOf(active);\r\n\r\n            if (i == -1) {\r\n                return [ null, null ];\r\n            }\r\n\r\n            const bundle = await FxBundle11.createBundle(list11[i], { translator });\r\n            const tech = Techniques.createTechnique(bundle);\r\n            const controls = decodeBundleControls(bundle);\r\n\r\n            if (tech) {\r\n                if (forceRestart) timeline.start();\r\n                // verbose('next technique has been created.');\r\n            }\r\n\r\n            return [ tech, controls ];\r\n        }\r\n\r\n        /** @deprecated */\r\n        async function create(forceRestart = true): Promise<[ ITechnique, IPlaygroundControlsState ]> {\r\n            const i = list.map(fx => fx.name).indexOf(active);\r\n\r\n            if (i == -1) {\r\n                return create11(forceRestart);\r\n            }\r\n\r\n            const bundle = await FxBundle.createBundle(list[i], { translator, omitHLSL: true });\r\n            const tech = Techniques.createTechnique(bundle);\r\n            const controls = decodeBundleControls(bundle);\r\n\r\n            if (tech) {\r\n                if (forceRestart) timeline.start();\r\n                // verbose('next technique has been created.');\r\n            }\r\n\r\n            return [ tech, controls ];\r\n        }\r\n\r\n        async function drop() {\r\n            await destroy(technique);\r\n            [ technique, controls ] = [ null, null ];\r\n        }\r\n\r\n        async function forceReload() {\r\n            await destroy(technique);\r\n            [ technique, controls ] = await create();\r\n        }\r\n\r\n        // fixme: move technique to playground\r\n        async function $hackDestroyResources() {\r\n            // IP: hack to notify plathground to destroy all the resources\r\n            // literally set null technique and thus call release of all dependent resources\r\n            dispatch({ type: evt.PLAYGROUND_TECHNIQUE_UPDATE, payload: { technique, controls } });\r\n            await sleep(10);\r\n            return;\r\n        }\r\n\r\n        async function switchVMRuntime() {\r\n            await drop();                   // destroy current technique\r\n            await $hackDestroyResources();  // wait for release of all it's resources\r\n\r\n            VM.switchRuntime();\r\n            [ technique, controls ] = await create();\r\n        }\r\n\r\n        async function switchTechniqueRuntime() {\r\n            await drop();                   // destroy current technique\r\n            await $hackDestroyResources();  // wait for release of all it's resources\r\n\r\n            Techniques.switchRuntime();\r\n            [ technique, controls ] = await create();\r\n        }\r\n\r\n        async function softReload() {\r\n            if (!technique) {\r\n                await forceReload();\r\n                return;\r\n            }\r\n\r\n            // controls stay unchanged\r\n            let [ next, ctrlsNext ] = await create(false);\r\n            let prev = technique;\r\n\r\n\r\n            await copy(next, prev);\r\n            await destroy(prev);\r\n            \r\n            technique = next;\r\n            controls = ctrlsNext;\r\n        }\r\n\r\n        switch (action.type) {\r\n            case evt.PLAYGROUND_SWITCH_VM_RUNTIME:\r\n                await switchVMRuntime();\r\n                break;\r\n            case evt.PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME:\r\n                await switchTechniqueRuntime();\r\n                break;\r\n            default:\r\n                if (!file.slDocument || file.slDocument.diagnosticReport.errors > 0) {\r\n                    await drop();\r\n                }\r\n                else {\r\n                    await softReload();\r\n                }\r\n        }\r\n\r\n        dispatch({ type: evt.PLAYGROUND_TECHNIQUE_UPDATE, payload: { technique, controls } });\r\n\r\n        if (playground.autosave) {\r\n            dispatch({ type: evt.PLAYGROUND_EFFECT_AUTOSAVE_REQUEST, payload: {} });\r\n        }\r\n\r\n        // construct default export name if possible\r\n        if (!playground.exportName) {\r\n            const uri = URI.parse(file.uri);\r\n            if (uri.protocol == 'file') {\r\n                const filename = Path.parse(URI.toLocalPath(uri)).replaceExt('bfx');\r\n                // dispatch fake event to update export name\r\n                dispatch({ type: evt.PLAYGROUND_EFFECT_HAS_BEEN_SAVED, payload: { filename: URI.fromLocalPath(filename) } });\r\n            }\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n\r\nconst playgroundSaveFileAsLogic = createLogic<IStoreState, IPlaygroundEffectSaveRequest['payload']>({\r\n    type: [\r\n        evt.PLAYGROUND_EFFECT_SAVE_REQUEST\r\n    ],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const state = getState();\r\n        const file = getFileState(state);\r\n        const playground = getPlaygroundState(state);\r\n        const scope = getScope(file);\r\n        const list = filterTechniques(scope);\r\n        const translator = asFxTranslatorOprions(state);\r\n\r\n        const tech = playground.technique;\r\n\r\n        const exportName = Path.parse(file.uri);\r\n        exportName.ext = \"bfx\"; // binary fx\r\n\r\n        // download packed version of single (! active only !) technique\r\n        // -----------------------------------\r\n        let options: FxBundle.BundleOptions = { \r\n            packed: true,\r\n            meta: {\r\n                source: file.uri,\r\n                author: state.s3d?.p4?.['User name']\r\n            },\r\n            omitGLSL: false,\r\n            omitHLSL: false,\r\n            translator\r\n        };\r\n        \r\n        const techInstr = list.find((fx => fx.name == tech.getName()));\r\n        const data = await FxBundle.createBundle(techInstr, options, asConvolutionPack(state)) as Uint8Array;\r\n\r\n        // download unpacked version\r\n        // -----------------------------------\r\n\r\n        // const bundles = new BundleCollectionT(await Promise.all(list.map(async fx => await FxBundle.createPartFxBundle(fx))));\r\n        // let fbb = new flatbuffers.Builder(1);\r\n        // let size = bundles.pack(fbb);\r\n\r\n        if (ipc.isElectron()) {\r\n            let filename = null;\r\n            // reqest to make silent auto save using known local file path\r\n            if (action.payload.silent) {\r\n                filename = ipc.sync.saveFile(URI.toLocalPath(playground.exportName), data);\r\n            }\r\n            else {\r\n                filename = ipc.sync.saveFileDialog(\r\n                { \r\n                    defaultPath: URI.toLocalPath(playground.exportName),\r\n                    title: \"Save binary FX\", \r\n                    buttonLabel: \"Save\",\r\n                    filters: [\r\n                        { name: 'Binary FX', extensions: ['bfx'] },\r\n                    ]\r\n                }\r\n                , data);\r\n            }\r\n\r\n            if (filename) {\r\n                // URI.fromLocalPath(fromLocalPath)\r\n                dispatch({ type: evt.PLAYGROUND_EFFECT_HAS_BEEN_SAVED, payload: { filename: URI.fromLocalPath(filename) } });\r\n                verbose(`Effect '${filename}' has been exported successfully.`);\r\n\r\n                toast({\r\n                    size: 'tiny',\r\n                    type: 'info',\r\n                    title: `${action.payload.silent ? 'Autoexport' : 'Export'} complete`,\r\n                    description: `Effect '${filename}' has been exported successfully.`,\r\n                    animation: 'bounce',\r\n                    time: 2000\r\n                });\r\n            }\r\n        }\r\n        // web browser\r\n        else {\r\n            // download packed version of single (! active only !) technique\r\n            // -----------------------------------\r\n            downloadByteBuffer(data, exportName.basename, 'application/octet-stream');\r\n\r\n            // download unpacked version\r\n            // -----------------------------------\r\n            // downloadByteBuffer(fbb.asUint8Array(), exportName.basename, 'application/octet-stream');   \r\n        }\r\n\r\n        let fxDir = state.s3d?.env?.Get('fx-dir');\r\n        if (fxDir) {\r\n            let fileName = path.basename(playground.exportName);\r\n            let sourcePath = fxDir + '\\\\' + fileName;\r\n            let sourceResourcePath = sourcePath + '.resource';\r\n            let destinationPath = URI.toLocalPath(URI.fromLocalPath(sourcePath));\r\n            let destinationResourcePath = URI.toLocalPath(URI.fromLocalPath(sourceResourcePath));\r\n            ipc.sync.saveFile(destinationPath, data);\r\n            ipc.sync.saveFile(destinationResourcePath, '__type: res_desc_bfx\\nlinks: []\\nbfx: ' + fileName + '\\n');\r\n        } \r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n// on technique update complete\r\nconst playgroundTechniqueUpdateLogic = createLogic<IStoreState>({\r\n    type: [\r\n        evt.PLAYGROUND_EFFECT_AUTOSAVE_REQUEST\r\n    ],\r\n    latest: true,\r\n    debounce: 1000,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const playground = getPlaygroundState(getState());\r\n        if (playground.exportName && playground.technique) {\r\n            dispatch({ type: evt.PLAYGROUND_EFFECT_SAVE_REQUEST, payload: { silent: true } });\r\n        }\r\n        done();\r\n    }\r\n});\r\n\r\n// on technique update complete\r\nconst playgroundSetOptionAutosave = createLogic<IStoreState, IPlaygroundSetOptionAutosave['payload']>({\r\n    type: [evt.PLAYGROUND_SET_OPTION_AUTOSAVE],\r\n    latest: true,\r\n    debounce: 100,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        if (action.payload.enabled) {\r\n            dispatch({ type: evt.PLAYGROUND_EFFECT_AUTOSAVE_REQUEST, payload: {} });\r\n        }\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n\r\nexport default [\r\n    playgroundUpdateLogic,\r\n    playgroundSaveFileAsLogic,\r\n    playgroundTechniqueUpdateLogic,\r\n    playgroundSetOptionAutosave\r\n];\r\n","import { types } from '@lib/fx/analisys/helpers';\r\nimport { createFXSLDocument, extendFXSLDocument } from '@lib/fx/FXSLDocument';\r\nimport { createTextDocument } from '@lib/fx/TextDocument';\r\nimport { FxEmitter } from '@lib/fx/translators/FxEmitter';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\nimport { isDefAndNotNull } from '@lib/util/s3d/type';\r\nimport { nodes, sourceCode } from '@sandbox/actions';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IGraphAddConstant, IGraphChangeLayout, IGraphCompile, IGraphLoaded, IGraphRemoveConstant, IGraphSetConstant } from '@sandbox/actions/ActionTypes';\r\nimport { history } from '@sandbox/reducers/router';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport { LGraph, LiteGraph } from 'litegraph.js';\r\nimport { matchPath } from 'react-router-dom';\r\nimport { createLogic } from 'redux-logic';\r\nimport { GRAPH_KEYWORD, LOCATION_PATTERN, PATH_PARAMS_TYPE, LIB_PATH } from './common';\r\n\r\nimport { CodeEmitter } from '@lib/fx/translators/CodeEmitter';\r\nimport docs from '@sandbox/components/graphEx/utils/docs';\r\n\r\n// import all factories\r\n\r\nimport { PART_LOCAL_NAME, PART_TYPE } from '@sandbox/components/graphEx/common';\r\n\r\nimport BasicType from '@sandbox/components/graphEx/BasicType';\r\nimport Decomposer from '@sandbox/components/graphEx/Decomposer';\r\nimport Float from '@sandbox/components/graphEx/Float';\r\nimport FuncNodes from '@sandbox/components/graphEx/FuncNodes';\r\nimport IfStmt from '@sandbox/components/graphEx/IfStmt';\r\nimport Int from '@sandbox/components/graphEx/Int';\r\nimport Operators from '@sandbox/components/graphEx/Operators';\r\nimport StmtList from '@sandbox/components/graphEx/StmtList';\r\nimport Uniforms from '@sandbox/components/graphEx/Uniforms';\r\n\r\nimport DefaultMaterial from '@sandbox/components/graphEx/fx/DefaultMaterial';\r\nimport Kill from '@sandbox/components/graphEx/fx/Kill';\r\nimport KillBy from '@sandbox/components/graphEx/fx/KillBy';\r\nimport LwiMaterial from '@sandbox/components/graphEx/fx/LwiMaterial';\r\nimport Param from '@sandbox/components/graphEx/fx/Param';\r\nimport Part from '@sandbox/components/graphEx/fx/Part';\r\nimport PartId from '@sandbox/components/graphEx/fx/PartId';\r\nimport PartInit from '@sandbox/components/graphEx/fx/PartInit';\r\nimport PartPrevious from '@sandbox/components/graphEx/fx/PartPrevious';\r\nimport PartSpawn from '@sandbox/components/graphEx/fx/PartSpawn';\r\nimport PartUpdate from '@sandbox/components/graphEx/fx/PartUpdate';\r\nimport UserConst from '@sandbox/components/graphEx/fx/UserConst';\r\n\r\n\r\nimport { ITypeInstruction } from '@lib/idl/IInstruction';\r\nimport { CodeEmitterNode, ICodeMaterialNode, ISpawner, LGraphNodeFactory } from '@sandbox/components/graphEx/GraphNode';\r\nimport GraphTemplateJSON from '@sandbox/components/graphEx/lib/template.json';\r\nimport { getEnv } from '@sandbox/reducers/nodes';\r\n\r\n\r\nasync function loadEnv(layout: string): Promise<ISLDocument> {\r\n    // todo: don't reload library every time\r\n    const includeResolver = async (name) => createTextDocument(name, await (await fetch(name)).text());\r\n    const libraryPath = `${LIB_PATH}/lib.hlsl`;\r\n    const libText = await createTextDocument(\"\", `#include \"${libraryPath}\"`);\r\n    const lib = await createFXSLDocument(libText, { includeResolver });\r\n\r\n    // extract and fill graph node documentation database\r\n    // todo: move to statics\r\n    docs(libText);\r\n\r\n    const partTex = await createTextDocument('://part-layout', layout);\r\n    return extendFXSLDocument(partTex, lib, null, { includeResolver })\r\n}\r\n\r\n\r\n//\r\n// \r\n//\r\n\r\ninterface IJSONPartFx {\r\n    layout: string;\r\n    graph: ReturnType<LGraph['serialize']>;\r\n    constants?: { name: string; type: string; value: string; } [];\r\n    capacity?: number;\r\n    source?: string;\r\n}\r\n\r\ninterface IJSONFx {\r\n    type: 'part';\r\n    content: IJSONPartFx;\r\n}\r\n\r\n\r\nexport function packGraphToJSON(state: IStoreState): string {\r\n    const { nodes: { graph, env, constants, capacity }, sourceFile } = state;\r\n    const type = env.root.scope.findType(PART_TYPE);\r\n    const layout = CodeEmitter.translate(type);\r\n    const source = sourceFile.content;\r\n\r\n    const content = <IJSONPartFx>{\r\n        layout,\r\n        graph: graph.serialize(),\r\n        constants,\r\n        capacity,\r\n        source\r\n    }\r\n\r\n    const fx: IJSONFx = { type: 'part', content };\r\n    return JSON.stringify(fx, null, '    ');\r\n}\r\n\r\n\r\nexport function unpackGraphFromJSON(data: string): IJSONPartFx {\r\n    let json: IJSONFx = null;\r\n    try {\r\n        json = JSON.parse(data);\r\n    } catch (e) {\r\n        console.error('could not parse XFX data');\r\n        json = (GraphTemplateJSON as any);\r\n    }\r\n    console.assert(json.type === 'part');\r\n    return json.content;\r\n}\r\n\r\nfunction produceNodes(env: () => ISLDocument, ...list: ((env: () => ISLDocument) => LGraphNodeFactory)[])\r\n{\r\n    let nodeList = <LGraphNodeFactory>{};\r\n    list.forEach(prod => { nodeList = { ...nodeList, ...prod(env) } });\r\n    return nodeList;\r\n}\r\n\r\n//\r\n// \r\n//\r\n\r\nconst graphLoadedLogic = createLogic<IStoreState, IGraphLoaded['payload'], IJSONPartFx>({\r\n    type: [evt.GRAPH_LOADED],\r\n    latest: true,\r\n    debounce: 500,\r\n\r\n    async transform({ getState, action }, next) {\r\n        const unpacked = unpackGraphFromJSON(action.payload.content);\r\n        action.payload.env = await loadEnv(unpacked.layout);\r\n        action.payload.constants = unpacked.constants || [];\r\n        action.payload.capacity = unpacked.capacity || 4096;\r\n        // pass unpacked json as meta so as not to double the unpacking\r\n        next({ ...action, meta: unpacked });\r\n    },\r\n\r\n    async process({ getState, action, action$ }, dispatch, done) {\r\n\r\n        // const uri = getState().sourceFile.uri;\r\n        const graph = getState().nodes.graph;\r\n        const { graph: content } = action.meta;\r\n        const { env, constants } = action.payload;\r\n\r\n        console.assert(isDefAndNotNull(env));\r\n\r\n        graph.clear();\r\n        // todo: unregister previous nodes\r\n\r\n        // reload graph infrastructure\r\n        // produce nodes\r\n        let nodeList = produceNodes(() => getEnv(getState()), \r\n            Operators,\r\n            Float,\r\n            Int,\r\n            IfStmt,\r\n            FuncNodes,\r\n            BasicType,\r\n            Kill,\r\n            KillBy,\r\n            Decomposer,\r\n            Uniforms,\r\n            StmtList,\r\n            Part,\r\n            PartId,\r\n            PartUpdate,\r\n            PartSpawn,\r\n            PartInit,\r\n            PartPrevious,\r\n            LwiMaterial,\r\n            DefaultMaterial,\r\n            Param\r\n        );\r\n\r\n        nodeList = { ...nodeList, ...UserConst(() => getEnv(getState()), constants) };\r\n\r\n        LiteGraph.clearRegisteredTypes();\r\n\r\n        // register all available nodes\r\n        Object.keys(nodeList).forEach(link =>\r\n            LiteGraph.registerNodeType(link, nodeList[link]));\r\n\r\n        // load serialized graph\r\n        // todo: validate that all serialized nodes are available\r\n        graph.configure(content);\r\n\r\n        dispatch(nodes.recompile());\r\n\r\n        const location = getState().router.location.pathname;\r\n        const match = matchPath<PATH_PARAMS_TYPE>(location, {\r\n            path: LOCATION_PATTERN,\r\n            exact: false\r\n        });\r\n\r\n        if (match) {\r\n            const { fx, view } = match.params;\r\n            history.push(`/${view}/${fx}/${GRAPH_KEYWORD}`);\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\ninterface Plug {\r\n    capacity: number;\r\n    initId: number;\r\n    passes: PassPlug[];\r\n}\r\n\r\ninterface PassPlug {\r\n    id: number;\r\n    sorting: boolean;\r\n    geometry: string;\r\n}\r\n\r\nfunction makeFxTemplate(env: ISLDocument, plug: Plug) {\r\n\r\n    let passes = plug.passes.map((plug, i) => \r\n`   pass P${i} {\r\n        Sorting = ${plug.sorting};\r\n        PrerenderRoutine = compile PrerenderRoutine${plug.id}();\r\n        Geometry = \"${plug.geometry.toLowerCase()}\";\r\n    }`).join(\"\\n\\n\");\r\n\r\n    return (\r\n`\r\npartFx G {\r\n    Capacity = ${plug.capacity};\r\n    SpawnRoutine = compile SpawnRoutine();\r\n    InitRoutine = compile InitRoutine${plug.initId}();\r\n    UpdateRoutine = compile UpdateRoutine();\r\n\r\n${passes}\r\n}\r\n\r\n`);\r\n}\r\n\r\nconst compileLogic = createLogic<IStoreState, IGraphCompile['payload']>({\r\n    type: [evt.GRAPH_COMPILE],\r\n    latest: true,\r\n    debounce: 500,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const state = getState();\r\n        const { nodes } = state;\r\n        const { graph, env, constants, capacity } = nodes;\r\n\r\n        // IP: hack to find all spawners/initializer by type\r\n        const InitInstance = LiteGraph.registered_node_types['fx/InitRoutine'];\r\n\r\n        let spawn = graph.findNodeByTitle(\"SpawnRoutine\") as CodeEmitterNode;\r\n        let update = graph.findNodeByTitle(\"UpdateRoutine\") as CodeEmitterNode;\r\n        let inits = graph.findNodesByClass(InitInstance) as ISpawner[];\r\n        let prerender: ICodeMaterialNode[] = [];\r\n        prerender = [ ...prerender, ...graph.findNodesByTitle(\"DefaultMaterial\") as ICodeMaterialNode[] ];\r\n        prerender = [ ...prerender, ...graph.findNodesByTitle(\"LwiMaterial\") as ICodeMaterialNode[] ];\r\n\r\n        let constDoc = null;\r\n        if (constants.length) {\r\n            constDoc = await createTextDocument('://user-constants', \r\n            constants.map(({ name, type, value }) => `static const ${type} ${name} = ${value};`).join('\\n') + '\\n\\n');\r\n        }\r\n\r\n        let doc = await extendFXSLDocument(constDoc, env);\r\n        doc = await spawn.run(doc);\r\n        for (let init of inits) {\r\n            doc = await init.run(doc);\r\n        }\r\n        doc = await update.run(doc);\r\n\r\n        let plugs: PassPlug[] = [];\r\n        for (let i in prerender) {\r\n            let { id, sorting, geometry } = prerender[i];\r\n            doc = await prerender[i].run(doc);\r\n            plugs.push({ id, sorting, geometry });\r\n        }\r\n\r\n        doc = await extendFXSLDocument(await createTextDocument(\"://fx-template\", \r\n        makeFxTemplate(env, { passes: plugs, initId: inits.find(init => init.pure).id, capacity })), doc);\r\n\r\n        let content = Diagnostics.stringify(doc.diagnosticReport);\r\n        console.log(content);\r\n\r\n        graph.list_of_graphcanvas.forEach(canvas => canvas.draw(true, true));\r\n\r\n        dispatch(sourceCode.setContent(FxEmitter.translateTechnique(doc, 'G')));\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nconst changeLayoutLogic = createLogic<IStoreState, IGraphChangeLayout['payload']>({\r\n    type: [evt.GRAPH_CHANGE_LAYOUT],\r\n\r\n    async validate({ getState, action }, allow, reject) {\r\n        let envNew: ISLDocument;\r\n        let typeNew: ITypeInstruction;\r\n\r\n        try {\r\n            envNew = await loadEnv(action.payload.layout);\r\n            typeNew = envNew.root.scope.findType(PART_TYPE);\r\n\r\n            if (!typeNew) {\r\n                reject({ type: 'graph-change-layout-error' });\r\n                return;\r\n            }\r\n        } catch (e) { \r\n            reject({ type: 'graph-change-layout-error' });\r\n            return;\r\n        }\r\n\r\n        const { env, graph } = getState().nodes;\r\n        const type = env.root.scope.findType(PART_TYPE);\r\n\r\n        //\r\n        // Aux\r\n        //\r\n\r\n        function nodeRebuilder(type: string): (() => void)[] {\r\n            return graph.findNodesByType(type).map(node => {\r\n                let [ x, y ] = node.pos;\r\n                graph.remove(node);\r\n                return () => {\r\n                    node = LiteGraph.createNode(type);\r\n                    graph.add(node);\r\n                    node.pos = [ x, y ];\r\n                }\r\n            })\r\n        };\r\n\r\n        function remove(type: string) {\r\n            let cbs = nodeRebuilder(type);\r\n            return () => cbs.forEach(cb => cb());\r\n        }\r\n\r\n        const restore = (cb: () => void) => cb();\r\n\r\n        //\r\n\r\n        // todo: skip if no changes\r\n        // if (type.fields.length == typeNew.fields.length) {\r\n        //     // no changes, nothing todo.\r\n        //     console.warn('no layout changes found');\r\n        //     allow({ ...action, payload: { env } });\r\n        //     return;\r\n        // }\r\n\r\n        // same name but diff type\r\n        const toRecreateField = type.fields\r\n            .filter(p => typeNew.fields.find(n => n.name == p.name &&\r\n                !types.compare(n.type, p.type)))\r\n            .map(v => v.name);\r\n\r\n        // name no more exists\r\n        const toRemoveField = type.fields\r\n            .filter(p => !typeNew.fields.find(n => n.name == p.name))\r\n            .map(v => v.name);\r\n\r\n        // same name and type but diff input index\r\n        const toReconnectField = type.fields\r\n            .filter((p, pi) => typeNew.fields.find((n, ni) => pi != ni &&\r\n                n.name == p.name && types.compare(n.type, p.type)))\r\n            .map(v => v.name);\r\n            \r\n        // toCreate?\r\n\r\n        console.log('remove:', toRemoveField);\r\n        console.log('recreate:', toRecreateField);\r\n        console.log('reconnect:', toReconnectField);\r\n\r\n        //\r\n        // Remove all no more existring nodes\r\n        //\r\n\r\n        toRemoveField.forEach(fieldName => {\r\n            // sync with PartPrev.ts\r\n            const name = `${PART_LOCAL_NAME}.${fieldName}`;\r\n            let nodes = graph.findNodesByType(`fx/${name}`);\r\n            nodes.forEach(node => graph.remove(node));\r\n            nodes = graph.findNodesByType(`fx/out ${name}`);\r\n            nodes.forEach(node => graph.remove(node));\r\n        });\r\n\r\n        //\r\n        // Remove nodes with changed types and remember list of recreation routines\r\n        //\r\n        \r\n        // sync with PartPrev.ts, PartInit.ts etc.\r\n        let partRemoved = remove(`fx/${PART_LOCAL_NAME}`);\r\n        let fieldsRemoved = toRecreateField.map(f => remove(`fx/${PART_LOCAL_NAME}.${f}`));\r\n        let partRemovedOut = remove(`fx/out ${PART_LOCAL_NAME}`);\r\n        let fieldsRemovedOut = toRecreateField.map(f => remove(`fx/out ${PART_LOCAL_NAME}.${f}`));\r\n\r\n        //\r\n        // Unlink prev types\r\n        //\r\n\r\n        let nodeList = produceNodes(\r\n            () => env, \r\n            PartPrevious,   // part in\r\n            Part            // part out\r\n            );\r\n\r\n        Object.keys(nodeList).forEach(type => LiteGraph.unregisterNodeType(type));\r\n\r\n        //\r\n        // Link new types\r\n        //\r\n\r\n        nodeList = produceNodes(\r\n            () => envNew, \r\n            PartPrevious,   // part in\r\n            Part            // part out\r\n            );\r\n\r\n        Object.keys(nodeList).forEach(type => LiteGraph.registerNodeType(type, nodeList[type]));\r\n\r\n        //\r\n        // Process recreation routines\r\n        //\r\n\r\n        // todo: restore connections!\r\n        restore(partRemoved);\r\n        fieldsRemoved.forEach(field => restore(field));\r\n        restore(partRemovedOut);\r\n        fieldsRemovedOut.forEach(field => restore(field));\r\n\r\n        allow({ ...action, payload: { env: envNew } });\r\n    },\r\n});\r\n\r\nconst addConstantlogic = createLogic<IStoreState, IGraphAddConstant['payload']>({\r\n    type: [evt.GRAPH_ADD_CONSTANT],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const { env, graph, constants } = getState().nodes;\r\n\r\n        const nodeList = UserConst(() => getEnv(getState()), [ action.payload.value ]);\r\n        Object.keys(nodeList).forEach(link =>\r\n            LiteGraph.registerNodeType(link, nodeList[link]));\r\n\r\n        done();\r\n    }\r\n});\r\n\r\nconst removeConstantlogic = createLogic<IStoreState, IGraphRemoveConstant['payload']>({\r\n    type: [evt.GRAPH_REMOVE_CONSTANT],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const { env, graph, constants } = getState().nodes;\r\n\r\n        const nodeType = `user constants/${action.payload.name}`;\r\n        graph.findNodesByType(nodeType).forEach(node => graph.remove(node));\r\n        LiteGraph.unregisterNodeType(nodeType);\r\n\r\n        done();\r\n    }\r\n});\r\n\r\nconst updateParamsLogic = createLogic<IStoreState, IGraphSetConstant['payload']>({\r\n    type: [evt.GRAPH_SET_CONSTANT, evt.GRAPH_SET_CAPACITY],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        dispatch(nodes.recompile());\r\n        done();\r\n    }\r\n});\r\n\r\nconst resetLogic = createLogic<IStoreState>({\r\n    type: [evt.GRAPH_RESET],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        // const parserParams = getState().parserParams;\r\n        console.log('graph reset!');\r\n        done();\r\n    }\r\n});\r\nexport default [\r\n    resetLogic,\r\n    compileLogic,\r\n    graphLoadedLogic,\r\n    changeLayoutLogic,\r\n    addConstantlogic,\r\n    removeConstantlogic,\r\n    updateParamsLogic\r\n];\r\n","/* tslint:disable:typedef */\r\n\r\nimport { isDef, isDefAndNotNull, isNull, verbose } from '@lib/common';\r\nimport * as Bytecode from '@lib/fx/bytecode';\r\nimport { cdlview } from '@lib/fx/bytecode/DebugLayout';\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\nimport { createFXSLDocument } from '@lib/fx/FXSLDocument';\r\nimport { createSLASTDocument } from '@lib/fx/SLASTDocument';\r\nimport { createDefaultSLParser } from '@lib/fx/SLParser';\r\nimport { createTextDocument } from '@lib/fx/TextDocument';\r\nimport { createPPDocument } from '@lib/parser/Preprocessor';\r\nimport { IDispatch } from '@sandbox/actions';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IDebuggerCompile, IDebuggerOptionsChanged, IMarkerDesc } from '@sandbox/actions/ActionTypes';\r\nimport { getDebugger, getFileState } from '@sandbox/reducers/sourceFile';\r\nimport IStoreState, { IDebuggerState, IFileState, IMarker } from '@sandbox/store/IStoreState';\r\nimport { LocationChangeAction, LOCATION_CHANGE } from 'connected-react-router';\r\nimport { matchPath } from 'react-router-dom';\r\nimport { toast } from 'react-semantic-toasts';\r\nimport 'react-semantic-toasts/styles/react-semantic-alert.css';\r\nimport { createLogic } from 'redux-logic';\r\nimport { LOCAL_SESSION_ID, LOCATION_PATTERN, PATH_PARAMS_TYPE, RAW_KEYWORD } from './common';\r\nimport * as Depot from '@sandbox/reducers/depot';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\nimport { IFunctionDeclInstruction } from '@lib/idl/IInstruction';\r\nimport { IBCDocument } from '@lib/fx/bytecode/Bytecode';\r\n\r\n// IP: proposal for future switching to async parsing\r\n\r\n// import * as Comlink from 'comlink';\r\n// import { ParsingeWorker } from './parsing/ParsingWorker'\r\n// import { IParsingProvider } from './parsing/ParsingProvider';\r\n// const provider = Comlink.wrap<IParsingProvider>(new ParsingeWorker());\r\n// provider.createDefaultSLParser();\r\n\r\nconst DEBUGGER_COLORIZATION_PREFIX = 'debug-ln-clr';\r\n\r\ndeclare const PRODUCTION: boolean;\r\n\r\nfunction cleanupMarkersBatch(state: IStoreState, prefix: string): string[] {\r\n    return Object\r\n        .keys(state.sourceFile.markers)\r\n        .filter(name => name.startsWith(`${prefix}-`));\r\n}\r\n\r\nfunction cleanupMarkers(dispatch: IDispatch, batch: string[]) {\r\n    if (batch.length > 0) {\r\n        dispatch({ type: evt.SOURCE_CODE_REMOVE_MARKER_BATCH, payload: { batch } });\r\n    }\r\n}\r\n\r\ntype IMarkerType = IMarker['type'];\r\n\r\nfunction emitMarkersBatch(list, type: IMarkerType, prefix: string): IMarkerDesc[] {\r\n    return list.map((desc, i) => {\r\n        const { loc, message, payload } = desc;\r\n        return {\r\n            name: `${prefix}-${message}-${i}`,\r\n            range: loc,\r\n            type,\r\n            tooltip: message,\r\n            payload\r\n        };\r\n    });\r\n}\r\n\r\nfunction emitMarkers(dispatch: IDispatch, batch: IMarkerDesc[]) {\r\n    dispatch({ type: evt.SOURCE_CODE_ADD_MARKER_BATCH, payload: { batch } });\r\n}\r\n\r\n\r\nconst emitDebuggerColorization = (list) => emitMarkersBatch(list, 'line', DEBUGGER_COLORIZATION_PREFIX);\r\nconst cleanupDebuggerColorization = (state) => cleanupMarkersBatch(state, DEBUGGER_COLORIZATION_PREFIX);\r\n\r\n\r\nasync function processParsing(state: IStoreState, dispatch): Promise<void> {\r\n    const { depot, parserParams: { parsingFlags: flags }, sourceFile: { content: source, uri, defines } } = state;\r\n\r\n    // if (matchLocation(state).params.view !== PLAYGROUND_VIEW) {\r\n    //     return;\r\n    // }\r\n\r\n    if (!source) {\r\n        return;\r\n    }\r\n    \r\n    const includeResolver = Depot.makeResolver(depot);\r\n    const textDocument = await createTextDocument(uri, source);\r\n    const slastDocument = await createSLASTDocument(textDocument, { flags, includeResolver, defines: defines.map(def => ({ name: def })) });\r\n\r\n    const unreachableCode = slastDocument.unreachableCode.filter(loc => String(loc.start.file) === String(slastDocument.uri));\r\n\r\n    // TODO: move it to language service\r\n    cleanupMarkers(<IDispatch>dispatch, cleanupMarkersBatch(state, 'unreachable-code'));\r\n    emitMarkers(<IDispatch>dispatch, emitMarkersBatch(unreachableCode.map(loc => ({ loc, payload: {} })), 'unreachable-code', 'unreachable-code'));\r\n\r\n    if (!PRODUCTION) {\r\n        // verbose(Diagnostics.stringify(diag));\r\n    }\r\n\r\n    if (slastDocument.diagnosticReport.errors > 0) {\r\n        toast({\r\n            type: 'error',\r\n            title: `Parsing failed.`,\r\n            animation: 'scale',\r\n            size: 'tiny',\r\n            time: 2000\r\n        });\r\n    }\r\n\r\n    // if (!diag.errors)\r\n    {\r\n        dispatch({ type: evt.SOURCE_CODE_PARSING_COMPLETE, payload: { slastDocument } });\r\n    }\r\n}\r\n\r\n\r\nasync function processAnalyze(state: IStoreState, dispatch: IDispatch): Promise<void> {\r\n    const { slastDocument } = state.sourceFile;\r\n\r\n    if (!slastDocument) {\r\n        return;\r\n    }\r\n\r\n    const slDocument = await createFXSLDocument(slastDocument);\r\n\r\n    if (!PRODUCTION) {\r\n        // verbose(Diagnostics.stringify(diag));\r\n    }\r\n\r\n    if (slDocument.diagnosticReport.errors > 0) {\r\n        toast({\r\n            type: 'error',\r\n            title: `Analysis failed.`,\r\n            animation: 'scale',\r\n            size: 'tiny',\r\n            time: 2000\r\n        });\r\n    }\r\n\r\n    if (slDocument.diagnosticReport.warnings > 0) {\r\n        // pass only deprecations as editor's decorators to use custom styling\r\n        // note: by default warnings and errors are provided by LanguageServiceProvider validation\r\n        emitMarkers(<IDispatch>dispatch, \r\n            emitMarkersBatch(slDocument.diagnosticReport.messages\r\n             .filter(msg => msg.code === `A3008`) // EAnalyzerWarnings.Deprecated\r\n            .map(({ start, end, content }) => ({ loc: { start, end }, message: '@deprecated', payload: {} })), \r\n            'deprecated', 'deprecated'));\r\n    }\r\n\r\n    // if (!diag.errors)\r\n    {\r\n        dispatch({ type: evt.SOURCE_CODE_ANALYSIS_COMPLETE, payload: { result: slDocument } });\r\n    }\r\n}\r\n\r\n\r\nconst updateParserLogic = createLogic<IStoreState>({\r\n    type: [evt.GRAMMAR_CONTENT_SPECIFIED, evt.PARSER_PARAMS_CHANGED],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const parserParams = getState().parserParams;\r\n        const { grammar, type, flags } = parserParams;\r\n        /**\r\n         * !!! note: all inline functionality inside analyze.ts depends on this setup\r\n         */\r\n        console.log('%c Creating parser...', 'background: #222; color: #bada55');\r\n        try {\r\n            createDefaultSLParser({ grammar, type, flags });\r\n            console.log('%c [ DONE ]', 'background: #222; color: #bada55');\r\n        } catch (e) {\r\n            console.error('could not initialize parser.');\r\n            return null;\r\n        }\r\n\r\n        // todo: add support for failed setup\r\n        done();\r\n    }\r\n});\r\n\r\nconst dropSourceFileLogic = createLogic<IStoreState>({\r\n    type: evt.SOURCE_FILE_DROP_STATE,\r\n    async process({ getState, action }) {\r\n        localStorage.removeItem(LOCAL_SESSION_ID);\r\n    }\r\n});\r\n\r\nconst updateSourceContentLogic = createLogic<IStoreState>({\r\n    type: [evt.SOURCE_CODE_MODIFED, evt.SOURCE_FILE_LOADED],\r\n    latest: true,\r\n    debounce: 500,\r\n\r\n    async process({ getState, action, action$ }, dispatch, done) {\r\n        const $debugger = getDebugger(getState());\r\n        if (!$debugger.options.autocompile) {\r\n            dispatch({ type: evt.DEBUGGER_RESET });\r\n        }\r\n        await processParsing(getState(), dispatch);\r\n\r\n        // TODO: move to separate routine\r\n\r\n        const location = getState().router.location.pathname;\r\n        const match = matchPath<PATH_PARAMS_TYPE>(location, {\r\n            path: LOCATION_PATTERN,\r\n            exact: false\r\n        });\r\n\r\n        if (match) {\r\n            const { view, fx, name } = match.params;\r\n            if (fx && name === RAW_KEYWORD) {\r\n                await processRaw(getState(), dispatch);\r\n            }\r\n\r\n            // Is new file loaded?\r\n            if (action.type === evt.SOURCE_FILE_LOADED) {\r\n                if (localStorage.getItem(LOCAL_SESSION_ID) !== fx) {\r\n                    localStorage.setItem(LOCAL_SESSION_ID, fx);\r\n                    verbose(`Last sesstion data has been updated. (${localStorage.getItem(LOCAL_SESSION_ID)})`);\r\n\r\n                    toast({\r\n                        type: 'info',\r\n                        title: 'Session update.',\r\n                        description: `Last sesstion data has been updated.`,\r\n                        animation: 'fade up',\r\n                        size: 'tiny',\r\n                        time: 2000\r\n                    });\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n\r\nconst parsingCompleteLogic = createLogic<IStoreState>({\r\n    type: [evt.SOURCE_CODE_PARSING_COMPLETE],\r\n    async process({ getState, action, action$ }, dispatch, done) {\r\n        await processAnalyze(getState(), <any>dispatch);\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nfunction buildDebuggerSourceColorization(debuggerState: IDebuggerState, fileState: IFileState) {\r\n    // const fn = fileState.slDocument.root.scope.findFunction(debuggerState.query, null);\r\n    const locList = [];\r\n\r\n    if (debuggerState.bcDocument?.program) {\r\n        // const from = fn.sourceNode.loc.start.line;\r\n        // const to = fn.sourceNode.loc.end.line;\r\n\r\n        const from = 0;\r\n        const to = fileState.content.split('\\n').length;\r\n\r\n        const cdl = cdlview(debuggerState.bcDocument.program.cdl);\r\n\r\n        for (let ln = from; ln <= to; ++ln) {\r\n            const color = cdl.resolveLineColor(ln, fileState.uri);\r\n            if (color !== -1) {\r\n                const loc = { start: { file: null, line: ln, column: 0 }, end: null };\r\n                locList.push({ loc, payload: { color } });\r\n            }\r\n        }\r\n    }\r\n    return locList;\r\n}\r\n\r\n\r\nconst debuggerCompileLogic = createLogic<IStoreState, IDebuggerCompile['payload']>({\r\n    type: evt.DEBUGGER_COMPILE,\r\n    cancelType: evt.DEBUGGER_RESET,\r\n    latest: true,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const file = getFileState(getState());\r\n        const debuggerState = getDebugger(getState());\r\n        const type = action?.payload?.type || 'expression';\r\n\r\n        let query = action?.payload?.query || debuggerState.query;\r\n\r\n        if (!isNull(file.slDocument)) {\r\n            const scope = file.slDocument.root.scope;\r\n\r\n            let func: IFunctionDeclInstruction = null;\r\n            if (type === 'expression') {\r\n                query ||= `${Bytecode.DEFAULT_ENTRY_POINT_NAME}()`;\r\n                func = scope.findFunction(query, null);\r\n            }\r\n\r\n            if (type === 'pass') {\r\n                if (!query) {\r\n                    const tech = Object.values(scope.techniques11).find(tech => tech.passes.length > 0);\r\n                    const pass = tech?.passes[0];\r\n                    query = `${tech?.name}::${pass?.name}`\r\n                }\r\n\r\n                const [ , techName, passName, ] = query.match(/([\\w\\.]+)::([\\w]+)/);\r\n                func = scope.findTechnique11(techName).passes.find(p => p.name === passName);\r\n            }\r\n\r\n            // workaround for debug purposes (interpretations of the expressions string as function name)\r\n            let bcDocument: IBCDocument = null;\r\n            if (func) {\r\n                bcDocument = Bytecode.translate(func);\r\n            } else {\r\n                bcDocument = await Bytecode.translateExpression(query, file.slDocument);\r\n            }\r\n\r\n            if (bcDocument.diagnosticReport.errors > 0) {\r\n                console.error(Diagnostics.stringify(bcDocument.diagnosticReport));\r\n                alert(`could not evaluate query '${query}', see console log for details`);\r\n            } \r\n            \r\n            dispatch({ type: evt.DEBUGGER_START_DEBUG, payload: { query, bcDocument } });\r\n        } else {\r\n            console.error('invalid compile request!');\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n\r\nasync function processRaw(state: IStoreState, dispatch): Promise<void> {\r\n    const file = getFileState(state);\r\n    const includeResolver = Depot.makeResolver(state.depot);\r\n    const defines = file.defines.map(name => ({ name }));\r\n    const document = await createPPDocument(await createTextDocument(file.uri, file.content), { includeResolver, defines });\r\n\r\n    dispatch({ type: evt.SOURCE_CODE_PREPROCESSING_COMPLETE, payload: { document } });\r\n}\r\n\r\n\r\nconst navigationLogicHook = createLogic<IStoreState, LocationChangeAction['payload']>({\r\n    type: LOCATION_CHANGE,\r\n    latest: true,\r\n    debounce: 10,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const location = action.payload.location.pathname;\r\n        const sourceFile = getFileState(getState());\r\n\r\n        const match = matchPath<PATH_PARAMS_TYPE>(location, {\r\n            path: LOCATION_PATTERN,\r\n            exact: false\r\n        });\r\n\r\n        if (match) {\r\n            const { view, fx, name } = match.params;\r\n            if (fx && name === RAW_KEYWORD) {\r\n                await processRaw(getState(), dispatch);\r\n            }\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n// const markersAddLogic = createLogic<IStoreState>({\r\n//     type: evt.SOURCE_CODE_ADD_MARKER_BATCH,\r\n//     debounce: 10000,\r\n//     process: ({ getState, action }, dispatch, done) => done()\r\n// });\r\n\r\n// const markersDelLogic = createLogic<IStoreState>({\r\n//     type: evt.SOURCE_CODE_REMOVE_MARKER_BATCH,\r\n//     debounce: 500,\r\n//     process: ({ getState, action }, dispatch, done) => done()\r\n// });\r\n\r\nconst debuggerResetLogic = createLogic<IStoreState>({\r\n    type: evt.DEBUGGER_RESET,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const $debugger = getDebugger(getState());\r\n        if ($debugger.options.colorize) {\r\n            cleanupMarkers(<IDispatch>dispatch, cleanupDebuggerColorization(getState()));\r\n        }\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nconst debuggerOptionsChangedLogic = createLogic<IStoreState, IDebuggerOptionsChanged['payload']>({\r\n    type: evt.DEBUGGER_OPTIONS_CHANGED,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const { autocompile, colorize, wasm } = action.payload.options;\r\n        if (isDef(autocompile) && autocompile === true) {\r\n            dispatch({ type: evt.DEBUGGER_COMPILE });\r\n        }\r\n        if (isDef(colorize) && colorize === false) {\r\n            cleanupMarkers(<IDispatch>dispatch, cleanupDebuggerColorization(getState()));\r\n        } else {\r\n            const markers = buildDebuggerSourceColorization(getDebugger(getState()), getFileState(getState()));\r\n            emitMarkers(<IDispatch>dispatch, emitDebuggerColorization(markers));\r\n        }\r\n        if (isDef(wasm) && wasm != VM.isWASM()) {\r\n            dispatch({ type: evt.PLAYGROUND_SWITCH_VM_RUNTIME });\r\n        }\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nconst debuggerStartLogic = createLogic<IStoreState>({\r\n    type: evt.DEBUGGER_START_DEBUG,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const fileState = getFileState(getState());\r\n        const debuggerState = getDebugger(getState());\r\n\r\n        if (debuggerState.options.colorize) {\r\n            const markers = buildDebuggerSourceColorization(debuggerState, fileState);\r\n            emitMarkers(<IDispatch>dispatch, emitDebuggerColorization(markers));\r\n        }\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nconst debuggerAutocompileLogic = createLogic<IStoreState>({\r\n    type: evt.SOURCE_CODE_ANALYSIS_COMPLETE,\r\n\r\n    process({ getState }, dispatch, done) {\r\n        const debuggerState = getDebugger(getState());\r\n\r\n        if (debuggerState.options.autocompile) {\r\n            dispatch({ type: evt.DEBUGGER_COMPILE });\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n\r\nconst defineLogic = createLogic<IStoreState>({\r\n    type: [evt.SOURCE_CODE_SET_DEFINE, evt.SOURCE_CODE_REMOVE_DEFINE],\r\n\r\n    process({ getState }, dispatch, done) {\r\n        const state = getState();\r\n        const { content } = getFileState(state);\r\n        // cleanupMarkers(<IDispatch>dispatch, cleanupMarkersBatch(state, 'line'));\r\n        dispatch({ type: evt.SOURCE_CODE_MODIFED, payload: { content } });\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n\r\nexport default [\r\n    dropSourceFileLogic,\r\n    updateParserLogic,\r\n    updateSourceContentLogic,\r\n    parsingCompleteLogic,\r\n    debuggerCompileLogic,\r\n    debuggerResetLogic,\r\n    debuggerOptionsChangedLogic,\r\n    debuggerStartLogic,\r\n    debuggerAutocompileLogic,\r\n    // markersAddLogic,\r\n    // markersDelLogic\r\n    navigationLogicHook,\r\n    defineLogic\r\n];","import * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { createLogic } from 'redux-logic';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport { IS3DInitEnv } from '@sandbox/actions/ActionTypes';\r\nimport { isString } from '@lib/common';\r\nimport * as S3D from '@lib/util/s3d/prjenv';\r\nimport * as p4 from \"@lib/util/p4/p4\"\r\n\r\n\r\nconst initEnvLogic = createLogic<IStoreState, IS3DInitEnv['payload']>({\r\n    type: evt.S3D_INIT_ENV,\r\n\r\n    process({ getState, action }, dispatch, done) {\r\n        const projectRoot = action.payload.projectRoot;\r\n\r\n        if (isString(projectRoot)) {\r\n            const prjenv = new S3D.ProjectEnv(projectRoot);\r\n\r\n            // console.log(prjenv.Get('game-name'));\r\n            // console.log(prjenv.Get('project-prebuild-dir'));\r\n            // console.log(prjenv.Get('pic-dir'));\r\n            // console.log(prjenv.Get('common-prebuild-dir'));\r\n            // console.log(prjenv.Get('common-assets-dir'));\r\n            // console.log(prjenv.Get('project-assets-dir'));\r\n\r\n            // todo: use more strict check\r\n            if (prjenv.Get('game-name')) {\r\n                dispatch({ type: evt.S3D_INIT_ENV_SUCCESSED, payload: { env: prjenv } });\r\n                dispatch({ type: evt.S3D_CONNECT_P4, payload: {} });\r\n                return done();\r\n            }\r\n        }\r\n\r\n        dispatch({ type: evt.S3D_INIT_ENV_FAILED, payload: {} })\r\n        return done();\r\n    }\r\n});\r\n\r\n\r\nconst connectP4Logic = createLogic<IStoreState>({\r\n    type: evt.S3D_CONNECT_P4,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const connect = getState().s3d.env.Get('perforce-settings');\r\n        try {\r\n            await p4.run(`set P4PORT=${connect['server']}`)\r\n            await p4.run(`set P4USER=${connect['login']}`);\r\n            await p4.run(`set P4CLIENT=${connect['workspace']}`);\r\n\r\n            const stdout = await p4.run('info');\r\n\r\n            let info = {};\r\n\r\n            stdout.split('\\n').forEach((note: string) => {\r\n                let v = note.split(':');\r\n                let field = v[0];\r\n                let value = v[1];\r\n\r\n                info[field] = value;\r\n            });\r\n\r\n            dispatch({ type: evt.S3D_CONNECT_P4_SUCCESSED, payload: { info } });\r\n            done();\r\n\r\n        } finally {\r\n            done();\r\n        }\r\n    }\r\n});\r\n\r\n\r\nexport default [\r\n    initEnvLogic,\r\n    connectP4Logic\r\n];\r\n","import Preview from '@sandbox/containers/Preview';\r\nimport * as ipc from '@sandbox/ipc';\r\nimport * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\n\r\nrequire('semantic-ui-less/semantic.less');\r\n\r\nconst { file } = ipc.sync.argv();\r\n\r\nReactDOM.render(\r\n    <Preview name={ file } />,\r\n    document.getElementById('app')\r\n);\r\n\r\n","import { IDepotActions, IDepotUpdateComplete } from '@sandbox/actions/ActionTypes';\r\nimport { handleActions } from '@sandbox/reducers/handleActions';\r\nimport IStoreState, { IDepot, IDepotFolder } from '@sandbox/store/IStoreState';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport path from 'path';\r\nimport { IncludeResolver } from '@lib/idl/parser/IParser';\r\nimport * as ipc from '@sandbox/ipc';\r\nimport * as fs from 'fs';\r\nimport * as URI from '@lib/uri/uri';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { createTextDocument } from '@lib/fx/TextDocument';\r\n\r\nconst initialState: IDepot = {\r\n    root: null,\r\n};\r\n\r\nexport default handleActions<IDepot, IDepotActions>({\r\n    [evt.DEPOT_UPDATE_COMPLETE]: (state, action: IDepotUpdateComplete) => ({ ...state, root: { ...state.root, ...action.payload.root } }),\r\n}, initialState);\r\n\r\n\r\nconst debug = (message: string) => {};//console.log(message);\r\n\r\nexport async function resolveName(depot: IDepot, name: string): Promise<string>\r\n{\r\n    debug(`Request to resolve filename \"${name}\".`);\r\n    \r\n    name = decodeURIComponent(name);\r\n    const uri = URI.parse(name);\r\n\r\n    // early exit for web version\r\n    if (uri.protocol === 'file') {\r\n        console.assert(ipc.isElectron());\r\n\r\n        if (fs.existsSync(URI.toLocalPath(uri))) {\r\n           debug(`Direct include has been resolved \"${name}\".`);\r\n           return name;\r\n        }\r\n    }\r\n\r\n\r\n    //\r\n    // Attempt to find any folder including basename of target name\r\n    //\r\n\r\n    const reduceFolder = (node: IDepotFolder, name: string): string => {\r\n        let file = node?.files?.find(file => path.normalize(file).indexOf(path.normalize(name)) != -1);\r\n        if (!file)\r\n            if (node.folders)\r\n                for (let folder of node.folders)\r\n                {\r\n                    file = reduceFolder(folder, name);\r\n                    if (file) break;\r\n                }\r\n        return file;\r\n    };\r\n\r\n    name = reduceFolder(depot.root, path.basename(URI.toLocalPath(uri)));\r\n    if (name) {\r\n        debug(`Indirect include has been resolved \"${name}\".`);\r\n        return name;\r\n    }\r\n\r\n    debug(`Filename has not been resolved \"${arguments[1]}\".`);\r\n    return null;\r\n}\r\n\r\n\r\n// import { store } from '@sandbox/store';\r\nexport function makeResolver(depot: IDepot): IncludeResolver {\r\n    return async (name: string): Promise<ITextDocument> => {\r\n        if (typeof name !== 'string') debugger;\r\n\r\n        const fullname = await resolveName(depot, name);\r\n        const uri = URI.parse(fullname);\r\n        \r\n        if (!fullname) {\r\n            return null;\r\n        }\r\n\r\n        switch (uri.protocol)\r\n        {\r\n            case 'file':\r\n                console.assert(ipc.isElectron());\r\n                // todo: move readFile to ipc\r\n                return createTextDocument(String(uri), (await fs.promises.readFile(URI.toLocalPath(uri))).toString());\r\n            default:\r\n                try {\r\n                    return createTextDocument(fullname, await (await fetch(fullname)).text());\r\n                } catch (e) {\r\n                    console.error(`Can't resolve file \"${name}\"`);\r\n                    return null;\r\n                }\r\n        }\r\n    };\r\n}\r\n\r\n\r\nexport const getDepot = (store: IStoreState): IDepot => store.depot;\r\n","import { IBaseAction } from \"@sandbox/actions/ActionTypes\";\r\n\r\nexport function handleActions<StateType extends {}, ActionType extends IBaseAction<string>>(map: { [actionType: string]: (state: StateType, action: ActionType) => StateType; }, initialState: StateType) {\r\n    return (state: StateType, action: ActionType) => {\r\n        state = state ? state : initialState;\r\n        \r\n        if (map.hasOwnProperty(action.type)) {\r\n            return map[action.type](state, action);\r\n        }\r\n\r\n        return state;\r\n    }\r\n}","import { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IGraphActions, IGraphAddConstant, IGraphChangeLayout, IGraphCompile, IGraphLoaded, IGraphNodeDocsProvided, IGraphRemoveConstant, IGraphSetCapacity, IGraphSetConstant, ISourceFileActions, ISourceFileDropState } from '@sandbox/actions/ActionTypes';\r\nimport { handleActions } from '@sandbox/reducers/handleActions';\r\nimport IStoreState, { INodePipeline } from '@sandbox/store/IStoreState';\r\nimport { LGraph } from 'litegraph.js';\r\n\r\nconst initialState: INodePipeline = {\r\n    docs: null,\r\n    graph: new LGraph,\r\n    revision: 0,\r\n    env: null,\r\n    constants: [],\r\n    capacity: 4096\r\n};\r\n\r\n\r\nexport default handleActions<INodePipeline, IGraphActions | ISourceFileActions>({\r\n    // hack to reset graph along with source file\r\n    [evt.SOURCE_FILE_DROP_STATE]: (state, action: ISourceFileDropState) =>\r\n    ({\r\n        ...state,\r\n        revision: 0\r\n    }),\r\n\r\n    [evt.GRAPH_MODIFIED]: (state, action: IGraphCompile) =>\r\n        ({ ...state, revision: state.revision + 1 }),\r\n    \r\n    [evt.GRAPH_LOADED]: (state, { payload }: IGraphLoaded) =>\r\n        ({ ...state, env: payload.env, constants: payload.constants, capacity: payload.capacity }),\r\n\r\n    [evt.GRAPH_NODE_DOCS_PROVIDED]: (state, { payload }: IGraphNodeDocsProvided) =>\r\n        ({ ...state, docs: payload.docs }),\r\n    \r\n    [evt.GRAPH_CHANGE_LAYOUT]: (state, { payload }: IGraphChangeLayout) =>\r\n    ({ ...state, env: payload.env }),\r\n\r\n    [evt.GRAPH_ADD_CONSTANT]: (state, { payload }: IGraphAddConstant) =>\r\n        ({ ...state, constants: [ ...state.constants, payload.value ], revision: state.revision + 1 }),\r\n\r\n    [evt.GRAPH_SET_CONSTANT]: (state, { payload }: IGraphSetConstant) =>\r\n        ({ ...state, constants: \r\n            state.constants.map(c => c.name === payload.name ? ({ ...c, value: payload.value }) : c) \r\n        , revision: state.revision + 1 }),\r\n\r\n    [evt.GRAPH_REMOVE_CONSTANT]: (state, { payload }: IGraphRemoveConstant) =>\r\n        ({ ...state, constants: state.constants.filter(desc => desc.name != payload.name), revision: state.revision + 1 }),\r\n    \r\n    [evt.GRAPH_SET_CAPACITY]: (state, { payload }: IGraphSetCapacity) =>\r\n        ({ ...state, capacity: payload.value, revision: state.revision + 1 }),\r\n\r\n}, initialState);\r\n\r\nexport const getEnv = (state: IStoreState): ISLDocument => state.nodes.env;\r\n","import { EParserFlags, EParserType, IASTDocumentFlags } from '@lib/idl/parser/IParser';\r\nimport { GRAMMAR_CONTENT_SPECIFIED, PARSER_PARAMS_CHANGED, PARSING_PARAMS_CHANGED } from '@sandbox/actions/ActionTypeKeys';\r\nimport { IGrammarContentSpecified, IParserParamsActions, IParserParamsChanged, IParsingParamsChanged } from '@sandbox/actions/ActionTypes';\r\nimport { IParserState, IStoreState } from '@sandbox/store/IStoreState';\r\n\r\nimport { handleActions } from './handleActions';\r\n\r\ndeclare const MODE: string;\r\n\r\nconst initialState: IParserState = {\r\n    filename: null,\r\n    grammar: null,\r\n    type: EParserType.k_LALR,\r\n    flags: EParserFlags.k_Default,\r\n    // TODO: rename option (or move it out of this scope)\r\n    parsingFlags: IASTDocumentFlags.k_Optimize\r\n};\r\n\r\nif (MODE === 'development') {\r\n    initialState.flags |= EParserFlags.k_Debug;\r\n    initialState.parsingFlags |= IASTDocumentFlags.k_DeveloperMode;\r\n}\r\n\r\n\r\nexport default handleActions<IParserState, IParserParamsActions>({\r\n    [ GRAMMAR_CONTENT_SPECIFIED ]: (state, action: IGrammarContentSpecified) => \r\n        ({ ...state, grammar: action.payload.content }),\r\n\r\n    [ PARSER_PARAMS_CHANGED ]: (state, action: IParserParamsChanged) => {\r\n        const { flags, type } = action.payload;\r\n        return { ...state, flags, type };\r\n    },\r\n\r\n    [ PARSING_PARAMS_CHANGED ]: (state, action: IParsingParamsChanged) => {\r\n        const { flags } = action.payload;\r\n        return { ...state, parsingFlags: flags };\r\n    }\r\n}, initialState);\r\n\r\n\r\n//- Selectors\r\n\r\nexport const getParser = (state: IStoreState): IParserState => state.parserParams;\r\n","import * as Techniques from '@lib/fx/techniques';\r\nimport * as Timeline from '@lib/fx/timeline';\r\nimport { IScope, ITechnique11Instruction, ITechniqueInstruction } from \"@lib/idl/IInstruction\";\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IPlaygroundActions, IPlaygroundEffectHasBeenDropped, IPlaygroundEffectHasBeenSaved, IPlaygroundSetOptionAutosave, IPlaygroundSetShaderFormat, IPlaygroundSwitchTechniqueRuntime, IPlaygroundTechniqueUpdate } from \"@sandbox/actions/ActionTypes\";\r\nimport { handleActions } from '@sandbox/reducers/handleActions';\r\nimport IStoreState, { IPlaygroundState } from \"@sandbox/store/IStoreState\";\r\n\r\nconst initialState: IPlaygroundState = {\r\n    technique: null,\r\n    timeline: Timeline.make(),\r\n    controls: { controls: {}, values: {}, presets: [] },\r\n    presets: {},\r\n    revision: 0,\r\n    wasm: Techniques.isWASM(),\r\n    shaderFormat: 'glsl',\r\n\r\n    exportName: null, // LOCAL_SESSION_AUTOSAVE\r\n    autosave: false\r\n};\r\n\r\n\r\n\r\nexport default handleActions<IPlaygroundState, IPlaygroundActions>({\r\n    [evt.PLAYGROUND_TECHNIQUE_UPDATE]: (state, { payload }: IPlaygroundTechniqueUpdate) =>\r\n        ({ ...state, technique: payload.technique, controls: payload.controls, revision: state.revision + 1 }),\r\n    [evt.PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME]: (state, action: IPlaygroundSwitchTechniqueRuntime) =>\r\n        ({ ...state, wasm: !state.wasm }),\r\n    [evt.PLAYGROUND_EFFECT_HAS_BEEN_SAVED]: (state, action: IPlaygroundEffectHasBeenSaved) =>\r\n        ({ ...state, exportName: action.payload.filename }),\r\n    [evt.PLAYGROUND_EFFECT_HAS_BEEN_DROPPED]: (state, action: IPlaygroundEffectHasBeenDropped) =>\r\n        ({ ...state, exportName: null, technique: null }),\r\n    [evt.PLAYGROUND_SET_OPTION_AUTOSAVE]: (state, action: IPlaygroundSetOptionAutosave) =>\r\n        ({ ...state, autosave: action.payload.enabled }),\r\n    [evt.PLAYGROUND_SET_SHADER_FORMAT]: (state, action: IPlaygroundSetShaderFormat) =>\r\n        ({ ...state, shaderFormat: action.payload.format })\r\n}, initialState);\r\n\r\n\r\nexport const getEmitterName = (playground: IPlaygroundState) => playground.technique ? playground.technique.getName() : null;\r\n/** @deprecated */\r\nexport function filterTechniques(scope: IScope): ITechniqueInstruction[] {\r\n    if (!scope) {\r\n        return [];\r\n    }\r\n\r\n    const map = scope.techniques;\r\n    return Object.keys(map).map(name => map[name]);\r\n}\r\n\r\nexport function filterTechniques11(scope: IScope): ITechnique11Instruction[] {\r\n    if (!scope) {\r\n        return [];\r\n    }\r\n\r\n    const map = scope.techniques11;\r\n    return Object.keys(map).map(name => map[name]);\r\n}\r\n\r\nexport const getPlaygroundState = (state: IStoreState): IPlaygroundState => state.playground;\r\n","import { connectRouter } from 'connected-react-router';\r\nimport { createHashHistory } from 'history';\r\n\r\nexport const history = createHashHistory();\r\n\r\nexport default connectRouter(history);","import { IS3DActions, IS3DConnectP4Success, IS3DInitEnv, IS3DInitEnvFailed, IS3DInitEnvSuccess } from \"@sandbox/actions/ActionTypes\";\r\nimport { IS3DState } from \"@sandbox/store/IStoreState\";\r\nimport { handleActions } from \"./handleActions\";\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\n\r\nconst initialState: IS3DState = {\r\n    env: null,\r\n    p4: null\r\n};\r\n\r\nexport default handleActions<IS3DState, IS3DActions>({\r\n    [evt.S3D_INIT_ENV_SUCCESSED]: (state, action: IS3DInitEnvSuccess) => ({ ...state, env: action.payload.env }),\r\n    [evt.S3D_INIT_ENV_FAILED]: (state, action: IS3DInitEnvFailed) => ({ ...state, env: null }),\r\n    [evt.S3D_CONNECT_P4_SUCCESSED]: (state, action: IS3DConnectP4Success) => ({ ...state, p4: action.payload.info }),\r\n}, initialState);\r\n\r\n","import { assert } from '@lib/common';\r\nimport { ConvolutionPackEx } from '@lib/fx/bundles/utils';\r\nimport * as Bytecode from '@lib/fx/bytecode/VM';\r\nimport * as Techniques from '@lib/fx/techniques';\r\nimport { IScope } from '@lib/idl/IInstruction';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { StringRef } from '@lib/util/StringRef';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IDebuggerActions, IDebuggerOptionsChanged, IDebuggerStartDebug, IGraphLoaded, ISourceCodeAddBreakpoint, ISourceCodeAddMarker, ISourceCodeAddMarkerBatch, ISourceCodeAnalysisComplete, ISourceCodeModified, ISourceCodeParsingComplete, ISourceCodePreprocessingComplete, ISourceCodeRemoveBreakpoint, ISourceCodeRemoveMarker, ISourceCodeRemoveMarkerBatch, ISourceCodeSetDefine, ISourceFileActions, ISourceFileDropState, ISourceFileLoaded, ISourceFileLoadingFailed, ISourceFileRequest } from '@sandbox/actions/ActionTypes';\r\nimport { handleActions } from '@sandbox/reducers/handleActions';\r\nimport { IDebuggerState, IFileState, IStoreState } from '@sandbox/store/IStoreState';\r\nimport * as Depot from '@sandbox/reducers/depot';\r\n\r\nconst initialState: IFileState = {\r\n    revision: 0,\r\n    uri: null,\r\n    content: '',\r\n    error: null,\r\n    markers: {},\r\n    breakpoints: [],\r\n    slastDocument: null,\r\n    slDocument: null,\r\n    rawDocument: null,\r\n    defines: [],\r\n    debugger: {\r\n        query: null,\r\n        bcDocument: null,\r\n        options: {\r\n            colorize: true,\r\n            disableOptimizations: true,\r\n            autocompile: false,\r\n            wasm: Bytecode.isWASM()\r\n        }\r\n    }\r\n};\r\n\r\n\r\nexport default handleActions<IFileState, ISourceFileActions | IDebuggerActions | IGraphLoaded>({\r\n    // hack: intercept filename of graph as main filename\r\n    [evt.GRAPH_LOADED]: (state, action: IGraphLoaded) => \r\n        ({ ...state, uri: action.payload.filename }),\r\n\r\n    // don't update uri separatly from content (!)\r\n    // [evt.SOURCE_FILE_REQUEST]: (state, action: ISourceFileRequest) =>\r\n    //     ({ ...state, uri: action.payload.filename }),\r\n\r\n    [evt.SOURCE_FILE_LOADED]: (state, action: ISourceFileLoaded) =>\r\n        ({ ...state, uri: action.payload.filename, content: action.payload.content, revision: 0 }),\r\n\r\n    [evt.SOURCE_FILE_LOADING_FAILED]: (state, action: ISourceFileLoadingFailed) =>\r\n        ({\r\n            ...state,\r\n            error: action.payload.error,\r\n            // NOTE: temp solution (clean up all info about prev file)\r\n            content: null,\r\n            debugger: { ...state.debugger, bcDocument: null },\r\n            breakpoints: [],\r\n            slastDocument: null,\r\n            slDocument: null,\r\n            revision: 0,\r\n            wasm: Techniques.isWASM()\r\n        }),\r\n\r\n    [evt.SOURCE_FILE_DROP_STATE]: (state, action: ISourceFileDropState) =>\r\n        ({\r\n            ...state,\r\n            error: null,\r\n            content: null,\r\n            debugger: { ...state.debugger, bcDocument: null },\r\n            markers: {},\r\n            breakpoints: [],\r\n            slastDocument: null,\r\n            slDocument: null, \r\n            revision: 0\r\n        }),\r\n\r\n    [evt.SOURCE_CODE_MODIFED]: (state, action: ISourceCodeModified) =>\r\n        ({\r\n            ...state, markers: {}, \r\n            content: action.payload.content, \r\n            uri: action.payload.filename || state.uri,\r\n            revision: state.revision + 1\r\n            // , debugger: { entryPoint: null, runtime: null, ...state.debugger } =\r\n        }),\r\n\r\n    [evt.SOURCE_CODE_PARSING_COMPLETE]: (state, action: ISourceCodeParsingComplete) =>\r\n        ({ ...state, slastDocument: action.payload.slastDocument }),\r\n\r\n    [evt.SOURCE_CODE_ANALYSIS_COMPLETE]: (state, action: ISourceCodeAnalysisComplete) =>\r\n        ({ ...state, slDocument: action.payload.result }),\r\n\r\n    [evt.SOURCE_CODE_PREPROCESSING_COMPLETE]: (state, action: ISourceCodePreprocessingComplete) =>\r\n        ({ ...state, rawDocument: action.payload.document }),\r\n\r\n    //\r\n    // markers\r\n    //\r\n\r\n    [evt.SOURCE_CODE_ADD_MARKER]: (state, action: ISourceCodeAddMarker) =>\r\n        ({ ...state, markers: { ...state.markers, [action.payload.name]: action.payload } }),\r\n\r\n    [evt.SOURCE_CODE_REMOVE_MARKER]: (state, action: ISourceCodeRemoveMarker) => {\r\n        const markers = { ...state.markers };\r\n        delete markers[action.payload.name];\r\n        return { ...state, markers };\r\n    },\r\n\r\n    [evt.SOURCE_CODE_ADD_MARKER_BATCH]: (state, action: ISourceCodeAddMarkerBatch) => {\r\n        const markers = { ...state.markers };\r\n        action.payload.batch.forEach(desc => markers[desc.name] = desc);\r\n        return { ...state, markers };\r\n    },\r\n\r\n    [evt.SOURCE_CODE_REMOVE_MARKER_BATCH]: (state, action: ISourceCodeRemoveMarkerBatch) => {\r\n        const markers = { ...state.markers };\r\n        action.payload.batch.forEach(name => {\r\n            delete markers[name];\r\n        });\r\n        return { ...state, markers };\r\n    },\r\n\r\n    //\r\n    // breakpoints\r\n    //\r\n\r\n    [evt.SOURCE_CODE_ADD_BREAKPOINT]: (state, action: ISourceCodeAddBreakpoint) => {\r\n        assert(state.breakpoints.indexOf(action.payload.line) === -1);\r\n        return ({ ...state, breakpoints: [...state.breakpoints, action.payload.line] })\r\n    },\r\n\r\n    [evt.SOURCE_CODE_REMOVE_BREAKPOINT]: (state, action: ISourceCodeRemoveBreakpoint) => {\r\n        return { ...state, breakpoints: state.breakpoints.filter(ln => ln !== action.payload.line) };\r\n    },\r\n\r\n    [evt.SOURCE_CODE_SET_DEFINE]: (state, { payload: { name } }: ISourceCodeSetDefine) => {\r\n        return { ...state, defines: [ name, ...state.defines.filter(def => def != name) ] };\r\n    },\r\n\r\n    [evt.SOURCE_CODE_REMOVE_DEFINE]: (state, { payload: { name } }: ISourceCodeSetDefine) => {\r\n        return { ...state, defines: state.defines.filter(def => def != name) };\r\n    },\r\n\r\n    //\r\n    // debugger\r\n    //\r\n\r\n    [evt.DEBUGGER_START_DEBUG]: (state, action: IDebuggerStartDebug) => {\r\n        const options = state.debugger.options;\r\n        const { query, bcDocument } = action.payload;\r\n        return { ...state, debugger: { query, bcDocument, options } };\r\n    },\r\n\r\n    [evt.DEBUGGER_RESET]: (state) => {\r\n        const { debugger: { options } } = state;\r\n        return { ...state, debugger: { query: null, bcDocument: null, options, layout: 'i32' } };\r\n    },\r\n\r\n    [evt.DEBUGGER_OPTIONS_CHANGED]: (state: IFileState, action: IDebuggerOptionsChanged) => {\r\n        const options = { ...state.debugger.options, ...action.payload.options };\r\n        const $debugger = { ...state.debugger, options };\r\n        // console.log(JSON.stringify(options, null, '\\t'));\r\n        return { ...state, debugger: $debugger };\r\n    },\r\n}, initialState);\r\n\r\n\r\n//- Selectors\r\n\r\n// export const getFileStateNoMarkers = (state: IStoreState): IFileState => ({ ...state.sourceFile, markers: null });\r\nexport const getFileState = (state: IStoreState): IFileState => state.sourceFile;\r\nexport const getDebugger = (state: IStoreState): IDebuggerState => getFileState(state).debugger;\r\nexport const getScope = (file: IFileState): IScope => file.slDocument ? file.slDocument.root.scope : null;\r\n\r\nexport const getRawContent = (file: IFileState): string => file.rawDocument ? file.rawDocument.source : null;\r\nexport const asTextDocument = ({ uri, content }: IFileState): ITextDocument => ({ uri: StringRef.make(uri), source: content });\r\nexport const asSLASTDocument = (file: IFileState) => file.slastDocument;\r\n\r\nexport const asConvolutionPack = (state: IStoreState): ConvolutionPackEx => {\r\n    const file = state.sourceFile;\r\n    const depot = state.depot;\r\n    const textDocument = asTextDocument(file);\r\n    const slastDocument = asSLASTDocument(file);\r\n    const includeResolver = Depot.makeResolver(depot);\r\n    const defines = file.defines;\r\n\r\n    return new ConvolutionPackEx(textDocument, slastDocument, includeResolver, defines);\r\n}\r\n","import { IFxContextExOptions } from '@lib/fx/translators/FxTranslator';\r\nimport { handleActions } from '@sandbox/reducers/handleActions';\r\nimport IStoreState, { ITranslatorParams } from '@sandbox/store/IStoreState';\r\n\r\nconst initialState: ITranslatorParams = {\r\n    uiControlsGatherToDedicatedConstantBuffer: true,\r\n    uiControlsConstantBufferRegister: 10,\r\n\r\n    globalUniformsGatherToDedicatedConstantBuffer: true,\r\n    globalUniformsConstantBufferRegister: 11\r\n};\r\n\r\n\r\nexport default handleActions<ITranslatorParams, any/* todo */>({\r\n\r\n}, initialState);\r\n\r\n\r\n\r\n//- Selectors\r\n\r\nexport const asFxTranslatorOprions = (state: IStoreState): IFxContextExOptions => {\r\n    return { ...state.translatorParams };\r\n}\r\n","/// <reference path=\"../webpack.d.ts\" />\r\n\r\n// import ActionTypes from '@sandbox/actions/ActionTypes';\r\nimport commonLogic from '@sandbox/logic/common';\r\nimport depotLogic from '@sandbox/logic/depot';\r\nimport fxRuntimeLogic from '@sandbox/logic/fxRuntime';\r\n// import graphLogic from '@sandbox/logic/nodes';\r\nimport graphLogic from '@sandbox/logic/nodesEx';\r\nimport parsingLogic from '@sandbox/logic/parsing';\r\nimport s3dLogic from '@sandbox/logic/s3d';\r\nimport depot from '@sandbox/reducers/depot';\r\nimport nodes from '@sandbox/reducers/nodes';\r\nimport parserParams from '@sandbox/reducers/parserParams';\r\nimport translatorParams from '@sandbox/reducers/translatorParams';\r\nimport playground from '@sandbox/reducers/playground';\r\nimport router from '@sandbox/reducers/router';\r\nimport s3d from '@sandbox/reducers/s3d';\r\nimport sourceFile from '@sandbox/reducers/sourceFile';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport { applyMiddleware, combineReducers, createStore, Middleware } from 'redux';\r\nimport reduxImmutableStateInvariant from 'redux-immutable-state-invariant';\r\nimport { createLogger } from 'redux-logger';\r\nimport { createLogicMiddleware } from 'redux-logic';\r\n\r\nconst reducer = combineReducers<IStoreState>({ \r\n    sourceFile, \r\n    parserParams, \r\n    translatorParams,\r\n    router, \r\n    playground, \r\n    nodes, \r\n    s3d, \r\n    depot\r\n});\r\n\r\nconst logic = createLogicMiddleware([\r\n    ...commonLogic,\r\n    ...parsingLogic,\r\n    ...fxRuntimeLogic,\r\n    ...graphLogic,\r\n    ...s3dLogic,\r\n    ...depotLogic\r\n]);\r\n\r\n\r\nconst logger = createLogger({\r\n    collapsed: true,\r\n    diff: false\r\n});\r\n\r\n\r\nconst reduxImmutableState = reduxImmutableStateInvariant({\r\n    ignore: [\r\n        'sourceFile.slastDocument',\r\n        'sourceFile.slDocument',\r\n        'sourceFile.debugger.bcDocument',\r\n        'playground.technique',\r\n        'playground.timeline',\r\n        'playground.controls',\r\n        'nodes.graph',\r\n        'nodes.env',\r\n        's3d.env'\r\n    ]\r\n} as any);\r\n\r\n// todo: add support for retail configuration\r\nconst middleware: Middleware[] = !PRODUCTION ?\r\n    [/*thunk, */logic, logger, reduxImmutableState] :\r\n    [logic];\r\n\r\nexport const store = createStore<IStoreState, any, any, any>(\r\n    reducer,\r\n    applyMiddleware(...middleware)\r\n);\r\n\r\n\r\n//\r\n// IP: hack to preserved some of user-set options\r\n//\r\n\r\nconst BACKUP_DEFINES = \"store-backup-defines\";\r\n// const BACKUP_SHADER_FORMAT = \"store-backup-shader-format\";\r\n\r\nstore.subscribe(()=>{\r\n    const state = <IStoreState>store.getState(); \r\n    localStorage[BACKUP_DEFINES] = JSON.stringify(state.sourceFile.defines);\r\n    // localStorage[BACKUP_SHADER_FORMAT] = state.playground.shaderFormat;\r\n});\r\n\r\n// store.dispatch({ type: \"playground-set-shader-format\", payload: { format: localStorage[BACKUP_SHADER_FORMAT] } });\r\nJSON.parse(localStorage[BACKUP_DEFINES] || \"[]\").forEach(name => store.dispatch({ type: \"source-code-set-define\", payload: { name } }));","\r\nvar Module = (() => {\r\n  var _scriptDir = import.meta.url;\r\n  \r\n  return (\r\nfunction(Module) {\r\n  Module = Module || {};\r\n\r\n\r\n\r\n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(Module) { ..generated code.. }\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module = typeof Module != 'undefined' ? Module : {};\r\n\r\n// See https://caniuse.com/mdn-javascript_builtins_object_assign\r\n\r\n// Set up the promise that indicates the Module is initialized\r\nvar readyPromiseResolve, readyPromiseReject;\r\nModule['ready'] = new Promise(function(resolve, reject) {\r\n  readyPromiseResolve = resolve;\r\n  readyPromiseReject = reject;\r\n});\r\n\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\n// {{PRE_JSES}}\r\n\r\n// Sometimes an existing Module object exists with properties\r\n// meant to overwrite the default module functionality. Here\r\n// we collect those properties and reapply _after_ we configure\r\n// the current environment's defaults to avoid having to be so\r\n// defensive during initialization.\r\nvar moduleOverrides = Object.assign({}, Module);\r\n\r\nvar arguments_ = [];\r\nvar thisProgram = './this.program';\r\nvar quit_ = (status, toThrow) => {\r\n  throw toThrow;\r\n};\r\n\r\n// Determine the runtime environment we are in. You can customize this by\r\n// setting the ENVIRONMENT setting at compile time (see settings.js).\r\n\r\nvar ENVIRONMENT_IS_WEB = true;\r\nvar ENVIRONMENT_IS_WORKER = false;\r\nvar ENVIRONMENT_IS_NODE = false;\r\nvar ENVIRONMENT_IS_SHELL = false;\r\n\r\n// `/` should be present at the end if `scriptDirectory` is not empty\r\nvar scriptDirectory = '';\r\nfunction locateFile(path) {\r\n  if (Module['locateFile']) {\r\n    return Module['locateFile'](path, scriptDirectory);\r\n  }\r\n  return scriptDirectory + path;\r\n}\r\n\r\n// Hooks that are implemented differently in different runtime environments.\r\nvar read_,\r\n    readAsync,\r\n    readBinary,\r\n    setWindowTitle;\r\n\r\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\r\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\r\n// ENVIRONMENT_IS_NODE.\r\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\r\n    scriptDirectory = self.location.href;\r\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\r\n    scriptDirectory = document.currentScript.src;\r\n  }\r\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\r\n  // is gone, so we saved it, and we use it here instead of any other info.\r\n  if (_scriptDir) {\r\n    scriptDirectory = _scriptDir;\r\n  }\r\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\r\n  // otherwise, slice off the final part of the url to find the script directory.\r\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\r\n  // and scriptDirectory will correctly be replaced with an empty string.\r\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\r\n  // they are removed because they could contain a slash.\r\n  if (scriptDirectory.indexOf('blob:') !== 0) {\r\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf('/')+1);\r\n  } else {\r\n    scriptDirectory = '';\r\n  }\r\n\r\n  // Differentiate the Web Worker from the Node Worker case, as reading must\r\n  // be done differently.\r\n  {\r\n// include: web_or_worker_shell_read.js\r\n\r\n\r\n  read_ = (url) => {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, false);\r\n      xhr.send(null);\r\n      return xhr.responseText;\r\n  }\r\n\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    readBinary = (url) => {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, false);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.send(null);\r\n        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\r\n    };\r\n  }\r\n\r\n  readAsync = (url, onload, onerror) => {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, true);\r\n    xhr.responseType = 'arraybuffer';\r\n    xhr.onload = () => {\r\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n        onload(xhr.response);\r\n        return;\r\n      }\r\n      onerror();\r\n    };\r\n    xhr.onerror = onerror;\r\n    xhr.send(null);\r\n  }\r\n\r\n// end include: web_or_worker_shell_read.js\r\n  }\r\n\r\n  setWindowTitle = (title) => document.title = title;\r\n} else\r\n{\r\n}\r\n\r\nvar out = Module['print'] || console.log.bind(console);\r\nvar err = Module['printErr'] || console.warn.bind(console);\r\n\r\n// Merge back in the overrides\r\nObject.assign(Module, moduleOverrides);\r\n// Free the object hierarchy contained in the overrides, this lets the GC\r\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\r\nmoduleOverrides = null;\r\n\r\n// Emit code to handle expected values on the Module object. This applies Module.x\r\n// to the proper local x. This has two benefits: first, we only emit it if it is\r\n// expected to arrive, and second, by using a local everywhere else that can be\r\n// minified.\r\n\r\nif (Module['arguments']) arguments_ = Module['arguments'];\r\n\r\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];\r\n\r\nif (Module['quit']) quit_ = Module['quit'];\r\n\r\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\r\n\r\n\r\n\r\n\r\nvar STACK_ALIGN = 16;\r\nvar POINTER_SIZE = 4;\r\n\r\nfunction getNativeTypeSize(type) {\r\n  switch (type) {\r\n    case 'i1': case 'i8': case 'u8': return 1;\r\n    case 'i16': case 'u16': return 2;\r\n    case 'i32': case 'u32': return 4;\r\n    case 'i64': case 'u64': return 8;\r\n    case 'float': return 4;\r\n    case 'double': return 8;\r\n    default: {\r\n      if (type[type.length - 1] === '*') {\r\n        return POINTER_SIZE;\r\n      } else if (type[0] === 'i') {\r\n        const bits = Number(type.substr(1));\r\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\r\n        return bits / 8;\r\n      } else {\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnOnce(text) {\r\n  if (!warnOnce.shown) warnOnce.shown = {};\r\n  if (!warnOnce.shown[text]) {\r\n    warnOnce.shown[text] = 1;\r\n    err(text);\r\n  }\r\n}\r\n\r\n// include: runtime_functions.js\r\n\r\n\r\n// This gives correct answers for everything less than 2^{14} = 16384\r\n// I hope nobody is contemplating functions with 16384 arguments...\r\nfunction uleb128Encode(n) {\r\n  if (n < 128) {\r\n    return [n];\r\n  }\r\n  return [(n % 128) | 128, n >> 7];\r\n}\r\n\r\n// Wraps a JS function as a wasm function with a given signature.\r\nfunction convertJsFunctionToWasm(func, sig) {\r\n\r\n  // If the type reflection proposal is available, use the new\r\n  // \"WebAssembly.Function\" constructor.\r\n  // Otherwise, construct a minimal wasm module importing the JS function and\r\n  // re-exporting it.\r\n  if (typeof WebAssembly.Function == \"function\") {\r\n    var typeNames = {\r\n      'i': 'i32',\r\n      'j': 'i64',\r\n      'f': 'f32',\r\n      'd': 'f64',\r\n      'p': 'i32',\r\n    };\r\n    var type = {\r\n      parameters: [],\r\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\r\n    };\r\n    for (var i = 1; i < sig.length; ++i) {\r\n      type.parameters.push(typeNames[sig[i]]);\r\n    }\r\n    return new WebAssembly.Function(type, func);\r\n  }\r\n\r\n  // The module is static, with the exception of the type section, which is\r\n  // generated based on the signature passed in.\r\n  var typeSection = [\r\n    0x01, // count: 1\r\n    0x60, // form: func\r\n  ];\r\n  var sigRet = sig.slice(0, 1);\r\n  var sigParam = sig.slice(1);\r\n  var typeCodes = {\r\n    'i': 0x7f, // i32\r\n    'p': 0x7f, // i32\r\n    'j': 0x7e, // i64\r\n    'f': 0x7d, // f32\r\n    'd': 0x7c, // f64\r\n  };\r\n\r\n  // Parameters, length + signatures\r\n  typeSection = typeSection.concat(uleb128Encode(sigParam.length));\r\n  for (var i = 0; i < sigParam.length; ++i) {\r\n    typeSection.push(typeCodes[sigParam[i]]);\r\n  }\r\n\r\n  // Return values, length + signatures\r\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\r\n  if (sigRet == 'v') {\r\n    typeSection.push(0x00);\r\n  } else {\r\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\r\n  }\r\n\r\n  // Write the section code and overall length of the type section into the\r\n  // section header\r\n  typeSection = [0x01 /* Type section code */].concat(\r\n    uleb128Encode(typeSection.length),\r\n    typeSection\r\n  );\r\n\r\n  // Rest of the module is static\r\n  var bytes = new Uint8Array([\r\n    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\r\n    0x01, 0x00, 0x00, 0x00, // version: 1\r\n  ].concat(typeSection, [\r\n    0x02, 0x07, // import section\r\n      // (import \"e\" \"f\" (func 0 (type 0)))\r\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\r\n    0x07, 0x05, // export section\r\n      // (export \"f\" (func 0 (type 0)))\r\n      0x01, 0x01, 0x66, 0x00, 0x00,\r\n  ]));\r\n\r\n   // We can compile this wasm module synchronously because it is very small.\r\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\r\n  var module = new WebAssembly.Module(bytes);\r\n  var instance = new WebAssembly.Instance(module, {\r\n    'e': {\r\n      'f': func\r\n    }\r\n  });\r\n  var wrappedFunc = instance.exports['f'];\r\n  return wrappedFunc;\r\n}\r\n\r\nvar freeTableIndexes = [];\r\n\r\n// Weak map of functions in the table to their indexes, created on first use.\r\nvar functionsInTableMap;\r\n\r\nfunction getEmptyTableSlot() {\r\n  // Reuse a free index if there is one, otherwise grow.\r\n  if (freeTableIndexes.length) {\r\n    return freeTableIndexes.pop();\r\n  }\r\n  // Grow the table\r\n  try {\r\n    wasmTable.grow(1);\r\n  } catch (err) {\r\n    if (!(err instanceof RangeError)) {\r\n      throw err;\r\n    }\r\n    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';\r\n  }\r\n  return wasmTable.length - 1;\r\n}\r\n\r\nfunction updateTableMap(offset, count) {\r\n  for (var i = offset; i < offset + count; i++) {\r\n    var item = getWasmTableEntry(i);\r\n    // Ignore null values.\r\n    if (item) {\r\n      functionsInTableMap.set(item, i);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Add a function to the table.\r\n * 'sig' parameter is required if the function being added is a JS function.\r\n * @param {string=} sig\r\n */\r\nfunction addFunction(func, sig) {\r\n\r\n  // Check if the function is already in the table, to ensure each function\r\n  // gets a unique index. First, create the map if this is the first use.\r\n  if (!functionsInTableMap) {\r\n    functionsInTableMap = new WeakMap();\r\n    updateTableMap(0, wasmTable.length);\r\n  }\r\n  if (functionsInTableMap.has(func)) {\r\n    return functionsInTableMap.get(func);\r\n  }\r\n\r\n  // It's not in the table, add it now.\r\n\r\n  var ret = getEmptyTableSlot();\r\n\r\n  // Set the new value.\r\n  try {\r\n    // Attempting to call this with JS function will cause of table.set() to fail\r\n    setWasmTableEntry(ret, func);\r\n  } catch (err) {\r\n    if (!(err instanceof TypeError)) {\r\n      throw err;\r\n    }\r\n    var wrapped = convertJsFunctionToWasm(func, sig);\r\n    setWasmTableEntry(ret, wrapped);\r\n  }\r\n\r\n  functionsInTableMap.set(func, ret);\r\n\r\n  return ret;\r\n}\r\n\r\nfunction removeFunction(index) {\r\n  functionsInTableMap.delete(getWasmTableEntry(index));\r\n  freeTableIndexes.push(index);\r\n}\r\n\r\n// end include: runtime_functions.js\r\n// include: runtime_debug.js\r\n\r\n\r\n// end include: runtime_debug.js\r\nvar tempRet0 = 0;\r\nvar setTempRet0 = (value) => { tempRet0 = value; };\r\nvar getTempRet0 = () => tempRet0;\r\n\r\n\r\n\r\n// === Preamble library stuff ===\r\n\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\nvar wasmBinary;\r\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\r\nvar noExitRuntime = Module['noExitRuntime'] || true;\r\n\r\nif (typeof WebAssembly != 'object') {\r\n  abort('no native wasm support detected');\r\n}\r\n\r\n// Wasm globals\r\n\r\nvar wasmMemory;\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n\r\n// whether we are quitting the application. no code should run after this.\r\n// set in exit() and abort()\r\nvar ABORT = false;\r\n\r\n// set by exit() and abort().  Passed to 'onExit' handler.\r\n// NOTE: This is also used as the process return code code in shell environments\r\n// but only when noExitRuntime is false.\r\nvar EXITSTATUS;\r\n\r\n/** @type {function(*, string=)} */\r\nfunction assert(condition, text) {\r\n  if (!condition) {\r\n    // This build was created without ASSERTIONS defined.  `assert()` should not\r\n    // ever be called in this configuration but in case there are callers in\r\n    // the wild leave this simple abort() implemenation here for now.\r\n    abort(text);\r\n  }\r\n}\r\n\r\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\r\nfunction getCFunc(ident) {\r\n  var func = Module['_' + ident]; // closure exported function\r\n  return func;\r\n}\r\n\r\n// C calling interface.\r\n/** @param {string|null=} returnType\r\n    @param {Array=} argTypes\r\n    @param {Arguments|Array=} args\r\n    @param {Object=} opts */\r\nfunction ccall(ident, returnType, argTypes, args, opts) {\r\n  // For fast lookup of conversion functions\r\n  var toC = {\r\n    'string': function(str) {\r\n      var ret = 0;\r\n      if (str !== null && str !== undefined && str !== 0) { // null string\r\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\r\n        var len = (str.length << 2) + 1;\r\n        ret = stackAlloc(len);\r\n        stringToUTF8(str, ret, len);\r\n      }\r\n      return ret;\r\n    },\r\n    'array': function(arr) {\r\n      var ret = stackAlloc(arr.length);\r\n      writeArrayToMemory(arr, ret);\r\n      return ret;\r\n    }\r\n  };\r\n\r\n  function convertReturnValue(ret) {\r\n    if (returnType === 'string') {\r\n      \r\n      return UTF8ToString(ret);\r\n    }\r\n    if (returnType === 'boolean') return Boolean(ret);\r\n    return ret;\r\n  }\r\n\r\n  var func = getCFunc(ident);\r\n  var cArgs = [];\r\n  var stack = 0;\r\n  if (args) {\r\n    for (var i = 0; i < args.length; i++) {\r\n      var converter = toC[argTypes[i]];\r\n      if (converter) {\r\n        if (stack === 0) stack = stackSave();\r\n        cArgs[i] = converter(args[i]);\r\n      } else {\r\n        cArgs[i] = args[i];\r\n      }\r\n    }\r\n  }\r\n  var ret = func.apply(null, cArgs);\r\n  function onDone(ret) {\r\n    if (stack !== 0) stackRestore(stack);\r\n    return convertReturnValue(ret);\r\n  }\r\n\r\n  ret = onDone(ret);\r\n  return ret;\r\n}\r\n\r\n/** @param {string=} returnType\r\n    @param {Array=} argTypes\r\n    @param {Object=} opts */\r\nfunction cwrap(ident, returnType, argTypes, opts) {\r\n  argTypes = argTypes || [];\r\n  // When the function takes numbers and returns a number, we can just return\r\n  // the original function\r\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\r\n  var numericRet = returnType !== 'string';\r\n  if (numericRet && numericArgs && !opts) {\r\n    return getCFunc(ident);\r\n  }\r\n  return function() {\r\n    return ccall(ident, returnType, argTypes, arguments, opts);\r\n  }\r\n}\r\n\r\n// include: runtime_legacy.js\r\n\r\n\r\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\r\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\r\n\r\n/**\r\n * allocate(): This function is no longer used by emscripten but is kept around to avoid\r\n *             breaking external users.\r\n *             You should normally not use allocate(), and instead allocate\r\n *             memory using _malloc()/stackAlloc(), initialize it with\r\n *             setValue(), and so forth.\r\n * @param {(Uint8Array|Array<number>)} slab: An array of data.\r\n * @param {number=} allocator : How to allocate memory, see ALLOC_*\r\n */\r\nfunction allocate(slab, allocator) {\r\n  var ret;\r\n\r\n  if (allocator == ALLOC_STACK) {\r\n    ret = stackAlloc(slab.length);\r\n  } else {\r\n    ret = _malloc(slab.length);\r\n  }\r\n\r\n  if (!slab.subarray && !slab.slice) {\r\n    slab = new Uint8Array(slab);\r\n  }\r\n  HEAPU8.set(slab, ret);\r\n  return ret;\r\n}\r\n\r\n// end include: runtime_legacy.js\r\n// include: runtime_strings.js\r\n\r\n\r\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\r\n\r\nvar UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\r\n// a copy of that string as a Javascript String object.\r\n/**\r\n * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n * @param {number} idx\r\n * @param {number=} maxBytesToRead\r\n * @return {string}\r\n */\r\nfunction UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\r\n  var endIdx = idx + maxBytesToRead;\r\n  var endPtr = idx;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\r\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n\r\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\r\n    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\r\n  } else {\r\n    var str = '';\r\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\r\n    while (idx < endPtr) {\r\n      // For UTF8 byte structure, see:\r\n      // http://en.wikipedia.org/wiki/UTF-8#Description\r\n      // https://www.ietf.org/rfc/rfc2279.txt\r\n      // https://tools.ietf.org/html/rfc3629\r\n      var u0 = heapOrArray[idx++];\r\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\r\n      var u1 = heapOrArray[idx++] & 63;\r\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\r\n      var u2 = heapOrArray[idx++] & 63;\r\n      if ((u0 & 0xF0) == 0xE0) {\r\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n      } else {\r\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\r\n      }\r\n\r\n      if (u0 < 0x10000) {\r\n        str += String.fromCharCode(u0);\r\n      } else {\r\n        var ch = u0 - 0x10000;\r\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\r\n// copy of that string as a Javascript String object.\r\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\r\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\r\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\r\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\r\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\r\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\r\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\r\n//                 style or the other.\r\n/**\r\n * @param {number} ptr\r\n * @param {number=} maxBytesToRead\r\n * @return {string}\r\n */\r\nfunction UTF8ToString(ptr, maxBytesToRead) {\r\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\r\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.\r\n//   outIdx: The starting offset in the array to begin the copying.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\r\n//                    This count should include the null terminator,\r\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\r\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\r\n    return 0;\r\n\r\n  var startIdx = outIdx;\r\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xD800 && u <= 0xDFFF) {\r\n      var u1 = str.charCodeAt(++i);\r\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\r\n    }\r\n    if (u <= 0x7F) {\r\n      if (outIdx >= endIdx) break;\r\n      heap[outIdx++] = u;\r\n    } else if (u <= 0x7FF) {\r\n      if (outIdx + 1 >= endIdx) break;\r\n      heap[outIdx++] = 0xC0 | (u >> 6);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    } else if (u <= 0xFFFF) {\r\n      if (outIdx + 2 >= endIdx) break;\r\n      heap[outIdx++] = 0xE0 | (u >> 12);\r\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    } else {\r\n      if (outIdx + 3 >= endIdx) break;\r\n      heap[outIdx++] = 0xF0 | (u >> 18);\r\n      heap[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    }\r\n  }\r\n  // Null-terminate the pointer to the buffer.\r\n  heap[outIdx] = 0;\r\n  return outIdx - startIdx;\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\r\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\r\nfunction lengthBytesUTF8(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    if (u <= 0x7F) ++len;\r\n    else if (u <= 0x7FF) len += 2;\r\n    else if (u <= 0xFFFF) len += 3;\r\n    else len += 4;\r\n  }\r\n  return len;\r\n}\r\n\r\n// end include: runtime_strings.js\r\n// include: runtime_strings_extra.js\r\n\r\n\r\n// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\r\n\r\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nfunction AsciiToString(ptr) {\r\n  var str = '';\r\n  while (1) {\r\n    var ch = HEAPU8[((ptr++)>>0)];\r\n    if (!ch) return str;\r\n    str += String.fromCharCode(ch);\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\r\n\r\nfunction stringToAscii(str, outPtr) {\r\n  return writeAsciiToMemory(str, outPtr, false);\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nvar UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;\r\n\r\nfunction UTF16ToString(ptr, maxBytesToRead) {\r\n  var endPtr = ptr;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  var idx = endPtr >> 1;\r\n  var maxIdx = idx + maxBytesToRead / 2;\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n  // will always evaluate to true. This saves on code size.\r\n  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\r\n  endPtr = idx << 1;\r\n\r\n  if (endPtr - ptr > 32 && UTF16Decoder) {\r\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n  } else {\r\n    var str = '';\r\n\r\n    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition\r\n    // will always evaluate to true. The loop is then terminated on the first null char.\r\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\r\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\r\n      if (codeUnit == 0) break;\r\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\r\n      str += String.fromCharCode(codeUnit);\r\n    }\r\n\r\n    return str;\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7FFFFFFF;\r\n  }\r\n  if (maxBytesToWrite < 2) return 0;\r\n  maxBytesToWrite -= 2; // Null terminator.\r\n  var startPtr = outPtr;\r\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\r\n  for (var i = 0; i < numCharsToWrite; ++i) {\r\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    HEAP16[((outPtr)>>1)] = codeUnit;\r\n    outPtr += 2;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP16[((outPtr)>>1)] = 0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF16(str) {\r\n  return str.length*2;\r\n}\r\n\r\nfunction UTF32ToString(ptr, maxBytesToRead) {\r\n  var i = 0;\r\n\r\n  var str = '';\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n  // will always evaluate to true. This saves on code size.\r\n  while (!(i >= maxBytesToRead / 4)) {\r\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\r\n    if (utf32 == 0) break;\r\n    ++i;\r\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    if (utf32 >= 0x10000) {\r\n      var ch = utf32 - 0x10000;\r\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n    } else {\r\n      str += String.fromCharCode(utf32);\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7FFFFFFF;\r\n  }\r\n  if (maxBytesToWrite < 4) return 0;\r\n  var startPtr = outPtr;\r\n  var endPtr = startPtr + maxBytesToWrite - 4;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\r\n      var trailSurrogate = str.charCodeAt(++i);\r\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\r\n    }\r\n    HEAP32[((outPtr)>>2)] = codeUnit;\r\n    outPtr += 4;\r\n    if (outPtr + 4 > endPtr) break;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP32[((outPtr)>>2)] = 0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF32(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i);\r\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\r\n    len += 4;\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n// Allocate heap space for a JS string, and write it there.\r\n// It is the responsibility of the caller to free() that memory.\r\nfunction allocateUTF8(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = _malloc(size);\r\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Allocate stack space for a JS string, and write it there.\r\nfunction allocateUTF8OnStack(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = stackAlloc(size);\r\n  stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Deprecated: This function should not be called because it is unsafe and does not provide\r\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\r\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\r\n// to be secure from out of bounds writes.\r\n/** @deprecated\r\n    @param {boolean=} dontAddNull */\r\nfunction writeStringToMemory(string, buffer, dontAddNull) {\r\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\r\n\r\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\r\n  if (dontAddNull) {\r\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\r\n    // character that existed at the location where the null will be placed, and restore\r\n    // that after the write (below).\r\n    end = buffer + lengthBytesUTF8(string);\r\n    lastChar = HEAP8[end];\r\n  }\r\n  stringToUTF8(string, buffer, Infinity);\r\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\r\n}\r\n\r\nfunction writeArrayToMemory(array, buffer) {\r\n  HEAP8.set(array, buffer);\r\n}\r\n\r\n/** @param {boolean=} dontAddNull */\r\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\r\n  for (var i = 0; i < str.length; ++i) {\r\n    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;\r\n}\r\n\r\n// end include: runtime_strings_extra.js\r\n// Memory management\r\n\r\nvar HEAP,\r\n/** @type {!ArrayBuffer} */\r\n  buffer,\r\n/** @type {!Int8Array} */\r\n  HEAP8,\r\n/** @type {!Uint8Array} */\r\n  HEAPU8,\r\n/** @type {!Int16Array} */\r\n  HEAP16,\r\n/** @type {!Uint16Array} */\r\n  HEAPU16,\r\n/** @type {!Int32Array} */\r\n  HEAP32,\r\n/** @type {!Uint32Array} */\r\n  HEAPU32,\r\n/** @type {!Float32Array} */\r\n  HEAPF32,\r\n/** @type {!Float64Array} */\r\n  HEAPF64;\r\n\r\nfunction updateGlobalBufferAndViews(buf) {\r\n  buffer = buf;\r\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\r\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\r\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\r\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\r\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\r\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\r\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\r\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\r\n}\r\n\r\nvar TOTAL_STACK = 2097152;\r\n\r\nvar INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 134217728;\r\n\r\n// include: runtime_init_table.js\r\n// In regular non-RELOCATABLE mode the table is exported\r\n// from the wasm module and this will be assigned once\r\n// the exports are available.\r\nvar wasmTable;\r\n\r\n// end include: runtime_init_table.js\r\n// include: runtime_stack_check.js\r\n\r\n\r\n// end include: runtime_stack_check.js\r\n// include: runtime_assertions.js\r\n\r\n\r\n// end include: runtime_assertions.js\r\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\r\nvar __ATINIT__    = []; // functions called during startup\r\nvar __ATEXIT__    = []; // functions called during shutdown\r\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\r\n\r\nvar runtimeInitialized = false;\r\n\r\nfunction keepRuntimeAlive() {\r\n  return noExitRuntime;\r\n}\r\n\r\nfunction preRun() {\r\n\r\n  if (Module['preRun']) {\r\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\r\n    while (Module['preRun'].length) {\r\n      addOnPreRun(Module['preRun'].shift());\r\n    }\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction initRuntime() {\r\n  runtimeInitialized = true;\r\n\r\n  \r\nif (!Module[\"noFSInit\"] && !FS.init.initialized)\r\n  FS.init();\r\nFS.ignorePermissions = false;\r\n\r\nTTY.init();\r\n  callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction postRun() {\r\n\r\n  if (Module['postRun']) {\r\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\r\n    while (Module['postRun'].length) {\r\n      addOnPostRun(Module['postRun'].shift());\r\n    }\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n  __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n  __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnExit(cb) {\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n  __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\n// include: runtime_math.js\r\n\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\r\n\r\n// end include: runtime_math.js\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// Module.preRun (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\nvar runDependencyWatcher = null;\r\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  return id;\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback(); // can add another dependenciesFulfilled\r\n    }\r\n  }\r\n}\r\n\r\n/** @param {string|number=} what */\r\nfunction abort(what) {\r\n  {\r\n    if (Module['onAbort']) {\r\n      Module['onAbort'](what);\r\n    }\r\n  }\r\n\r\n  what = 'Aborted(' + what + ')';\r\n  // TODO(sbc): Should we remove printing and leave it up to whoever\r\n  // catches the exception?\r\n  err(what);\r\n\r\n  ABORT = true;\r\n  EXITSTATUS = 1;\r\n\r\n  what += '. Build with -sASSERTIONS for more info.';\r\n\r\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\r\n  // exception, which means we'd run destructors on it. We need the error to\r\n  // simply make the program stop.\r\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\r\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\r\n  // a trap or not based on a hidden field within the object. So at the moment\r\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\r\n  // allows this in the wasm spec.\r\n\r\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\r\n  // defintion for WebAssembly.RuntimeError claims it takes no arguments even\r\n  // though it can.\r\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\r\n  /** @suppress {checkTypes} */\r\n  var e = new WebAssembly.RuntimeError(what);\r\n\r\n  readyPromiseReject(e);\r\n  // Throw the error whether or not MODULARIZE is set because abort is used\r\n  // in code paths apart from instantiation where an exception is expected\r\n  // to be thrown when abort is called.\r\n  throw e;\r\n}\r\n\r\n// {{MEM_INITIALIZER}}\r\n\r\n// include: memoryprofiler.js\r\n\r\n\r\n// end include: memoryprofiler.js\r\n// include: URIUtils.js\r\n\r\n\r\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\r\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\r\n\r\n// Indicates whether filename is a base64 data URI.\r\nfunction isDataURI(filename) {\r\n  // Prefix of data URIs emitted by SINGLE_FILE and related options.\r\n  return filename.startsWith(dataURIPrefix);\r\n}\r\n\r\n// Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\nfunction isFileURI(filename) {\r\n  return filename.startsWith('file://');\r\n}\r\n\r\n// end include: URIUtils.js\r\nvar wasmBinaryFile;\r\nif (Module['locateFile']) {\r\n  wasmBinaryFile = 'C:/Husky/streams2/tools/code/Influx/webpack-addons/module-7937ca9cc6f8782be9620f24a283f5b5.wasm';\r\n  if (!isDataURI(wasmBinaryFile)) {\r\n    wasmBinaryFile = locateFile(wasmBinaryFile);\r\n  }\r\n} else {\r\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\r\n  wasmBinaryFile = new URL('C:/Husky/streams2/tools/code/Influx/webpack-addons/module-7937ca9cc6f8782be9620f24a283f5b5.wasm', import.meta.url).toString();\r\n}\r\n\r\nfunction getBinary(file) {\r\n  try {\r\n    if (file == wasmBinaryFile && wasmBinary) {\r\n      return new Uint8Array(wasmBinary);\r\n    }\r\n    if (readBinary) {\r\n      return readBinary(file);\r\n    } else {\r\n      throw \"both async and sync fetching of the wasm failed\";\r\n    }\r\n  }\r\n  catch (err) {\r\n    abort(err);\r\n  }\r\n}\r\n\r\nfunction getBinaryPromise() {\r\n  // If we don't have the binary yet, try to to load it asynchronously.\r\n  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\r\n  // See https://github.com/github/fetch/pull/92#issuecomment-140665932\r\n  // Cordova or Electron apps are typically loaded from a file:// url.\r\n  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\r\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\r\n    if (typeof fetch == 'function'\r\n    ) {\r\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\r\n        if (!response['ok']) {\r\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\r\n        }\r\n        return response['arrayBuffer']();\r\n      }).catch(function () {\r\n          return getBinary(wasmBinaryFile);\r\n      });\r\n    }\r\n  }\r\n\r\n  // Otherwise, getBinary should be able to get it synchronously\r\n  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });\r\n}\r\n\r\n// Create the wasm instance.\r\n// Receives the wasm imports, returns the exports.\r\nfunction createWasm() {\r\n  // prepare imports\r\n  var info = {\r\n    'env': asmLibraryArg,\r\n    'wasi_snapshot_preview1': asmLibraryArg,\r\n  };\r\n  // Load the wasm module and create an instance of using native support in the JS engine.\r\n  // handle a generated wasm instance, receiving its exports and\r\n  // performing other necessary setup\r\n  /** @param {WebAssembly.Module=} module*/\r\n  function receiveInstance(instance, module) {\r\n    var exports = instance.exports;\r\n\r\n    Module['asm'] = exports;\r\n\r\n    wasmMemory = Module['asm']['memory'];\r\n    updateGlobalBufferAndViews(wasmMemory.buffer);\r\n\r\n    wasmTable = Module['asm']['__indirect_function_table'];\r\n\r\n    addOnInit(Module['asm']['__wasm_call_ctors']);\r\n\r\n    removeRunDependency('wasm-instantiate');\r\n\r\n  }\r\n  // we can't run yet (except in a pthread, where we have a custom sync instantiator)\r\n  addRunDependency('wasm-instantiate');\r\n\r\n  // Prefer streaming instantiation if available.\r\n  function receiveInstantiationResult(result) {\r\n    // 'result' is a ResultObject object which has both the module and instance.\r\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\r\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\r\n    receiveInstance(result['instance']);\r\n  }\r\n\r\n  function instantiateArrayBuffer(receiver) {\r\n    return getBinaryPromise().then(function(binary) {\r\n      return WebAssembly.instantiate(binary, info);\r\n    }).then(function (instance) {\r\n      return instance;\r\n    }).then(receiver, function(reason) {\r\n      err('failed to asynchronously prepare wasm: ' + reason);\r\n\r\n      abort(reason);\r\n    });\r\n  }\r\n\r\n  function instantiateAsync() {\r\n    if (!wasmBinary &&\r\n        typeof WebAssembly.instantiateStreaming == 'function' &&\r\n        !isDataURI(wasmBinaryFile) &&\r\n        typeof fetch == 'function') {\r\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\r\n        // Suppress closure warning here since the upstream definition for\r\n        // instantiateStreaming only allows Promise<Repsponse> rather than\r\n        // an actual Response.\r\n        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\r\n        /** @suppress {checkTypes} */\r\n        var result = WebAssembly.instantiateStreaming(response, info);\r\n\r\n        return result.then(\r\n          receiveInstantiationResult,\r\n          function(reason) {\r\n            // We expect the most common failure cause to be a bad MIME type for the binary,\r\n            // in which case falling back to ArrayBuffer instantiation should work.\r\n            err('wasm streaming compile failed: ' + reason);\r\n            err('falling back to ArrayBuffer instantiation');\r\n            return instantiateArrayBuffer(receiveInstantiationResult);\r\n          });\r\n      });\r\n    } else {\r\n      return instantiateArrayBuffer(receiveInstantiationResult);\r\n    }\r\n  }\r\n\r\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\r\n  // to any other async startup actions they are performing.\r\n  // Also pthreads and wasm workers initialize the wasm instance through this path.\r\n  if (Module['instantiateWasm']) {\r\n    try {\r\n      var exports = Module['instantiateWasm'](info, receiveInstance);\r\n      return exports;\r\n    } catch(e) {\r\n      err('Module.instantiateWasm callback failed with error: ' + e);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If instantiation fails, reject the module ready promise.\r\n  instantiateAsync().catch(readyPromiseReject);\r\n  return {}; // no exports yet; we'll fill them in later\r\n}\r\n\r\n// Globals used by JS i64 conversions (see makeSetValue)\r\nvar tempDouble;\r\nvar tempI64;\r\n\r\n// === Body ===\r\n\r\nvar ASM_CONSTS = {\r\n  \r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n  function callRuntimeCallbacks(callbacks) {\r\n      while (callbacks.length > 0) {\r\n        var callback = callbacks.shift();\r\n        if (typeof callback == 'function') {\r\n          callback(Module); // Pass the module as the first argument.\r\n          continue;\r\n        }\r\n        var func = callback.func;\r\n        if (typeof func == 'number') {\r\n          if (callback.arg === undefined) {\r\n            // Run the wasm function ptr with signature 'v'. If no function\r\n            // with such signature was exported, this call does not need\r\n            // to be emitted (and would confuse Closure)\r\n            getWasmTableEntry(func)();\r\n          } else {\r\n            // If any function with signature 'vi' was exported, run\r\n            // the callback with that signature.\r\n            getWasmTableEntry(func)(callback.arg);\r\n          }\r\n        } else {\r\n          func(callback.arg === undefined ? null : callback.arg);\r\n        }\r\n      }\r\n    }\r\n\r\n  function withStackSave(f) {\r\n      var stack = stackSave();\r\n      var ret = f();\r\n      stackRestore(stack);\r\n      return ret;\r\n    }\r\n  function demangle(func) {\r\n      return func;\r\n    }\r\n\r\n  function demangleAll(text) {\r\n      var regex =\r\n        /\\b_Z[\\w\\d_]+/g;\r\n      return text.replace(regex,\r\n        function(x) {\r\n          var y = demangle(x);\r\n          return x === y ? x : (y + ' [' + x + ']');\r\n        });\r\n    }\r\n\r\n  \r\n    /** @param {number} ptr\r\n        @param {string} type\r\n        @param {number|boolean=} noSafe */\r\n  function getValue(ptr, type = 'i8', noSafe) {\r\n      if (type.endsWith('*')) type = 'u32';\r\n      switch (type) {\r\n        case 'i1': return HEAP8[((ptr)>>0)];\r\n        case 'i8': return HEAP8[((ptr)>>0)];\r\n        case 'i16': return HEAP16[((ptr)>>1)];\r\n        case 'i32': return HEAP32[((ptr)>>2)];\r\n        case 'i64': return HEAP32[((ptr)>>2)];\r\n        case 'float': return HEAPF32[((ptr)>>2)];\r\n        case 'double': return Number(HEAPF64[((ptr)>>3)]);\r\n        default: abort('invalid type for getValue: ' + type);\r\n      }\r\n      return null;\r\n    }\r\n\r\n  var wasmTableMirror = [];\r\n  function getWasmTableEntry(funcPtr) {\r\n      var func = wasmTableMirror[funcPtr];\r\n      if (!func) {\r\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\r\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\r\n      }\r\n      return func;\r\n    }\r\n\r\n  function handleException(e) {\r\n      // Certain exception types we do not treat as errors since they are used for\r\n      // internal control flow.\r\n      // 1. ExitStatus, which is thrown by exit()\r\n      // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\r\n      //    that wish to return to JS event loop.\r\n      if (e instanceof ExitStatus || e == 'unwind') {\r\n        return EXITSTATUS;\r\n      }\r\n      quit_(1, e);\r\n    }\r\n\r\n  function jsStackTrace() {\r\n      var error = new Error();\r\n      if (!error.stack) {\r\n        // IE10+ special cases: It does have callstack info, but it is only\r\n        // populated if an Error object is thrown, so try that as a special-case.\r\n        try {\r\n          throw new Error();\r\n        } catch(e) {\r\n          error = e;\r\n        }\r\n        if (!error.stack) {\r\n          return '(no stack trace available)';\r\n        }\r\n      }\r\n      return error.stack.toString();\r\n    }\r\n\r\n  \r\n    /** @param {number} ptr\r\n        @param {number} value\r\n        @param {string} type\r\n        @param {number|boolean=} noSafe */\r\n  function setValue(ptr, value, type = 'i8', noSafe) {\r\n      if (type.endsWith('*')) type = 'u32';\r\n      switch (type) {\r\n        case 'i1': HEAP8[((ptr)>>0)] = value; break;\r\n        case 'i8': HEAP8[((ptr)>>0)] = value; break;\r\n        case 'i16': HEAP16[((ptr)>>1)] = value; break;\r\n        case 'i32': HEAP32[((ptr)>>2)] = value; break;\r\n        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;\r\n        case 'float': HEAPF32[((ptr)>>2)] = value; break;\r\n        case 'double': HEAPF64[((ptr)>>3)] = value; break;\r\n        default: abort('invalid type for setValue: ' + type);\r\n      }\r\n    }\r\n\r\n  function setWasmTableEntry(idx, func) {\r\n      wasmTable.set(idx, func);\r\n      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped\r\n      // functions so we need to call it here to retrieve the potential wrapper correctly\r\n      // instead of just storing 'func' directly into wasmTableMirror\r\n      wasmTableMirror[idx] = wasmTable.get(idx);\r\n    }\r\n\r\n  function stackTrace() {\r\n      var js = jsStackTrace();\r\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\r\n      return demangleAll(js);\r\n    }\r\n\r\n  function ___assert_fail(condition, filename, line, func) {\r\n      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\r\n    }\r\n\r\n  function ___cxa_allocate_exception(size) {\r\n      // Thrown object is prepended by exception metadata block\r\n      return _malloc(size + 24) + 24;\r\n    }\r\n\r\n  /** @constructor */\r\n  function ExceptionInfo(excPtr) {\r\n      this.excPtr = excPtr;\r\n      this.ptr = excPtr - 24;\r\n  \r\n      this.set_type = function(type) {\r\n        HEAPU32[(((this.ptr)+(4))>>2)] = type;\r\n      };\r\n  \r\n      this.get_type = function() {\r\n        return HEAPU32[(((this.ptr)+(4))>>2)];\r\n      };\r\n  \r\n      this.set_destructor = function(destructor) {\r\n        HEAPU32[(((this.ptr)+(8))>>2)] = destructor;\r\n      };\r\n  \r\n      this.get_destructor = function() {\r\n        return HEAPU32[(((this.ptr)+(8))>>2)];\r\n      };\r\n  \r\n      this.set_refcount = function(refcount) {\r\n        HEAP32[((this.ptr)>>2)] = refcount;\r\n      };\r\n  \r\n      this.set_caught = function (caught) {\r\n        caught = caught ? 1 : 0;\r\n        HEAP8[(((this.ptr)+(12))>>0)] = caught;\r\n      };\r\n  \r\n      this.get_caught = function () {\r\n        return HEAP8[(((this.ptr)+(12))>>0)] != 0;\r\n      };\r\n  \r\n      this.set_rethrown = function (rethrown) {\r\n        rethrown = rethrown ? 1 : 0;\r\n        HEAP8[(((this.ptr)+(13))>>0)] = rethrown;\r\n      };\r\n  \r\n      this.get_rethrown = function () {\r\n        return HEAP8[(((this.ptr)+(13))>>0)] != 0;\r\n      };\r\n  \r\n      // Initialize native structure fields. Should be called once after allocated.\r\n      this.init = function(type, destructor) {\r\n        this.set_adjusted_ptr(0);\r\n        this.set_type(type);\r\n        this.set_destructor(destructor);\r\n        this.set_refcount(0);\r\n        this.set_caught(false);\r\n        this.set_rethrown(false);\r\n      }\r\n  \r\n      this.add_ref = function() {\r\n        var value = HEAP32[((this.ptr)>>2)];\r\n        HEAP32[((this.ptr)>>2)] = value + 1;\r\n      };\r\n  \r\n      // Returns true if last reference released.\r\n      this.release_ref = function() {\r\n        var prev = HEAP32[((this.ptr)>>2)];\r\n        HEAP32[((this.ptr)>>2)] = prev - 1;\r\n        return prev === 1;\r\n      };\r\n  \r\n      this.set_adjusted_ptr = function(adjustedPtr) {\r\n        HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;\r\n      };\r\n  \r\n      this.get_adjusted_ptr = function() {\r\n        return HEAPU32[(((this.ptr)+(16))>>2)];\r\n      };\r\n  \r\n      // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted\r\n      // when the pointer is casted to some of the exception object base classes (e.g. when virtual\r\n      // inheritance is used). When a pointer is thrown this method should return the thrown pointer\r\n      // itself.\r\n      this.get_exception_ptr = function() {\r\n        // Work around a fastcomp bug, this code is still included for some reason in a build without\r\n        // exceptions support.\r\n        var isPointer = ___cxa_is_pointer_type(this.get_type());\r\n        if (isPointer) {\r\n          return HEAPU32[((this.excPtr)>>2)];\r\n        }\r\n        var adjusted = this.get_adjusted_ptr();\r\n        if (adjusted !== 0) return adjusted;\r\n        return this.excPtr;\r\n      };\r\n    }\r\n  \r\n  var exceptionLast = 0;\r\n  \r\n  var uncaughtExceptionCount = 0;\r\n  function ___cxa_throw(ptr, type, destructor) {\r\n      var info = new ExceptionInfo(ptr);\r\n      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\r\n      info.init(type, destructor);\r\n      exceptionLast = ptr;\r\n      uncaughtExceptionCount++;\r\n      throw ptr;\r\n    }\r\n\r\n  var structRegistrations = {};\r\n  \r\n  function runDestructors(destructors) {\r\n      while (destructors.length) {\r\n        var ptr = destructors.pop();\r\n        var del = destructors.pop();\r\n        del(ptr);\r\n      }\r\n    }\r\n  \r\n  function simpleReadValueFromPointer(pointer) {\r\n      return this['fromWireType'](HEAPU32[pointer >> 2]);\r\n    }\r\n  \r\n  var awaitingDependencies = {};\r\n  \r\n  var registeredTypes = {};\r\n  \r\n  var typeDependencies = {};\r\n  \r\n  var char_0 = 48;\r\n  \r\n  var char_9 = 57;\r\n  function makeLegalFunctionName(name) {\r\n      if (undefined === name) {\r\n        return '_unknown';\r\n      }\r\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\r\n      var f = name.charCodeAt(0);\r\n      if (f >= char_0 && f <= char_9) {\r\n        return '_' + name;\r\n      }\r\n      return name;\r\n    }\r\n  function createNamedFunction(name, body) {\r\n      name = makeLegalFunctionName(name);\r\n      /*jshint evil:true*/\r\n      return new Function(\r\n          \"body\",\r\n          \"return function \" + name + \"() {\\n\" +\r\n          \"    \\\"use strict\\\";\" +\r\n          \"    return body.apply(this, arguments);\\n\" +\r\n          \"};\\n\"\r\n      )(body);\r\n    }\r\n  function extendError(baseErrorType, errorName) {\r\n      var errorClass = createNamedFunction(errorName, function(message) {\r\n          this.name = errorName;\r\n          this.message = message;\r\n  \r\n          var stack = (new Error(message)).stack;\r\n          if (stack !== undefined) {\r\n              this.stack = this.toString() + '\\n' +\r\n                  stack.replace(/^Error(:[^\\n]*)?\\n/, '');\r\n          }\r\n      });\r\n      errorClass.prototype = Object.create(baseErrorType.prototype);\r\n      errorClass.prototype.constructor = errorClass;\r\n      errorClass.prototype.toString = function() {\r\n          if (this.message === undefined) {\r\n              return this.name;\r\n          } else {\r\n              return this.name + ': ' + this.message;\r\n          }\r\n      };\r\n  \r\n      return errorClass;\r\n    }\r\n  var InternalError = undefined;\r\n  function throwInternalError(message) {\r\n      throw new InternalError(message);\r\n    }\r\n  function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\r\n      myTypes.forEach(function(type) {\r\n          typeDependencies[type] = dependentTypes;\r\n      });\r\n  \r\n      function onComplete(typeConverters) {\r\n          var myTypeConverters = getTypeConverters(typeConverters);\r\n          if (myTypeConverters.length !== myTypes.length) {\r\n              throwInternalError('Mismatched type converter count');\r\n          }\r\n          for (var i = 0; i < myTypes.length; ++i) {\r\n              registerType(myTypes[i], myTypeConverters[i]);\r\n          }\r\n      }\r\n  \r\n      var typeConverters = new Array(dependentTypes.length);\r\n      var unregisteredTypes = [];\r\n      var registered = 0;\r\n      dependentTypes.forEach((dt, i) => {\r\n        if (registeredTypes.hasOwnProperty(dt)) {\r\n          typeConverters[i] = registeredTypes[dt];\r\n        } else {\r\n          unregisteredTypes.push(dt);\r\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\r\n            awaitingDependencies[dt] = [];\r\n          }\r\n          awaitingDependencies[dt].push(() => {\r\n            typeConverters[i] = registeredTypes[dt];\r\n            ++registered;\r\n            if (registered === unregisteredTypes.length) {\r\n              onComplete(typeConverters);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      if (0 === unregisteredTypes.length) {\r\n        onComplete(typeConverters);\r\n      }\r\n    }\r\n  function __embind_finalize_value_object(structType) {\r\n      var reg = structRegistrations[structType];\r\n      delete structRegistrations[structType];\r\n  \r\n      var rawConstructor = reg.rawConstructor;\r\n      var rawDestructor = reg.rawDestructor;\r\n      var fieldRecords = reg.fields;\r\n      var fieldTypes = fieldRecords.map((field) => field.getterReturnType).\r\n                concat(fieldRecords.map((field) => field.setterArgumentType));\r\n      whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {\r\n        var fields = {};\r\n        fieldRecords.forEach((field, i) => {\r\n          var fieldName = field.fieldName;\r\n          var getterReturnType = fieldTypes[i];\r\n          var getter = field.getter;\r\n          var getterContext = field.getterContext;\r\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\r\n          var setter = field.setter;\r\n          var setterContext = field.setterContext;\r\n          fields[fieldName] = {\r\n            read: (ptr) => {\r\n              return getterReturnType['fromWireType'](\r\n                  getter(getterContext, ptr));\r\n            },\r\n            write: (ptr, o) => {\r\n              var destructors = [];\r\n              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));\r\n              runDestructors(destructors);\r\n            }\r\n          };\r\n        });\r\n  \r\n        return [{\r\n          name: reg.name,\r\n          'fromWireType': function(ptr) {\r\n            var rv = {};\r\n            for (var i in fields) {\r\n              rv[i] = fields[i].read(ptr);\r\n            }\r\n            rawDestructor(ptr);\r\n            return rv;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n            // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations:\r\n            // assume all fields are present without checking.\r\n            for (var fieldName in fields) {\r\n              if (!(fieldName in o)) {\r\n                throw new TypeError('Missing field:  \"' + fieldName + '\"');\r\n              }\r\n            }\r\n            var ptr = rawConstructor();\r\n            for (fieldName in fields) {\r\n              fields[fieldName].write(ptr, o[fieldName]);\r\n            }\r\n            if (destructors !== null) {\r\n              destructors.push(rawDestructor, ptr);\r\n            }\r\n            return ptr;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': simpleReadValueFromPointer,\r\n          destructorFunction: rawDestructor,\r\n        }];\r\n      });\r\n    }\r\n\r\n  function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\r\n\r\n  function getShiftFromSize(size) {\r\n      switch (size) {\r\n          case 1: return 0;\r\n          case 2: return 1;\r\n          case 4: return 2;\r\n          case 8: return 3;\r\n          default:\r\n              throw new TypeError('Unknown type size: ' + size);\r\n      }\r\n    }\r\n  \r\n  function embind_init_charCodes() {\r\n      var codes = new Array(256);\r\n      for (var i = 0; i < 256; ++i) {\r\n          codes[i] = String.fromCharCode(i);\r\n      }\r\n      embind_charCodes = codes;\r\n    }\r\n  var embind_charCodes = undefined;\r\n  function readLatin1String(ptr) {\r\n      var ret = \"\";\r\n      var c = ptr;\r\n      while (HEAPU8[c]) {\r\n          ret += embind_charCodes[HEAPU8[c++]];\r\n      }\r\n      return ret;\r\n    }\r\n  \r\n  var BindingError = undefined;\r\n  function throwBindingError(message) {\r\n      throw new BindingError(message);\r\n    }\r\n  /** @param {Object=} options */\r\n  function registerType(rawType, registeredInstance, options = {}) {\r\n      if (!('argPackAdvance' in registeredInstance)) {\r\n          throw new TypeError('registerType registeredInstance requires argPackAdvance');\r\n      }\r\n  \r\n      var name = registeredInstance.name;\r\n      if (!rawType) {\r\n          throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\r\n      }\r\n      if (registeredTypes.hasOwnProperty(rawType)) {\r\n          if (options.ignoreDuplicateRegistrations) {\r\n              return;\r\n          } else {\r\n              throwBindingError(\"Cannot register type '\" + name + \"' twice\");\r\n          }\r\n      }\r\n  \r\n      registeredTypes[rawType] = registeredInstance;\r\n      delete typeDependencies[rawType];\r\n  \r\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\r\n        var callbacks = awaitingDependencies[rawType];\r\n        delete awaitingDependencies[rawType];\r\n        callbacks.forEach((cb) => cb());\r\n      }\r\n    }\r\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\r\n      var shift = getShiftFromSize(size);\r\n  \r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          name: name,\r\n          'fromWireType': function(wt) {\r\n              // ambiguous emscripten ABI: sometimes return values are\r\n              // true or false, and sometimes integers (0 or 1)\r\n              return !!wt;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n              return o ? trueValue : falseValue;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': function(pointer) {\r\n              // TODO: if heap is fixed (like in asm.js) this could be executed outside\r\n              var heap;\r\n              if (size === 1) {\r\n                  heap = HEAP8;\r\n              } else if (size === 2) {\r\n                  heap = HEAP16;\r\n              } else if (size === 4) {\r\n                  heap = HEAP32;\r\n              } else {\r\n                  throw new TypeError(\"Unknown boolean type size: \" + name);\r\n              }\r\n              return this['fromWireType'](heap[pointer >> shift]);\r\n          },\r\n          destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  function ClassHandle_isAliasOf(other) {\r\n      if (!(this instanceof ClassHandle)) {\r\n        return false;\r\n      }\r\n      if (!(other instanceof ClassHandle)) {\r\n        return false;\r\n      }\r\n  \r\n      var leftClass = this.$$.ptrType.registeredClass;\r\n      var left = this.$$.ptr;\r\n      var rightClass = other.$$.ptrType.registeredClass;\r\n      var right = other.$$.ptr;\r\n  \r\n      while (leftClass.baseClass) {\r\n        left = leftClass.upcast(left);\r\n        leftClass = leftClass.baseClass;\r\n      }\r\n  \r\n      while (rightClass.baseClass) {\r\n        right = rightClass.upcast(right);\r\n        rightClass = rightClass.baseClass;\r\n      }\r\n  \r\n      return leftClass === rightClass && left === right;\r\n    }\r\n  \r\n  function shallowCopyInternalPointer(o) {\r\n      return {\r\n          count: o.count,\r\n          deleteScheduled: o.deleteScheduled,\r\n          preservePointerOnDelete: o.preservePointerOnDelete,\r\n          ptr: o.ptr,\r\n          ptrType: o.ptrType,\r\n          smartPtr: o.smartPtr,\r\n          smartPtrType: o.smartPtrType,\r\n      };\r\n    }\r\n  \r\n  function throwInstanceAlreadyDeleted(obj) {\r\n      function getInstanceTypeName(handle) {\r\n        return handle.$$.ptrType.registeredClass.name;\r\n      }\r\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\r\n    }\r\n  \r\n  var finalizationRegistry = false;\r\n  \r\n  function detachFinalizer(handle) {}\r\n  \r\n  function runDestructor($$) {\r\n      if ($$.smartPtr) {\r\n          $$.smartPtrType.rawDestructor($$.smartPtr);\r\n      } else {\r\n          $$.ptrType.registeredClass.rawDestructor($$.ptr);\r\n      }\r\n    }\r\n  function releaseClassHandle($$) {\r\n      $$.count.value -= 1;\r\n      var toDelete = 0 === $$.count.value;\r\n      if (toDelete) {\r\n        runDestructor($$);\r\n      }\r\n    }\r\n  \r\n  function downcastPointer(ptr, ptrClass, desiredClass) {\r\n      if (ptrClass === desiredClass) {\r\n        return ptr;\r\n      }\r\n      if (undefined === desiredClass.baseClass) {\r\n        return null; // no conversion\r\n      }\r\n  \r\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\r\n      if (rv === null) {\r\n          return null;\r\n      }\r\n      return desiredClass.downcast(rv);\r\n    }\r\n  \r\n  var registeredPointers = {};\r\n  \r\n  function getInheritedInstanceCount() {\r\n      return Object.keys(registeredInstances).length;\r\n    }\r\n  \r\n  function getLiveInheritedInstances() {\r\n      var rv = [];\r\n      for (var k in registeredInstances) {\r\n          if (registeredInstances.hasOwnProperty(k)) {\r\n              rv.push(registeredInstances[k]);\r\n          }\r\n      }\r\n      return rv;\r\n    }\r\n  \r\n  var deletionQueue = [];\r\n  function flushPendingDeletes() {\r\n      while (deletionQueue.length) {\r\n        var obj = deletionQueue.pop();\r\n        obj.$$.deleteScheduled = false;\r\n        obj['delete']();\r\n      }\r\n    }\r\n  \r\n  var delayFunction = undefined;\r\n  function setDelayFunction(fn) {\r\n      delayFunction = fn;\r\n      if (deletionQueue.length && delayFunction) {\r\n        delayFunction(flushPendingDeletes);\r\n      }\r\n    }\r\n  function init_embind() {\r\n      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;\r\n      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;\r\n      Module['flushPendingDeletes'] = flushPendingDeletes;\r\n      Module['setDelayFunction'] = setDelayFunction;\r\n    }\r\n  var registeredInstances = {};\r\n  \r\n  function getBasestPointer(class_, ptr) {\r\n      if (ptr === undefined) {\r\n          throwBindingError('ptr should not be undefined');\r\n      }\r\n      while (class_.baseClass) {\r\n          ptr = class_.upcast(ptr);\r\n          class_ = class_.baseClass;\r\n      }\r\n      return ptr;\r\n    }\r\n  function getInheritedInstance(class_, ptr) {\r\n      ptr = getBasestPointer(class_, ptr);\r\n      return registeredInstances[ptr];\r\n    }\r\n  \r\n  function makeClassHandle(prototype, record) {\r\n      if (!record.ptrType || !record.ptr) {\r\n        throwInternalError('makeClassHandle requires ptr and ptrType');\r\n      }\r\n      var hasSmartPtrType = !!record.smartPtrType;\r\n      var hasSmartPtr = !!record.smartPtr;\r\n      if (hasSmartPtrType !== hasSmartPtr) {\r\n        throwInternalError('Both smartPtrType and smartPtr must be specified');\r\n      }\r\n      record.count = { value: 1 };\r\n      return attachFinalizer(Object.create(prototype, {\r\n        $$: {\r\n            value: record,\r\n        },\r\n      }));\r\n    }\r\n  function RegisteredPointer_fromWireType(ptr) {\r\n      // ptr is a raw pointer (or a raw smartpointer)\r\n  \r\n      // rawPointer is a maybe-null raw pointer\r\n      var rawPointer = this.getPointee(ptr);\r\n      if (!rawPointer) {\r\n        this.destructor(ptr);\r\n        return null;\r\n      }\r\n  \r\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\r\n      if (undefined !== registeredInstance) {\r\n        // JS object has been neutered, time to repopulate it\r\n        if (0 === registeredInstance.$$.count.value) {\r\n          registeredInstance.$$.ptr = rawPointer;\r\n          registeredInstance.$$.smartPtr = ptr;\r\n          return registeredInstance['clone']();\r\n        } else {\r\n          // else, just increment reference count on existing object\r\n          // it already has a reference to the smart pointer\r\n          var rv = registeredInstance['clone']();\r\n          this.destructor(ptr);\r\n          return rv;\r\n        }\r\n      }\r\n  \r\n      function makeDefaultHandle() {\r\n        if (this.isSmartPointer) {\r\n          return makeClassHandle(this.registeredClass.instancePrototype, {\r\n            ptrType: this.pointeeType,\r\n            ptr: rawPointer,\r\n            smartPtrType: this,\r\n            smartPtr: ptr,\r\n          });\r\n        } else {\r\n          return makeClassHandle(this.registeredClass.instancePrototype, {\r\n            ptrType: this,\r\n            ptr: ptr,\r\n          });\r\n        }\r\n      }\r\n  \r\n      var actualType = this.registeredClass.getActualType(rawPointer);\r\n      var registeredPointerRecord = registeredPointers[actualType];\r\n      if (!registeredPointerRecord) {\r\n        return makeDefaultHandle.call(this);\r\n      }\r\n  \r\n      var toType;\r\n      if (this.isConst) {\r\n        toType = registeredPointerRecord.constPointerType;\r\n      } else {\r\n        toType = registeredPointerRecord.pointerType;\r\n      }\r\n      var dp = downcastPointer(\r\n          rawPointer,\r\n          this.registeredClass,\r\n          toType.registeredClass);\r\n      if (dp === null) {\r\n          return makeDefaultHandle.call(this);\r\n      }\r\n      if (this.isSmartPointer) {\r\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n          ptrType: toType,\r\n          ptr: dp,\r\n          smartPtrType: this,\r\n          smartPtr: ptr,\r\n        });\r\n      } else {\r\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n          ptrType: toType,\r\n          ptr: dp,\r\n        });\r\n      }\r\n    }\r\n  function attachFinalizer(handle) {\r\n      if ('undefined' === typeof FinalizationRegistry) {\r\n          attachFinalizer = (handle) => handle;\r\n          return handle;\r\n      }\r\n      // If the running environment has a FinalizationRegistry (see\r\n      // https://github.com/tc39/proposal-weakrefs), then attach finalizers\r\n      // for class handles.  We check for the presence of FinalizationRegistry\r\n      // at run-time, not build-time.\r\n      finalizationRegistry = new FinalizationRegistry((info) => {\r\n          releaseClassHandle(info.$$);\r\n      });\r\n      attachFinalizer = (handle) => {\r\n        var $$ = handle.$$;\r\n        var hasSmartPtr = !!$$.smartPtr;\r\n        if (hasSmartPtr) {\r\n          // We should not call the destructor on raw pointers in case other code expects the pointee to live\r\n          var info = { $$: $$ };\r\n          finalizationRegistry.register(handle, info, handle);\r\n        }\r\n        return handle;\r\n      };\r\n      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);\r\n      return attachFinalizer(handle);\r\n    }\r\n  function ClassHandle_clone() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n  \r\n      if (this.$$.preservePointerOnDelete) {\r\n        this.$$.count.value += 1;\r\n        return this;\r\n      } else {\r\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\r\n          $$: {\r\n            value: shallowCopyInternalPointer(this.$$),\r\n          }\r\n        }));\r\n  \r\n        clone.$$.count.value += 1;\r\n        clone.$$.deleteScheduled = false;\r\n        return clone;\r\n      }\r\n    }\r\n  \r\n  function ClassHandle_delete() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n  \r\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n        throwBindingError('Object already scheduled for deletion');\r\n      }\r\n  \r\n      detachFinalizer(this);\r\n      releaseClassHandle(this.$$);\r\n  \r\n      if (!this.$$.preservePointerOnDelete) {\r\n        this.$$.smartPtr = undefined;\r\n        this.$$.ptr = undefined;\r\n      }\r\n    }\r\n  \r\n  function ClassHandle_isDeleted() {\r\n      return !this.$$.ptr;\r\n    }\r\n  \r\n  function ClassHandle_deleteLater() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n        throwBindingError('Object already scheduled for deletion');\r\n      }\r\n      deletionQueue.push(this);\r\n      if (deletionQueue.length === 1 && delayFunction) {\r\n        delayFunction(flushPendingDeletes);\r\n      }\r\n      this.$$.deleteScheduled = true;\r\n      return this;\r\n    }\r\n  function init_ClassHandle() {\r\n      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;\r\n      ClassHandle.prototype['clone'] = ClassHandle_clone;\r\n      ClassHandle.prototype['delete'] = ClassHandle_delete;\r\n      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;\r\n      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;\r\n    }\r\n  function ClassHandle() {\r\n    }\r\n  \r\n  function ensureOverloadTable(proto, methodName, humanName) {\r\n      if (undefined === proto[methodName].overloadTable) {\r\n        var prevFunc = proto[methodName];\r\n        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\r\n        proto[methodName] = function() {\r\n          // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\r\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\r\n              throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\r\n          }\r\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\r\n        };\r\n        // Move the previous function into the overload table.\r\n        proto[methodName].overloadTable = [];\r\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\r\n      }\r\n    }\r\n  /** @param {number=} numArguments */\r\n  function exposePublicSymbol(name, value, numArguments) {\r\n      if (Module.hasOwnProperty(name)) {\r\n        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\r\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\r\n        }\r\n  \r\n        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\r\n        // that routes between the two.\r\n        ensureOverloadTable(Module, name, name);\r\n        if (Module.hasOwnProperty(numArguments)) {\r\n            throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\r\n        }\r\n        // Add the new function into the overload table.\r\n        Module[name].overloadTable[numArguments] = value;\r\n      }\r\n      else {\r\n        Module[name] = value;\r\n        if (undefined !== numArguments) {\r\n          Module[name].numArguments = numArguments;\r\n        }\r\n      }\r\n    }\r\n  \r\n  /** @constructor */\r\n  function RegisteredClass(name,\r\n                               constructor,\r\n                               instancePrototype,\r\n                               rawDestructor,\r\n                               baseClass,\r\n                               getActualType,\r\n                               upcast,\r\n                               downcast) {\r\n      this.name = name;\r\n      this.constructor = constructor;\r\n      this.instancePrototype = instancePrototype;\r\n      this.rawDestructor = rawDestructor;\r\n      this.baseClass = baseClass;\r\n      this.getActualType = getActualType;\r\n      this.upcast = upcast;\r\n      this.downcast = downcast;\r\n      this.pureVirtualFunctions = [];\r\n    }\r\n  \r\n  function upcastPointer(ptr, ptrClass, desiredClass) {\r\n      while (ptrClass !== desiredClass) {\r\n        if (!ptrClass.upcast) {\r\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\r\n        }\r\n        ptr = ptrClass.upcast(ptr);\r\n        ptrClass = ptrClass.baseClass;\r\n      }\r\n      return ptr;\r\n    }\r\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError('null is not a valid ' + this.name);\r\n        }\r\n        return 0;\r\n      }\r\n  \r\n      if (!handle.$$) {\r\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n      return ptr;\r\n    }\r\n  \r\n  function genericPointerToWireType(destructors, handle) {\r\n      var ptr;\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError('null is not a valid ' + this.name);\r\n        }\r\n  \r\n        if (this.isSmartPointer) {\r\n          ptr = this.rawConstructor();\r\n          if (destructors !== null) {\r\n            destructors.push(this.rawDestructor, ptr);\r\n          }\r\n          return ptr;\r\n        } else {\r\n          return 0;\r\n        }\r\n      }\r\n  \r\n      if (!handle.$$) {\r\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\r\n      }\r\n      if (!this.isConst && handle.$$.ptrType.isConst) {\r\n        throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n  \r\n      if (this.isSmartPointer) {\r\n        // TODO: this is not strictly true\r\n        // We could support BY_EMVAL conversions from raw pointers to smart pointers\r\n        // because the smart pointer can hold a reference to the handle\r\n        if (undefined === handle.$$.smartPtr) {\r\n          throwBindingError('Passing raw pointer to smart pointer is illegal');\r\n        }\r\n  \r\n        switch (this.sharingPolicy) {\r\n          case 0: // NONE\r\n            // no upcasting\r\n            if (handle.$$.smartPtrType === this) {\r\n              ptr = handle.$$.smartPtr;\r\n            } else {\r\n              throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\r\n            }\r\n            break;\r\n  \r\n          case 1: // INTRUSIVE\r\n            ptr = handle.$$.smartPtr;\r\n            break;\r\n  \r\n          case 2: // BY_EMVAL\r\n            if (handle.$$.smartPtrType === this) {\r\n              ptr = handle.$$.smartPtr;\r\n            } else {\r\n              var clonedHandle = handle['clone']();\r\n              ptr = this.rawShare(\r\n                ptr,\r\n                Emval.toHandle(function() {\r\n                  clonedHandle['delete']();\r\n                })\r\n              );\r\n              if (destructors !== null) {\r\n                destructors.push(this.rawDestructor, ptr);\r\n              }\r\n            }\r\n            break;\r\n  \r\n          default:\r\n            throwBindingError('Unsupporting sharing policy');\r\n        }\r\n      }\r\n      return ptr;\r\n    }\r\n  \r\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError('null is not a valid ' + this.name);\r\n        }\r\n        return 0;\r\n      }\r\n  \r\n      if (!handle.$$) {\r\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\r\n      }\r\n      if (handle.$$.ptrType.isConst) {\r\n          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n      return ptr;\r\n    }\r\n  \r\n  function RegisteredPointer_getPointee(ptr) {\r\n      if (this.rawGetPointee) {\r\n        ptr = this.rawGetPointee(ptr);\r\n      }\r\n      return ptr;\r\n    }\r\n  \r\n  function RegisteredPointer_destructor(ptr) {\r\n      if (this.rawDestructor) {\r\n        this.rawDestructor(ptr);\r\n      }\r\n    }\r\n  \r\n  function RegisteredPointer_deleteObject(handle) {\r\n      if (handle !== null) {\r\n        handle['delete']();\r\n      }\r\n    }\r\n  function init_RegisteredPointer() {\r\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\r\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\r\n      RegisteredPointer.prototype['argPackAdvance'] = 8;\r\n      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;\r\n      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;\r\n      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;\r\n    }\r\n  /** @constructor\r\n      @param {*=} pointeeType,\r\n      @param {*=} sharingPolicy,\r\n      @param {*=} rawGetPointee,\r\n      @param {*=} rawConstructor,\r\n      @param {*=} rawShare,\r\n      @param {*=} rawDestructor,\r\n       */\r\n  function RegisteredPointer(\r\n      name,\r\n      registeredClass,\r\n      isReference,\r\n      isConst,\r\n  \r\n      // smart pointer properties\r\n      isSmartPointer,\r\n      pointeeType,\r\n      sharingPolicy,\r\n      rawGetPointee,\r\n      rawConstructor,\r\n      rawShare,\r\n      rawDestructor\r\n    ) {\r\n      this.name = name;\r\n      this.registeredClass = registeredClass;\r\n      this.isReference = isReference;\r\n      this.isConst = isConst;\r\n  \r\n      // smart pointer properties\r\n      this.isSmartPointer = isSmartPointer;\r\n      this.pointeeType = pointeeType;\r\n      this.sharingPolicy = sharingPolicy;\r\n      this.rawGetPointee = rawGetPointee;\r\n      this.rawConstructor = rawConstructor;\r\n      this.rawShare = rawShare;\r\n      this.rawDestructor = rawDestructor;\r\n  \r\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\r\n        if (isConst) {\r\n          this['toWireType'] = constNoSmartPtrRawPointerToWireType;\r\n          this.destructorFunction = null;\r\n        } else {\r\n          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\r\n          this.destructorFunction = null;\r\n        }\r\n      } else {\r\n        this['toWireType'] = genericPointerToWireType;\r\n        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns\r\n        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.\r\n        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in\r\n        //       craftInvokerFunction altogether.\r\n      }\r\n    }\r\n  \r\n  /** @param {number=} numArguments */\r\n  function replacePublicSymbol(name, value, numArguments) {\r\n      if (!Module.hasOwnProperty(name)) {\r\n        throwInternalError('Replacing nonexistant public symbol');\r\n      }\r\n      // If there's an overload table for this symbol, replace the symbol in the overload table instead.\r\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\r\n        Module[name].overloadTable[numArguments] = value;\r\n      }\r\n      else {\r\n        Module[name] = value;\r\n        Module[name].argCount = numArguments;\r\n      }\r\n    }\r\n  \r\n  function dynCallLegacy(sig, ptr, args) {\r\n      var f = Module[\"dynCall_\" + sig];\r\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\r\n    }\r\n  /** @param {Object=} args */\r\n  function dynCall(sig, ptr, args) {\r\n      // Without WASM_BIGINT support we cannot directly call function with i64 as\r\n      // part of thier signature, so we rely the dynCall functions generated by\r\n      // wasm-emscripten-finalize\r\n      if (sig.includes('j')) {\r\n        return dynCallLegacy(sig, ptr, args);\r\n      }\r\n      return getWasmTableEntry(ptr).apply(null, args)\r\n    }\r\n  function getDynCaller(sig, ptr) {\r\n      var argCache = [];\r\n      return function() {\r\n        argCache.length = 0;\r\n        Object.assign(argCache, arguments);\r\n        return dynCall(sig, ptr, argCache);\r\n      };\r\n    }\r\n  function embind__requireFunction(signature, rawFunction) {\r\n      signature = readLatin1String(signature);\r\n  \r\n      function makeDynCaller() {\r\n        if (signature.includes('j')) {\r\n          return getDynCaller(signature, rawFunction);\r\n        }\r\n        return getWasmTableEntry(rawFunction);\r\n      }\r\n  \r\n      var fp = makeDynCaller();\r\n      if (typeof fp != \"function\") {\r\n          throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\r\n      }\r\n      return fp;\r\n    }\r\n  \r\n  var UnboundTypeError = undefined;\r\n  \r\n  function getTypeName(type) {\r\n      var ptr = ___getTypeName(type);\r\n      var rv = readLatin1String(ptr);\r\n      _free(ptr);\r\n      return rv;\r\n    }\r\n  function throwUnboundTypeError(message, types) {\r\n      var unboundTypes = [];\r\n      var seen = {};\r\n      function visit(type) {\r\n        if (seen[type]) {\r\n          return;\r\n        }\r\n        if (registeredTypes[type]) {\r\n          return;\r\n        }\r\n        if (typeDependencies[type]) {\r\n          typeDependencies[type].forEach(visit);\r\n          return;\r\n        }\r\n        unboundTypes.push(type);\r\n        seen[type] = true;\r\n      }\r\n      types.forEach(visit);\r\n  \r\n      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));\r\n    }\r\n  function __embind_register_class(rawType,\r\n                                     rawPointerType,\r\n                                     rawConstPointerType,\r\n                                     baseClassRawType,\r\n                                     getActualTypeSignature,\r\n                                     getActualType,\r\n                                     upcastSignature,\r\n                                     upcast,\r\n                                     downcastSignature,\r\n                                     downcast,\r\n                                     name,\r\n                                     destructorSignature,\r\n                                     rawDestructor) {\r\n      name = readLatin1String(name);\r\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\r\n      if (upcast) {\r\n        upcast = embind__requireFunction(upcastSignature, upcast);\r\n      }\r\n      if (downcast) {\r\n        downcast = embind__requireFunction(downcastSignature, downcast);\r\n      }\r\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\r\n      var legalFunctionName = makeLegalFunctionName(name);\r\n  \r\n      exposePublicSymbol(legalFunctionName, function() {\r\n        // this code cannot run if baseClassRawType is zero\r\n        throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);\r\n      });\r\n  \r\n      whenDependentTypesAreResolved(\r\n        [rawType, rawPointerType, rawConstPointerType],\r\n        baseClassRawType ? [baseClassRawType] : [],\r\n        function(base) {\r\n          base = base[0];\r\n  \r\n          var baseClass;\r\n          var basePrototype;\r\n          if (baseClassRawType) {\r\n            baseClass = base.registeredClass;\r\n            basePrototype = baseClass.instancePrototype;\r\n          } else {\r\n            basePrototype = ClassHandle.prototype;\r\n          }\r\n  \r\n          var constructor = createNamedFunction(legalFunctionName, function() {\r\n            if (Object.getPrototypeOf(this) !== instancePrototype) {\r\n              throw new BindingError(\"Use 'new' to construct \" + name);\r\n            }\r\n            if (undefined === registeredClass.constructor_body) {\r\n              throw new BindingError(name + \" has no accessible constructor\");\r\n            }\r\n            var body = registeredClass.constructor_body[arguments.length];\r\n            if (undefined === body) {\r\n              throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\r\n            }\r\n            return body.apply(this, arguments);\r\n          });\r\n  \r\n          var instancePrototype = Object.create(basePrototype, {\r\n            constructor: { value: constructor },\r\n          });\r\n  \r\n          constructor.prototype = instancePrototype;\r\n  \r\n          var registeredClass = new RegisteredClass(name,\r\n                                                    constructor,\r\n                                                    instancePrototype,\r\n                                                    rawDestructor,\r\n                                                    baseClass,\r\n                                                    getActualType,\r\n                                                    upcast,\r\n                                                    downcast);\r\n  \r\n          var referenceConverter = new RegisteredPointer(name,\r\n                                                         registeredClass,\r\n                                                         true,\r\n                                                         false,\r\n                                                         false);\r\n  \r\n          var pointerConverter = new RegisteredPointer(name + '*',\r\n                                                       registeredClass,\r\n                                                       false,\r\n                                                       false,\r\n                                                       false);\r\n  \r\n          var constPointerConverter = new RegisteredPointer(name + ' const*',\r\n                                                            registeredClass,\r\n                                                            false,\r\n                                                            true,\r\n                                                            false);\r\n  \r\n          registeredPointers[rawType] = {\r\n            pointerType: pointerConverter,\r\n            constPointerType: constPointerConverter\r\n          };\r\n  \r\n          replacePublicSymbol(legalFunctionName, constructor);\r\n  \r\n          return [referenceConverter, pointerConverter, constPointerConverter];\r\n        }\r\n      );\r\n    }\r\n\r\n  function new_(constructor, argumentList) {\r\n      if (!(constructor instanceof Function)) {\r\n        throw new TypeError('new_ called with constructor type ' + typeof(constructor) + \" which is not a function\");\r\n      }\r\n      /*\r\n       * Previously, the following line was just:\r\n       *   function dummy() {};\r\n       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even\r\n       * though at creation, the 'dummy' has the correct constructor name.  Thus,\r\n       * objects created with IMVU.new would show up in the debugger as 'dummy',\r\n       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the\r\n       * issue.  Doublely-unfortunately, there's no way to write a test for this\r\n       * behavior.  -NRD 2013.02.22\r\n       */\r\n      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});\r\n      dummy.prototype = constructor.prototype;\r\n      var obj = new dummy;\r\n  \r\n      var r = constructor.apply(obj, argumentList);\r\n      return (r instanceof Object) ? r : obj;\r\n    }\r\n  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\r\n      // humanName: a human-readable string name for the function to be generated.\r\n      // argTypes: An array that contains the embind type objects for all types in the function signature.\r\n      //    argTypes[0] is the type object for the function return value.\r\n      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\r\n      //    argTypes[2...] are the actual function parameters.\r\n      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\r\n      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\r\n      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\r\n      var argCount = argTypes.length;\r\n  \r\n      if (argCount < 2) {\r\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\r\n      }\r\n  \r\n      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);\r\n  \r\n      // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\r\n  // TODO: This omits argument count check - enable only at -O3 or similar.\r\n  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\r\n  //       return FUNCTION_TABLE[fn];\r\n  //    }\r\n  \r\n      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\r\n      // TODO: Remove this completely once all function invokers are being dynamically generated.\r\n      var needsDestructorStack = false;\r\n  \r\n      for (var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.\r\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack\r\n          needsDestructorStack = true;\r\n          break;\r\n        }\r\n      }\r\n  \r\n      var returns = (argTypes[0].name !== \"void\");\r\n  \r\n      var argsList = \"\";\r\n      var argsListWired = \"\";\r\n      for (var i = 0; i < argCount - 2; ++i) {\r\n        argsList += (i!==0?\", \":\"\")+\"arg\"+i;\r\n        argsListWired += (i!==0?\", \":\"\")+\"arg\"+i+\"Wired\";\r\n      }\r\n  \r\n      var invokerFnBody =\r\n          \"return function \"+makeLegalFunctionName(humanName)+\"(\"+argsList+\") {\\n\" +\r\n          \"if (arguments.length !== \"+(argCount - 2)+\") {\\n\" +\r\n              \"throwBindingError('function \"+humanName+\" called with ' + arguments.length + ' arguments, expected \"+(argCount - 2)+\" args!');\\n\" +\r\n          \"}\\n\";\r\n  \r\n      if (needsDestructorStack) {\r\n        invokerFnBody += \"var destructors = [];\\n\";\r\n      }\r\n  \r\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\r\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\r\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\r\n  \r\n      if (isClassMethodFunc) {\r\n        invokerFnBody += \"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\";\r\n      }\r\n  \r\n      for (var i = 0; i < argCount - 2; ++i) {\r\n        invokerFnBody += \"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";\r\n        args1.push(\"argType\"+i);\r\n        args2.push(argTypes[i+2]);\r\n      }\r\n  \r\n      if (isClassMethodFunc) {\r\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\r\n      }\r\n  \r\n      invokerFnBody +=\r\n          (returns?\"var rv = \":\"\") + \"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";\r\n  \r\n      if (needsDestructorStack) {\r\n        invokerFnBody += \"runDestructors(destructors);\\n\";\r\n      } else {\r\n        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\r\n          var paramName = (i === 1 ? \"thisWired\" : (\"arg\"+(i - 2)+\"Wired\"));\r\n          if (argTypes[i].destructorFunction !== null) {\r\n            invokerFnBody += paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";\r\n            args1.push(paramName+\"_dtor\");\r\n            args2.push(argTypes[i].destructorFunction);\r\n          }\r\n        }\r\n      }\r\n  \r\n      if (returns) {\r\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" +\r\n                         \"return ret;\\n\";\r\n      } else {\r\n      }\r\n  \r\n      invokerFnBody += \"}\\n\";\r\n  \r\n      args1.push(invokerFnBody);\r\n  \r\n      var invokerFunction = new_(Function, args1).apply(null, args2);\r\n      return invokerFunction;\r\n    }\r\n  \r\n  function heap32VectorToArray(count, firstElement) {\r\n      var array = [];\r\n      for (var i = 0; i < count; i++) {\r\n          array.push(HEAP32[(firstElement >> 2) + i]);\r\n      }\r\n      return array;\r\n    }\r\n  function __embind_register_class_class_function(rawClassType,\r\n                                                    methodName,\r\n                                                    argCount,\r\n                                                    rawArgTypesAddr,\r\n                                                    invokerSignature,\r\n                                                    rawInvoker,\r\n                                                    fn) {\r\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n      methodName = readLatin1String(methodName);\r\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\r\n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\r\n        classType = classType[0];\r\n        var humanName = classType.name + '.' + methodName;\r\n  \r\n        function unboundTypesHandler() {\r\n          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);\r\n        }\r\n  \r\n        if (methodName.startsWith(\"@@\")) {\r\n          methodName = Symbol[methodName.substring(2)];\r\n        }\r\n  \r\n        var proto = classType.registeredClass.constructor;\r\n        if (undefined === proto[methodName]) {\r\n          // This is the first function to be registered with this name.\r\n          unboundTypesHandler.argCount = argCount-1;\r\n          proto[methodName] = unboundTypesHandler;\r\n        } else {\r\n          // There was an existing function with the same name registered. Set up\r\n          // a function overload routing table.\r\n          ensureOverloadTable(proto, methodName, humanName);\r\n          proto[methodName].overloadTable[argCount-1] = unboundTypesHandler;\r\n        }\r\n  \r\n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\r\n          // Replace the initial unbound-types-handler stub with the proper\r\n          // function. If multiple overloads are registered, the function handlers\r\n          // go into an overload table.\r\n          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);\r\n          var func = craftInvokerFunction(humanName, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn);\r\n          if (undefined === proto[methodName].overloadTable) {\r\n            func.argCount = argCount-1;\r\n            proto[methodName] = func;\r\n          } else {\r\n            proto[methodName].overloadTable[argCount-1] = func;\r\n          }\r\n          return [];\r\n        });\r\n        return [];\r\n      });\r\n    }\r\n\r\n  function __embind_register_class_constructor(\r\n      rawClassType,\r\n      argCount,\r\n      rawArgTypesAddr,\r\n      invokerSignature,\r\n      invoker,\r\n      rawConstructor\r\n    ) {\r\n      assert(argCount > 0);\r\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n      invoker = embind__requireFunction(invokerSignature, invoker);\r\n      var args = [rawConstructor];\r\n      var destructors = [];\r\n  \r\n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\r\n        classType = classType[0];\r\n        var humanName = 'constructor ' + classType.name;\r\n  \r\n        if (undefined === classType.registeredClass.constructor_body) {\r\n          classType.registeredClass.constructor_body = [];\r\n        }\r\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\r\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount-1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\r\n        }\r\n        classType.registeredClass.constructor_body[argCount - 1] = () => {\r\n          throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);\r\n        };\r\n  \r\n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\r\n          // Insert empty slot for context type (argTypes[1]).\r\n          argTypes.splice(1, 0, null);\r\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\r\n          return [];\r\n        });\r\n        return [];\r\n      });\r\n    }\r\n\r\n  function __embind_register_class_function(rawClassType,\r\n                                              methodName,\r\n                                              argCount,\r\n                                              rawArgTypesAddr, // [ReturnType, ThisType, Args...]\r\n                                              invokerSignature,\r\n                                              rawInvoker,\r\n                                              context,\r\n                                              isPureVirtual) {\r\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n      methodName = readLatin1String(methodName);\r\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\r\n  \r\n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\r\n        classType = classType[0];\r\n        var humanName = classType.name + '.' + methodName;\r\n  \r\n        if (methodName.startsWith(\"@@\")) {\r\n          methodName = Symbol[methodName.substring(2)];\r\n        }\r\n  \r\n        if (isPureVirtual) {\r\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\r\n        }\r\n  \r\n        function unboundTypesHandler() {\r\n          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);\r\n        }\r\n  \r\n        var proto = classType.registeredClass.instancePrototype;\r\n        var method = proto[methodName];\r\n        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {\r\n          // This is the first overload to be registered, OR we are replacing a\r\n          // function in the base class with a function in the derived class.\r\n          unboundTypesHandler.argCount = argCount - 2;\r\n          unboundTypesHandler.className = classType.name;\r\n          proto[methodName] = unboundTypesHandler;\r\n        } else {\r\n          // There was an existing function with the same name registered. Set up\r\n          // a function overload routing table.\r\n          ensureOverloadTable(proto, methodName, humanName);\r\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\r\n        }\r\n  \r\n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\r\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\r\n  \r\n          // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types\r\n          // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.\r\n          if (undefined === proto[methodName].overloadTable) {\r\n            // Set argCount in case an overload is registered later\r\n            memberFunction.argCount = argCount - 2;\r\n            proto[methodName] = memberFunction;\r\n          } else {\r\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\r\n          }\r\n  \r\n          return [];\r\n        });\r\n        return [];\r\n      });\r\n    }\r\n\r\n  var emval_free_list = [];\r\n  \r\n  var emval_handle_array = [{},{value:undefined},{value:null},{value:true},{value:false}];\r\n  function __emval_decref(handle) {\r\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\r\n        emval_handle_array[handle] = undefined;\r\n        emval_free_list.push(handle);\r\n      }\r\n    }\r\n  \r\n  function count_emval_handles() {\r\n      var count = 0;\r\n      for (var i = 5; i < emval_handle_array.length; ++i) {\r\n        if (emval_handle_array[i] !== undefined) {\r\n          ++count;\r\n        }\r\n      }\r\n      return count;\r\n    }\r\n  \r\n  function get_first_emval() {\r\n      for (var i = 5; i < emval_handle_array.length; ++i) {\r\n        if (emval_handle_array[i] !== undefined) {\r\n          return emval_handle_array[i];\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n  function init_emval() {\r\n      Module['count_emval_handles'] = count_emval_handles;\r\n      Module['get_first_emval'] = get_first_emval;\r\n    }\r\n  var Emval = {toValue:(handle) => {\r\n        if (!handle) {\r\n            throwBindingError('Cannot use deleted val. handle = ' + handle);\r\n        }\r\n        return emval_handle_array[handle].value;\r\n      },toHandle:(value) => {\r\n        switch (value) {\r\n          case undefined: return 1;\r\n          case null: return 2;\r\n          case true: return 3;\r\n          case false: return 4;\r\n          default:{\r\n            var handle = emval_free_list.length ?\r\n                emval_free_list.pop() :\r\n                emval_handle_array.length;\r\n  \r\n            emval_handle_array[handle] = {refcount: 1, value: value};\r\n            return handle;\r\n          }\r\n        }\r\n      }};\r\n  function __embind_register_emval(rawType, name) {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': function(handle) {\r\n          var rv = Emval.toValue(handle);\r\n          __emval_decref(handle);\r\n          return rv;\r\n        },\r\n        'toWireType': function(destructors, value) {\r\n          return Emval.toHandle(value);\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': simpleReadValueFromPointer,\r\n        destructorFunction: null, // This type does not need a destructor\r\n  \r\n        // TODO: do we need a deleteObject here?  write a test where\r\n        // emval is passed into JS via an interface\r\n      });\r\n    }\r\n\r\n  function _embind_repr(v) {\r\n      if (v === null) {\r\n          return 'null';\r\n      }\r\n      var t = typeof v;\r\n      if (t === 'object' || t === 'array' || t === 'function') {\r\n          return v.toString();\r\n      } else {\r\n          return '' + v;\r\n      }\r\n    }\r\n  \r\n  function floatReadValueFromPointer(name, shift) {\r\n      switch (shift) {\r\n          case 2: return function(pointer) {\r\n              return this['fromWireType'](HEAPF32[pointer >> 2]);\r\n          };\r\n          case 3: return function(pointer) {\r\n              return this['fromWireType'](HEAPF64[pointer >> 3]);\r\n          };\r\n          default:\r\n              throw new TypeError(\"Unknown float type: \" + name);\r\n      }\r\n    }\r\n  function __embind_register_float(rawType, name, size) {\r\n      var shift = getShiftFromSize(size);\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          name: name,\r\n          'fromWireType': function(value) {\r\n               return value;\r\n          },\r\n          'toWireType': function(destructors, value) {\r\n              // The VM will perform JS to Wasm value conversion, according to the spec:\r\n              // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n              return value;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': floatReadValueFromPointer(name, shift),\r\n          destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  function integerReadValueFromPointer(name, shift, signed) {\r\n      // integers are quite common, so generate very specialized functions\r\n      switch (shift) {\r\n          case 0: return signed ?\r\n              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :\r\n              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };\r\n          case 1: return signed ?\r\n              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :\r\n              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };\r\n          case 2: return signed ?\r\n              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :\r\n              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };\r\n          default:\r\n              throw new TypeError(\"Unknown integer type: \" + name);\r\n      }\r\n    }\r\n  function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\r\n      name = readLatin1String(name);\r\n      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.\r\n          maxRange = 4294967295;\r\n      }\r\n  \r\n      var shift = getShiftFromSize(size);\r\n  \r\n      var fromWireType = (value) => value;\r\n  \r\n      if (minRange === 0) {\r\n          var bitshift = 32 - 8*size;\r\n          fromWireType = (value) => (value << bitshift) >>> bitshift;\r\n      }\r\n  \r\n      var isUnsignedType = (name.includes('unsigned'));\r\n      var checkAssertions = (value, toTypeName) => {\r\n      }\r\n      var toWireType;\r\n      if (isUnsignedType) {\r\n          toWireType = function(destructors, value) {\r\n              checkAssertions(value, this.name);\r\n              return value >>> 0;\r\n          }\r\n      } else {\r\n          toWireType = function(destructors, value) {\r\n              checkAssertions(value, this.name);\r\n              // The VM will perform JS to Wasm value conversion, according to the spec:\r\n              // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n              return value;\r\n          }\r\n      }\r\n      registerType(primitiveType, {\r\n          name: name,\r\n          'fromWireType': fromWireType,\r\n          'toWireType': toWireType,\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),\r\n          destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\r\n      var typeMapping = [\r\n        Int8Array,\r\n        Uint8Array,\r\n        Int16Array,\r\n        Uint16Array,\r\n        Int32Array,\r\n        Uint32Array,\r\n        Float32Array,\r\n        Float64Array,\r\n      ];\r\n  \r\n      var TA = typeMapping[dataTypeIndex];\r\n  \r\n      function decodeMemoryView(handle) {\r\n        handle = handle >> 2;\r\n        var heap = HEAPU32;\r\n        var size = heap[handle]; // in elements\r\n        var data = heap[handle + 1]; // byte offset into emscripten heap\r\n        return new TA(buffer, data, size);\r\n      }\r\n  \r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': decodeMemoryView,\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': decodeMemoryView,\r\n      }, {\r\n        ignoreDuplicateRegistrations: true,\r\n      });\r\n    }\r\n\r\n  function __embind_register_std_string(rawType, name) {\r\n      name = readLatin1String(name);\r\n      var stdStringIsUTF8\r\n      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>\r\n      = (name === \"std::string\");\r\n  \r\n      registerType(rawType, {\r\n          name: name,\r\n          'fromWireType': function(value) {\r\n              var length = HEAPU32[value >> 2];\r\n  \r\n              var str;\r\n              if (stdStringIsUTF8) {\r\n                  var decodeStartPtr = value + 4;\r\n                  // Looping here to support possible embedded '0' bytes\r\n                  for (var i = 0; i <= length; ++i) {\r\n                      var currentBytePtr = value + 4 + i;\r\n                      if (i == length || HEAPU8[currentBytePtr] == 0) {\r\n                          var maxRead = currentBytePtr - decodeStartPtr;\r\n                          var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\r\n                          if (str === undefined) {\r\n                              str = stringSegment;\r\n                          } else {\r\n                              str += String.fromCharCode(0);\r\n                              str += stringSegment;\r\n                          }\r\n                          decodeStartPtr = currentBytePtr + 1;\r\n                      }\r\n                  }\r\n              } else {\r\n                  var a = new Array(length);\r\n                  for (var i = 0; i < length; ++i) {\r\n                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\r\n                  }\r\n                  str = a.join('');\r\n              }\r\n  \r\n              _free(value);\r\n  \r\n              return str;\r\n          },\r\n          'toWireType': function(destructors, value) {\r\n              if (value instanceof ArrayBuffer) {\r\n                  value = new Uint8Array(value);\r\n              }\r\n  \r\n              var getLength;\r\n              var valueIsOfTypeString = (typeof value == 'string');\r\n  \r\n              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\r\n                  throwBindingError('Cannot pass non-string to std::string');\r\n              }\r\n              if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n                  getLength = () => lengthBytesUTF8(value);\r\n              } else {\r\n                  getLength = () => value.length;\r\n              }\r\n  \r\n              // assumes 4-byte alignment\r\n              var length = getLength();\r\n              var ptr = _malloc(4 + length + 1);\r\n              HEAPU32[ptr >> 2] = length;\r\n              if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n                  stringToUTF8(value, ptr + 4, length + 1);\r\n              } else {\r\n                  if (valueIsOfTypeString) {\r\n                      for (var i = 0; i < length; ++i) {\r\n                          var charCode = value.charCodeAt(i);\r\n                          if (charCode > 255) {\r\n                              _free(ptr);\r\n                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\r\n                          }\r\n                          HEAPU8[ptr + 4 + i] = charCode;\r\n                      }\r\n                  } else {\r\n                      for (var i = 0; i < length; ++i) {\r\n                          HEAPU8[ptr + 4 + i] = value[i];\r\n                      }\r\n                  }\r\n              }\r\n  \r\n              if (destructors !== null) {\r\n                  destructors.push(_free, ptr);\r\n              }\r\n              return ptr;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': simpleReadValueFromPointer,\r\n          destructorFunction: function(ptr) { _free(ptr); },\r\n      });\r\n    }\r\n\r\n  function __embind_register_std_wstring(rawType, charSize, name) {\r\n      name = readLatin1String(name);\r\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\r\n      if (charSize === 2) {\r\n        decodeString = UTF16ToString;\r\n        encodeString = stringToUTF16;\r\n        lengthBytesUTF = lengthBytesUTF16;\r\n        getHeap = () => HEAPU16;\r\n        shift = 1;\r\n      } else if (charSize === 4) {\r\n        decodeString = UTF32ToString;\r\n        encodeString = stringToUTF32;\r\n        lengthBytesUTF = lengthBytesUTF32;\r\n        getHeap = () => HEAPU32;\r\n        shift = 2;\r\n      }\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': function(value) {\r\n          // Code mostly taken from _embind_register_std_string fromWireType\r\n          var length = HEAPU32[value >> 2];\r\n          var HEAP = getHeap();\r\n          var str;\r\n  \r\n          var decodeStartPtr = value + 4;\r\n          // Looping here to support possible embedded '0' bytes\r\n          for (var i = 0; i <= length; ++i) {\r\n            var currentBytePtr = value + 4 + i * charSize;\r\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\r\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\r\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\r\n              if (str === undefined) {\r\n                str = stringSegment;\r\n              } else {\r\n                str += String.fromCharCode(0);\r\n                str += stringSegment;\r\n              }\r\n              decodeStartPtr = currentBytePtr + charSize;\r\n            }\r\n          }\r\n  \r\n          _free(value);\r\n  \r\n          return str;\r\n        },\r\n        'toWireType': function(destructors, value) {\r\n          if (!(typeof value == 'string')) {\r\n            throwBindingError('Cannot pass non-string to C++ string type ' + name);\r\n          }\r\n  \r\n          // assumes 4-byte alignment\r\n          var length = lengthBytesUTF(value);\r\n          var ptr = _malloc(4 + length + charSize);\r\n          HEAPU32[ptr >> 2] = length >> shift;\r\n  \r\n          encodeString(value, ptr + 4, length + charSize);\r\n  \r\n          if (destructors !== null) {\r\n            destructors.push(_free, ptr);\r\n          }\r\n          return ptr;\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': simpleReadValueFromPointer,\r\n        destructorFunction: function(ptr) { _free(ptr); },\r\n      });\r\n    }\r\n\r\n  function __embind_register_value_object(\r\n      rawType,\r\n      name,\r\n      constructorSignature,\r\n      rawConstructor,\r\n      destructorSignature,\r\n      rawDestructor\r\n    ) {\r\n      structRegistrations[rawType] = {\r\n        name: readLatin1String(name),\r\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\r\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\r\n        fields: [],\r\n      };\r\n    }\r\n\r\n  function __embind_register_value_object_field(\r\n      structType,\r\n      fieldName,\r\n      getterReturnType,\r\n      getterSignature,\r\n      getter,\r\n      getterContext,\r\n      setterArgumentType,\r\n      setterSignature,\r\n      setter,\r\n      setterContext\r\n    ) {\r\n      structRegistrations[structType].fields.push({\r\n        fieldName: readLatin1String(fieldName),\r\n        getterReturnType: getterReturnType,\r\n        getter: embind__requireFunction(getterSignature, getter),\r\n        getterContext: getterContext,\r\n        setterArgumentType: setterArgumentType,\r\n        setter: embind__requireFunction(setterSignature, setter),\r\n        setterContext: setterContext,\r\n      });\r\n    }\r\n\r\n  function __embind_register_void(rawType, name) {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          isVoid: true, // void return values can be optimized out sometimes\r\n          name: name,\r\n          'argPackAdvance': 0,\r\n          'fromWireType': function() {\r\n              return undefined;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n              // TODO: assert if anything else is given?\r\n              return undefined;\r\n          },\r\n      });\r\n    }\r\n\r\n  function requireRegisteredType(rawType, humanName) {\r\n      var impl = registeredTypes[rawType];\r\n      if (undefined === impl) {\r\n          throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\r\n      }\r\n      return impl;\r\n    }\r\n  function __emval_as(handle, returnType, destructorsRef) {\r\n      handle = Emval.toValue(handle);\r\n      returnType = requireRegisteredType(returnType, 'emval::as');\r\n      var destructors = [];\r\n      var rd = Emval.toHandle(destructors);\r\n      HEAP32[destructorsRef >> 2] = rd;\r\n      return returnType['toWireType'](destructors, handle);\r\n    }\r\n\r\n  function __emval_allocateDestructors(destructorsRef) {\r\n      var destructors = [];\r\n      HEAP32[destructorsRef >> 2] = Emval.toHandle(destructors);\r\n      return destructors;\r\n    }\r\n  \r\n  var emval_symbols = {};\r\n  function getStringOrSymbol(address) {\r\n      var symbol = emval_symbols[address];\r\n      if (symbol === undefined) {\r\n        return readLatin1String(address);\r\n      }\r\n      return symbol;\r\n    }\r\n  \r\n  var emval_methodCallers = [];\r\n  function __emval_call_method(caller, handle, methodName, destructorsRef, args) {\r\n      caller = emval_methodCallers[caller];\r\n      handle = Emval.toValue(handle);\r\n      methodName = getStringOrSymbol(methodName);\r\n      return caller(handle, methodName, __emval_allocateDestructors(destructorsRef), args);\r\n    }\r\n\r\n  function __emval_call_void_method(caller, handle, methodName, args) {\r\n      caller = emval_methodCallers[caller];\r\n      handle = Emval.toValue(handle);\r\n      methodName = getStringOrSymbol(methodName);\r\n      caller(handle, methodName, null, args);\r\n    }\r\n\r\n\r\n  function __emval_addMethodCaller(caller) {\r\n      var id = emval_methodCallers.length;\r\n      emval_methodCallers.push(caller);\r\n      return id;\r\n    }\r\n  \r\n  function __emval_lookupTypes(argCount, argTypes) {\r\n      var a = new Array(argCount);\r\n      for (var i = 0; i < argCount; ++i) {\r\n        a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i],\r\n                                     \"parameter \" + i);\r\n      }\r\n      return a;\r\n    }\r\n  \r\n  var emval_registeredMethods = [];\r\n  function __emval_get_method_caller(argCount, argTypes) {\r\n      var types = __emval_lookupTypes(argCount, argTypes);\r\n      var retType = types[0];\r\n      var signatureName = retType.name + \"_$\" + types.slice(1).map(function (t) { return t.name; }).join(\"_\") + \"$\";\r\n      var returnId = emval_registeredMethods[signatureName];\r\n      if (returnId !== undefined) {\r\n        return returnId;\r\n      }\r\n  \r\n      var params = [\"retType\"];\r\n      var args = [retType];\r\n  \r\n      var argsList = \"\"; // 'arg0, arg1, arg2, ... , argN'\r\n      for (var i = 0; i < argCount - 1; ++i) {\r\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\r\n        params.push(\"argType\" + i);\r\n        args.push(types[1 + i]);\r\n      }\r\n  \r\n      var functionName = makeLegalFunctionName(\"methodCaller_\" + signatureName);\r\n      var functionBody =\r\n          \"return function \" + functionName + \"(handle, name, destructors, args) {\\n\";\r\n  \r\n      var offset = 0;\r\n      for (var i = 0; i < argCount - 1; ++i) {\r\n          functionBody +=\r\n          \"    var arg\" + i + \" = argType\" + i + \".readValueFromPointer(args\" + (offset ? (\"+\"+offset) : \"\") + \");\\n\";\r\n          offset += types[i + 1]['argPackAdvance'];\r\n      }\r\n      functionBody +=\r\n          \"    var rv = handle[name](\" + argsList + \");\\n\";\r\n      for (var i = 0; i < argCount - 1; ++i) {\r\n          if (types[i + 1]['deleteObject']) {\r\n              functionBody +=\r\n              \"    argType\" + i + \".deleteObject(arg\" + i + \");\\n\";\r\n          }\r\n      }\r\n      if (!retType.isVoid) {\r\n          functionBody +=\r\n          \"    return retType.toWireType(destructors, rv);\\n\";\r\n      }\r\n      functionBody +=\r\n          \"};\\n\";\r\n  \r\n      params.push(functionBody);\r\n      var invokerFunction = new_(Function, params).apply(null, args);\r\n      returnId = __emval_addMethodCaller(invokerFunction);\r\n      emval_registeredMethods[signatureName] = returnId;\r\n      return returnId;\r\n    }\r\n\r\n  function __emval_get_property(handle, key) {\r\n      handle = Emval.toValue(handle);\r\n      key = Emval.toValue(key);\r\n      return Emval.toHandle(handle[key]);\r\n    }\r\n\r\n  function __emval_incref(handle) {\r\n      if (handle > 4) {\r\n        emval_handle_array[handle].refcount += 1;\r\n      }\r\n    }\r\n\r\n  function __emval_new_array() {\r\n      return Emval.toHandle([]);\r\n    }\r\n\r\n  function __emval_new_cstring(v) {\r\n      return Emval.toHandle(getStringOrSymbol(v));\r\n    }\r\n\r\n  function __emval_run_destructors(handle) {\r\n      var destructors = Emval.toValue(handle);\r\n      runDestructors(destructors);\r\n      __emval_decref(handle);\r\n    }\r\n\r\n  function __emval_take_value(type, argv) {\r\n      type = requireRegisteredType(type, '_emval_take_value');\r\n      var v = type['readValueFromPointer'](argv);\r\n      return Emval.toHandle(v);\r\n    }\r\n\r\n  function _abort() {\r\n      abort('');\r\n    }\r\n\r\n  function _emscripten_memcpy_big(dest, src, num) {\r\n      HEAPU8.copyWithin(dest, src, src + num);\r\n    }\r\n\r\n  function getHeapMax() {\r\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\r\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\r\n      // for any code that deals with heap sizes, which would require special\r\n      // casing all heap size related code to treat 0 specially.\r\n      return 2147483648;\r\n    }\r\n  \r\n  function emscripten_realloc_buffer(size) {\r\n      try {\r\n        // round size grow request up to wasm page size (fixed 64KB per spec)\r\n        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size\r\n        updateGlobalBufferAndViews(wasmMemory.buffer);\r\n        return 1 /*success*/;\r\n      } catch(e) {\r\n      }\r\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\r\n      // anyhow)\r\n    }\r\n  function _emscripten_resize_heap(requestedSize) {\r\n      var oldSize = HEAPU8.length;\r\n      requestedSize = requestedSize >>> 0;\r\n      // With multithreaded builds, races can happen (another thread might increase the size\r\n      // in between), so return a failure, and let the caller retry.\r\n  \r\n      // Memory resize rules:\r\n      // 1.  Always increase heap size to at least the requested size, rounded up\r\n      //     to next page multiple.\r\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\r\n      //     geometrically: increase the heap size according to\r\n      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\r\n      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\r\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\r\n      //     linearly: increase the heap size by at least\r\n      //     MEMORY_GROWTH_LINEAR_STEP bytes.\r\n      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\r\n      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\r\n      // 4.  If we were unable to allocate as much memory, it may be due to\r\n      //     over-eager decision to excessively reserve due to (3) above.\r\n      //     Hence if an allocation fails, cut down on the amount of excess\r\n      //     growth, in an attempt to succeed to perform a smaller allocation.\r\n  \r\n      // A limit is set for how much we can grow. We should not exceed that\r\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\r\n      var maxHeapSize = getHeapMax();\r\n      if (requestedSize > maxHeapSize) {\r\n        return false;\r\n      }\r\n  \r\n      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\r\n  \r\n      // Loop through potential heap size increases. If we attempt a too eager\r\n      // reservation that fails, cut down on the attempted size and reserve a\r\n      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\r\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\r\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\r\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\r\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\r\n  \r\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\r\n  \r\n        var replacement = emscripten_realloc_buffer(newSize);\r\n        if (replacement) {\r\n  \r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n  var ENV = {};\r\n  \r\n  function getExecutableName() {\r\n      return thisProgram || './this.program';\r\n    }\r\n  function getEnvStrings() {\r\n      if (!getEnvStrings.strings) {\r\n        // Default values.\r\n        // Browser language detection #8751\r\n        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';\r\n        var env = {\r\n          'USER': 'web_user',\r\n          'LOGNAME': 'web_user',\r\n          'PATH': '/',\r\n          'PWD': '/',\r\n          'HOME': '/home/web_user',\r\n          'LANG': lang,\r\n          '_': getExecutableName()\r\n        };\r\n        // Apply the user-provided values, if any.\r\n        for (var x in ENV) {\r\n          // x is a key in ENV; if ENV[x] is undefined, that means it was\r\n          // explicitly set to be so. We allow user code to do that to\r\n          // force variables with default values to remain unset.\r\n          if (ENV[x] === undefined) delete env[x];\r\n          else env[x] = ENV[x];\r\n        }\r\n        var strings = [];\r\n        for (var x in env) {\r\n          strings.push(x + '=' + env[x]);\r\n        }\r\n        getEnvStrings.strings = strings;\r\n      }\r\n      return getEnvStrings.strings;\r\n    }\r\n  \r\n  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {\r\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n        return splitPathRe.exec(filename).slice(1);\r\n      },normalizeArray:(parts, allowAboveRoot) => {\r\n        // if the path tries to go above the root, `up` ends up > 0\r\n        var up = 0;\r\n        for (var i = parts.length - 1; i >= 0; i--) {\r\n          var last = parts[i];\r\n          if (last === '.') {\r\n            parts.splice(i, 1);\r\n          } else if (last === '..') {\r\n            parts.splice(i, 1);\r\n            up++;\r\n          } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n          }\r\n        }\r\n        // if the path is allowed to go above the root, restore leading ..s\r\n        if (allowAboveRoot) {\r\n          for (; up; up--) {\r\n            parts.unshift('..');\r\n          }\r\n        }\r\n        return parts;\r\n      },normalize:(path) => {\r\n        var isAbsolute = PATH.isAbs(path),\r\n            trailingSlash = path.substr(-1) === '/';\r\n        // Normalize the path\r\n        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\r\n        if (!path && !isAbsolute) {\r\n          path = '.';\r\n        }\r\n        if (path && trailingSlash) {\r\n          path += '/';\r\n        }\r\n        return (isAbsolute ? '/' : '') + path;\r\n      },dirname:(path) => {\r\n        var result = PATH.splitPath(path),\r\n            root = result[0],\r\n            dir = result[1];\r\n        if (!root && !dir) {\r\n          // No dirname whatsoever\r\n          return '.';\r\n        }\r\n        if (dir) {\r\n          // It has a dirname, strip trailing slash\r\n          dir = dir.substr(0, dir.length - 1);\r\n        }\r\n        return root + dir;\r\n      },basename:(path) => {\r\n        // EMSCRIPTEN return '/'' for '/', not an empty string\r\n        if (path === '/') return '/';\r\n        path = PATH.normalize(path);\r\n        path = path.replace(/\\/$/, \"\");\r\n        var lastSlash = path.lastIndexOf('/');\r\n        if (lastSlash === -1) return path;\r\n        return path.substr(lastSlash+1);\r\n      },join:function() {\r\n        var paths = Array.prototype.slice.call(arguments, 0);\r\n        return PATH.normalize(paths.join('/'));\r\n      },join2:(l, r) => {\r\n        return PATH.normalize(l + '/' + r);\r\n      }};\r\n  \r\n  function getRandomDevice() {\r\n      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\r\n        // for modern web browsers\r\n        var randomBuffer = new Uint8Array(1);\r\n        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };\r\n      } else\r\n      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\r\n      return function() { abort(\"randomDevice\"); };\r\n    }\r\n  \r\n  var PATH_FS = {resolve:function() {\r\n        var resolvedPath = '',\r\n          resolvedAbsolute = false;\r\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n          var path = (i >= 0) ? arguments[i] : FS.cwd();\r\n          // Skip empty and invalid entries\r\n          if (typeof path != 'string') {\r\n            throw new TypeError('Arguments to path.resolve must be strings');\r\n          } else if (!path) {\r\n            return ''; // an invalid portion invalidates the whole thing\r\n          }\r\n          resolvedPath = path + '/' + resolvedPath;\r\n          resolvedAbsolute = PATH.isAbs(path);\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\r\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n      },relative:(from, to) => {\r\n        from = PATH_FS.resolve(from).substr(1);\r\n        to = PATH_FS.resolve(to).substr(1);\r\n        function trim(arr) {\r\n          var start = 0;\r\n          for (; start < arr.length; start++) {\r\n            if (arr[start] !== '') break;\r\n          }\r\n          var end = arr.length - 1;\r\n          for (; end >= 0; end--) {\r\n            if (arr[end] !== '') break;\r\n          }\r\n          if (start > end) return [];\r\n          return arr.slice(start, end - start + 1);\r\n        }\r\n        var fromParts = trim(from.split('/'));\r\n        var toParts = trim(to.split('/'));\r\n        var length = Math.min(fromParts.length, toParts.length);\r\n        var samePartsLength = length;\r\n        for (var i = 0; i < length; i++) {\r\n          if (fromParts[i] !== toParts[i]) {\r\n            samePartsLength = i;\r\n            break;\r\n          }\r\n        }\r\n        var outputParts = [];\r\n        for (var i = samePartsLength; i < fromParts.length; i++) {\r\n          outputParts.push('..');\r\n        }\r\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n        return outputParts.join('/');\r\n      }};\r\n  \r\n  var TTY = {ttys:[],init:function () {\r\n        // https://github.com/emscripten-core/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\r\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\r\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\r\n        //   // with text files until FS.init can be refactored.\r\n        //   process['stdin']['setEncoding']('utf8');\r\n        // }\r\n      },shutdown:function() {\r\n        // https://github.com/emscripten-core/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\r\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\r\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\r\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\r\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\r\n        //   process['stdin']['pause']();\r\n        // }\r\n      },register:function(dev, ops) {\r\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\r\n        FS.registerDevice(dev, TTY.stream_ops);\r\n      },stream_ops:{open:function(stream) {\r\n          var tty = TTY.ttys[stream.node.rdev];\r\n          if (!tty) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          stream.tty = tty;\r\n          stream.seekable = false;\r\n        },close:function(stream) {\r\n          // flush any pending line data\r\n          stream.tty.ops.flush(stream.tty);\r\n        },flush:function(stream) {\r\n          stream.tty.ops.flush(stream.tty);\r\n        },read:function(stream, buffer, offset, length, pos /* ignored */) {\r\n          if (!stream.tty || !stream.tty.ops.get_char) {\r\n            throw new FS.ErrnoError(60);\r\n          }\r\n          var bytesRead = 0;\r\n          for (var i = 0; i < length; i++) {\r\n            var result;\r\n            try {\r\n              result = stream.tty.ops.get_char(stream.tty);\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(29);\r\n            }\r\n            if (result === undefined && bytesRead === 0) {\r\n              throw new FS.ErrnoError(6);\r\n            }\r\n            if (result === null || result === undefined) break;\r\n            bytesRead++;\r\n            buffer[offset+i] = result;\r\n          }\r\n          if (bytesRead) {\r\n            stream.node.timestamp = Date.now();\r\n          }\r\n          return bytesRead;\r\n        },write:function(stream, buffer, offset, length, pos) {\r\n          if (!stream.tty || !stream.tty.ops.put_char) {\r\n            throw new FS.ErrnoError(60);\r\n          }\r\n          try {\r\n            for (var i = 0; i < length; i++) {\r\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\r\n            }\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n          if (length) {\r\n            stream.node.timestamp = Date.now();\r\n          }\r\n          return i;\r\n        }},default_tty_ops:{get_char:function(tty) {\r\n          if (!tty.input.length) {\r\n            var result = null;\r\n            if (typeof window != 'undefined' &&\r\n              typeof window.prompt == 'function') {\r\n              // Browser.\r\n              result = window.prompt('Input: ');  // returns null on cancel\r\n              if (result !== null) {\r\n                result += '\\n';\r\n              }\r\n            } else if (typeof readline == 'function') {\r\n              // Command line.\r\n              result = readline();\r\n              if (result !== null) {\r\n                result += '\\n';\r\n              }\r\n            }\r\n            if (!result) {\r\n              return null;\r\n            }\r\n            tty.input = intArrayFromString(result, true);\r\n          }\r\n          return tty.input.shift();\r\n        },put_char:function(tty, val) {\r\n          if (val === null || val === 10) {\r\n            out(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\r\n          }\r\n        },flush:function(tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            out(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          }\r\n        }},default_tty1_ops:{put_char:function(tty, val) {\r\n          if (val === null || val === 10) {\r\n            err(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val);\r\n          }\r\n        },flush:function(tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            err(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          }\r\n        }}};\r\n  \r\n  function zeroMemory(address, size) {\r\n      HEAPU8.fill(0, address, address + size);\r\n    }\r\n  \r\n  function alignMemory(size, alignment) {\r\n      return Math.ceil(size / alignment) * alignment;\r\n    }\r\n  function mmapAlloc(size) {\r\n      abort();\r\n    }\r\n  var MEMFS = {ops_table:null,mount:function(mount) {\r\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\r\n      },createNode:function(parent, name, mode, dev) {\r\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n          // no supported\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (!MEMFS.ops_table) {\r\n          MEMFS.ops_table = {\r\n            dir: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr,\r\n                lookup: MEMFS.node_ops.lookup,\r\n                mknod: MEMFS.node_ops.mknod,\r\n                rename: MEMFS.node_ops.rename,\r\n                unlink: MEMFS.node_ops.unlink,\r\n                rmdir: MEMFS.node_ops.rmdir,\r\n                readdir: MEMFS.node_ops.readdir,\r\n                symlink: MEMFS.node_ops.symlink\r\n              },\r\n              stream: {\r\n                llseek: MEMFS.stream_ops.llseek\r\n              }\r\n            },\r\n            file: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr\r\n              },\r\n              stream: {\r\n                llseek: MEMFS.stream_ops.llseek,\r\n                read: MEMFS.stream_ops.read,\r\n                write: MEMFS.stream_ops.write,\r\n                allocate: MEMFS.stream_ops.allocate,\r\n                mmap: MEMFS.stream_ops.mmap,\r\n                msync: MEMFS.stream_ops.msync\r\n              }\r\n            },\r\n            link: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr,\r\n                readlink: MEMFS.node_ops.readlink\r\n              },\r\n              stream: {}\r\n            },\r\n            chrdev: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr\r\n              },\r\n              stream: FS.chrdev_stream_ops\r\n            }\r\n          };\r\n        }\r\n        var node = FS.createNode(parent, name, mode, dev);\r\n        if (FS.isDir(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.dir.node;\r\n          node.stream_ops = MEMFS.ops_table.dir.stream;\r\n          node.contents = {};\r\n        } else if (FS.isFile(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.file.node;\r\n          node.stream_ops = MEMFS.ops_table.file.stream;\r\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\r\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\r\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\r\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\r\n          node.contents = null; \r\n        } else if (FS.isLink(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.link.node;\r\n          node.stream_ops = MEMFS.ops_table.link.stream;\r\n        } else if (FS.isChrdev(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.chrdev.node;\r\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n        }\r\n        node.timestamp = Date.now();\r\n        // add the new node to the parent\r\n        if (parent) {\r\n          parent.contents[name] = node;\r\n          parent.timestamp = node.timestamp;\r\n        }\r\n        return node;\r\n      },getFileDataAsTypedArray:function(node) {\r\n        if (!node.contents) return new Uint8Array(0);\r\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\r\n        return new Uint8Array(node.contents);\r\n      },expandFileStorage:function(node, newCapacity) {\r\n        var prevCapacity = node.contents ? node.contents.length : 0;\r\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\r\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\r\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\r\n        // avoid overshooting the allocation cap by a very large margin.\r\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\r\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\r\n        var oldContents = node.contents;\r\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\r\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\r\n      },resizeFileStorage:function(node, newSize) {\r\n        if (node.usedBytes == newSize) return;\r\n        if (newSize == 0) {\r\n          node.contents = null; // Fully decommit when requesting a resize to zero.\r\n          node.usedBytes = 0;\r\n        } else {\r\n          var oldContents = node.contents;\r\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\r\n          if (oldContents) {\r\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\r\n          }\r\n          node.usedBytes = newSize;\r\n        }\r\n      },node_ops:{getattr:function(node) {\r\n          var attr = {};\r\n          // device numbers reuse inode numbers.\r\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n          attr.ino = node.id;\r\n          attr.mode = node.mode;\r\n          attr.nlink = 1;\r\n          attr.uid = 0;\r\n          attr.gid = 0;\r\n          attr.rdev = node.rdev;\r\n          if (FS.isDir(node.mode)) {\r\n            attr.size = 4096;\r\n          } else if (FS.isFile(node.mode)) {\r\n            attr.size = node.usedBytes;\r\n          } else if (FS.isLink(node.mode)) {\r\n            attr.size = node.link.length;\r\n          } else {\r\n            attr.size = 0;\r\n          }\r\n          attr.atime = new Date(node.timestamp);\r\n          attr.mtime = new Date(node.timestamp);\r\n          attr.ctime = new Date(node.timestamp);\r\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\r\n          //       but this is not required by the standard.\r\n          attr.blksize = 4096;\r\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n          return attr;\r\n        },setattr:function(node, attr) {\r\n          if (attr.mode !== undefined) {\r\n            node.mode = attr.mode;\r\n          }\r\n          if (attr.timestamp !== undefined) {\r\n            node.timestamp = attr.timestamp;\r\n          }\r\n          if (attr.size !== undefined) {\r\n            MEMFS.resizeFileStorage(node, attr.size);\r\n          }\r\n        },lookup:function(parent, name) {\r\n          throw FS.genericErrors[44];\r\n        },mknod:function(parent, name, mode, dev) {\r\n          return MEMFS.createNode(parent, name, mode, dev);\r\n        },rename:function(old_node, new_dir, new_name) {\r\n          // if we're overwriting a directory at new_name, make sure it's empty.\r\n          if (FS.isDir(old_node.mode)) {\r\n            var new_node;\r\n            try {\r\n              new_node = FS.lookupNode(new_dir, new_name);\r\n            } catch (e) {\r\n            }\r\n            if (new_node) {\r\n              for (var i in new_node.contents) {\r\n                throw new FS.ErrnoError(55);\r\n              }\r\n            }\r\n          }\r\n          // do the internal rewiring\r\n          delete old_node.parent.contents[old_node.name];\r\n          old_node.parent.timestamp = Date.now()\r\n          old_node.name = new_name;\r\n          new_dir.contents[new_name] = old_node;\r\n          new_dir.timestamp = old_node.parent.timestamp;\r\n          old_node.parent = new_dir;\r\n        },unlink:function(parent, name) {\r\n          delete parent.contents[name];\r\n          parent.timestamp = Date.now();\r\n        },rmdir:function(parent, name) {\r\n          var node = FS.lookupNode(parent, name);\r\n          for (var i in node.contents) {\r\n            throw new FS.ErrnoError(55);\r\n          }\r\n          delete parent.contents[name];\r\n          parent.timestamp = Date.now();\r\n        },readdir:function(node) {\r\n          var entries = ['.', '..'];\r\n          for (var key in node.contents) {\r\n            if (!node.contents.hasOwnProperty(key)) {\r\n              continue;\r\n            }\r\n            entries.push(key);\r\n          }\r\n          return entries;\r\n        },symlink:function(parent, newname, oldpath) {\r\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\r\n          node.link = oldpath;\r\n          return node;\r\n        },readlink:function(node) {\r\n          if (!FS.isLink(node.mode)) {\r\n            throw new FS.ErrnoError(28);\r\n          }\r\n          return node.link;\r\n        }},stream_ops:{read:function(stream, buffer, offset, length, position) {\r\n          var contents = stream.node.contents;\r\n          if (position >= stream.node.usedBytes) return 0;\r\n          var size = Math.min(stream.node.usedBytes - position, length);\r\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\r\n            buffer.set(contents.subarray(position, position + size), offset);\r\n          } else {\r\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\r\n          }\r\n          return size;\r\n        },write:function(stream, buffer, offset, length, position, canOwn) {\r\n          // If the buffer is located in main memory (HEAP), and if\r\n          // memory can grow, we can't hold on to references of the\r\n          // memory buffer, as they may get invalidated. That means we\r\n          // need to do copy its contents.\r\n          if (buffer.buffer === HEAP8.buffer) {\r\n            canOwn = false;\r\n          }\r\n  \r\n          if (!length) return 0;\r\n          var node = stream.node;\r\n          node.timestamp = Date.now();\r\n  \r\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\r\n            if (canOwn) {\r\n              node.contents = buffer.subarray(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\r\n              node.contents = buffer.slice(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\r\n              node.contents.set(buffer.subarray(offset, offset + length), position);\r\n              return length;\r\n            }\r\n          }\r\n  \r\n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\r\n          MEMFS.expandFileStorage(node, position+length);\r\n          if (node.contents.subarray && buffer.subarray) {\r\n            // Use typed array write which is available.\r\n            node.contents.set(buffer.subarray(offset, offset + length), position);\r\n          } else {\r\n            for (var i = 0; i < length; i++) {\r\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\r\n            }\r\n          }\r\n          node.usedBytes = Math.max(node.usedBytes, position + length);\r\n          return length;\r\n        },llseek:function(stream, offset, whence) {\r\n          var position = offset;\r\n          if (whence === 1) {\r\n            position += stream.position;\r\n          } else if (whence === 2) {\r\n            if (FS.isFile(stream.node.mode)) {\r\n              position += stream.node.usedBytes;\r\n            }\r\n          }\r\n          if (position < 0) {\r\n            throw new FS.ErrnoError(28);\r\n          }\r\n          return position;\r\n        },allocate:function(stream, offset, length) {\r\n          MEMFS.expandFileStorage(stream.node, offset + length);\r\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\r\n        },mmap:function(stream, length, position, prot, flags) {\r\n          if (!FS.isFile(stream.node.mode)) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          var ptr;\r\n          var allocated;\r\n          var contents = stream.node.contents;\r\n          // Only make a new copy when MAP_PRIVATE is specified.\r\n          if (!(flags & 2) && contents.buffer === buffer) {\r\n            // We can't emulate MAP_SHARED when the file is not backed by the buffer\r\n            // we're mapping to (e.g. the HEAP buffer).\r\n            allocated = false;\r\n            ptr = contents.byteOffset;\r\n          } else {\r\n            // Try to avoid unnecessary slices.\r\n            if (position > 0 || position + length < contents.length) {\r\n              if (contents.subarray) {\r\n                contents = contents.subarray(position, position + length);\r\n              } else {\r\n                contents = Array.prototype.slice.call(contents, position, position + length);\r\n              }\r\n            }\r\n            allocated = true;\r\n            ptr = mmapAlloc(length);\r\n            if (!ptr) {\r\n              throw new FS.ErrnoError(48);\r\n            }\r\n            HEAP8.set(contents, ptr);\r\n          }\r\n          return { ptr: ptr, allocated: allocated };\r\n        },msync:function(stream, buffer, offset, length, mmapFlags) {\r\n          if (!FS.isFile(stream.node.mode)) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          if (mmapFlags & 2) {\r\n            // MAP_PRIVATE calls need not to be synced back to underlying fs\r\n            return 0;\r\n          }\r\n  \r\n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n          // should we check if bytesWritten and length are the same?\r\n          return 0;\r\n        }}};\r\n  \r\n  /** @param {boolean=} noRunDep */\r\n  function asyncLoad(url, onload, onerror, noRunDep) {\r\n      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';\r\n      readAsync(url, function(arrayBuffer) {\r\n        assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\r\n        onload(new Uint8Array(arrayBuffer));\r\n        if (dep) removeRunDependency(dep);\r\n      }, function(event) {\r\n        if (onerror) {\r\n          onerror();\r\n        } else {\r\n          throw 'Loading data file \"' + url + '\" failed.';\r\n        }\r\n      });\r\n      if (dep) addRunDependency(dep);\r\n    }\r\n  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {\r\n        path = PATH_FS.resolve(FS.cwd(), path);\r\n  \r\n        if (!path) return { path: '', node: null };\r\n  \r\n        var defaults = {\r\n          follow_mount: true,\r\n          recurse_count: 0\r\n        };\r\n        opts = Object.assign(defaults, opts)\r\n  \r\n        if (opts.recurse_count > 8) {  // max recursive lookup of 8\r\n          throw new FS.ErrnoError(32);\r\n        }\r\n  \r\n        // split the path\r\n        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);\r\n  \r\n        // start at the root\r\n        var current = FS.root;\r\n        var current_path = '/';\r\n  \r\n        for (var i = 0; i < parts.length; i++) {\r\n          var islast = (i === parts.length-1);\r\n          if (islast && opts.parent) {\r\n            // stop resolving\r\n            break;\r\n          }\r\n  \r\n          current = FS.lookupNode(current, parts[i]);\r\n          current_path = PATH.join2(current_path, parts[i]);\r\n  \r\n          // jump to the mount's root node if this is a mountpoint\r\n          if (FS.isMountpoint(current)) {\r\n            if (!islast || (islast && opts.follow_mount)) {\r\n              current = current.mounted.root;\r\n            }\r\n          }\r\n  \r\n          // by default, lookupPath will not follow a symlink if it is the final path component.\r\n          // setting opts.follow = true will override this behavior.\r\n          if (!islast || opts.follow) {\r\n            var count = 0;\r\n            while (FS.isLink(current.mode)) {\r\n              var link = FS.readlink(current_path);\r\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\r\n  \r\n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\r\n              current = lookup.node;\r\n  \r\n              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\r\n                throw new FS.ErrnoError(32);\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        return { path: current_path, node: current };\r\n      },getPath:(node) => {\r\n        var path;\r\n        while (true) {\r\n          if (FS.isRoot(node)) {\r\n            var mount = node.mount.mountpoint;\r\n            if (!path) return mount;\r\n            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;\r\n          }\r\n          path = path ? node.name + '/' + path : node.name;\r\n          node = node.parent;\r\n        }\r\n      },hashName:(parentid, name) => {\r\n        var hash = 0;\r\n  \r\n        for (var i = 0; i < name.length; i++) {\r\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\r\n        }\r\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\r\n      },hashAddNode:(node) => {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        node.name_next = FS.nameTable[hash];\r\n        FS.nameTable[hash] = node;\r\n      },hashRemoveNode:(node) => {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        if (FS.nameTable[hash] === node) {\r\n          FS.nameTable[hash] = node.name_next;\r\n        } else {\r\n          var current = FS.nameTable[hash];\r\n          while (current) {\r\n            if (current.name_next === node) {\r\n              current.name_next = node.name_next;\r\n              break;\r\n            }\r\n            current = current.name_next;\r\n          }\r\n        }\r\n      },lookupNode:(parent, name) => {\r\n        var errCode = FS.mayLookup(parent);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode, parent);\r\n        }\r\n        var hash = FS.hashName(parent.id, name);\r\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n          var nodeName = node.name;\r\n          if (node.parent.id === parent.id && nodeName === name) {\r\n            return node;\r\n          }\r\n        }\r\n        // if we failed to find it in the cache, call into the VFS\r\n        return FS.lookup(parent, name);\r\n      },createNode:(parent, name, mode, rdev) => {\r\n        var node = new FS.FSNode(parent, name, mode, rdev);\r\n  \r\n        FS.hashAddNode(node);\r\n  \r\n        return node;\r\n      },destroyNode:(node) => {\r\n        FS.hashRemoveNode(node);\r\n      },isRoot:(node) => {\r\n        return node === node.parent;\r\n      },isMountpoint:(node) => {\r\n        return !!node.mounted;\r\n      },isFile:(mode) => {\r\n        return (mode & 61440) === 32768;\r\n      },isDir:(mode) => {\r\n        return (mode & 61440) === 16384;\r\n      },isLink:(mode) => {\r\n        return (mode & 61440) === 40960;\r\n      },isChrdev:(mode) => {\r\n        return (mode & 61440) === 8192;\r\n      },isBlkdev:(mode) => {\r\n        return (mode & 61440) === 24576;\r\n      },isFIFO:(mode) => {\r\n        return (mode & 61440) === 4096;\r\n      },isSocket:(mode) => {\r\n        return (mode & 49152) === 49152;\r\n      },flagModes:{\"r\":0,\"r+\":2,\"w\":577,\"w+\":578,\"a\":1089,\"a+\":1090},modeStringToFlags:(str) => {\r\n        var flags = FS.flagModes[str];\r\n        if (typeof flags == 'undefined') {\r\n          throw new Error('Unknown file open mode: ' + str);\r\n        }\r\n        return flags;\r\n      },flagsToPermissionString:(flag) => {\r\n        var perms = ['r', 'w', 'rw'][flag & 3];\r\n        if ((flag & 512)) {\r\n          perms += 'w';\r\n        }\r\n        return perms;\r\n      },nodePermissions:(node, perms) => {\r\n        if (FS.ignorePermissions) {\r\n          return 0;\r\n        }\r\n        // return 0 if any user, group or owner bits are set.\r\n        if (perms.includes('r') && !(node.mode & 292)) {\r\n          return 2;\r\n        } else if (perms.includes('w') && !(node.mode & 146)) {\r\n          return 2;\r\n        } else if (perms.includes('x') && !(node.mode & 73)) {\r\n          return 2;\r\n        }\r\n        return 0;\r\n      },mayLookup:(dir) => {\r\n        var errCode = FS.nodePermissions(dir, 'x');\r\n        if (errCode) return errCode;\r\n        if (!dir.node_ops.lookup) return 2;\r\n        return 0;\r\n      },mayCreate:(dir, name) => {\r\n        try {\r\n          var node = FS.lookupNode(dir, name);\r\n          return 20;\r\n        } catch (e) {\r\n        }\r\n        return FS.nodePermissions(dir, 'wx');\r\n      },mayDelete:(dir, name, isdir) => {\r\n        var node;\r\n        try {\r\n          node = FS.lookupNode(dir, name);\r\n        } catch (e) {\r\n          return e.errno;\r\n        }\r\n        var errCode = FS.nodePermissions(dir, 'wx');\r\n        if (errCode) {\r\n          return errCode;\r\n        }\r\n        if (isdir) {\r\n          if (!FS.isDir(node.mode)) {\r\n            return 54;\r\n          }\r\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n            return 10;\r\n          }\r\n        } else {\r\n          if (FS.isDir(node.mode)) {\r\n            return 31;\r\n          }\r\n        }\r\n        return 0;\r\n      },mayOpen:(node, flags) => {\r\n        if (!node) {\r\n          return 44;\r\n        }\r\n        if (FS.isLink(node.mode)) {\r\n          return 32;\r\n        } else if (FS.isDir(node.mode)) {\r\n          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\r\n              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\r\n            return 31;\r\n          }\r\n        }\r\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {\r\n        for (var fd = fd_start; fd <= fd_end; fd++) {\r\n          if (!FS.streams[fd]) {\r\n            return fd;\r\n          }\r\n        }\r\n        throw new FS.ErrnoError(33);\r\n      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {\r\n        if (!FS.FSStream) {\r\n          FS.FSStream = /** @constructor */ function() {\r\n            this.shared = { };\r\n          };\r\n          FS.FSStream.prototype = {\r\n            object: {\r\n              get: function() { return this.node; },\r\n              set: function(val) { this.node = val; }\r\n            },\r\n            isRead: {\r\n              get: function() { return (this.flags & 2097155) !== 1; }\r\n            },\r\n            isWrite: {\r\n              get: function() { return (this.flags & 2097155) !== 0; }\r\n            },\r\n            isAppend: {\r\n              get: function() { return (this.flags & 1024); }\r\n            },\r\n            flags: {\r\n              get: function() { return this.shared.flags; },\r\n              set: function(val) { this.shared.flags = val; },\r\n            },\r\n            position : {\r\n              get function() { return this.shared.position; },\r\n              set: function(val) { this.shared.position = val; },\r\n            },\r\n          };\r\n        }\r\n        // clone it, so we can return an instance of FSStream\r\n        stream = Object.assign(new FS.FSStream(), stream);\r\n        var fd = FS.nextfd(fd_start, fd_end);\r\n        stream.fd = fd;\r\n        FS.streams[fd] = stream;\r\n        return stream;\r\n      },closeStream:(fd) => {\r\n        FS.streams[fd] = null;\r\n      },chrdev_stream_ops:{open:(stream) => {\r\n          var device = FS.getDevice(stream.node.rdev);\r\n          // override node's stream ops with the device's\r\n          stream.stream_ops = device.stream_ops;\r\n          // forward the open call\r\n          if (stream.stream_ops.open) {\r\n            stream.stream_ops.open(stream);\r\n          }\r\n        },llseek:() => {\r\n          throw new FS.ErrnoError(70);\r\n        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {\r\n        FS.devices[dev] = { stream_ops: ops };\r\n      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {\r\n        var mounts = [];\r\n        var check = [mount];\r\n  \r\n        while (check.length) {\r\n          var m = check.pop();\r\n  \r\n          mounts.push(m);\r\n  \r\n          check.push.apply(check, m.mounts);\r\n        }\r\n  \r\n        return mounts;\r\n      },syncfs:(populate, callback) => {\r\n        if (typeof populate == 'function') {\r\n          callback = populate;\r\n          populate = false;\r\n        }\r\n  \r\n        FS.syncFSRequests++;\r\n  \r\n        if (FS.syncFSRequests > 1) {\r\n          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');\r\n        }\r\n  \r\n        var mounts = FS.getMounts(FS.root.mount);\r\n        var completed = 0;\r\n  \r\n        function doCallback(errCode) {\r\n          FS.syncFSRequests--;\r\n          return callback(errCode);\r\n        }\r\n  \r\n        function done(errCode) {\r\n          if (errCode) {\r\n            if (!done.errored) {\r\n              done.errored = true;\r\n              return doCallback(errCode);\r\n            }\r\n            return;\r\n          }\r\n          if (++completed >= mounts.length) {\r\n            doCallback(null);\r\n          }\r\n        };\r\n  \r\n        // sync all mounts\r\n        mounts.forEach((mount) => {\r\n          if (!mount.type.syncfs) {\r\n            return done(null);\r\n          }\r\n          mount.type.syncfs(mount, populate, done);\r\n        });\r\n      },mount:(type, opts, mountpoint) => {\r\n        var root = mountpoint === '/';\r\n        var pseudo = !mountpoint;\r\n        var node;\r\n  \r\n        if (root && FS.root) {\r\n          throw new FS.ErrnoError(10);\r\n        } else if (!root && !pseudo) {\r\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n          mountpoint = lookup.path;  // use the absolute path\r\n          node = lookup.node;\r\n  \r\n          if (FS.isMountpoint(node)) {\r\n            throw new FS.ErrnoError(10);\r\n          }\r\n  \r\n          if (!FS.isDir(node.mode)) {\r\n            throw new FS.ErrnoError(54);\r\n          }\r\n        }\r\n  \r\n        var mount = {\r\n          type: type,\r\n          opts: opts,\r\n          mountpoint: mountpoint,\r\n          mounts: []\r\n        };\r\n  \r\n        // create a root node for the fs\r\n        var mountRoot = type.mount(mount);\r\n        mountRoot.mount = mount;\r\n        mount.root = mountRoot;\r\n  \r\n        if (root) {\r\n          FS.root = mountRoot;\r\n        } else if (node) {\r\n          // set as a mountpoint\r\n          node.mounted = mount;\r\n  \r\n          // add the new mount to the current mount's children\r\n          if (node.mount) {\r\n            node.mount.mounts.push(mount);\r\n          }\r\n        }\r\n  \r\n        return mountRoot;\r\n      },unmount:(mountpoint) => {\r\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n        if (!FS.isMountpoint(lookup.node)) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n  \r\n        // destroy the nodes for this mount, and all its child mounts\r\n        var node = lookup.node;\r\n        var mount = node.mounted;\r\n        var mounts = FS.getMounts(mount);\r\n  \r\n        Object.keys(FS.nameTable).forEach((hash) => {\r\n          var current = FS.nameTable[hash];\r\n  \r\n          while (current) {\r\n            var next = current.name_next;\r\n  \r\n            if (mounts.includes(current.mount)) {\r\n              FS.destroyNode(current);\r\n            }\r\n  \r\n            current = next;\r\n          }\r\n        });\r\n  \r\n        // no longer a mountpoint\r\n        node.mounted = null;\r\n  \r\n        // remove this mount from the child mounts\r\n        var idx = node.mount.mounts.indexOf(mount);\r\n        node.mount.mounts.splice(idx, 1);\r\n      },lookup:(parent, name) => {\r\n        return parent.node_ops.lookup(parent, name);\r\n      },mknod:(path, mode, dev) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        if (!name || name === '.' || name === '..') {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var errCode = FS.mayCreate(parent, name);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.mknod) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return parent.node_ops.mknod(parent, name, mode, dev);\r\n      },create:(path, mode) => {\r\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\r\n        mode &= 4095;\r\n        mode |= 32768;\r\n        return FS.mknod(path, mode, 0);\r\n      },mkdir:(path, mode) => {\r\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\r\n        mode &= 511 | 512;\r\n        mode |= 16384;\r\n        return FS.mknod(path, mode, 0);\r\n      },mkdirTree:(path, mode) => {\r\n        var dirs = path.split('/');\r\n        var d = '';\r\n        for (var i = 0; i < dirs.length; ++i) {\r\n          if (!dirs[i]) continue;\r\n          d += '/' + dirs[i];\r\n          try {\r\n            FS.mkdir(d, mode);\r\n          } catch(e) {\r\n            if (e.errno != 20) throw e;\r\n          }\r\n        }\r\n      },mkdev:(path, mode, dev) => {\r\n        if (typeof dev == 'undefined') {\r\n          dev = mode;\r\n          mode = 438 /* 0666 */;\r\n        }\r\n        mode |= 8192;\r\n        return FS.mknod(path, mode, dev);\r\n      },symlink:(oldpath, newpath) => {\r\n        if (!PATH_FS.resolve(oldpath)) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var lookup = FS.lookupPath(newpath, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var newname = PATH.basename(newpath);\r\n        var errCode = FS.mayCreate(parent, newname);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.symlink) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return parent.node_ops.symlink(parent, newname, oldpath);\r\n      },rename:(old_path, new_path) => {\r\n        var old_dirname = PATH.dirname(old_path);\r\n        var new_dirname = PATH.dirname(new_path);\r\n        var old_name = PATH.basename(old_path);\r\n        var new_name = PATH.basename(new_path);\r\n        // parents must exist\r\n        var lookup, old_dir, new_dir;\r\n  \r\n        // let the errors from non existant directories percolate up\r\n        lookup = FS.lookupPath(old_path, { parent: true });\r\n        old_dir = lookup.node;\r\n        lookup = FS.lookupPath(new_path, { parent: true });\r\n        new_dir = lookup.node;\r\n  \r\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\r\n        // need to be part of the same mount\r\n        if (old_dir.mount !== new_dir.mount) {\r\n          throw new FS.ErrnoError(75);\r\n        }\r\n        // source must exist\r\n        var old_node = FS.lookupNode(old_dir, old_name);\r\n        // old path should not be an ancestor of the new path\r\n        var relative = PATH_FS.relative(old_path, new_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        // new path should not be an ancestor of the old path\r\n        relative = PATH_FS.relative(new_path, old_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(55);\r\n        }\r\n        // see if the new path already exists\r\n        var new_node;\r\n        try {\r\n          new_node = FS.lookupNode(new_dir, new_name);\r\n        } catch (e) {\r\n          // not fatal\r\n        }\r\n        // early out if nothing needs to change\r\n        if (old_node === new_node) {\r\n          return;\r\n        }\r\n        // we'll need to delete the old entry\r\n        var isdir = FS.isDir(old_node.mode);\r\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        // need delete permissions if we'll be overwriting.\r\n        // need create permissions if new doesn't already exist.\r\n        errCode = new_node ?\r\n          FS.mayDelete(new_dir, new_name, isdir) :\r\n          FS.mayCreate(new_dir, new_name);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!old_dir.node_ops.rename) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        // if we are going to change the parent, check write permissions\r\n        if (new_dir !== old_dir) {\r\n          errCode = FS.nodePermissions(old_dir, 'w');\r\n          if (errCode) {\r\n            throw new FS.ErrnoError(errCode);\r\n          }\r\n        }\r\n        // remove the node from the lookup hash\r\n        FS.hashRemoveNode(old_node);\r\n        // do the underlying fs rename\r\n        try {\r\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          // add the node back to the hash (in case node_ops.rename\r\n          // changed its name)\r\n          FS.hashAddNode(old_node);\r\n        }\r\n      },rmdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var errCode = FS.mayDelete(parent, name, true);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.rmdir) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        parent.node_ops.rmdir(parent, name);\r\n        FS.destroyNode(node);\r\n      },readdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        if (!node.node_ops.readdir) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        return node.node_ops.readdir(node);\r\n      },unlink:(path) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var errCode = FS.mayDelete(parent, name, false);\r\n        if (errCode) {\r\n          // According to POSIX, we should map EISDIR to EPERM, but\r\n          // we instead do what Linux does (and we must, as we use\r\n          // the musl linux libc).\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.unlink) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        parent.node_ops.unlink(parent, name);\r\n        FS.destroyNode(node);\r\n      },readlink:(path) => {\r\n        var lookup = FS.lookupPath(path);\r\n        var link = lookup.node;\r\n        if (!link) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!link.node_ops.readlink) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\r\n      },stat:(path, dontFollow) => {\r\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n        var node = lookup.node;\r\n        if (!node) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!node.node_ops.getattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return node.node_ops.getattr(node);\r\n      },lstat:(path) => {\r\n        return FS.stat(path, true);\r\n      },chmod:(path, mode, dontFollow) => {\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          mode: (mode & 4095) | (node.mode & ~4095),\r\n          timestamp: Date.now()\r\n        });\r\n      },lchmod:(path, mode) => {\r\n        FS.chmod(path, mode, true);\r\n      },fchmod:(fd, mode) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        FS.chmod(stream.node, mode);\r\n      },chown:(path, uid, gid, dontFollow) => {\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          timestamp: Date.now()\r\n          // we ignore the uid / gid for now\r\n        });\r\n      },lchown:(path, uid, gid) => {\r\n        FS.chown(path, uid, gid, true);\r\n      },fchown:(fd, uid, gid) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        FS.chown(stream.node, uid, gid);\r\n      },truncate:(path, len) => {\r\n        if (len < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: true });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!FS.isFile(node.mode)) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var errCode = FS.nodePermissions(node, 'w');\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          size: len,\r\n          timestamp: Date.now()\r\n        });\r\n      },ftruncate:(fd, len) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        FS.truncate(stream.node, len);\r\n      },utime:(path, atime, mtime) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        node.node_ops.setattr(node, {\r\n          timestamp: Math.max(atime, mtime)\r\n        });\r\n      },open:(path, flags, mode) => {\r\n        if (path === \"\") {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;\r\n        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\r\n        if ((flags & 64)) {\r\n          mode = (mode & 4095) | 32768;\r\n        } else {\r\n          mode = 0;\r\n        }\r\n        var node;\r\n        if (typeof path == 'object') {\r\n          node = path;\r\n        } else {\r\n          path = PATH.normalize(path);\r\n          try {\r\n            var lookup = FS.lookupPath(path, {\r\n              follow: !(flags & 131072)\r\n            });\r\n            node = lookup.node;\r\n          } catch (e) {\r\n            // ignore\r\n          }\r\n        }\r\n        // perhaps we need to create the node\r\n        var created = false;\r\n        if ((flags & 64)) {\r\n          if (node) {\r\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\r\n            if ((flags & 128)) {\r\n              throw new FS.ErrnoError(20);\r\n            }\r\n          } else {\r\n            // node doesn't exist, try to create it\r\n            node = FS.mknod(path, mode, 0);\r\n            created = true;\r\n          }\r\n        }\r\n        if (!node) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        // can't truncate a device\r\n        if (FS.isChrdev(node.mode)) {\r\n          flags &= ~512;\r\n        }\r\n        // if asked only for a directory, then this must be one\r\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        // check permissions, if this is not a file we just created now (it is ok to\r\n        // create and write to a file with read-only permissions; it is read-only\r\n        // for later use)\r\n        if (!created) {\r\n          var errCode = FS.mayOpen(node, flags);\r\n          if (errCode) {\r\n            throw new FS.ErrnoError(errCode);\r\n          }\r\n        }\r\n        // do truncation if necessary\r\n        if ((flags & 512) && !created) {\r\n          FS.truncate(node, 0);\r\n        }\r\n        // we've already handled these, don't pass down to the underlying vfs\r\n        flags &= ~(128 | 512 | 131072);\r\n  \r\n        // register the stream with the filesystem\r\n        var stream = FS.createStream({\r\n          node: node,\r\n          path: FS.getPath(node),  // we want the absolute path to the node\r\n          flags: flags,\r\n          seekable: true,\r\n          position: 0,\r\n          stream_ops: node.stream_ops,\r\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\r\n          ungotten: [],\r\n          error: false\r\n        });\r\n        // call the new stream's open function\r\n        if (stream.stream_ops.open) {\r\n          stream.stream_ops.open(stream);\r\n        }\r\n        if (Module['logReadFiles'] && !(flags & 1)) {\r\n          if (!FS.readFiles) FS.readFiles = {};\r\n          if (!(path in FS.readFiles)) {\r\n            FS.readFiles[path] = 1;\r\n          }\r\n        }\r\n        return stream;\r\n      },close:(stream) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (stream.getdents) stream.getdents = null; // free readdir state\r\n        try {\r\n          if (stream.stream_ops.close) {\r\n            stream.stream_ops.close(stream);\r\n          }\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          FS.closeStream(stream.fd);\r\n        }\r\n        stream.fd = null;\r\n      },isClosed:(stream) => {\r\n        return stream.fd === null;\r\n      },llseek:(stream, offset, whence) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (!stream.seekable || !stream.stream_ops.llseek) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        if (whence != 0 && whence != 1 && whence != 2) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n        stream.ungotten = [];\r\n        return stream.position;\r\n      },read:(stream, buffer, offset, length, position) => {\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!stream.stream_ops.read) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var seeking = typeof position != 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n        if (!seeking) stream.position += bytesRead;\r\n        return bytesRead;\r\n      },write:(stream, buffer, offset, length, position, canOwn) => {\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!stream.stream_ops.write) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (stream.seekable && stream.flags & 1024) {\r\n          // seek to the end before writing in append mode\r\n          FS.llseek(stream, 0, 2);\r\n        }\r\n        var seeking = typeof position != 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n        if (!seeking) stream.position += bytesWritten;\r\n        return bytesWritten;\r\n      },allocate:(stream, offset, length) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (offset < 0 || length <= 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        if (!stream.stream_ops.allocate) {\r\n          throw new FS.ErrnoError(138);\r\n        }\r\n        stream.stream_ops.allocate(stream, offset, length);\r\n      },mmap:(stream, length, position, prot, flags) => {\r\n        // User requests writing to file (prot & PROT_WRITE != 0).\r\n        // Checking if we have permissions to write to the file unless\r\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\r\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\r\n        // as all modifications will be visible only in the memory of\r\n        // the current process.\r\n        if ((prot & 2) !== 0\r\n            && (flags & 2) === 0\r\n            && (stream.flags & 2097155) !== 2) {\r\n          throw new FS.ErrnoError(2);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(2);\r\n        }\r\n        if (!stream.stream_ops.mmap) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\r\n      },msync:(stream, buffer, offset, length, mmapFlags) => {\r\n        if (!stream || !stream.stream_ops.msync) {\r\n          return 0;\r\n        }\r\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {\r\n        if (!stream.stream_ops.ioctl) {\r\n          throw new FS.ErrnoError(59);\r\n        }\r\n        return stream.stream_ops.ioctl(stream, cmd, arg);\r\n      },readFile:(path, opts = {}) => {\r\n        opts.flags = opts.flags || 0;\r\n        opts.encoding = opts.encoding || 'binary';\r\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\r\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\r\n        }\r\n        var ret;\r\n        var stream = FS.open(path, opts.flags);\r\n        var stat = FS.stat(path);\r\n        var length = stat.size;\r\n        var buf = new Uint8Array(length);\r\n        FS.read(stream, buf, 0, length, 0);\r\n        if (opts.encoding === 'utf8') {\r\n          ret = UTF8ArrayToString(buf, 0);\r\n        } else if (opts.encoding === 'binary') {\r\n          ret = buf;\r\n        }\r\n        FS.close(stream);\r\n        return ret;\r\n      },writeFile:(path, data, opts = {}) => {\r\n        opts.flags = opts.flags || 577;\r\n        var stream = FS.open(path, opts.flags, opts.mode);\r\n        if (typeof data == 'string') {\r\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\r\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n        } else if (ArrayBuffer.isView(data)) {\r\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n        } else {\r\n          throw new Error('Unsupported data type');\r\n        }\r\n        FS.close(stream);\r\n      },cwd:() => FS.currentPath,chdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        if (lookup.node === null) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!FS.isDir(lookup.node.mode)) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        var errCode = FS.nodePermissions(lookup.node, 'x');\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        FS.currentPath = lookup.path;\r\n      },createDefaultDirectories:() => {\r\n        FS.mkdir('/tmp');\r\n        FS.mkdir('/home');\r\n        FS.mkdir('/home/web_user');\r\n      },createDefaultDevices:() => {\r\n        // create /dev\r\n        FS.mkdir('/dev');\r\n        // setup /dev/null\r\n        FS.registerDevice(FS.makedev(1, 3), {\r\n          read: () => 0,\r\n          write: (stream, buffer, offset, length, pos) => length,\r\n        });\r\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\r\n        // setup /dev/tty and /dev/tty1\r\n        // stderr needs to print output using err() rather than out()\r\n        // so we register a second tty just for it.\r\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\r\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\r\n        // setup /dev/[u]random\r\n        var random_device = getRandomDevice();\r\n        FS.createDevice('/dev', 'random', random_device);\r\n        FS.createDevice('/dev', 'urandom', random_device);\r\n        // we're not going to emulate the actual shm device,\r\n        // just create the tmp dirs that reside in it commonly\r\n        FS.mkdir('/dev/shm');\r\n        FS.mkdir('/dev/shm/tmp');\r\n      },createSpecialDirectories:() => {\r\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\r\n        // name of the stream for fd 6 (see test_unistd_ttyname)\r\n        FS.mkdir('/proc');\r\n        var proc_self = FS.mkdir('/proc/self');\r\n        FS.mkdir('/proc/self/fd');\r\n        FS.mount({\r\n          mount: () => {\r\n            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\r\n            node.node_ops = {\r\n              lookup: (parent, name) => {\r\n                var fd = +name;\r\n                var stream = FS.getStream(fd);\r\n                if (!stream) throw new FS.ErrnoError(8);\r\n                var ret = {\r\n                  parent: null,\r\n                  mount: { mountpoint: 'fake' },\r\n                  node_ops: { readlink: () => stream.path },\r\n                };\r\n                ret.parent = ret; // make it look like a simple root node\r\n                return ret;\r\n              }\r\n            };\r\n            return node;\r\n          }\r\n        }, {}, '/proc/self/fd');\r\n      },createStandardStreams:() => {\r\n        // TODO deprecate the old functionality of a single\r\n        // input / output callback and that utilizes FS.createDevice\r\n        // and instead require a unique set of stream ops\r\n  \r\n        // by default, we symlink the standard streams to the\r\n        // default tty devices. however, if the standard streams\r\n        // have been overwritten we create a unique device for\r\n        // them instead.\r\n        if (Module['stdin']) {\r\n          FS.createDevice('/dev', 'stdin', Module['stdin']);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdin');\r\n        }\r\n        if (Module['stdout']) {\r\n          FS.createDevice('/dev', 'stdout', null, Module['stdout']);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdout');\r\n        }\r\n        if (Module['stderr']) {\r\n          FS.createDevice('/dev', 'stderr', null, Module['stderr']);\r\n        } else {\r\n          FS.symlink('/dev/tty1', '/dev/stderr');\r\n        }\r\n  \r\n        // open default streams for the stdin, stdout and stderr devices\r\n        var stdin = FS.open('/dev/stdin', 0);\r\n        var stdout = FS.open('/dev/stdout', 1);\r\n        var stderr = FS.open('/dev/stderr', 1);\r\n      },ensureErrnoError:() => {\r\n        if (FS.ErrnoError) return;\r\n        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {\r\n          this.node = node;\r\n          this.setErrno = /** @this{Object} */ function(errno) {\r\n            this.errno = errno;\r\n          };\r\n          this.setErrno(errno);\r\n          this.message = 'FS error';\r\n  \r\n        };\r\n        FS.ErrnoError.prototype = new Error();\r\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\r\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\r\n        [44].forEach((code) => {\r\n          FS.genericErrors[code] = new FS.ErrnoError(code);\r\n          FS.genericErrors[code].stack = '<generic error, no stack>';\r\n        });\r\n      },staticInit:() => {\r\n        FS.ensureErrnoError();\r\n  \r\n        FS.nameTable = new Array(4096);\r\n  \r\n        FS.mount(MEMFS, {}, '/');\r\n  \r\n        FS.createDefaultDirectories();\r\n        FS.createDefaultDevices();\r\n        FS.createSpecialDirectories();\r\n  \r\n        FS.filesystems = {\r\n          'MEMFS': MEMFS,\r\n        };\r\n      },init:(input, output, error) => {\r\n        FS.init.initialized = true;\r\n  \r\n        FS.ensureErrnoError();\r\n  \r\n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\r\n        Module['stdin'] = input || Module['stdin'];\r\n        Module['stdout'] = output || Module['stdout'];\r\n        Module['stderr'] = error || Module['stderr'];\r\n  \r\n        FS.createStandardStreams();\r\n      },quit:() => {\r\n        FS.init.initialized = false;\r\n        // Call musl-internal function to close all stdio streams, so nothing is\r\n        // left in internal buffers.\r\n        // close all of our streams\r\n        for (var i = 0; i < FS.streams.length; i++) {\r\n          var stream = FS.streams[i];\r\n          if (!stream) {\r\n            continue;\r\n          }\r\n          FS.close(stream);\r\n        }\r\n      },getMode:(canRead, canWrite) => {\r\n        var mode = 0;\r\n        if (canRead) mode |= 292 | 73;\r\n        if (canWrite) mode |= 146;\r\n        return mode;\r\n      },findObject:(path, dontResolveLastLink) => {\r\n        var ret = FS.analyzePath(path, dontResolveLastLink);\r\n        if (ret.exists) {\r\n          return ret.object;\r\n        } else {\r\n          return null;\r\n        }\r\n      },analyzePath:(path, dontResolveLastLink) => {\r\n        // operate from within the context of the symlink's target\r\n        try {\r\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          path = lookup.path;\r\n        } catch (e) {\r\n        }\r\n        var ret = {\r\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\r\n          parentExists: false, parentPath: null, parentObject: null\r\n        };\r\n        try {\r\n          var lookup = FS.lookupPath(path, { parent: true });\r\n          ret.parentExists = true;\r\n          ret.parentPath = lookup.path;\r\n          ret.parentObject = lookup.node;\r\n          ret.name = PATH.basename(path);\r\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          ret.exists = true;\r\n          ret.path = lookup.path;\r\n          ret.object = lookup.node;\r\n          ret.name = lookup.node.name;\r\n          ret.isRoot = lookup.path === '/';\r\n        } catch (e) {\r\n          ret.error = e.errno;\r\n        };\r\n        return ret;\r\n      },createPath:(parent, path, canRead, canWrite) => {\r\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n        var parts = path.split('/').reverse();\r\n        while (parts.length) {\r\n          var part = parts.pop();\r\n          if (!part) continue;\r\n          var current = PATH.join2(parent, part);\r\n          try {\r\n            FS.mkdir(current);\r\n          } catch (e) {\r\n            // ignore EEXIST\r\n          }\r\n          parent = current;\r\n        }\r\n        return current;\r\n      },createFile:(parent, name, properties, canRead, canWrite) => {\r\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS.getMode(canRead, canWrite);\r\n        return FS.create(path, mode);\r\n      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {\r\n        var path = name;\r\n        if (parent) {\r\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n          path = name ? PATH.join2(parent, name) : parent;\r\n        }\r\n        var mode = FS.getMode(canRead, canWrite);\r\n        var node = FS.create(path, mode);\r\n        if (data) {\r\n          if (typeof data == 'string') {\r\n            var arr = new Array(data.length);\r\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n            data = arr;\r\n          }\r\n          // make sure we can write to the file\r\n          FS.chmod(node, mode | 146);\r\n          var stream = FS.open(node, 577);\r\n          FS.write(stream, data, 0, data.length, 0, canOwn);\r\n          FS.close(stream);\r\n          FS.chmod(node, mode);\r\n        }\r\n        return node;\r\n      },createDevice:(parent, name, input, output) => {\r\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS.getMode(!!input, !!output);\r\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\r\n        var dev = FS.makedev(FS.createDevice.major++, 0);\r\n        // Create a fake device that a set of stream ops to emulate\r\n        // the old behavior.\r\n        FS.registerDevice(dev, {\r\n          open: (stream) => {\r\n            stream.seekable = false;\r\n          },\r\n          close: (stream) => {\r\n            // flush any pending line data\r\n            if (output && output.buffer && output.buffer.length) {\r\n              output(10);\r\n            }\r\n          },\r\n          read: (stream, buffer, offset, length, pos /* ignored */) => {\r\n            var bytesRead = 0;\r\n            for (var i = 0; i < length; i++) {\r\n              var result;\r\n              try {\r\n                result = input();\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(29);\r\n              }\r\n              if (result === undefined && bytesRead === 0) {\r\n                throw new FS.ErrnoError(6);\r\n              }\r\n              if (result === null || result === undefined) break;\r\n              bytesRead++;\r\n              buffer[offset+i] = result;\r\n            }\r\n            if (bytesRead) {\r\n              stream.node.timestamp = Date.now();\r\n            }\r\n            return bytesRead;\r\n          },\r\n          write: (stream, buffer, offset, length, pos) => {\r\n            for (var i = 0; i < length; i++) {\r\n              try {\r\n                output(buffer[offset+i]);\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(29);\r\n              }\r\n            }\r\n            if (length) {\r\n              stream.node.timestamp = Date.now();\r\n            }\r\n            return i;\r\n          }\r\n        });\r\n        return FS.mkdev(path, mode, dev);\r\n      },forceLoadFile:(obj) => {\r\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n        if (typeof XMLHttpRequest != 'undefined') {\r\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\r\n        } else if (read_) {\r\n          // Command-line.\r\n          try {\r\n            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\r\n            //          read() will try to parse UTF8.\r\n            obj.contents = intArrayFromString(read_(obj.url), true);\r\n            obj.usedBytes = obj.contents.length;\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n        } else {\r\n          throw new Error('Cannot load without read() or XMLHttpRequest.');\r\n        }\r\n      },createLazyFile:(parent, name, url, canRead, canWrite) => {\r\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\r\n        /** @constructor */\r\n        function LazyUint8Array() {\r\n          this.lengthKnown = false;\r\n          this.chunks = []; // Loaded chunks. Index is the chunk number\r\n        }\r\n        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {\r\n          if (idx > this.length-1 || idx < 0) {\r\n            return undefined;\r\n          }\r\n          var chunkOffset = idx % this.chunkSize;\r\n          var chunkNum = (idx / this.chunkSize)|0;\r\n          return this.getter(chunkNum)[chunkOffset];\r\n        };\r\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\r\n          this.getter = getter;\r\n        };\r\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\r\n          // Find length\r\n          var xhr = new XMLHttpRequest();\r\n          xhr.open('HEAD', url, false);\r\n          xhr.send(null);\r\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n          var header;\r\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n  \r\n          var chunkSize = 1024*1024; // Chunk size in bytes\r\n  \r\n          if (!hasByteServing) chunkSize = datalength;\r\n  \r\n          // Function to get a range from the remote URL.\r\n          var doXHR = (from, to) => {\r\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n            if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n  \r\n            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.open('GET', url, false);\r\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n  \r\n            // Some hints to the browser that we want binary data.\r\n            xhr.responseType = 'arraybuffer';\r\n            if (xhr.overrideMimeType) {\r\n              xhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n            }\r\n  \r\n            xhr.send(null);\r\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n            if (xhr.response !== undefined) {\r\n              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));\r\n            } else {\r\n              return intArrayFromString(xhr.responseText || '', true);\r\n            }\r\n          };\r\n          var lazyArray = this;\r\n          lazyArray.setDataGetter((chunkNum) => {\r\n            var start = chunkNum * chunkSize;\r\n            var end = (chunkNum+1) * chunkSize - 1; // including this byte\r\n            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\r\n            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\r\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\r\n            }\r\n            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');\r\n            return lazyArray.chunks[chunkNum];\r\n          });\r\n  \r\n          if (usesGzip || !datalength) {\r\n            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\r\n            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\r\n            datalength = this.getter(0).length;\r\n            chunkSize = datalength;\r\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\r\n          }\r\n  \r\n          this._length = datalength;\r\n          this._chunkSize = chunkSize;\r\n          this.lengthKnown = true;\r\n        };\r\n        if (typeof XMLHttpRequest != 'undefined') {\r\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\r\n          var lazyArray = new LazyUint8Array();\r\n          Object.defineProperties(lazyArray, {\r\n            length: {\r\n              get: /** @this{Object} */ function() {\r\n                if (!this.lengthKnown) {\r\n                  this.cacheLength();\r\n                }\r\n                return this._length;\r\n              }\r\n            },\r\n            chunkSize: {\r\n              get: /** @this{Object} */ function() {\r\n                if (!this.lengthKnown) {\r\n                  this.cacheLength();\r\n                }\r\n                return this._chunkSize;\r\n              }\r\n            }\r\n          });\r\n  \r\n          var properties = { isDevice: false, contents: lazyArray };\r\n        } else {\r\n          var properties = { isDevice: false, url: url };\r\n        }\r\n  \r\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n        // This is a total hack, but I want to get this lazy file code out of the\r\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\r\n        // be its own thin LAZYFS proxying calls to MEMFS.\r\n        if (properties.contents) {\r\n          node.contents = properties.contents;\r\n        } else if (properties.url) {\r\n          node.contents = null;\r\n          node.url = properties.url;\r\n        }\r\n        // Add a function that defers querying the file size until it is asked the first time.\r\n        Object.defineProperties(node, {\r\n          usedBytes: {\r\n            get: /** @this {FSNode} */ function() { return this.contents.length; }\r\n          }\r\n        });\r\n        // override each stream op with one that tries to force load the lazy file first\r\n        var stream_ops = {};\r\n        var keys = Object.keys(node.stream_ops);\r\n        keys.forEach((key) => {\r\n          var fn = node.stream_ops[key];\r\n          stream_ops[key] = function forceLoadLazyFile() {\r\n            FS.forceLoadFile(node);\r\n            return fn.apply(null, arguments);\r\n          };\r\n        });\r\n        // use a custom read function\r\n        stream_ops.read = (stream, buffer, offset, length, position) => {\r\n          FS.forceLoadFile(node);\r\n          var contents = stream.node.contents;\r\n          if (position >= contents.length)\r\n            return 0;\r\n          var size = Math.min(contents.length - position, length);\r\n          if (contents.slice) { // normal array\r\n            for (var i = 0; i < size; i++) {\r\n              buffer[offset + i] = contents[position + i];\r\n            }\r\n          } else {\r\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\r\n              buffer[offset + i] = contents.get(position + i);\r\n            }\r\n          }\r\n          return size;\r\n        };\r\n        node.stream_ops = stream_ops;\r\n        return node;\r\n      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\r\n        // TODO we should allow people to just pass in a complete filename instead\r\n        // of parent and name being that we just join them anyways\r\n        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\r\n        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname\r\n        function processData(byteArray) {\r\n          function finish(byteArray) {\r\n            if (preFinish) preFinish();\r\n            if (!dontCreateFile) {\r\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n            }\r\n            if (onload) onload();\r\n            removeRunDependency(dep);\r\n          }\r\n          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {\r\n            if (onerror) onerror();\r\n            removeRunDependency(dep);\r\n          })) {\r\n            return;\r\n          }\r\n          finish(byteArray);\r\n        }\r\n        addRunDependency(dep);\r\n        if (typeof url == 'string') {\r\n          asyncLoad(url, (byteArray) => processData(byteArray), onerror);\r\n        } else {\r\n          processData(url);\r\n        }\r\n      },indexedDB:() => {\r\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n      },DB_NAME:() => {\r\n        return 'EM_FS_' + window.location.pathname;\r\n      },DB_VERSION:20,DB_STORE_NAME:\"FILE_DATA\",saveFilesToDB:(paths, onload, onerror) => {\r\n        onload = onload || (() => {});\r\n        onerror = onerror || (() => {});\r\n        var indexedDB = FS.indexedDB();\r\n        try {\r\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n        } catch (e) {\r\n          return onerror(e);\r\n        }\r\n        openRequest.onupgradeneeded = () => {\r\n          out('creating db');\r\n          var db = openRequest.result;\r\n          db.createObjectStore(FS.DB_STORE_NAME);\r\n        };\r\n        openRequest.onsuccess = () => {\r\n          var db = openRequest.result;\r\n          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');\r\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n          var ok = 0, fail = 0, total = paths.length;\r\n          function finish() {\r\n            if (fail == 0) onload(); else onerror();\r\n          }\r\n          paths.forEach((path) => {\r\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\r\n            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };\r\n            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };\r\n          });\r\n          transaction.onerror = onerror;\r\n        };\r\n        openRequest.onerror = onerror;\r\n      },loadFilesFromDB:(paths, onload, onerror) => {\r\n        onload = onload || (() => {});\r\n        onerror = onerror || (() => {});\r\n        var indexedDB = FS.indexedDB();\r\n        try {\r\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n        } catch (e) {\r\n          return onerror(e);\r\n        }\r\n        openRequest.onupgradeneeded = onerror; // no database to load from\r\n        openRequest.onsuccess = () => {\r\n          var db = openRequest.result;\r\n          try {\r\n            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');\r\n          } catch(e) {\r\n            onerror(e);\r\n            return;\r\n          }\r\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n          var ok = 0, fail = 0, total = paths.length;\r\n          function finish() {\r\n            if (fail == 0) onload(); else onerror();\r\n          }\r\n          paths.forEach((path) => {\r\n            var getRequest = files.get(path);\r\n            getRequest.onsuccess = () => {\r\n              if (FS.analyzePath(path).exists) {\r\n                FS.unlink(path);\r\n              }\r\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\r\n              ok++;\r\n              if (ok + fail == total) finish();\r\n            };\r\n            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };\r\n          });\r\n          transaction.onerror = onerror;\r\n        };\r\n        openRequest.onerror = onerror;\r\n      }};\r\n  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {\r\n        if (PATH.isAbs(path)) {\r\n          return path;\r\n        }\r\n        // relative path\r\n        var dir;\r\n        if (dirfd === -100) {\r\n          dir = FS.cwd();\r\n        } else {\r\n          var dirstream = FS.getStream(dirfd);\r\n          if (!dirstream) throw new FS.ErrnoError(8);\r\n          dir = dirstream.path;\r\n        }\r\n        if (path.length == 0) {\r\n          if (!allowEmpty) {\r\n            throw new FS.ErrnoError(44);;\r\n          }\r\n          return dir;\r\n        }\r\n        return PATH.join2(dir, path);\r\n      },doStat:function(func, path, buf) {\r\n        try {\r\n          var stat = func(path);\r\n        } catch (e) {\r\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\r\n            // an error occurred while trying to look up the path; we should just report ENOTDIR\r\n            return -54;\r\n          }\r\n          throw e;\r\n        }\r\n        HEAP32[((buf)>>2)] = stat.dev;\r\n        HEAP32[(((buf)+(4))>>2)] = 0;\r\n        HEAP32[(((buf)+(8))>>2)] = stat.ino;\r\n        HEAP32[(((buf)+(12))>>2)] = stat.mode;\r\n        HEAP32[(((buf)+(16))>>2)] = stat.nlink;\r\n        HEAP32[(((buf)+(20))>>2)] = stat.uid;\r\n        HEAP32[(((buf)+(24))>>2)] = stat.gid;\r\n        HEAP32[(((buf)+(28))>>2)] = stat.rdev;\r\n        HEAP32[(((buf)+(32))>>2)] = 0;\r\n        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);\r\n        HEAP32[(((buf)+(48))>>2)] = 4096;\r\n        HEAP32[(((buf)+(52))>>2)] = stat.blocks;\r\n        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(60))>>2)] = 0;\r\n        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(68))>>2)] = 0;\r\n        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(76))>>2)] = 0;\r\n        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);\r\n        return 0;\r\n      },doMsync:function(addr, stream, len, flags, offset) {\r\n        var buffer = HEAPU8.slice(addr, addr + len);\r\n        FS.msync(stream, buffer, offset, len, flags);\r\n      },varargs:undefined,get:function() {\r\n        SYSCALLS.varargs += 4;\r\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\r\n        return ret;\r\n      },getStr:function(ptr) {\r\n        var ret = UTF8ToString(ptr);\r\n        return ret;\r\n      },getStreamFromFD:function(fd) {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) throw new FS.ErrnoError(8);\r\n        return stream;\r\n      }};\r\n  function _environ_get(__environ, environ_buf) {\r\n      var bufSize = 0;\r\n      getEnvStrings().forEach(function(string, i) {\r\n        var ptr = environ_buf + bufSize;\r\n        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;\r\n        writeAsciiToMemory(string, ptr);\r\n        bufSize += string.length + 1;\r\n      });\r\n      return 0;\r\n    }\r\n\r\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\r\n      var strings = getEnvStrings();\r\n      HEAPU32[((penviron_count)>>2)] = strings.length;\r\n      var bufSize = 0;\r\n      strings.forEach(function(string) {\r\n        bufSize += string.length + 1;\r\n      });\r\n      HEAPU32[((penviron_buf_size)>>2)] = bufSize;\r\n      return 0;\r\n    }\r\n\r\n  function _fd_close(fd) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      FS.close(stream);\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  /** @param {number=} offset */\r\n  function doReadv(stream, iov, iovcnt, offset) {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        var curr = FS.read(stream, HEAP8,ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr;\r\n        if (curr < len) break; // nothing more to read\r\n      }\r\n      return ret;\r\n    }\r\n  function _fd_read(fd, iov, iovcnt, pnum) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      var num = doReadv(stream, iov, iovcnt);\r\n      HEAP32[((pnum)>>2)] = num;\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  function convertI32PairToI53Checked(lo, hi) {\r\n      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\r\n    }\r\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\r\n  try {\r\n  \r\n      var offset = convertI32PairToI53Checked(offset_low, offset_high); if (isNaN(offset)) return 61;\r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      FS.llseek(stream, offset, whence);\r\n      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);\r\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  /** @param {number=} offset */\r\n  function doWritev(stream, iov, iovcnt, offset) {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        var curr = FS.write(stream, HEAP8,ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr;\r\n      }\r\n      return ret;\r\n    }\r\n  function _fd_write(fd, iov, iovcnt, pnum) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      var num = doWritev(stream, iov, iovcnt);\r\n      HEAPU32[((pnum)>>2)] = num;\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  function _setTempRet0(val) {\r\n      setTempRet0(val);\r\n    }\r\n\r\n  function __isLeapYear(year) {\r\n        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);\r\n    }\r\n  \r\n  function __arraySum(array, index) {\r\n      var sum = 0;\r\n      for (var i = 0; i <= index; sum += array[i++]) {\r\n        // no-op\r\n      }\r\n      return sum;\r\n    }\r\n  \r\n  var __MONTH_DAYS_LEAP = [31,29,31,30,31,30,31,31,30,31,30,31];\r\n  \r\n  var __MONTH_DAYS_REGULAR = [31,28,31,30,31,30,31,31,30,31,30,31];\r\n  function __addDays(date, days) {\r\n      var newDate = new Date(date.getTime());\r\n      while (days > 0) {\r\n        var leap = __isLeapYear(newDate.getFullYear());\r\n        var currentMonth = newDate.getMonth();\r\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\r\n  \r\n        if (days > daysInCurrentMonth-newDate.getDate()) {\r\n          // we spill over to next month\r\n          days -= (daysInCurrentMonth-newDate.getDate()+1);\r\n          newDate.setDate(1);\r\n          if (currentMonth < 11) {\r\n            newDate.setMonth(currentMonth+1)\r\n          } else {\r\n            newDate.setMonth(0);\r\n            newDate.setFullYear(newDate.getFullYear()+1);\r\n          }\r\n        } else {\r\n          // we stay in current month\r\n          newDate.setDate(newDate.getDate()+days);\r\n          return newDate;\r\n        }\r\n      }\r\n  \r\n      return newDate;\r\n    }\r\n  function _strftime(s, maxsize, format, tm) {\r\n      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);\r\n      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html\r\n  \r\n      var tm_zone = HEAP32[(((tm)+(40))>>2)];\r\n  \r\n      var date = {\r\n        tm_sec: HEAP32[((tm)>>2)],\r\n        tm_min: HEAP32[(((tm)+(4))>>2)],\r\n        tm_hour: HEAP32[(((tm)+(8))>>2)],\r\n        tm_mday: HEAP32[(((tm)+(12))>>2)],\r\n        tm_mon: HEAP32[(((tm)+(16))>>2)],\r\n        tm_year: HEAP32[(((tm)+(20))>>2)],\r\n        tm_wday: HEAP32[(((tm)+(24))>>2)],\r\n        tm_yday: HEAP32[(((tm)+(28))>>2)],\r\n        tm_isdst: HEAP32[(((tm)+(32))>>2)],\r\n        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],\r\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''\r\n      };\r\n  \r\n      var pattern = UTF8ToString(format);\r\n  \r\n      // expand format\r\n      var EXPANSION_RULES_1 = {\r\n        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013\r\n        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y\r\n        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d\r\n        '%h': '%b',                       // Equivalent to %b\r\n        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation\r\n        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation\r\n        '%T': '%H:%M:%S',                 // Replaced by the time\r\n        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation\r\n        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation\r\n        // Modified Conversion Specifiers\r\n        '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.\r\n        '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.\r\n        '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.\r\n        '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.\r\n        '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.\r\n        '%EY': '%Y',                      // Replaced by the full alternative year representation.\r\n        '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.\r\n        '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.\r\n        '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.\r\n        '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.\r\n        '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.\r\n        '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.\r\n        '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.\r\n        '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).\r\n        '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.\r\n        '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.\r\n        '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.\r\n        '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.\r\n        '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.\r\n      };\r\n      for (var rule in EXPANSION_RULES_1) {\r\n        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);\r\n      }\r\n  \r\n      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\r\n      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\r\n  \r\n      function leadingSomething(value, digits, character) {\r\n        var str = typeof value == 'number' ? value.toString() : (value || '');\r\n        while (str.length < digits) {\r\n          str = character[0]+str;\r\n        }\r\n        return str;\r\n      }\r\n  \r\n      function leadingNulls(value, digits) {\r\n        return leadingSomething(value, digits, '0');\r\n      }\r\n  \r\n      function compareByDay(date1, date2) {\r\n        function sgn(value) {\r\n          return value < 0 ? -1 : (value > 0 ? 1 : 0);\r\n        }\r\n  \r\n        var compare;\r\n        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {\r\n          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {\r\n            compare = sgn(date1.getDate()-date2.getDate());\r\n          }\r\n        }\r\n        return compare;\r\n      }\r\n  \r\n      function getFirstWeekStartDate(janFourth) {\r\n          switch (janFourth.getDay()) {\r\n            case 0: // Sunday\r\n              return new Date(janFourth.getFullYear()-1, 11, 29);\r\n            case 1: // Monday\r\n              return janFourth;\r\n            case 2: // Tuesday\r\n              return new Date(janFourth.getFullYear(), 0, 3);\r\n            case 3: // Wednesday\r\n              return new Date(janFourth.getFullYear(), 0, 2);\r\n            case 4: // Thursday\r\n              return new Date(janFourth.getFullYear(), 0, 1);\r\n            case 5: // Friday\r\n              return new Date(janFourth.getFullYear()-1, 11, 31);\r\n            case 6: // Saturday\r\n              return new Date(janFourth.getFullYear()-1, 11, 30);\r\n          }\r\n      }\r\n  \r\n      function getWeekBasedYear(date) {\r\n          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);\r\n  \r\n          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\r\n          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);\r\n  \r\n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\r\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\r\n  \r\n          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\r\n            // this date is after the start of the first week of this year\r\n            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\r\n              return thisDate.getFullYear()+1;\r\n            } else {\r\n              return thisDate.getFullYear();\r\n            }\r\n          } else {\r\n            return thisDate.getFullYear()-1;\r\n          }\r\n      }\r\n  \r\n      var EXPANSION_RULES_2 = {\r\n        '%a': function(date) {\r\n          return WEEKDAYS[date.tm_wday].substring(0,3);\r\n        },\r\n        '%A': function(date) {\r\n          return WEEKDAYS[date.tm_wday];\r\n        },\r\n        '%b': function(date) {\r\n          return MONTHS[date.tm_mon].substring(0,3);\r\n        },\r\n        '%B': function(date) {\r\n          return MONTHS[date.tm_mon];\r\n        },\r\n        '%C': function(date) {\r\n          var year = date.tm_year+1900;\r\n          return leadingNulls((year/100)|0,2);\r\n        },\r\n        '%d': function(date) {\r\n          return leadingNulls(date.tm_mday, 2);\r\n        },\r\n        '%e': function(date) {\r\n          return leadingSomething(date.tm_mday, 2, ' ');\r\n        },\r\n        '%g': function(date) {\r\n          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.\r\n          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes\r\n          // January 4th, which is also the week that includes the first Thursday of the year, and\r\n          // is also the first week that contains at least four days in the year.\r\n          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of\r\n          // the last week of the preceding year; thus, for Saturday 2nd January 1999,\r\n          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,\r\n          // or 31st is a Monday, it and any following days are part of week 1 of the following year.\r\n          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.\r\n  \r\n          return getWeekBasedYear(date).toString().substring(2);\r\n        },\r\n        '%G': function(date) {\r\n          return getWeekBasedYear(date);\r\n        },\r\n        '%H': function(date) {\r\n          return leadingNulls(date.tm_hour, 2);\r\n        },\r\n        '%I': function(date) {\r\n          var twelveHour = date.tm_hour;\r\n          if (twelveHour == 0) twelveHour = 12;\r\n          else if (twelveHour > 12) twelveHour -= 12;\r\n          return leadingNulls(twelveHour, 2);\r\n        },\r\n        '%j': function(date) {\r\n          // Day of the year (001-366)\r\n          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);\r\n        },\r\n        '%m': function(date) {\r\n          return leadingNulls(date.tm_mon+1, 2);\r\n        },\r\n        '%M': function(date) {\r\n          return leadingNulls(date.tm_min, 2);\r\n        },\r\n        '%n': function() {\r\n          return '\\n';\r\n        },\r\n        '%p': function(date) {\r\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\r\n            return 'AM';\r\n          } else {\r\n            return 'PM';\r\n          }\r\n        },\r\n        '%S': function(date) {\r\n          return leadingNulls(date.tm_sec, 2);\r\n        },\r\n        '%t': function() {\r\n          return '\\t';\r\n        },\r\n        '%u': function(date) {\r\n          return date.tm_wday || 7;\r\n        },\r\n        '%U': function(date) {\r\n          var days = date.tm_yday + 7 - date.tm_wday;\r\n          return leadingNulls(Math.floor(days / 7), 2);\r\n        },\r\n        '%V': function(date) {\r\n          // Replaced by the week number of the year (Monday as the first day of the week)\r\n          // as a decimal number [01,53]. If the week containing 1 January has four\r\n          // or more days in the new year, then it is considered week 1.\r\n          // Otherwise, it is the last week of the previous year, and the next week is week 1.\r\n          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]\r\n          var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7 ) / 7);\r\n          // If 1 Jan is just 1-3 days past Monday, the previous week\r\n          // is also in this year.\r\n          if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\r\n            val++;\r\n          }\r\n          if (!val) {\r\n            val = 52;\r\n            // If 31 December of prev year a Thursday, or Friday of a\r\n            // leap year, then the prev year has 53 weeks.\r\n            var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\r\n            if (dec31 == 4 || (dec31 == 5 && __isLeapYear(date.tm_year%400-1))) {\r\n              val++;\r\n            }\r\n          } else if (val == 53) {\r\n            // If 1 January is not a Thursday, and not a Wednesday of a\r\n            // leap year, then this year has only 52 weeks.\r\n            var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\r\n            if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year)))\r\n              val = 1;\r\n          }\r\n          return leadingNulls(val, 2);\r\n        },\r\n        '%w': function(date) {\r\n          return date.tm_wday;\r\n        },\r\n        '%W': function(date) {\r\n          var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\r\n          return leadingNulls(Math.floor(days / 7), 2);\r\n        },\r\n        '%y': function(date) {\r\n          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]\r\n          return (date.tm_year+1900).toString().substring(2);\r\n        },\r\n        '%Y': function(date) {\r\n          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]\r\n          return date.tm_year+1900;\r\n        },\r\n        '%z': function(date) {\r\n          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).\r\n          // For example, \"-0430\" means 4 hours 30 minutes behind UTC (west of Greenwich).\r\n          var off = date.tm_gmtoff;\r\n          var ahead = off >= 0;\r\n          off = Math.abs(off) / 60;\r\n          // convert from minutes into hhmm format (which means 60 minutes = 100 units)\r\n          off = (off / 60)*100 + (off % 60);\r\n          return (ahead ? '+' : '-') + String(\"0000\" + off).slice(-4);\r\n        },\r\n        '%Z': function(date) {\r\n          return date.tm_zone;\r\n        },\r\n        '%%': function() {\r\n          return '%';\r\n        }\r\n      };\r\n  \r\n      // Replace %% with a pair of NULLs (which cannot occur in a C string), then\r\n      // re-inject them after processing.\r\n      pattern = pattern.replace(/%%/g, '\\0\\0')\r\n      for (var rule in EXPANSION_RULES_2) {\r\n        if (pattern.includes(rule)) {\r\n          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));\r\n        }\r\n      }\r\n      pattern = pattern.replace(/\\0\\0/g, '%')\r\n  \r\n      var bytes = intArrayFromString(pattern, false);\r\n      if (bytes.length > maxsize) {\r\n        return 0;\r\n      }\r\n  \r\n      writeArrayToMemory(bytes, s);\r\n      return bytes.length-1;\r\n    }\r\n  function _strftime_l(s, maxsize, format, tm) {\r\n      return _strftime(s, maxsize, format, tm); // no locale support yet\r\n    }\r\nInternalError = Module['InternalError'] = extendError(Error, 'InternalError');;\r\nembind_init_charCodes();\r\nBindingError = Module['BindingError'] = extendError(Error, 'BindingError');;\r\ninit_ClassHandle();\r\ninit_embind();;\r\ninit_RegisteredPointer();\r\nUnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;\r\ninit_emval();;\r\n\r\n  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {\r\n    if (!parent) {\r\n      parent = this;  // root node sets parent to itself\r\n    }\r\n    this.parent = parent;\r\n    this.mount = parent.mount;\r\n    this.mounted = null;\r\n    this.id = FS.nextInode++;\r\n    this.name = name;\r\n    this.mode = mode;\r\n    this.node_ops = {};\r\n    this.stream_ops = {};\r\n    this.rdev = rdev;\r\n  };\r\n  var readMode = 292/*292*/ | 73/*73*/;\r\n  var writeMode = 146/*146*/;\r\n  Object.defineProperties(FSNode.prototype, {\r\n   read: {\r\n    get: /** @this{FSNode} */function() {\r\n     return (this.mode & readMode) === readMode;\r\n    },\r\n    set: /** @this{FSNode} */function(val) {\r\n     val ? this.mode |= readMode : this.mode &= ~readMode;\r\n    }\r\n   },\r\n   write: {\r\n    get: /** @this{FSNode} */function() {\r\n     return (this.mode & writeMode) === writeMode;\r\n    },\r\n    set: /** @this{FSNode} */function(val) {\r\n     val ? this.mode |= writeMode : this.mode &= ~writeMode;\r\n    }\r\n   },\r\n   isFolder: {\r\n    get: /** @this{FSNode} */function() {\r\n     return FS.isDir(this.mode);\r\n    }\r\n   },\r\n   isDevice: {\r\n    get: /** @this{FSNode} */function() {\r\n     return FS.isChrdev(this.mode);\r\n    }\r\n   }\r\n  });\r\n  FS.FSNode = FSNode;\r\n  FS.staticInit();;\r\nvar ASSERTIONS = false;\r\n\r\n\r\n\r\n/** @type {function(string, boolean=, number=)} */\r\nfunction intArrayFromString(stringy, dontAddNull, length) {\r\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\r\n  var u8array = new Array(len);\r\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n  if (dontAddNull) u8array.length = numBytesWritten;\r\n  return u8array;\r\n}\r\n\r\nfunction intArrayToString(array) {\r\n  var ret = [];\r\n  for (var i = 0; i < array.length; i++) {\r\n    var chr = array[i];\r\n    if (chr > 0xFF) {\r\n      if (ASSERTIONS) {\r\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\r\n      }\r\n      chr &= 0xFF;\r\n    }\r\n    ret.push(String.fromCharCode(chr));\r\n  }\r\n  return ret.join('');\r\n}\r\n\r\n\r\nvar asmLibraryArg = {\r\n  \"__assert_fail\": ___assert_fail,\r\n  \"__cxa_allocate_exception\": ___cxa_allocate_exception,\r\n  \"__cxa_throw\": ___cxa_throw,\r\n  \"_embind_finalize_value_object\": __embind_finalize_value_object,\r\n  \"_embind_register_bigint\": __embind_register_bigint,\r\n  \"_embind_register_bool\": __embind_register_bool,\r\n  \"_embind_register_class\": __embind_register_class,\r\n  \"_embind_register_class_class_function\": __embind_register_class_class_function,\r\n  \"_embind_register_class_constructor\": __embind_register_class_constructor,\r\n  \"_embind_register_class_function\": __embind_register_class_function,\r\n  \"_embind_register_emval\": __embind_register_emval,\r\n  \"_embind_register_float\": __embind_register_float,\r\n  \"_embind_register_integer\": __embind_register_integer,\r\n  \"_embind_register_memory_view\": __embind_register_memory_view,\r\n  \"_embind_register_std_string\": __embind_register_std_string,\r\n  \"_embind_register_std_wstring\": __embind_register_std_wstring,\r\n  \"_embind_register_value_object\": __embind_register_value_object,\r\n  \"_embind_register_value_object_field\": __embind_register_value_object_field,\r\n  \"_embind_register_void\": __embind_register_void,\r\n  \"_emval_as\": __emval_as,\r\n  \"_emval_call_method\": __emval_call_method,\r\n  \"_emval_call_void_method\": __emval_call_void_method,\r\n  \"_emval_decref\": __emval_decref,\r\n  \"_emval_get_method_caller\": __emval_get_method_caller,\r\n  \"_emval_get_property\": __emval_get_property,\r\n  \"_emval_incref\": __emval_incref,\r\n  \"_emval_new_array\": __emval_new_array,\r\n  \"_emval_new_cstring\": __emval_new_cstring,\r\n  \"_emval_run_destructors\": __emval_run_destructors,\r\n  \"_emval_take_value\": __emval_take_value,\r\n  \"abort\": _abort,\r\n  \"emscripten_memcpy_big\": _emscripten_memcpy_big,\r\n  \"emscripten_resize_heap\": _emscripten_resize_heap,\r\n  \"environ_get\": _environ_get,\r\n  \"environ_sizes_get\": _environ_sizes_get,\r\n  \"fd_close\": _fd_close,\r\n  \"fd_read\": _fd_read,\r\n  \"fd_seek\": _fd_seek,\r\n  \"fd_write\": _fd_write,\r\n  \"setTempRet0\": _setTempRet0,\r\n  \"strftime_l\": _strftime_l\r\n};\r\nvar asm = createWasm();\r\n/** @type {function(...*):?} */\r\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\r\n  return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"__wasm_call_ctors\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _malloc = Module[\"_malloc\"] = function() {\r\n  return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"malloc\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___getTypeName = Module[\"___getTypeName\"] = function() {\r\n  return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"__getTypeName\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function() {\r\n  return (___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = Module[\"asm\"][\"__embind_register_native_and_builtin_types\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___errno_location = Module[\"___errno_location\"] = function() {\r\n  return (___errno_location = Module[\"___errno_location\"] = Module[\"asm\"][\"__errno_location\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _free = Module[\"_free\"] = function() {\r\n  return (_free = Module[\"_free\"] = Module[\"asm\"][\"free\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar stackSave = Module[\"stackSave\"] = function() {\r\n  return (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"stackSave\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar stackRestore = Module[\"stackRestore\"] = function() {\r\n  return (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"stackRestore\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\r\n  return (stackAlloc = Module[\"stackAlloc\"] = Module[\"asm\"][\"stackAlloc\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = function() {\r\n  return (___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = Module[\"asm\"][\"__cxa_is_pointer_type\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_viijii = Module[\"dynCall_viijii\"] = function() {\r\n  return (dynCall_viijii = Module[\"dynCall_viijii\"] = Module[\"asm\"][\"dynCall_viijii\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\r\n  return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"dynCall_jiji\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = function() {\r\n  return (dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = Module[\"asm\"][\"dynCall_iiiiij\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = function() {\r\n  return (dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = Module[\"asm\"][\"dynCall_iiiiijj\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = function() {\r\n  return (dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = Module[\"asm\"][\"dynCall_iiiiiijj\"]).apply(null, arguments);\r\n};\r\n\r\n\r\n\r\n\r\n\r\n// === Auto-generated postamble setup entry stuff ===\r\n\r\n\r\n\r\nvar calledRun;\r\n\r\n/**\r\n * @constructor\r\n * @this {ExitStatus}\r\n */\r\nfunction ExitStatus(status) {\r\n  this.name = \"ExitStatus\";\r\n  this.message = \"Program terminated with exit(\" + status + \")\";\r\n  this.status = status;\r\n}\r\n\r\nvar calledMain = false;\r\n\r\ndependenciesFulfilled = function runCaller() {\r\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\r\n  if (!calledRun) run();\r\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\r\n};\r\n\r\n/** @type {function(Array=)} */\r\nfunction run(args) {\r\n  args = args || arguments_;\r\n\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n  preRun();\r\n\r\n  // a preRun added a dependency, run will be called later\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n  function doRun() {\r\n    // run may have just been called through dependencies being fulfilled just in this very frame,\r\n    // or while the async setStatus time below was happening\r\n    if (calledRun) return;\r\n    calledRun = true;\r\n    Module['calledRun'] = true;\r\n\r\n    if (ABORT) return;\r\n\r\n    initRuntime();\r\n\r\n    readyPromiseResolve(Module);\r\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\r\n\r\n    postRun();\r\n  }\r\n\r\n  if (Module['setStatus']) {\r\n    Module['setStatus']('Running...');\r\n    setTimeout(function() {\r\n      setTimeout(function() {\r\n        Module['setStatus']('');\r\n      }, 1);\r\n      doRun();\r\n    }, 1);\r\n  } else\r\n  {\r\n    doRun();\r\n  }\r\n}\r\nModule['run'] = run;\r\n\r\n/** @param {boolean|number=} implicit */\r\nfunction exit(status, implicit) {\r\n  EXITSTATUS = status;\r\n\r\n  procExit(status);\r\n}\r\n\r\nfunction procExit(code) {\r\n  EXITSTATUS = code;\r\n  if (!keepRuntimeAlive()) {\r\n    if (Module['onExit']) Module['onExit'](code);\r\n    ABORT = true;\r\n  }\r\n  quit_(code, new ExitStatus(code));\r\n}\r\n\r\nif (Module['preInit']) {\r\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\r\n  while (Module['preInit'].length > 0) {\r\n    Module['preInit'].pop()();\r\n  }\r\n}\r\n\r\nrun();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  return Module.ready\r\n}\r\n);\r\n})();\r\nexport default Module;","\r\nvar Module = (() => {\r\n  var _scriptDir = import.meta.url;\r\n  \r\n  return (\r\nfunction(Module) {\r\n  Module = Module || {};\r\n\r\n\r\n\r\n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(Module) { ..generated code.. }\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module = typeof Module != 'undefined' ? Module : {};\r\n\r\n// See https://caniuse.com/mdn-javascript_builtins_object_assign\r\n\r\n// Set up the promise that indicates the Module is initialized\r\nvar readyPromiseResolve, readyPromiseReject;\r\nModule['ready'] = new Promise(function(resolve, reject) {\r\n  readyPromiseResolve = resolve;\r\n  readyPromiseReject = reject;\r\n});\r\n\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\n// {{PRE_JSES}}\r\n\r\n// Sometimes an existing Module object exists with properties\r\n// meant to overwrite the default module functionality. Here\r\n// we collect those properties and reapply _after_ we configure\r\n// the current environment's defaults to avoid having to be so\r\n// defensive during initialization.\r\nvar moduleOverrides = Object.assign({}, Module);\r\n\r\nvar arguments_ = [];\r\nvar thisProgram = './this.program';\r\nvar quit_ = (status, toThrow) => {\r\n  throw toThrow;\r\n};\r\n\r\n// Determine the runtime environment we are in. You can customize this by\r\n// setting the ENVIRONMENT setting at compile time (see settings.js).\r\n\r\nvar ENVIRONMENT_IS_WEB = true;\r\nvar ENVIRONMENT_IS_WORKER = false;\r\nvar ENVIRONMENT_IS_NODE = false;\r\nvar ENVIRONMENT_IS_SHELL = false;\r\n\r\n// `/` should be present at the end if `scriptDirectory` is not empty\r\nvar scriptDirectory = '';\r\nfunction locateFile(path) {\r\n  if (Module['locateFile']) {\r\n    return Module['locateFile'](path, scriptDirectory);\r\n  }\r\n  return scriptDirectory + path;\r\n}\r\n\r\n// Hooks that are implemented differently in different runtime environments.\r\nvar read_,\r\n    readAsync,\r\n    readBinary,\r\n    setWindowTitle;\r\n\r\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\r\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\r\n// ENVIRONMENT_IS_NODE.\r\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\r\n    scriptDirectory = self.location.href;\r\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\r\n    scriptDirectory = document.currentScript.src;\r\n  }\r\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\r\n  // is gone, so we saved it, and we use it here instead of any other info.\r\n  if (_scriptDir) {\r\n    scriptDirectory = _scriptDir;\r\n  }\r\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\r\n  // otherwise, slice off the final part of the url to find the script directory.\r\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\r\n  // and scriptDirectory will correctly be replaced with an empty string.\r\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\r\n  // they are removed because they could contain a slash.\r\n  if (scriptDirectory.indexOf('blob:') !== 0) {\r\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf('/')+1);\r\n  } else {\r\n    scriptDirectory = '';\r\n  }\r\n\r\n  // Differentiate the Web Worker from the Node Worker case, as reading must\r\n  // be done differently.\r\n  {\r\n// include: web_or_worker_shell_read.js\r\n\r\n\r\n  read_ = (url) => {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, false);\r\n      xhr.send(null);\r\n      return xhr.responseText;\r\n  }\r\n\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    readBinary = (url) => {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, false);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.send(null);\r\n        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\r\n    };\r\n  }\r\n\r\n  readAsync = (url, onload, onerror) => {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, true);\r\n    xhr.responseType = 'arraybuffer';\r\n    xhr.onload = () => {\r\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n        onload(xhr.response);\r\n        return;\r\n      }\r\n      onerror();\r\n    };\r\n    xhr.onerror = onerror;\r\n    xhr.send(null);\r\n  }\r\n\r\n// end include: web_or_worker_shell_read.js\r\n  }\r\n\r\n  setWindowTitle = (title) => document.title = title;\r\n} else\r\n{\r\n}\r\n\r\nvar out = Module['print'] || console.log.bind(console);\r\nvar err = Module['printErr'] || console.warn.bind(console);\r\n\r\n// Merge back in the overrides\r\nObject.assign(Module, moduleOverrides);\r\n// Free the object hierarchy contained in the overrides, this lets the GC\r\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\r\nmoduleOverrides = null;\r\n\r\n// Emit code to handle expected values on the Module object. This applies Module.x\r\n// to the proper local x. This has two benefits: first, we only emit it if it is\r\n// expected to arrive, and second, by using a local everywhere else that can be\r\n// minified.\r\n\r\nif (Module['arguments']) arguments_ = Module['arguments'];\r\n\r\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];\r\n\r\nif (Module['quit']) quit_ = Module['quit'];\r\n\r\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\r\n\r\n\r\n\r\n\r\nvar STACK_ALIGN = 16;\r\nvar POINTER_SIZE = 4;\r\n\r\nfunction getNativeTypeSize(type) {\r\n  switch (type) {\r\n    case 'i1': case 'i8': case 'u8': return 1;\r\n    case 'i16': case 'u16': return 2;\r\n    case 'i32': case 'u32': return 4;\r\n    case 'i64': case 'u64': return 8;\r\n    case 'float': return 4;\r\n    case 'double': return 8;\r\n    default: {\r\n      if (type[type.length - 1] === '*') {\r\n        return POINTER_SIZE;\r\n      } else if (type[0] === 'i') {\r\n        const bits = Number(type.substr(1));\r\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\r\n        return bits / 8;\r\n      } else {\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnOnce(text) {\r\n  if (!warnOnce.shown) warnOnce.shown = {};\r\n  if (!warnOnce.shown[text]) {\r\n    warnOnce.shown[text] = 1;\r\n    err(text);\r\n  }\r\n}\r\n\r\n// include: runtime_functions.js\r\n\r\n\r\n// This gives correct answers for everything less than 2^{14} = 16384\r\n// I hope nobody is contemplating functions with 16384 arguments...\r\nfunction uleb128Encode(n) {\r\n  if (n < 128) {\r\n    return [n];\r\n  }\r\n  return [(n % 128) | 128, n >> 7];\r\n}\r\n\r\n// Wraps a JS function as a wasm function with a given signature.\r\nfunction convertJsFunctionToWasm(func, sig) {\r\n\r\n  // If the type reflection proposal is available, use the new\r\n  // \"WebAssembly.Function\" constructor.\r\n  // Otherwise, construct a minimal wasm module importing the JS function and\r\n  // re-exporting it.\r\n  if (typeof WebAssembly.Function == \"function\") {\r\n    var typeNames = {\r\n      'i': 'i32',\r\n      'j': 'i64',\r\n      'f': 'f32',\r\n      'd': 'f64',\r\n      'p': 'i32',\r\n    };\r\n    var type = {\r\n      parameters: [],\r\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\r\n    };\r\n    for (var i = 1; i < sig.length; ++i) {\r\n      type.parameters.push(typeNames[sig[i]]);\r\n    }\r\n    return new WebAssembly.Function(type, func);\r\n  }\r\n\r\n  // The module is static, with the exception of the type section, which is\r\n  // generated based on the signature passed in.\r\n  var typeSection = [\r\n    0x01, // count: 1\r\n    0x60, // form: func\r\n  ];\r\n  var sigRet = sig.slice(0, 1);\r\n  var sigParam = sig.slice(1);\r\n  var typeCodes = {\r\n    'i': 0x7f, // i32\r\n    'p': 0x7f, // i32\r\n    'j': 0x7e, // i64\r\n    'f': 0x7d, // f32\r\n    'd': 0x7c, // f64\r\n  };\r\n\r\n  // Parameters, length + signatures\r\n  typeSection = typeSection.concat(uleb128Encode(sigParam.length));\r\n  for (var i = 0; i < sigParam.length; ++i) {\r\n    typeSection.push(typeCodes[sigParam[i]]);\r\n  }\r\n\r\n  // Return values, length + signatures\r\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\r\n  if (sigRet == 'v') {\r\n    typeSection.push(0x00);\r\n  } else {\r\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\r\n  }\r\n\r\n  // Write the section code and overall length of the type section into the\r\n  // section header\r\n  typeSection = [0x01 /* Type section code */].concat(\r\n    uleb128Encode(typeSection.length),\r\n    typeSection\r\n  );\r\n\r\n  // Rest of the module is static\r\n  var bytes = new Uint8Array([\r\n    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\r\n    0x01, 0x00, 0x00, 0x00, // version: 1\r\n  ].concat(typeSection, [\r\n    0x02, 0x07, // import section\r\n      // (import \"e\" \"f\" (func 0 (type 0)))\r\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\r\n    0x07, 0x05, // export section\r\n      // (export \"f\" (func 0 (type 0)))\r\n      0x01, 0x01, 0x66, 0x00, 0x00,\r\n  ]));\r\n\r\n   // We can compile this wasm module synchronously because it is very small.\r\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\r\n  var module = new WebAssembly.Module(bytes);\r\n  var instance = new WebAssembly.Instance(module, {\r\n    'e': {\r\n      'f': func\r\n    }\r\n  });\r\n  var wrappedFunc = instance.exports['f'];\r\n  return wrappedFunc;\r\n}\r\n\r\nvar freeTableIndexes = [];\r\n\r\n// Weak map of functions in the table to their indexes, created on first use.\r\nvar functionsInTableMap;\r\n\r\nfunction getEmptyTableSlot() {\r\n  // Reuse a free index if there is one, otherwise grow.\r\n  if (freeTableIndexes.length) {\r\n    return freeTableIndexes.pop();\r\n  }\r\n  // Grow the table\r\n  try {\r\n    wasmTable.grow(1);\r\n  } catch (err) {\r\n    if (!(err instanceof RangeError)) {\r\n      throw err;\r\n    }\r\n    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';\r\n  }\r\n  return wasmTable.length - 1;\r\n}\r\n\r\nfunction updateTableMap(offset, count) {\r\n  for (var i = offset; i < offset + count; i++) {\r\n    var item = getWasmTableEntry(i);\r\n    // Ignore null values.\r\n    if (item) {\r\n      functionsInTableMap.set(item, i);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Add a function to the table.\r\n * 'sig' parameter is required if the function being added is a JS function.\r\n * @param {string=} sig\r\n */\r\nfunction addFunction(func, sig) {\r\n\r\n  // Check if the function is already in the table, to ensure each function\r\n  // gets a unique index. First, create the map if this is the first use.\r\n  if (!functionsInTableMap) {\r\n    functionsInTableMap = new WeakMap();\r\n    updateTableMap(0, wasmTable.length);\r\n  }\r\n  if (functionsInTableMap.has(func)) {\r\n    return functionsInTableMap.get(func);\r\n  }\r\n\r\n  // It's not in the table, add it now.\r\n\r\n  var ret = getEmptyTableSlot();\r\n\r\n  // Set the new value.\r\n  try {\r\n    // Attempting to call this with JS function will cause of table.set() to fail\r\n    setWasmTableEntry(ret, func);\r\n  } catch (err) {\r\n    if (!(err instanceof TypeError)) {\r\n      throw err;\r\n    }\r\n    var wrapped = convertJsFunctionToWasm(func, sig);\r\n    setWasmTableEntry(ret, wrapped);\r\n  }\r\n\r\n  functionsInTableMap.set(func, ret);\r\n\r\n  return ret;\r\n}\r\n\r\nfunction removeFunction(index) {\r\n  functionsInTableMap.delete(getWasmTableEntry(index));\r\n  freeTableIndexes.push(index);\r\n}\r\n\r\n// end include: runtime_functions.js\r\n// include: runtime_debug.js\r\n\r\n\r\n// end include: runtime_debug.js\r\nvar tempRet0 = 0;\r\nvar setTempRet0 = (value) => { tempRet0 = value; };\r\nvar getTempRet0 = () => tempRet0;\r\n\r\n\r\n\r\n// === Preamble library stuff ===\r\n\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\nvar wasmBinary;\r\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\r\nvar noExitRuntime = Module['noExitRuntime'] || true;\r\n\r\nif (typeof WebAssembly != 'object') {\r\n  abort('no native wasm support detected');\r\n}\r\n\r\n// Wasm globals\r\n\r\nvar wasmMemory;\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n\r\n// whether we are quitting the application. no code should run after this.\r\n// set in exit() and abort()\r\nvar ABORT = false;\r\n\r\n// set by exit() and abort().  Passed to 'onExit' handler.\r\n// NOTE: This is also used as the process return code code in shell environments\r\n// but only when noExitRuntime is false.\r\nvar EXITSTATUS;\r\n\r\n/** @type {function(*, string=)} */\r\nfunction assert(condition, text) {\r\n  if (!condition) {\r\n    // This build was created without ASSERTIONS defined.  `assert()` should not\r\n    // ever be called in this configuration but in case there are callers in\r\n    // the wild leave this simple abort() implemenation here for now.\r\n    abort(text);\r\n  }\r\n}\r\n\r\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\r\nfunction getCFunc(ident) {\r\n  var func = Module['_' + ident]; // closure exported function\r\n  return func;\r\n}\r\n\r\n// C calling interface.\r\n/** @param {string|null=} returnType\r\n    @param {Array=} argTypes\r\n    @param {Arguments|Array=} args\r\n    @param {Object=} opts */\r\nfunction ccall(ident, returnType, argTypes, args, opts) {\r\n  // For fast lookup of conversion functions\r\n  var toC = {\r\n    'string': function(str) {\r\n      var ret = 0;\r\n      if (str !== null && str !== undefined && str !== 0) { // null string\r\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\r\n        var len = (str.length << 2) + 1;\r\n        ret = stackAlloc(len);\r\n        stringToUTF8(str, ret, len);\r\n      }\r\n      return ret;\r\n    },\r\n    'array': function(arr) {\r\n      var ret = stackAlloc(arr.length);\r\n      writeArrayToMemory(arr, ret);\r\n      return ret;\r\n    }\r\n  };\r\n\r\n  function convertReturnValue(ret) {\r\n    if (returnType === 'string') {\r\n      \r\n      return UTF8ToString(ret);\r\n    }\r\n    if (returnType === 'boolean') return Boolean(ret);\r\n    return ret;\r\n  }\r\n\r\n  var func = getCFunc(ident);\r\n  var cArgs = [];\r\n  var stack = 0;\r\n  if (args) {\r\n    for (var i = 0; i < args.length; i++) {\r\n      var converter = toC[argTypes[i]];\r\n      if (converter) {\r\n        if (stack === 0) stack = stackSave();\r\n        cArgs[i] = converter(args[i]);\r\n      } else {\r\n        cArgs[i] = args[i];\r\n      }\r\n    }\r\n  }\r\n  var ret = func.apply(null, cArgs);\r\n  function onDone(ret) {\r\n    if (stack !== 0) stackRestore(stack);\r\n    return convertReturnValue(ret);\r\n  }\r\n\r\n  ret = onDone(ret);\r\n  return ret;\r\n}\r\n\r\n/** @param {string=} returnType\r\n    @param {Array=} argTypes\r\n    @param {Object=} opts */\r\nfunction cwrap(ident, returnType, argTypes, opts) {\r\n  argTypes = argTypes || [];\r\n  // When the function takes numbers and returns a number, we can just return\r\n  // the original function\r\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\r\n  var numericRet = returnType !== 'string';\r\n  if (numericRet && numericArgs && !opts) {\r\n    return getCFunc(ident);\r\n  }\r\n  return function() {\r\n    return ccall(ident, returnType, argTypes, arguments, opts);\r\n  }\r\n}\r\n\r\n// include: runtime_legacy.js\r\n\r\n\r\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\r\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\r\n\r\n/**\r\n * allocate(): This function is no longer used by emscripten but is kept around to avoid\r\n *             breaking external users.\r\n *             You should normally not use allocate(), and instead allocate\r\n *             memory using _malloc()/stackAlloc(), initialize it with\r\n *             setValue(), and so forth.\r\n * @param {(Uint8Array|Array<number>)} slab: An array of data.\r\n * @param {number=} allocator : How to allocate memory, see ALLOC_*\r\n */\r\nfunction allocate(slab, allocator) {\r\n  var ret;\r\n\r\n  if (allocator == ALLOC_STACK) {\r\n    ret = stackAlloc(slab.length);\r\n  } else {\r\n    ret = _malloc(slab.length);\r\n  }\r\n\r\n  if (!slab.subarray && !slab.slice) {\r\n    slab = new Uint8Array(slab);\r\n  }\r\n  HEAPU8.set(slab, ret);\r\n  return ret;\r\n}\r\n\r\n// end include: runtime_legacy.js\r\n// include: runtime_strings.js\r\n\r\n\r\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\r\n\r\nvar UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\r\n// a copy of that string as a Javascript String object.\r\n/**\r\n * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n * @param {number} idx\r\n * @param {number=} maxBytesToRead\r\n * @return {string}\r\n */\r\nfunction UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\r\n  var endIdx = idx + maxBytesToRead;\r\n  var endPtr = idx;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\r\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n\r\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\r\n    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\r\n  } else {\r\n    var str = '';\r\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\r\n    while (idx < endPtr) {\r\n      // For UTF8 byte structure, see:\r\n      // http://en.wikipedia.org/wiki/UTF-8#Description\r\n      // https://www.ietf.org/rfc/rfc2279.txt\r\n      // https://tools.ietf.org/html/rfc3629\r\n      var u0 = heapOrArray[idx++];\r\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\r\n      var u1 = heapOrArray[idx++] & 63;\r\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\r\n      var u2 = heapOrArray[idx++] & 63;\r\n      if ((u0 & 0xF0) == 0xE0) {\r\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n      } else {\r\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\r\n      }\r\n\r\n      if (u0 < 0x10000) {\r\n        str += String.fromCharCode(u0);\r\n      } else {\r\n        var ch = u0 - 0x10000;\r\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\r\n// copy of that string as a Javascript String object.\r\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\r\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\r\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\r\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\r\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\r\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\r\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\r\n//                 style or the other.\r\n/**\r\n * @param {number} ptr\r\n * @param {number=} maxBytesToRead\r\n * @return {string}\r\n */\r\nfunction UTF8ToString(ptr, maxBytesToRead) {\r\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\r\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.\r\n//   outIdx: The starting offset in the array to begin the copying.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\r\n//                    This count should include the null terminator,\r\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\r\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\r\n    return 0;\r\n\r\n  var startIdx = outIdx;\r\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xD800 && u <= 0xDFFF) {\r\n      var u1 = str.charCodeAt(++i);\r\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\r\n    }\r\n    if (u <= 0x7F) {\r\n      if (outIdx >= endIdx) break;\r\n      heap[outIdx++] = u;\r\n    } else if (u <= 0x7FF) {\r\n      if (outIdx + 1 >= endIdx) break;\r\n      heap[outIdx++] = 0xC0 | (u >> 6);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    } else if (u <= 0xFFFF) {\r\n      if (outIdx + 2 >= endIdx) break;\r\n      heap[outIdx++] = 0xE0 | (u >> 12);\r\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    } else {\r\n      if (outIdx + 3 >= endIdx) break;\r\n      heap[outIdx++] = 0xF0 | (u >> 18);\r\n      heap[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      heap[outIdx++] = 0x80 | (u & 63);\r\n    }\r\n  }\r\n  // Null-terminate the pointer to the buffer.\r\n  heap[outIdx] = 0;\r\n  return outIdx - startIdx;\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\r\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\r\nfunction lengthBytesUTF8(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    if (u <= 0x7F) ++len;\r\n    else if (u <= 0x7FF) len += 2;\r\n    else if (u <= 0xFFFF) len += 3;\r\n    else len += 4;\r\n  }\r\n  return len;\r\n}\r\n\r\n// end include: runtime_strings.js\r\n// include: runtime_strings_extra.js\r\n\r\n\r\n// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\r\n\r\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nfunction AsciiToString(ptr) {\r\n  var str = '';\r\n  while (1) {\r\n    var ch = HEAPU8[((ptr++)>>0)];\r\n    if (!ch) return str;\r\n    str += String.fromCharCode(ch);\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\r\n\r\nfunction stringToAscii(str, outPtr) {\r\n  return writeAsciiToMemory(str, outPtr, false);\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nvar UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;\r\n\r\nfunction UTF16ToString(ptr, maxBytesToRead) {\r\n  var endPtr = ptr;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  var idx = endPtr >> 1;\r\n  var maxIdx = idx + maxBytesToRead / 2;\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n  // will always evaluate to true. This saves on code size.\r\n  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\r\n  endPtr = idx << 1;\r\n\r\n  if (endPtr - ptr > 32 && UTF16Decoder) {\r\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n  } else {\r\n    var str = '';\r\n\r\n    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition\r\n    // will always evaluate to true. The loop is then terminated on the first null char.\r\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\r\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\r\n      if (codeUnit == 0) break;\r\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\r\n      str += String.fromCharCode(codeUnit);\r\n    }\r\n\r\n    return str;\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7FFFFFFF;\r\n  }\r\n  if (maxBytesToWrite < 2) return 0;\r\n  maxBytesToWrite -= 2; // Null terminator.\r\n  var startPtr = outPtr;\r\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\r\n  for (var i = 0; i < numCharsToWrite; ++i) {\r\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    HEAP16[((outPtr)>>1)] = codeUnit;\r\n    outPtr += 2;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP16[((outPtr)>>1)] = 0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF16(str) {\r\n  return str.length*2;\r\n}\r\n\r\nfunction UTF32ToString(ptr, maxBytesToRead) {\r\n  var i = 0;\r\n\r\n  var str = '';\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n  // will always evaluate to true. This saves on code size.\r\n  while (!(i >= maxBytesToRead / 4)) {\r\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\r\n    if (utf32 == 0) break;\r\n    ++i;\r\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    if (utf32 >= 0x10000) {\r\n      var ch = utf32 - 0x10000;\r\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n    } else {\r\n      str += String.fromCharCode(utf32);\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7FFFFFFF;\r\n  }\r\n  if (maxBytesToWrite < 4) return 0;\r\n  var startPtr = outPtr;\r\n  var endPtr = startPtr + maxBytesToWrite - 4;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\r\n      var trailSurrogate = str.charCodeAt(++i);\r\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\r\n    }\r\n    HEAP32[((outPtr)>>2)] = codeUnit;\r\n    outPtr += 4;\r\n    if (outPtr + 4 > endPtr) break;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP32[((outPtr)>>2)] = 0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF32(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i);\r\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\r\n    len += 4;\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n// Allocate heap space for a JS string, and write it there.\r\n// It is the responsibility of the caller to free() that memory.\r\nfunction allocateUTF8(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = _malloc(size);\r\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Allocate stack space for a JS string, and write it there.\r\nfunction allocateUTF8OnStack(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = stackAlloc(size);\r\n  stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Deprecated: This function should not be called because it is unsafe and does not provide\r\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\r\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\r\n// to be secure from out of bounds writes.\r\n/** @deprecated\r\n    @param {boolean=} dontAddNull */\r\nfunction writeStringToMemory(string, buffer, dontAddNull) {\r\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\r\n\r\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\r\n  if (dontAddNull) {\r\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\r\n    // character that existed at the location where the null will be placed, and restore\r\n    // that after the write (below).\r\n    end = buffer + lengthBytesUTF8(string);\r\n    lastChar = HEAP8[end];\r\n  }\r\n  stringToUTF8(string, buffer, Infinity);\r\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\r\n}\r\n\r\nfunction writeArrayToMemory(array, buffer) {\r\n  HEAP8.set(array, buffer);\r\n}\r\n\r\n/** @param {boolean=} dontAddNull */\r\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\r\n  for (var i = 0; i < str.length; ++i) {\r\n    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;\r\n}\r\n\r\n// end include: runtime_strings_extra.js\r\n// Memory management\r\n\r\nvar HEAP,\r\n/** @type {!ArrayBuffer} */\r\n  buffer,\r\n/** @type {!Int8Array} */\r\n  HEAP8,\r\n/** @type {!Uint8Array} */\r\n  HEAPU8,\r\n/** @type {!Int16Array} */\r\n  HEAP16,\r\n/** @type {!Uint16Array} */\r\n  HEAPU16,\r\n/** @type {!Int32Array} */\r\n  HEAP32,\r\n/** @type {!Uint32Array} */\r\n  HEAPU32,\r\n/** @type {!Float32Array} */\r\n  HEAPF32,\r\n/** @type {!Float64Array} */\r\n  HEAPF64;\r\n\r\nfunction updateGlobalBufferAndViews(buf) {\r\n  buffer = buf;\r\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\r\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\r\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\r\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\r\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\r\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\r\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\r\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\r\n}\r\n\r\nvar TOTAL_STACK = 2097152;\r\n\r\nvar INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 134217728;\r\n\r\n// include: runtime_init_table.js\r\n// In regular non-RELOCATABLE mode the table is exported\r\n// from the wasm module and this will be assigned once\r\n// the exports are available.\r\nvar wasmTable;\r\n\r\n// end include: runtime_init_table.js\r\n// include: runtime_stack_check.js\r\n\r\n\r\n// end include: runtime_stack_check.js\r\n// include: runtime_assertions.js\r\n\r\n\r\n// end include: runtime_assertions.js\r\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\r\nvar __ATINIT__    = []; // functions called during startup\r\nvar __ATEXIT__    = []; // functions called during shutdown\r\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\r\n\r\nvar runtimeInitialized = false;\r\n\r\nfunction keepRuntimeAlive() {\r\n  return noExitRuntime;\r\n}\r\n\r\nfunction preRun() {\r\n\r\n  if (Module['preRun']) {\r\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\r\n    while (Module['preRun'].length) {\r\n      addOnPreRun(Module['preRun'].shift());\r\n    }\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction initRuntime() {\r\n  runtimeInitialized = true;\r\n\r\n  \r\nif (!Module[\"noFSInit\"] && !FS.init.initialized)\r\n  FS.init();\r\nFS.ignorePermissions = false;\r\n\r\nTTY.init();\r\n  callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction postRun() {\r\n\r\n  if (Module['postRun']) {\r\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\r\n    while (Module['postRun'].length) {\r\n      addOnPostRun(Module['postRun'].shift());\r\n    }\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n  __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n  __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnExit(cb) {\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n  __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\n// include: runtime_math.js\r\n\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\r\n\r\n// end include: runtime_math.js\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// Module.preRun (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\nvar runDependencyWatcher = null;\r\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  return id;\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback(); // can add another dependenciesFulfilled\r\n    }\r\n  }\r\n}\r\n\r\n/** @param {string|number=} what */\r\nfunction abort(what) {\r\n  {\r\n    if (Module['onAbort']) {\r\n      Module['onAbort'](what);\r\n    }\r\n  }\r\n\r\n  what = 'Aborted(' + what + ')';\r\n  // TODO(sbc): Should we remove printing and leave it up to whoever\r\n  // catches the exception?\r\n  err(what);\r\n\r\n  ABORT = true;\r\n  EXITSTATUS = 1;\r\n\r\n  what += '. Build with -sASSERTIONS for more info.';\r\n\r\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\r\n  // exception, which means we'd run destructors on it. We need the error to\r\n  // simply make the program stop.\r\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\r\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\r\n  // a trap or not based on a hidden field within the object. So at the moment\r\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\r\n  // allows this in the wasm spec.\r\n\r\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\r\n  // defintion for WebAssembly.RuntimeError claims it takes no arguments even\r\n  // though it can.\r\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\r\n  /** @suppress {checkTypes} */\r\n  var e = new WebAssembly.RuntimeError(what);\r\n\r\n  readyPromiseReject(e);\r\n  // Throw the error whether or not MODULARIZE is set because abort is used\r\n  // in code paths apart from instantiation where an exception is expected\r\n  // to be thrown when abort is called.\r\n  throw e;\r\n}\r\n\r\n// {{MEM_INITIALIZER}}\r\n\r\n// include: memoryprofiler.js\r\n\r\n\r\n// end include: memoryprofiler.js\r\n// include: URIUtils.js\r\n\r\n\r\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\r\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\r\n\r\n// Indicates whether filename is a base64 data URI.\r\nfunction isDataURI(filename) {\r\n  // Prefix of data URIs emitted by SINGLE_FILE and related options.\r\n  return filename.startsWith(dataURIPrefix);\r\n}\r\n\r\n// Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\nfunction isFileURI(filename) {\r\n  return filename.startsWith('file://');\r\n}\r\n\r\n// end include: URIUtils.js\r\nvar wasmBinaryFile;\r\nif (Module['locateFile']) {\r\n  wasmBinaryFile = 'C:/Husky/streams2/tools/code/Influx/webpack-addons/module-e32e6b96488546f5db0e12945a440365.wasm';\r\n  if (!isDataURI(wasmBinaryFile)) {\r\n    wasmBinaryFile = locateFile(wasmBinaryFile);\r\n  }\r\n} else {\r\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\r\n  wasmBinaryFile = new URL('C:/Husky/streams2/tools/code/Influx/webpack-addons/module-e32e6b96488546f5db0e12945a440365.wasm', import.meta.url).toString();\r\n}\r\n\r\nfunction getBinary(file) {\r\n  try {\r\n    if (file == wasmBinaryFile && wasmBinary) {\r\n      return new Uint8Array(wasmBinary);\r\n    }\r\n    if (readBinary) {\r\n      return readBinary(file);\r\n    } else {\r\n      throw \"both async and sync fetching of the wasm failed\";\r\n    }\r\n  }\r\n  catch (err) {\r\n    abort(err);\r\n  }\r\n}\r\n\r\nfunction getBinaryPromise() {\r\n  // If we don't have the binary yet, try to to load it asynchronously.\r\n  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\r\n  // See https://github.com/github/fetch/pull/92#issuecomment-140665932\r\n  // Cordova or Electron apps are typically loaded from a file:// url.\r\n  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\r\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\r\n    if (typeof fetch == 'function'\r\n    ) {\r\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\r\n        if (!response['ok']) {\r\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\r\n        }\r\n        return response['arrayBuffer']();\r\n      }).catch(function () {\r\n          return getBinary(wasmBinaryFile);\r\n      });\r\n    }\r\n  }\r\n\r\n  // Otherwise, getBinary should be able to get it synchronously\r\n  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });\r\n}\r\n\r\n// Create the wasm instance.\r\n// Receives the wasm imports, returns the exports.\r\nfunction createWasm() {\r\n  // prepare imports\r\n  var info = {\r\n    'env': asmLibraryArg,\r\n    'wasi_snapshot_preview1': asmLibraryArg,\r\n  };\r\n  // Load the wasm module and create an instance of using native support in the JS engine.\r\n  // handle a generated wasm instance, receiving its exports and\r\n  // performing other necessary setup\r\n  /** @param {WebAssembly.Module=} module*/\r\n  function receiveInstance(instance, module) {\r\n    var exports = instance.exports;\r\n\r\n    Module['asm'] = exports;\r\n\r\n    wasmMemory = Module['asm']['memory'];\r\n    updateGlobalBufferAndViews(wasmMemory.buffer);\r\n\r\n    wasmTable = Module['asm']['__indirect_function_table'];\r\n\r\n    addOnInit(Module['asm']['__wasm_call_ctors']);\r\n\r\n    removeRunDependency('wasm-instantiate');\r\n\r\n  }\r\n  // we can't run yet (except in a pthread, where we have a custom sync instantiator)\r\n  addRunDependency('wasm-instantiate');\r\n\r\n  // Prefer streaming instantiation if available.\r\n  function receiveInstantiationResult(result) {\r\n    // 'result' is a ResultObject object which has both the module and instance.\r\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\r\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\r\n    receiveInstance(result['instance']);\r\n  }\r\n\r\n  function instantiateArrayBuffer(receiver) {\r\n    return getBinaryPromise().then(function(binary) {\r\n      return WebAssembly.instantiate(binary, info);\r\n    }).then(function (instance) {\r\n      return instance;\r\n    }).then(receiver, function(reason) {\r\n      err('failed to asynchronously prepare wasm: ' + reason);\r\n\r\n      abort(reason);\r\n    });\r\n  }\r\n\r\n  function instantiateAsync() {\r\n    if (!wasmBinary &&\r\n        typeof WebAssembly.instantiateStreaming == 'function' &&\r\n        !isDataURI(wasmBinaryFile) &&\r\n        typeof fetch == 'function') {\r\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\r\n        // Suppress closure warning here since the upstream definition for\r\n        // instantiateStreaming only allows Promise<Repsponse> rather than\r\n        // an actual Response.\r\n        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\r\n        /** @suppress {checkTypes} */\r\n        var result = WebAssembly.instantiateStreaming(response, info);\r\n\r\n        return result.then(\r\n          receiveInstantiationResult,\r\n          function(reason) {\r\n            // We expect the most common failure cause to be a bad MIME type for the binary,\r\n            // in which case falling back to ArrayBuffer instantiation should work.\r\n            err('wasm streaming compile failed: ' + reason);\r\n            err('falling back to ArrayBuffer instantiation');\r\n            return instantiateArrayBuffer(receiveInstantiationResult);\r\n          });\r\n      });\r\n    } else {\r\n      return instantiateArrayBuffer(receiveInstantiationResult);\r\n    }\r\n  }\r\n\r\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\r\n  // to any other async startup actions they are performing.\r\n  // Also pthreads and wasm workers initialize the wasm instance through this path.\r\n  if (Module['instantiateWasm']) {\r\n    try {\r\n      var exports = Module['instantiateWasm'](info, receiveInstance);\r\n      return exports;\r\n    } catch(e) {\r\n      err('Module.instantiateWasm callback failed with error: ' + e);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If instantiation fails, reject the module ready promise.\r\n  instantiateAsync().catch(readyPromiseReject);\r\n  return {}; // no exports yet; we'll fill them in later\r\n}\r\n\r\n// Globals used by JS i64 conversions (see makeSetValue)\r\nvar tempDouble;\r\nvar tempI64;\r\n\r\n// === Body ===\r\n\r\nvar ASM_CONSTS = {\r\n  \r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n  function callRuntimeCallbacks(callbacks) {\r\n      while (callbacks.length > 0) {\r\n        var callback = callbacks.shift();\r\n        if (typeof callback == 'function') {\r\n          callback(Module); // Pass the module as the first argument.\r\n          continue;\r\n        }\r\n        var func = callback.func;\r\n        if (typeof func == 'number') {\r\n          if (callback.arg === undefined) {\r\n            // Run the wasm function ptr with signature 'v'. If no function\r\n            // with such signature was exported, this call does not need\r\n            // to be emitted (and would confuse Closure)\r\n            getWasmTableEntry(func)();\r\n          } else {\r\n            // If any function with signature 'vi' was exported, run\r\n            // the callback with that signature.\r\n            getWasmTableEntry(func)(callback.arg);\r\n          }\r\n        } else {\r\n          func(callback.arg === undefined ? null : callback.arg);\r\n        }\r\n      }\r\n    }\r\n\r\n  function withStackSave(f) {\r\n      var stack = stackSave();\r\n      var ret = f();\r\n      stackRestore(stack);\r\n      return ret;\r\n    }\r\n  function demangle(func) {\r\n      return func;\r\n    }\r\n\r\n  function demangleAll(text) {\r\n      var regex =\r\n        /\\b_Z[\\w\\d_]+/g;\r\n      return text.replace(regex,\r\n        function(x) {\r\n          var y = demangle(x);\r\n          return x === y ? x : (y + ' [' + x + ']');\r\n        });\r\n    }\r\n\r\n  \r\n    /** @param {number} ptr\r\n        @param {string} type\r\n        @param {number|boolean=} noSafe */\r\n  function getValue(ptr, type = 'i8', noSafe) {\r\n      if (type.endsWith('*')) type = 'u32';\r\n      switch (type) {\r\n        case 'i1': return HEAP8[((ptr)>>0)];\r\n        case 'i8': return HEAP8[((ptr)>>0)];\r\n        case 'i16': return HEAP16[((ptr)>>1)];\r\n        case 'i32': return HEAP32[((ptr)>>2)];\r\n        case 'i64': return HEAP32[((ptr)>>2)];\r\n        case 'float': return HEAPF32[((ptr)>>2)];\r\n        case 'double': return Number(HEAPF64[((ptr)>>3)]);\r\n        default: abort('invalid type for getValue: ' + type);\r\n      }\r\n      return null;\r\n    }\r\n\r\n  var wasmTableMirror = [];\r\n  function getWasmTableEntry(funcPtr) {\r\n      var func = wasmTableMirror[funcPtr];\r\n      if (!func) {\r\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\r\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\r\n      }\r\n      return func;\r\n    }\r\n\r\n  function handleException(e) {\r\n      // Certain exception types we do not treat as errors since they are used for\r\n      // internal control flow.\r\n      // 1. ExitStatus, which is thrown by exit()\r\n      // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\r\n      //    that wish to return to JS event loop.\r\n      if (e instanceof ExitStatus || e == 'unwind') {\r\n        return EXITSTATUS;\r\n      }\r\n      quit_(1, e);\r\n    }\r\n\r\n  function jsStackTrace() {\r\n      var error = new Error();\r\n      if (!error.stack) {\r\n        // IE10+ special cases: It does have callstack info, but it is only\r\n        // populated if an Error object is thrown, so try that as a special-case.\r\n        try {\r\n          throw new Error();\r\n        } catch(e) {\r\n          error = e;\r\n        }\r\n        if (!error.stack) {\r\n          return '(no stack trace available)';\r\n        }\r\n      }\r\n      return error.stack.toString();\r\n    }\r\n\r\n  \r\n    /** @param {number} ptr\r\n        @param {number} value\r\n        @param {string} type\r\n        @param {number|boolean=} noSafe */\r\n  function setValue(ptr, value, type = 'i8', noSafe) {\r\n      if (type.endsWith('*')) type = 'u32';\r\n      switch (type) {\r\n        case 'i1': HEAP8[((ptr)>>0)] = value; break;\r\n        case 'i8': HEAP8[((ptr)>>0)] = value; break;\r\n        case 'i16': HEAP16[((ptr)>>1)] = value; break;\r\n        case 'i32': HEAP32[((ptr)>>2)] = value; break;\r\n        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;\r\n        case 'float': HEAPF32[((ptr)>>2)] = value; break;\r\n        case 'double': HEAPF64[((ptr)>>3)] = value; break;\r\n        default: abort('invalid type for setValue: ' + type);\r\n      }\r\n    }\r\n\r\n  function setWasmTableEntry(idx, func) {\r\n      wasmTable.set(idx, func);\r\n      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped\r\n      // functions so we need to call it here to retrieve the potential wrapper correctly\r\n      // instead of just storing 'func' directly into wasmTableMirror\r\n      wasmTableMirror[idx] = wasmTable.get(idx);\r\n    }\r\n\r\n  function stackTrace() {\r\n      var js = jsStackTrace();\r\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\r\n      return demangleAll(js);\r\n    }\r\n\r\n  function ___assert_fail(condition, filename, line, func) {\r\n      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\r\n    }\r\n\r\n  function ___cxa_allocate_exception(size) {\r\n      // Thrown object is prepended by exception metadata block\r\n      return _malloc(size + 24) + 24;\r\n    }\r\n\r\n  /** @constructor */\r\n  function ExceptionInfo(excPtr) {\r\n      this.excPtr = excPtr;\r\n      this.ptr = excPtr - 24;\r\n  \r\n      this.set_type = function(type) {\r\n        HEAPU32[(((this.ptr)+(4))>>2)] = type;\r\n      };\r\n  \r\n      this.get_type = function() {\r\n        return HEAPU32[(((this.ptr)+(4))>>2)];\r\n      };\r\n  \r\n      this.set_destructor = function(destructor) {\r\n        HEAPU32[(((this.ptr)+(8))>>2)] = destructor;\r\n      };\r\n  \r\n      this.get_destructor = function() {\r\n        return HEAPU32[(((this.ptr)+(8))>>2)];\r\n      };\r\n  \r\n      this.set_refcount = function(refcount) {\r\n        HEAP32[((this.ptr)>>2)] = refcount;\r\n      };\r\n  \r\n      this.set_caught = function (caught) {\r\n        caught = caught ? 1 : 0;\r\n        HEAP8[(((this.ptr)+(12))>>0)] = caught;\r\n      };\r\n  \r\n      this.get_caught = function () {\r\n        return HEAP8[(((this.ptr)+(12))>>0)] != 0;\r\n      };\r\n  \r\n      this.set_rethrown = function (rethrown) {\r\n        rethrown = rethrown ? 1 : 0;\r\n        HEAP8[(((this.ptr)+(13))>>0)] = rethrown;\r\n      };\r\n  \r\n      this.get_rethrown = function () {\r\n        return HEAP8[(((this.ptr)+(13))>>0)] != 0;\r\n      };\r\n  \r\n      // Initialize native structure fields. Should be called once after allocated.\r\n      this.init = function(type, destructor) {\r\n        this.set_adjusted_ptr(0);\r\n        this.set_type(type);\r\n        this.set_destructor(destructor);\r\n        this.set_refcount(0);\r\n        this.set_caught(false);\r\n        this.set_rethrown(false);\r\n      }\r\n  \r\n      this.add_ref = function() {\r\n        var value = HEAP32[((this.ptr)>>2)];\r\n        HEAP32[((this.ptr)>>2)] = value + 1;\r\n      };\r\n  \r\n      // Returns true if last reference released.\r\n      this.release_ref = function() {\r\n        var prev = HEAP32[((this.ptr)>>2)];\r\n        HEAP32[((this.ptr)>>2)] = prev - 1;\r\n        return prev === 1;\r\n      };\r\n  \r\n      this.set_adjusted_ptr = function(adjustedPtr) {\r\n        HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;\r\n      };\r\n  \r\n      this.get_adjusted_ptr = function() {\r\n        return HEAPU32[(((this.ptr)+(16))>>2)];\r\n      };\r\n  \r\n      // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted\r\n      // when the pointer is casted to some of the exception object base classes (e.g. when virtual\r\n      // inheritance is used). When a pointer is thrown this method should return the thrown pointer\r\n      // itself.\r\n      this.get_exception_ptr = function() {\r\n        // Work around a fastcomp bug, this code is still included for some reason in a build without\r\n        // exceptions support.\r\n        var isPointer = ___cxa_is_pointer_type(this.get_type());\r\n        if (isPointer) {\r\n          return HEAPU32[((this.excPtr)>>2)];\r\n        }\r\n        var adjusted = this.get_adjusted_ptr();\r\n        if (adjusted !== 0) return adjusted;\r\n        return this.excPtr;\r\n      };\r\n    }\r\n  \r\n  var exceptionLast = 0;\r\n  \r\n  var uncaughtExceptionCount = 0;\r\n  function ___cxa_throw(ptr, type, destructor) {\r\n      var info = new ExceptionInfo(ptr);\r\n      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\r\n      info.init(type, destructor);\r\n      exceptionLast = ptr;\r\n      uncaughtExceptionCount++;\r\n      throw ptr;\r\n    }\r\n\r\n  var structRegistrations = {};\r\n  \r\n  function runDestructors(destructors) {\r\n      while (destructors.length) {\r\n        var ptr = destructors.pop();\r\n        var del = destructors.pop();\r\n        del(ptr);\r\n      }\r\n    }\r\n  \r\n  function simpleReadValueFromPointer(pointer) {\r\n      return this['fromWireType'](HEAPU32[pointer >> 2]);\r\n    }\r\n  \r\n  var awaitingDependencies = {};\r\n  \r\n  var registeredTypes = {};\r\n  \r\n  var typeDependencies = {};\r\n  \r\n  var char_0 = 48;\r\n  \r\n  var char_9 = 57;\r\n  function makeLegalFunctionName(name) {\r\n      if (undefined === name) {\r\n        return '_unknown';\r\n      }\r\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\r\n      var f = name.charCodeAt(0);\r\n      if (f >= char_0 && f <= char_9) {\r\n        return '_' + name;\r\n      }\r\n      return name;\r\n    }\r\n  function createNamedFunction(name, body) {\r\n      name = makeLegalFunctionName(name);\r\n      /*jshint evil:true*/\r\n      return new Function(\r\n          \"body\",\r\n          \"return function \" + name + \"() {\\n\" +\r\n          \"    \\\"use strict\\\";\" +\r\n          \"    return body.apply(this, arguments);\\n\" +\r\n          \"};\\n\"\r\n      )(body);\r\n    }\r\n  function extendError(baseErrorType, errorName) {\r\n      var errorClass = createNamedFunction(errorName, function(message) {\r\n          this.name = errorName;\r\n          this.message = message;\r\n  \r\n          var stack = (new Error(message)).stack;\r\n          if (stack !== undefined) {\r\n              this.stack = this.toString() + '\\n' +\r\n                  stack.replace(/^Error(:[^\\n]*)?\\n/, '');\r\n          }\r\n      });\r\n      errorClass.prototype = Object.create(baseErrorType.prototype);\r\n      errorClass.prototype.constructor = errorClass;\r\n      errorClass.prototype.toString = function() {\r\n          if (this.message === undefined) {\r\n              return this.name;\r\n          } else {\r\n              return this.name + ': ' + this.message;\r\n          }\r\n      };\r\n  \r\n      return errorClass;\r\n    }\r\n  var InternalError = undefined;\r\n  function throwInternalError(message) {\r\n      throw new InternalError(message);\r\n    }\r\n  function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\r\n      myTypes.forEach(function(type) {\r\n          typeDependencies[type] = dependentTypes;\r\n      });\r\n  \r\n      function onComplete(typeConverters) {\r\n          var myTypeConverters = getTypeConverters(typeConverters);\r\n          if (myTypeConverters.length !== myTypes.length) {\r\n              throwInternalError('Mismatched type converter count');\r\n          }\r\n          for (var i = 0; i < myTypes.length; ++i) {\r\n              registerType(myTypes[i], myTypeConverters[i]);\r\n          }\r\n      }\r\n  \r\n      var typeConverters = new Array(dependentTypes.length);\r\n      var unregisteredTypes = [];\r\n      var registered = 0;\r\n      dependentTypes.forEach((dt, i) => {\r\n        if (registeredTypes.hasOwnProperty(dt)) {\r\n          typeConverters[i] = registeredTypes[dt];\r\n        } else {\r\n          unregisteredTypes.push(dt);\r\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\r\n            awaitingDependencies[dt] = [];\r\n          }\r\n          awaitingDependencies[dt].push(() => {\r\n            typeConverters[i] = registeredTypes[dt];\r\n            ++registered;\r\n            if (registered === unregisteredTypes.length) {\r\n              onComplete(typeConverters);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      if (0 === unregisteredTypes.length) {\r\n        onComplete(typeConverters);\r\n      }\r\n    }\r\n  function __embind_finalize_value_object(structType) {\r\n      var reg = structRegistrations[structType];\r\n      delete structRegistrations[structType];\r\n  \r\n      var rawConstructor = reg.rawConstructor;\r\n      var rawDestructor = reg.rawDestructor;\r\n      var fieldRecords = reg.fields;\r\n      var fieldTypes = fieldRecords.map((field) => field.getterReturnType).\r\n                concat(fieldRecords.map((field) => field.setterArgumentType));\r\n      whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {\r\n        var fields = {};\r\n        fieldRecords.forEach((field, i) => {\r\n          var fieldName = field.fieldName;\r\n          var getterReturnType = fieldTypes[i];\r\n          var getter = field.getter;\r\n          var getterContext = field.getterContext;\r\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\r\n          var setter = field.setter;\r\n          var setterContext = field.setterContext;\r\n          fields[fieldName] = {\r\n            read: (ptr) => {\r\n              return getterReturnType['fromWireType'](\r\n                  getter(getterContext, ptr));\r\n            },\r\n            write: (ptr, o) => {\r\n              var destructors = [];\r\n              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));\r\n              runDestructors(destructors);\r\n            }\r\n          };\r\n        });\r\n  \r\n        return [{\r\n          name: reg.name,\r\n          'fromWireType': function(ptr) {\r\n            var rv = {};\r\n            for (var i in fields) {\r\n              rv[i] = fields[i].read(ptr);\r\n            }\r\n            rawDestructor(ptr);\r\n            return rv;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n            // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations:\r\n            // assume all fields are present without checking.\r\n            for (var fieldName in fields) {\r\n              if (!(fieldName in o)) {\r\n                throw new TypeError('Missing field:  \"' + fieldName + '\"');\r\n              }\r\n            }\r\n            var ptr = rawConstructor();\r\n            for (fieldName in fields) {\r\n              fields[fieldName].write(ptr, o[fieldName]);\r\n            }\r\n            if (destructors !== null) {\r\n              destructors.push(rawDestructor, ptr);\r\n            }\r\n            return ptr;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': simpleReadValueFromPointer,\r\n          destructorFunction: rawDestructor,\r\n        }];\r\n      });\r\n    }\r\n\r\n  function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\r\n\r\n  function getShiftFromSize(size) {\r\n      switch (size) {\r\n          case 1: return 0;\r\n          case 2: return 1;\r\n          case 4: return 2;\r\n          case 8: return 3;\r\n          default:\r\n              throw new TypeError('Unknown type size: ' + size);\r\n      }\r\n    }\r\n  \r\n  function embind_init_charCodes() {\r\n      var codes = new Array(256);\r\n      for (var i = 0; i < 256; ++i) {\r\n          codes[i] = String.fromCharCode(i);\r\n      }\r\n      embind_charCodes = codes;\r\n    }\r\n  var embind_charCodes = undefined;\r\n  function readLatin1String(ptr) {\r\n      var ret = \"\";\r\n      var c = ptr;\r\n      while (HEAPU8[c]) {\r\n          ret += embind_charCodes[HEAPU8[c++]];\r\n      }\r\n      return ret;\r\n    }\r\n  \r\n  var BindingError = undefined;\r\n  function throwBindingError(message) {\r\n      throw new BindingError(message);\r\n    }\r\n  /** @param {Object=} options */\r\n  function registerType(rawType, registeredInstance, options = {}) {\r\n      if (!('argPackAdvance' in registeredInstance)) {\r\n          throw new TypeError('registerType registeredInstance requires argPackAdvance');\r\n      }\r\n  \r\n      var name = registeredInstance.name;\r\n      if (!rawType) {\r\n          throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\r\n      }\r\n      if (registeredTypes.hasOwnProperty(rawType)) {\r\n          if (options.ignoreDuplicateRegistrations) {\r\n              return;\r\n          } else {\r\n              throwBindingError(\"Cannot register type '\" + name + \"' twice\");\r\n          }\r\n      }\r\n  \r\n      registeredTypes[rawType] = registeredInstance;\r\n      delete typeDependencies[rawType];\r\n  \r\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\r\n        var callbacks = awaitingDependencies[rawType];\r\n        delete awaitingDependencies[rawType];\r\n        callbacks.forEach((cb) => cb());\r\n      }\r\n    }\r\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\r\n      var shift = getShiftFromSize(size);\r\n  \r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          name: name,\r\n          'fromWireType': function(wt) {\r\n              // ambiguous emscripten ABI: sometimes return values are\r\n              // true or false, and sometimes integers (0 or 1)\r\n              return !!wt;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n              return o ? trueValue : falseValue;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': function(pointer) {\r\n              // TODO: if heap is fixed (like in asm.js) this could be executed outside\r\n              var heap;\r\n              if (size === 1) {\r\n                  heap = HEAP8;\r\n              } else if (size === 2) {\r\n                  heap = HEAP16;\r\n              } else if (size === 4) {\r\n                  heap = HEAP32;\r\n              } else {\r\n                  throw new TypeError(\"Unknown boolean type size: \" + name);\r\n              }\r\n              return this['fromWireType'](heap[pointer >> shift]);\r\n          },\r\n          destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  function ClassHandle_isAliasOf(other) {\r\n      if (!(this instanceof ClassHandle)) {\r\n        return false;\r\n      }\r\n      if (!(other instanceof ClassHandle)) {\r\n        return false;\r\n      }\r\n  \r\n      var leftClass = this.$$.ptrType.registeredClass;\r\n      var left = this.$$.ptr;\r\n      var rightClass = other.$$.ptrType.registeredClass;\r\n      var right = other.$$.ptr;\r\n  \r\n      while (leftClass.baseClass) {\r\n        left = leftClass.upcast(left);\r\n        leftClass = leftClass.baseClass;\r\n      }\r\n  \r\n      while (rightClass.baseClass) {\r\n        right = rightClass.upcast(right);\r\n        rightClass = rightClass.baseClass;\r\n      }\r\n  \r\n      return leftClass === rightClass && left === right;\r\n    }\r\n  \r\n  function shallowCopyInternalPointer(o) {\r\n      return {\r\n          count: o.count,\r\n          deleteScheduled: o.deleteScheduled,\r\n          preservePointerOnDelete: o.preservePointerOnDelete,\r\n          ptr: o.ptr,\r\n          ptrType: o.ptrType,\r\n          smartPtr: o.smartPtr,\r\n          smartPtrType: o.smartPtrType,\r\n      };\r\n    }\r\n  \r\n  function throwInstanceAlreadyDeleted(obj) {\r\n      function getInstanceTypeName(handle) {\r\n        return handle.$$.ptrType.registeredClass.name;\r\n      }\r\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\r\n    }\r\n  \r\n  var finalizationRegistry = false;\r\n  \r\n  function detachFinalizer(handle) {}\r\n  \r\n  function runDestructor($$) {\r\n      if ($$.smartPtr) {\r\n          $$.smartPtrType.rawDestructor($$.smartPtr);\r\n      } else {\r\n          $$.ptrType.registeredClass.rawDestructor($$.ptr);\r\n      }\r\n    }\r\n  function releaseClassHandle($$) {\r\n      $$.count.value -= 1;\r\n      var toDelete = 0 === $$.count.value;\r\n      if (toDelete) {\r\n        runDestructor($$);\r\n      }\r\n    }\r\n  \r\n  function downcastPointer(ptr, ptrClass, desiredClass) {\r\n      if (ptrClass === desiredClass) {\r\n        return ptr;\r\n      }\r\n      if (undefined === desiredClass.baseClass) {\r\n        return null; // no conversion\r\n      }\r\n  \r\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\r\n      if (rv === null) {\r\n          return null;\r\n      }\r\n      return desiredClass.downcast(rv);\r\n    }\r\n  \r\n  var registeredPointers = {};\r\n  \r\n  function getInheritedInstanceCount() {\r\n      return Object.keys(registeredInstances).length;\r\n    }\r\n  \r\n  function getLiveInheritedInstances() {\r\n      var rv = [];\r\n      for (var k in registeredInstances) {\r\n          if (registeredInstances.hasOwnProperty(k)) {\r\n              rv.push(registeredInstances[k]);\r\n          }\r\n      }\r\n      return rv;\r\n    }\r\n  \r\n  var deletionQueue = [];\r\n  function flushPendingDeletes() {\r\n      while (deletionQueue.length) {\r\n        var obj = deletionQueue.pop();\r\n        obj.$$.deleteScheduled = false;\r\n        obj['delete']();\r\n      }\r\n    }\r\n  \r\n  var delayFunction = undefined;\r\n  function setDelayFunction(fn) {\r\n      delayFunction = fn;\r\n      if (deletionQueue.length && delayFunction) {\r\n        delayFunction(flushPendingDeletes);\r\n      }\r\n    }\r\n  function init_embind() {\r\n      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;\r\n      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;\r\n      Module['flushPendingDeletes'] = flushPendingDeletes;\r\n      Module['setDelayFunction'] = setDelayFunction;\r\n    }\r\n  var registeredInstances = {};\r\n  \r\n  function getBasestPointer(class_, ptr) {\r\n      if (ptr === undefined) {\r\n          throwBindingError('ptr should not be undefined');\r\n      }\r\n      while (class_.baseClass) {\r\n          ptr = class_.upcast(ptr);\r\n          class_ = class_.baseClass;\r\n      }\r\n      return ptr;\r\n    }\r\n  function getInheritedInstance(class_, ptr) {\r\n      ptr = getBasestPointer(class_, ptr);\r\n      return registeredInstances[ptr];\r\n    }\r\n  \r\n  function makeClassHandle(prototype, record) {\r\n      if (!record.ptrType || !record.ptr) {\r\n        throwInternalError('makeClassHandle requires ptr and ptrType');\r\n      }\r\n      var hasSmartPtrType = !!record.smartPtrType;\r\n      var hasSmartPtr = !!record.smartPtr;\r\n      if (hasSmartPtrType !== hasSmartPtr) {\r\n        throwInternalError('Both smartPtrType and smartPtr must be specified');\r\n      }\r\n      record.count = { value: 1 };\r\n      return attachFinalizer(Object.create(prototype, {\r\n        $$: {\r\n            value: record,\r\n        },\r\n      }));\r\n    }\r\n  function RegisteredPointer_fromWireType(ptr) {\r\n      // ptr is a raw pointer (or a raw smartpointer)\r\n  \r\n      // rawPointer is a maybe-null raw pointer\r\n      var rawPointer = this.getPointee(ptr);\r\n      if (!rawPointer) {\r\n        this.destructor(ptr);\r\n        return null;\r\n      }\r\n  \r\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\r\n      if (undefined !== registeredInstance) {\r\n        // JS object has been neutered, time to repopulate it\r\n        if (0 === registeredInstance.$$.count.value) {\r\n          registeredInstance.$$.ptr = rawPointer;\r\n          registeredInstance.$$.smartPtr = ptr;\r\n          return registeredInstance['clone']();\r\n        } else {\r\n          // else, just increment reference count on existing object\r\n          // it already has a reference to the smart pointer\r\n          var rv = registeredInstance['clone']();\r\n          this.destructor(ptr);\r\n          return rv;\r\n        }\r\n      }\r\n  \r\n      function makeDefaultHandle() {\r\n        if (this.isSmartPointer) {\r\n          return makeClassHandle(this.registeredClass.instancePrototype, {\r\n            ptrType: this.pointeeType,\r\n            ptr: rawPointer,\r\n            smartPtrType: this,\r\n            smartPtr: ptr,\r\n          });\r\n        } else {\r\n          return makeClassHandle(this.registeredClass.instancePrototype, {\r\n            ptrType: this,\r\n            ptr: ptr,\r\n          });\r\n        }\r\n      }\r\n  \r\n      var actualType = this.registeredClass.getActualType(rawPointer);\r\n      var registeredPointerRecord = registeredPointers[actualType];\r\n      if (!registeredPointerRecord) {\r\n        return makeDefaultHandle.call(this);\r\n      }\r\n  \r\n      var toType;\r\n      if (this.isConst) {\r\n        toType = registeredPointerRecord.constPointerType;\r\n      } else {\r\n        toType = registeredPointerRecord.pointerType;\r\n      }\r\n      var dp = downcastPointer(\r\n          rawPointer,\r\n          this.registeredClass,\r\n          toType.registeredClass);\r\n      if (dp === null) {\r\n          return makeDefaultHandle.call(this);\r\n      }\r\n      if (this.isSmartPointer) {\r\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n          ptrType: toType,\r\n          ptr: dp,\r\n          smartPtrType: this,\r\n          smartPtr: ptr,\r\n        });\r\n      } else {\r\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n          ptrType: toType,\r\n          ptr: dp,\r\n        });\r\n      }\r\n    }\r\n  function attachFinalizer(handle) {\r\n      if ('undefined' === typeof FinalizationRegistry) {\r\n          attachFinalizer = (handle) => handle;\r\n          return handle;\r\n      }\r\n      // If the running environment has a FinalizationRegistry (see\r\n      // https://github.com/tc39/proposal-weakrefs), then attach finalizers\r\n      // for class handles.  We check for the presence of FinalizationRegistry\r\n      // at run-time, not build-time.\r\n      finalizationRegistry = new FinalizationRegistry((info) => {\r\n          releaseClassHandle(info.$$);\r\n      });\r\n      attachFinalizer = (handle) => {\r\n        var $$ = handle.$$;\r\n        var hasSmartPtr = !!$$.smartPtr;\r\n        if (hasSmartPtr) {\r\n          // We should not call the destructor on raw pointers in case other code expects the pointee to live\r\n          var info = { $$: $$ };\r\n          finalizationRegistry.register(handle, info, handle);\r\n        }\r\n        return handle;\r\n      };\r\n      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);\r\n      return attachFinalizer(handle);\r\n    }\r\n  function ClassHandle_clone() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n  \r\n      if (this.$$.preservePointerOnDelete) {\r\n        this.$$.count.value += 1;\r\n        return this;\r\n      } else {\r\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\r\n          $$: {\r\n            value: shallowCopyInternalPointer(this.$$),\r\n          }\r\n        }));\r\n  \r\n        clone.$$.count.value += 1;\r\n        clone.$$.deleteScheduled = false;\r\n        return clone;\r\n      }\r\n    }\r\n  \r\n  function ClassHandle_delete() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n  \r\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n        throwBindingError('Object already scheduled for deletion');\r\n      }\r\n  \r\n      detachFinalizer(this);\r\n      releaseClassHandle(this.$$);\r\n  \r\n      if (!this.$$.preservePointerOnDelete) {\r\n        this.$$.smartPtr = undefined;\r\n        this.$$.ptr = undefined;\r\n      }\r\n    }\r\n  \r\n  function ClassHandle_isDeleted() {\r\n      return !this.$$.ptr;\r\n    }\r\n  \r\n  function ClassHandle_deleteLater() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n        throwBindingError('Object already scheduled for deletion');\r\n      }\r\n      deletionQueue.push(this);\r\n      if (deletionQueue.length === 1 && delayFunction) {\r\n        delayFunction(flushPendingDeletes);\r\n      }\r\n      this.$$.deleteScheduled = true;\r\n      return this;\r\n    }\r\n  function init_ClassHandle() {\r\n      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;\r\n      ClassHandle.prototype['clone'] = ClassHandle_clone;\r\n      ClassHandle.prototype['delete'] = ClassHandle_delete;\r\n      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;\r\n      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;\r\n    }\r\n  function ClassHandle() {\r\n    }\r\n  \r\n  function ensureOverloadTable(proto, methodName, humanName) {\r\n      if (undefined === proto[methodName].overloadTable) {\r\n        var prevFunc = proto[methodName];\r\n        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\r\n        proto[methodName] = function() {\r\n          // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\r\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\r\n              throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\r\n          }\r\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\r\n        };\r\n        // Move the previous function into the overload table.\r\n        proto[methodName].overloadTable = [];\r\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\r\n      }\r\n    }\r\n  /** @param {number=} numArguments */\r\n  function exposePublicSymbol(name, value, numArguments) {\r\n      if (Module.hasOwnProperty(name)) {\r\n        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\r\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\r\n        }\r\n  \r\n        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\r\n        // that routes between the two.\r\n        ensureOverloadTable(Module, name, name);\r\n        if (Module.hasOwnProperty(numArguments)) {\r\n            throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\r\n        }\r\n        // Add the new function into the overload table.\r\n        Module[name].overloadTable[numArguments] = value;\r\n      }\r\n      else {\r\n        Module[name] = value;\r\n        if (undefined !== numArguments) {\r\n          Module[name].numArguments = numArguments;\r\n        }\r\n      }\r\n    }\r\n  \r\n  /** @constructor */\r\n  function RegisteredClass(name,\r\n                               constructor,\r\n                               instancePrototype,\r\n                               rawDestructor,\r\n                               baseClass,\r\n                               getActualType,\r\n                               upcast,\r\n                               downcast) {\r\n      this.name = name;\r\n      this.constructor = constructor;\r\n      this.instancePrototype = instancePrototype;\r\n      this.rawDestructor = rawDestructor;\r\n      this.baseClass = baseClass;\r\n      this.getActualType = getActualType;\r\n      this.upcast = upcast;\r\n      this.downcast = downcast;\r\n      this.pureVirtualFunctions = [];\r\n    }\r\n  \r\n  function upcastPointer(ptr, ptrClass, desiredClass) {\r\n      while (ptrClass !== desiredClass) {\r\n        if (!ptrClass.upcast) {\r\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\r\n        }\r\n        ptr = ptrClass.upcast(ptr);\r\n        ptrClass = ptrClass.baseClass;\r\n      }\r\n      return ptr;\r\n    }\r\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError('null is not a valid ' + this.name);\r\n        }\r\n        return 0;\r\n      }\r\n  \r\n      if (!handle.$$) {\r\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n      return ptr;\r\n    }\r\n  \r\n  function genericPointerToWireType(destructors, handle) {\r\n      var ptr;\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError('null is not a valid ' + this.name);\r\n        }\r\n  \r\n        if (this.isSmartPointer) {\r\n          ptr = this.rawConstructor();\r\n          if (destructors !== null) {\r\n            destructors.push(this.rawDestructor, ptr);\r\n          }\r\n          return ptr;\r\n        } else {\r\n          return 0;\r\n        }\r\n      }\r\n  \r\n      if (!handle.$$) {\r\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\r\n      }\r\n      if (!this.isConst && handle.$$.ptrType.isConst) {\r\n        throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n  \r\n      if (this.isSmartPointer) {\r\n        // TODO: this is not strictly true\r\n        // We could support BY_EMVAL conversions from raw pointers to smart pointers\r\n        // because the smart pointer can hold a reference to the handle\r\n        if (undefined === handle.$$.smartPtr) {\r\n          throwBindingError('Passing raw pointer to smart pointer is illegal');\r\n        }\r\n  \r\n        switch (this.sharingPolicy) {\r\n          case 0: // NONE\r\n            // no upcasting\r\n            if (handle.$$.smartPtrType === this) {\r\n              ptr = handle.$$.smartPtr;\r\n            } else {\r\n              throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\r\n            }\r\n            break;\r\n  \r\n          case 1: // INTRUSIVE\r\n            ptr = handle.$$.smartPtr;\r\n            break;\r\n  \r\n          case 2: // BY_EMVAL\r\n            if (handle.$$.smartPtrType === this) {\r\n              ptr = handle.$$.smartPtr;\r\n            } else {\r\n              var clonedHandle = handle['clone']();\r\n              ptr = this.rawShare(\r\n                ptr,\r\n                Emval.toHandle(function() {\r\n                  clonedHandle['delete']();\r\n                })\r\n              );\r\n              if (destructors !== null) {\r\n                destructors.push(this.rawDestructor, ptr);\r\n              }\r\n            }\r\n            break;\r\n  \r\n          default:\r\n            throwBindingError('Unsupporting sharing policy');\r\n        }\r\n      }\r\n      return ptr;\r\n    }\r\n  \r\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError('null is not a valid ' + this.name);\r\n        }\r\n        return 0;\r\n      }\r\n  \r\n      if (!handle.$$) {\r\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\r\n      }\r\n      if (handle.$$.ptrType.isConst) {\r\n          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n      return ptr;\r\n    }\r\n  \r\n  function RegisteredPointer_getPointee(ptr) {\r\n      if (this.rawGetPointee) {\r\n        ptr = this.rawGetPointee(ptr);\r\n      }\r\n      return ptr;\r\n    }\r\n  \r\n  function RegisteredPointer_destructor(ptr) {\r\n      if (this.rawDestructor) {\r\n        this.rawDestructor(ptr);\r\n      }\r\n    }\r\n  \r\n  function RegisteredPointer_deleteObject(handle) {\r\n      if (handle !== null) {\r\n        handle['delete']();\r\n      }\r\n    }\r\n  function init_RegisteredPointer() {\r\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\r\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\r\n      RegisteredPointer.prototype['argPackAdvance'] = 8;\r\n      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;\r\n      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;\r\n      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;\r\n    }\r\n  /** @constructor\r\n      @param {*=} pointeeType,\r\n      @param {*=} sharingPolicy,\r\n      @param {*=} rawGetPointee,\r\n      @param {*=} rawConstructor,\r\n      @param {*=} rawShare,\r\n      @param {*=} rawDestructor,\r\n       */\r\n  function RegisteredPointer(\r\n      name,\r\n      registeredClass,\r\n      isReference,\r\n      isConst,\r\n  \r\n      // smart pointer properties\r\n      isSmartPointer,\r\n      pointeeType,\r\n      sharingPolicy,\r\n      rawGetPointee,\r\n      rawConstructor,\r\n      rawShare,\r\n      rawDestructor\r\n    ) {\r\n      this.name = name;\r\n      this.registeredClass = registeredClass;\r\n      this.isReference = isReference;\r\n      this.isConst = isConst;\r\n  \r\n      // smart pointer properties\r\n      this.isSmartPointer = isSmartPointer;\r\n      this.pointeeType = pointeeType;\r\n      this.sharingPolicy = sharingPolicy;\r\n      this.rawGetPointee = rawGetPointee;\r\n      this.rawConstructor = rawConstructor;\r\n      this.rawShare = rawShare;\r\n      this.rawDestructor = rawDestructor;\r\n  \r\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\r\n        if (isConst) {\r\n          this['toWireType'] = constNoSmartPtrRawPointerToWireType;\r\n          this.destructorFunction = null;\r\n        } else {\r\n          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\r\n          this.destructorFunction = null;\r\n        }\r\n      } else {\r\n        this['toWireType'] = genericPointerToWireType;\r\n        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns\r\n        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.\r\n        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in\r\n        //       craftInvokerFunction altogether.\r\n      }\r\n    }\r\n  \r\n  /** @param {number=} numArguments */\r\n  function replacePublicSymbol(name, value, numArguments) {\r\n      if (!Module.hasOwnProperty(name)) {\r\n        throwInternalError('Replacing nonexistant public symbol');\r\n      }\r\n      // If there's an overload table for this symbol, replace the symbol in the overload table instead.\r\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\r\n        Module[name].overloadTable[numArguments] = value;\r\n      }\r\n      else {\r\n        Module[name] = value;\r\n        Module[name].argCount = numArguments;\r\n      }\r\n    }\r\n  \r\n  function dynCallLegacy(sig, ptr, args) {\r\n      var f = Module[\"dynCall_\" + sig];\r\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\r\n    }\r\n  /** @param {Object=} args */\r\n  function dynCall(sig, ptr, args) {\r\n      // Without WASM_BIGINT support we cannot directly call function with i64 as\r\n      // part of thier signature, so we rely the dynCall functions generated by\r\n      // wasm-emscripten-finalize\r\n      if (sig.includes('j')) {\r\n        return dynCallLegacy(sig, ptr, args);\r\n      }\r\n      return getWasmTableEntry(ptr).apply(null, args)\r\n    }\r\n  function getDynCaller(sig, ptr) {\r\n      var argCache = [];\r\n      return function() {\r\n        argCache.length = 0;\r\n        Object.assign(argCache, arguments);\r\n        return dynCall(sig, ptr, argCache);\r\n      };\r\n    }\r\n  function embind__requireFunction(signature, rawFunction) {\r\n      signature = readLatin1String(signature);\r\n  \r\n      function makeDynCaller() {\r\n        if (signature.includes('j')) {\r\n          return getDynCaller(signature, rawFunction);\r\n        }\r\n        return getWasmTableEntry(rawFunction);\r\n      }\r\n  \r\n      var fp = makeDynCaller();\r\n      if (typeof fp != \"function\") {\r\n          throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\r\n      }\r\n      return fp;\r\n    }\r\n  \r\n  var UnboundTypeError = undefined;\r\n  \r\n  function getTypeName(type) {\r\n      var ptr = ___getTypeName(type);\r\n      var rv = readLatin1String(ptr);\r\n      _free(ptr);\r\n      return rv;\r\n    }\r\n  function throwUnboundTypeError(message, types) {\r\n      var unboundTypes = [];\r\n      var seen = {};\r\n      function visit(type) {\r\n        if (seen[type]) {\r\n          return;\r\n        }\r\n        if (registeredTypes[type]) {\r\n          return;\r\n        }\r\n        if (typeDependencies[type]) {\r\n          typeDependencies[type].forEach(visit);\r\n          return;\r\n        }\r\n        unboundTypes.push(type);\r\n        seen[type] = true;\r\n      }\r\n      types.forEach(visit);\r\n  \r\n      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));\r\n    }\r\n  function __embind_register_class(rawType,\r\n                                     rawPointerType,\r\n                                     rawConstPointerType,\r\n                                     baseClassRawType,\r\n                                     getActualTypeSignature,\r\n                                     getActualType,\r\n                                     upcastSignature,\r\n                                     upcast,\r\n                                     downcastSignature,\r\n                                     downcast,\r\n                                     name,\r\n                                     destructorSignature,\r\n                                     rawDestructor) {\r\n      name = readLatin1String(name);\r\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\r\n      if (upcast) {\r\n        upcast = embind__requireFunction(upcastSignature, upcast);\r\n      }\r\n      if (downcast) {\r\n        downcast = embind__requireFunction(downcastSignature, downcast);\r\n      }\r\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\r\n      var legalFunctionName = makeLegalFunctionName(name);\r\n  \r\n      exposePublicSymbol(legalFunctionName, function() {\r\n        // this code cannot run if baseClassRawType is zero\r\n        throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);\r\n      });\r\n  \r\n      whenDependentTypesAreResolved(\r\n        [rawType, rawPointerType, rawConstPointerType],\r\n        baseClassRawType ? [baseClassRawType] : [],\r\n        function(base) {\r\n          base = base[0];\r\n  \r\n          var baseClass;\r\n          var basePrototype;\r\n          if (baseClassRawType) {\r\n            baseClass = base.registeredClass;\r\n            basePrototype = baseClass.instancePrototype;\r\n          } else {\r\n            basePrototype = ClassHandle.prototype;\r\n          }\r\n  \r\n          var constructor = createNamedFunction(legalFunctionName, function() {\r\n            if (Object.getPrototypeOf(this) !== instancePrototype) {\r\n              throw new BindingError(\"Use 'new' to construct \" + name);\r\n            }\r\n            if (undefined === registeredClass.constructor_body) {\r\n              throw new BindingError(name + \" has no accessible constructor\");\r\n            }\r\n            var body = registeredClass.constructor_body[arguments.length];\r\n            if (undefined === body) {\r\n              throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\r\n            }\r\n            return body.apply(this, arguments);\r\n          });\r\n  \r\n          var instancePrototype = Object.create(basePrototype, {\r\n            constructor: { value: constructor },\r\n          });\r\n  \r\n          constructor.prototype = instancePrototype;\r\n  \r\n          var registeredClass = new RegisteredClass(name,\r\n                                                    constructor,\r\n                                                    instancePrototype,\r\n                                                    rawDestructor,\r\n                                                    baseClass,\r\n                                                    getActualType,\r\n                                                    upcast,\r\n                                                    downcast);\r\n  \r\n          var referenceConverter = new RegisteredPointer(name,\r\n                                                         registeredClass,\r\n                                                         true,\r\n                                                         false,\r\n                                                         false);\r\n  \r\n          var pointerConverter = new RegisteredPointer(name + '*',\r\n                                                       registeredClass,\r\n                                                       false,\r\n                                                       false,\r\n                                                       false);\r\n  \r\n          var constPointerConverter = new RegisteredPointer(name + ' const*',\r\n                                                            registeredClass,\r\n                                                            false,\r\n                                                            true,\r\n                                                            false);\r\n  \r\n          registeredPointers[rawType] = {\r\n            pointerType: pointerConverter,\r\n            constPointerType: constPointerConverter\r\n          };\r\n  \r\n          replacePublicSymbol(legalFunctionName, constructor);\r\n  \r\n          return [referenceConverter, pointerConverter, constPointerConverter];\r\n        }\r\n      );\r\n    }\r\n\r\n  function heap32VectorToArray(count, firstElement) {\r\n      var array = [];\r\n      for (var i = 0; i < count; i++) {\r\n          array.push(HEAP32[(firstElement >> 2) + i]);\r\n      }\r\n      return array;\r\n    }\r\n  function __embind_register_class_constructor(\r\n      rawClassType,\r\n      argCount,\r\n      rawArgTypesAddr,\r\n      invokerSignature,\r\n      invoker,\r\n      rawConstructor\r\n    ) {\r\n      assert(argCount > 0);\r\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n      invoker = embind__requireFunction(invokerSignature, invoker);\r\n      var args = [rawConstructor];\r\n      var destructors = [];\r\n  \r\n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\r\n        classType = classType[0];\r\n        var humanName = 'constructor ' + classType.name;\r\n  \r\n        if (undefined === classType.registeredClass.constructor_body) {\r\n          classType.registeredClass.constructor_body = [];\r\n        }\r\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\r\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount-1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\r\n        }\r\n        classType.registeredClass.constructor_body[argCount - 1] = () => {\r\n          throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);\r\n        };\r\n  \r\n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\r\n          // Insert empty slot for context type (argTypes[1]).\r\n          argTypes.splice(1, 0, null);\r\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\r\n          return [];\r\n        });\r\n        return [];\r\n      });\r\n    }\r\n\r\n  function new_(constructor, argumentList) {\r\n      if (!(constructor instanceof Function)) {\r\n        throw new TypeError('new_ called with constructor type ' + typeof(constructor) + \" which is not a function\");\r\n      }\r\n      /*\r\n       * Previously, the following line was just:\r\n       *   function dummy() {};\r\n       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even\r\n       * though at creation, the 'dummy' has the correct constructor name.  Thus,\r\n       * objects created with IMVU.new would show up in the debugger as 'dummy',\r\n       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the\r\n       * issue.  Doublely-unfortunately, there's no way to write a test for this\r\n       * behavior.  -NRD 2013.02.22\r\n       */\r\n      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});\r\n      dummy.prototype = constructor.prototype;\r\n      var obj = new dummy;\r\n  \r\n      var r = constructor.apply(obj, argumentList);\r\n      return (r instanceof Object) ? r : obj;\r\n    }\r\n  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\r\n      // humanName: a human-readable string name for the function to be generated.\r\n      // argTypes: An array that contains the embind type objects for all types in the function signature.\r\n      //    argTypes[0] is the type object for the function return value.\r\n      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\r\n      //    argTypes[2...] are the actual function parameters.\r\n      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\r\n      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\r\n      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\r\n      var argCount = argTypes.length;\r\n  \r\n      if (argCount < 2) {\r\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\r\n      }\r\n  \r\n      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);\r\n  \r\n      // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\r\n  // TODO: This omits argument count check - enable only at -O3 or similar.\r\n  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\r\n  //       return FUNCTION_TABLE[fn];\r\n  //    }\r\n  \r\n      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\r\n      // TODO: Remove this completely once all function invokers are being dynamically generated.\r\n      var needsDestructorStack = false;\r\n  \r\n      for (var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.\r\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack\r\n          needsDestructorStack = true;\r\n          break;\r\n        }\r\n      }\r\n  \r\n      var returns = (argTypes[0].name !== \"void\");\r\n  \r\n      var argsList = \"\";\r\n      var argsListWired = \"\";\r\n      for (var i = 0; i < argCount - 2; ++i) {\r\n        argsList += (i!==0?\", \":\"\")+\"arg\"+i;\r\n        argsListWired += (i!==0?\", \":\"\")+\"arg\"+i+\"Wired\";\r\n      }\r\n  \r\n      var invokerFnBody =\r\n          \"return function \"+makeLegalFunctionName(humanName)+\"(\"+argsList+\") {\\n\" +\r\n          \"if (arguments.length !== \"+(argCount - 2)+\") {\\n\" +\r\n              \"throwBindingError('function \"+humanName+\" called with ' + arguments.length + ' arguments, expected \"+(argCount - 2)+\" args!');\\n\" +\r\n          \"}\\n\";\r\n  \r\n      if (needsDestructorStack) {\r\n        invokerFnBody += \"var destructors = [];\\n\";\r\n      }\r\n  \r\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\r\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\r\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\r\n  \r\n      if (isClassMethodFunc) {\r\n        invokerFnBody += \"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\";\r\n      }\r\n  \r\n      for (var i = 0; i < argCount - 2; ++i) {\r\n        invokerFnBody += \"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";\r\n        args1.push(\"argType\"+i);\r\n        args2.push(argTypes[i+2]);\r\n      }\r\n  \r\n      if (isClassMethodFunc) {\r\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\r\n      }\r\n  \r\n      invokerFnBody +=\r\n          (returns?\"var rv = \":\"\") + \"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";\r\n  \r\n      if (needsDestructorStack) {\r\n        invokerFnBody += \"runDestructors(destructors);\\n\";\r\n      } else {\r\n        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\r\n          var paramName = (i === 1 ? \"thisWired\" : (\"arg\"+(i - 2)+\"Wired\"));\r\n          if (argTypes[i].destructorFunction !== null) {\r\n            invokerFnBody += paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";\r\n            args1.push(paramName+\"_dtor\");\r\n            args2.push(argTypes[i].destructorFunction);\r\n          }\r\n        }\r\n      }\r\n  \r\n      if (returns) {\r\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" +\r\n                         \"return ret;\\n\";\r\n      } else {\r\n      }\r\n  \r\n      invokerFnBody += \"}\\n\";\r\n  \r\n      args1.push(invokerFnBody);\r\n  \r\n      var invokerFunction = new_(Function, args1).apply(null, args2);\r\n      return invokerFunction;\r\n    }\r\n  function __embind_register_class_function(rawClassType,\r\n                                              methodName,\r\n                                              argCount,\r\n                                              rawArgTypesAddr, // [ReturnType, ThisType, Args...]\r\n                                              invokerSignature,\r\n                                              rawInvoker,\r\n                                              context,\r\n                                              isPureVirtual) {\r\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n      methodName = readLatin1String(methodName);\r\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\r\n  \r\n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\r\n        classType = classType[0];\r\n        var humanName = classType.name + '.' + methodName;\r\n  \r\n        if (methodName.startsWith(\"@@\")) {\r\n          methodName = Symbol[methodName.substring(2)];\r\n        }\r\n  \r\n        if (isPureVirtual) {\r\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\r\n        }\r\n  \r\n        function unboundTypesHandler() {\r\n          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);\r\n        }\r\n  \r\n        var proto = classType.registeredClass.instancePrototype;\r\n        var method = proto[methodName];\r\n        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {\r\n          // This is the first overload to be registered, OR we are replacing a\r\n          // function in the base class with a function in the derived class.\r\n          unboundTypesHandler.argCount = argCount - 2;\r\n          unboundTypesHandler.className = classType.name;\r\n          proto[methodName] = unboundTypesHandler;\r\n        } else {\r\n          // There was an existing function with the same name registered. Set up\r\n          // a function overload routing table.\r\n          ensureOverloadTable(proto, methodName, humanName);\r\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\r\n        }\r\n  \r\n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\r\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\r\n  \r\n          // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types\r\n          // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.\r\n          if (undefined === proto[methodName].overloadTable) {\r\n            // Set argCount in case an overload is registered later\r\n            memberFunction.argCount = argCount - 2;\r\n            proto[methodName] = memberFunction;\r\n          } else {\r\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\r\n          }\r\n  \r\n          return [];\r\n        });\r\n        return [];\r\n      });\r\n    }\r\n\r\n  var emval_free_list = [];\r\n  \r\n  var emval_handle_array = [{},{value:undefined},{value:null},{value:true},{value:false}];\r\n  function __emval_decref(handle) {\r\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\r\n        emval_handle_array[handle] = undefined;\r\n        emval_free_list.push(handle);\r\n      }\r\n    }\r\n  \r\n  function count_emval_handles() {\r\n      var count = 0;\r\n      for (var i = 5; i < emval_handle_array.length; ++i) {\r\n        if (emval_handle_array[i] !== undefined) {\r\n          ++count;\r\n        }\r\n      }\r\n      return count;\r\n    }\r\n  \r\n  function get_first_emval() {\r\n      for (var i = 5; i < emval_handle_array.length; ++i) {\r\n        if (emval_handle_array[i] !== undefined) {\r\n          return emval_handle_array[i];\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n  function init_emval() {\r\n      Module['count_emval_handles'] = count_emval_handles;\r\n      Module['get_first_emval'] = get_first_emval;\r\n    }\r\n  var Emval = {toValue:(handle) => {\r\n        if (!handle) {\r\n            throwBindingError('Cannot use deleted val. handle = ' + handle);\r\n        }\r\n        return emval_handle_array[handle].value;\r\n      },toHandle:(value) => {\r\n        switch (value) {\r\n          case undefined: return 1;\r\n          case null: return 2;\r\n          case true: return 3;\r\n          case false: return 4;\r\n          default:{\r\n            var handle = emval_free_list.length ?\r\n                emval_free_list.pop() :\r\n                emval_handle_array.length;\r\n  \r\n            emval_handle_array[handle] = {refcount: 1, value: value};\r\n            return handle;\r\n          }\r\n        }\r\n      }};\r\n  function __embind_register_emval(rawType, name) {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': function(handle) {\r\n          var rv = Emval.toValue(handle);\r\n          __emval_decref(handle);\r\n          return rv;\r\n        },\r\n        'toWireType': function(destructors, value) {\r\n          return Emval.toHandle(value);\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': simpleReadValueFromPointer,\r\n        destructorFunction: null, // This type does not need a destructor\r\n  \r\n        // TODO: do we need a deleteObject here?  write a test where\r\n        // emval is passed into JS via an interface\r\n      });\r\n    }\r\n\r\n  function _embind_repr(v) {\r\n      if (v === null) {\r\n          return 'null';\r\n      }\r\n      var t = typeof v;\r\n      if (t === 'object' || t === 'array' || t === 'function') {\r\n          return v.toString();\r\n      } else {\r\n          return '' + v;\r\n      }\r\n    }\r\n  \r\n  function floatReadValueFromPointer(name, shift) {\r\n      switch (shift) {\r\n          case 2: return function(pointer) {\r\n              return this['fromWireType'](HEAPF32[pointer >> 2]);\r\n          };\r\n          case 3: return function(pointer) {\r\n              return this['fromWireType'](HEAPF64[pointer >> 3]);\r\n          };\r\n          default:\r\n              throw new TypeError(\"Unknown float type: \" + name);\r\n      }\r\n    }\r\n  function __embind_register_float(rawType, name, size) {\r\n      var shift = getShiftFromSize(size);\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          name: name,\r\n          'fromWireType': function(value) {\r\n               return value;\r\n          },\r\n          'toWireType': function(destructors, value) {\r\n              // The VM will perform JS to Wasm value conversion, according to the spec:\r\n              // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n              return value;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': floatReadValueFromPointer(name, shift),\r\n          destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\r\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n      name = readLatin1String(name);\r\n  \r\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\r\n  \r\n      exposePublicSymbol(name, function() {\r\n          throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);\r\n      }, argCount - 1);\r\n  \r\n      whenDependentTypesAreResolved([], argTypes, function(argTypes) {\r\n          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);\r\n          replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn), argCount - 1);\r\n          return [];\r\n      });\r\n    }\r\n\r\n  function integerReadValueFromPointer(name, shift, signed) {\r\n      // integers are quite common, so generate very specialized functions\r\n      switch (shift) {\r\n          case 0: return signed ?\r\n              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :\r\n              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };\r\n          case 1: return signed ?\r\n              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :\r\n              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };\r\n          case 2: return signed ?\r\n              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :\r\n              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };\r\n          default:\r\n              throw new TypeError(\"Unknown integer type: \" + name);\r\n      }\r\n    }\r\n  function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\r\n      name = readLatin1String(name);\r\n      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.\r\n          maxRange = 4294967295;\r\n      }\r\n  \r\n      var shift = getShiftFromSize(size);\r\n  \r\n      var fromWireType = (value) => value;\r\n  \r\n      if (minRange === 0) {\r\n          var bitshift = 32 - 8*size;\r\n          fromWireType = (value) => (value << bitshift) >>> bitshift;\r\n      }\r\n  \r\n      var isUnsignedType = (name.includes('unsigned'));\r\n      var checkAssertions = (value, toTypeName) => {\r\n      }\r\n      var toWireType;\r\n      if (isUnsignedType) {\r\n          toWireType = function(destructors, value) {\r\n              checkAssertions(value, this.name);\r\n              return value >>> 0;\r\n          }\r\n      } else {\r\n          toWireType = function(destructors, value) {\r\n              checkAssertions(value, this.name);\r\n              // The VM will perform JS to Wasm value conversion, according to the spec:\r\n              // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n              return value;\r\n          }\r\n      }\r\n      registerType(primitiveType, {\r\n          name: name,\r\n          'fromWireType': fromWireType,\r\n          'toWireType': toWireType,\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),\r\n          destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\r\n      var typeMapping = [\r\n        Int8Array,\r\n        Uint8Array,\r\n        Int16Array,\r\n        Uint16Array,\r\n        Int32Array,\r\n        Uint32Array,\r\n        Float32Array,\r\n        Float64Array,\r\n      ];\r\n  \r\n      var TA = typeMapping[dataTypeIndex];\r\n  \r\n      function decodeMemoryView(handle) {\r\n        handle = handle >> 2;\r\n        var heap = HEAPU32;\r\n        var size = heap[handle]; // in elements\r\n        var data = heap[handle + 1]; // byte offset into emscripten heap\r\n        return new TA(buffer, data, size);\r\n      }\r\n  \r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': decodeMemoryView,\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': decodeMemoryView,\r\n      }, {\r\n        ignoreDuplicateRegistrations: true,\r\n      });\r\n    }\r\n\r\n  function __embind_register_std_string(rawType, name) {\r\n      name = readLatin1String(name);\r\n      var stdStringIsUTF8\r\n      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>\r\n      = (name === \"std::string\");\r\n  \r\n      registerType(rawType, {\r\n          name: name,\r\n          'fromWireType': function(value) {\r\n              var length = HEAPU32[value >> 2];\r\n  \r\n              var str;\r\n              if (stdStringIsUTF8) {\r\n                  var decodeStartPtr = value + 4;\r\n                  // Looping here to support possible embedded '0' bytes\r\n                  for (var i = 0; i <= length; ++i) {\r\n                      var currentBytePtr = value + 4 + i;\r\n                      if (i == length || HEAPU8[currentBytePtr] == 0) {\r\n                          var maxRead = currentBytePtr - decodeStartPtr;\r\n                          var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\r\n                          if (str === undefined) {\r\n                              str = stringSegment;\r\n                          } else {\r\n                              str += String.fromCharCode(0);\r\n                              str += stringSegment;\r\n                          }\r\n                          decodeStartPtr = currentBytePtr + 1;\r\n                      }\r\n                  }\r\n              } else {\r\n                  var a = new Array(length);\r\n                  for (var i = 0; i < length; ++i) {\r\n                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\r\n                  }\r\n                  str = a.join('');\r\n              }\r\n  \r\n              _free(value);\r\n  \r\n              return str;\r\n          },\r\n          'toWireType': function(destructors, value) {\r\n              if (value instanceof ArrayBuffer) {\r\n                  value = new Uint8Array(value);\r\n              }\r\n  \r\n              var getLength;\r\n              var valueIsOfTypeString = (typeof value == 'string');\r\n  \r\n              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\r\n                  throwBindingError('Cannot pass non-string to std::string');\r\n              }\r\n              if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n                  getLength = () => lengthBytesUTF8(value);\r\n              } else {\r\n                  getLength = () => value.length;\r\n              }\r\n  \r\n              // assumes 4-byte alignment\r\n              var length = getLength();\r\n              var ptr = _malloc(4 + length + 1);\r\n              HEAPU32[ptr >> 2] = length;\r\n              if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n                  stringToUTF8(value, ptr + 4, length + 1);\r\n              } else {\r\n                  if (valueIsOfTypeString) {\r\n                      for (var i = 0; i < length; ++i) {\r\n                          var charCode = value.charCodeAt(i);\r\n                          if (charCode > 255) {\r\n                              _free(ptr);\r\n                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\r\n                          }\r\n                          HEAPU8[ptr + 4 + i] = charCode;\r\n                      }\r\n                  } else {\r\n                      for (var i = 0; i < length; ++i) {\r\n                          HEAPU8[ptr + 4 + i] = value[i];\r\n                      }\r\n                  }\r\n              }\r\n  \r\n              if (destructors !== null) {\r\n                  destructors.push(_free, ptr);\r\n              }\r\n              return ptr;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': simpleReadValueFromPointer,\r\n          destructorFunction: function(ptr) { _free(ptr); },\r\n      });\r\n    }\r\n\r\n  function __embind_register_std_wstring(rawType, charSize, name) {\r\n      name = readLatin1String(name);\r\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\r\n      if (charSize === 2) {\r\n        decodeString = UTF16ToString;\r\n        encodeString = stringToUTF16;\r\n        lengthBytesUTF = lengthBytesUTF16;\r\n        getHeap = () => HEAPU16;\r\n        shift = 1;\r\n      } else if (charSize === 4) {\r\n        decodeString = UTF32ToString;\r\n        encodeString = stringToUTF32;\r\n        lengthBytesUTF = lengthBytesUTF32;\r\n        getHeap = () => HEAPU32;\r\n        shift = 2;\r\n      }\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': function(value) {\r\n          // Code mostly taken from _embind_register_std_string fromWireType\r\n          var length = HEAPU32[value >> 2];\r\n          var HEAP = getHeap();\r\n          var str;\r\n  \r\n          var decodeStartPtr = value + 4;\r\n          // Looping here to support possible embedded '0' bytes\r\n          for (var i = 0; i <= length; ++i) {\r\n            var currentBytePtr = value + 4 + i * charSize;\r\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\r\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\r\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\r\n              if (str === undefined) {\r\n                str = stringSegment;\r\n              } else {\r\n                str += String.fromCharCode(0);\r\n                str += stringSegment;\r\n              }\r\n              decodeStartPtr = currentBytePtr + charSize;\r\n            }\r\n          }\r\n  \r\n          _free(value);\r\n  \r\n          return str;\r\n        },\r\n        'toWireType': function(destructors, value) {\r\n          if (!(typeof value == 'string')) {\r\n            throwBindingError('Cannot pass non-string to C++ string type ' + name);\r\n          }\r\n  \r\n          // assumes 4-byte alignment\r\n          var length = lengthBytesUTF(value);\r\n          var ptr = _malloc(4 + length + charSize);\r\n          HEAPU32[ptr >> 2] = length >> shift;\r\n  \r\n          encodeString(value, ptr + 4, length + charSize);\r\n  \r\n          if (destructors !== null) {\r\n            destructors.push(_free, ptr);\r\n          }\r\n          return ptr;\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': simpleReadValueFromPointer,\r\n        destructorFunction: function(ptr) { _free(ptr); },\r\n      });\r\n    }\r\n\r\n  function __embind_register_value_object(\r\n      rawType,\r\n      name,\r\n      constructorSignature,\r\n      rawConstructor,\r\n      destructorSignature,\r\n      rawDestructor\r\n    ) {\r\n      structRegistrations[rawType] = {\r\n        name: readLatin1String(name),\r\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\r\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\r\n        fields: [],\r\n      };\r\n    }\r\n\r\n  function __embind_register_value_object_field(\r\n      structType,\r\n      fieldName,\r\n      getterReturnType,\r\n      getterSignature,\r\n      getter,\r\n      getterContext,\r\n      setterArgumentType,\r\n      setterSignature,\r\n      setter,\r\n      setterContext\r\n    ) {\r\n      structRegistrations[structType].fields.push({\r\n        fieldName: readLatin1String(fieldName),\r\n        getterReturnType: getterReturnType,\r\n        getter: embind__requireFunction(getterSignature, getter),\r\n        getterContext: getterContext,\r\n        setterArgumentType: setterArgumentType,\r\n        setter: embind__requireFunction(setterSignature, setter),\r\n        setterContext: setterContext,\r\n      });\r\n    }\r\n\r\n  function __embind_register_void(rawType, name) {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          isVoid: true, // void return values can be optimized out sometimes\r\n          name: name,\r\n          'argPackAdvance': 0,\r\n          'fromWireType': function() {\r\n              return undefined;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n              // TODO: assert if anything else is given?\r\n              return undefined;\r\n          },\r\n      });\r\n    }\r\n\r\n  function requireRegisteredType(rawType, humanName) {\r\n      var impl = registeredTypes[rawType];\r\n      if (undefined === impl) {\r\n          throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\r\n      }\r\n      return impl;\r\n    }\r\n  function __emval_as(handle, returnType, destructorsRef) {\r\n      handle = Emval.toValue(handle);\r\n      returnType = requireRegisteredType(returnType, 'emval::as');\r\n      var destructors = [];\r\n      var rd = Emval.toHandle(destructors);\r\n      HEAP32[destructorsRef >> 2] = rd;\r\n      return returnType['toWireType'](destructors, handle);\r\n    }\r\n\r\n  function __emval_allocateDestructors(destructorsRef) {\r\n      var destructors = [];\r\n      HEAP32[destructorsRef >> 2] = Emval.toHandle(destructors);\r\n      return destructors;\r\n    }\r\n  \r\n  var emval_symbols = {};\r\n  function getStringOrSymbol(address) {\r\n      var symbol = emval_symbols[address];\r\n      if (symbol === undefined) {\r\n        return readLatin1String(address);\r\n      }\r\n      return symbol;\r\n    }\r\n  \r\n  var emval_methodCallers = [];\r\n  function __emval_call_method(caller, handle, methodName, destructorsRef, args) {\r\n      caller = emval_methodCallers[caller];\r\n      handle = Emval.toValue(handle);\r\n      methodName = getStringOrSymbol(methodName);\r\n      return caller(handle, methodName, __emval_allocateDestructors(destructorsRef), args);\r\n    }\r\n\r\n  function __emval_call_void_method(caller, handle, methodName, args) {\r\n      caller = emval_methodCallers[caller];\r\n      handle = Emval.toValue(handle);\r\n      methodName = getStringOrSymbol(methodName);\r\n      caller(handle, methodName, null, args);\r\n    }\r\n\r\n\r\n  function emval_get_global() {\r\n      if (typeof globalThis == 'object') {\r\n        return globalThis;\r\n      }\r\n      return (function(){\r\n        return Function;\r\n      })()('return this')();\r\n    }\r\n  function __emval_get_global(name) {\r\n      if (name===0) {\r\n        return Emval.toHandle(emval_get_global());\r\n      } else {\r\n        name = getStringOrSymbol(name);\r\n        return Emval.toHandle(emval_get_global()[name]);\r\n      }\r\n    }\r\n\r\n  function __emval_addMethodCaller(caller) {\r\n      var id = emval_methodCallers.length;\r\n      emval_methodCallers.push(caller);\r\n      return id;\r\n    }\r\n  \r\n  function __emval_lookupTypes(argCount, argTypes) {\r\n      var a = new Array(argCount);\r\n      for (var i = 0; i < argCount; ++i) {\r\n        a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i],\r\n                                     \"parameter \" + i);\r\n      }\r\n      return a;\r\n    }\r\n  \r\n  var emval_registeredMethods = [];\r\n  function __emval_get_method_caller(argCount, argTypes) {\r\n      var types = __emval_lookupTypes(argCount, argTypes);\r\n      var retType = types[0];\r\n      var signatureName = retType.name + \"_$\" + types.slice(1).map(function (t) { return t.name; }).join(\"_\") + \"$\";\r\n      var returnId = emval_registeredMethods[signatureName];\r\n      if (returnId !== undefined) {\r\n        return returnId;\r\n      }\r\n  \r\n      var params = [\"retType\"];\r\n      var args = [retType];\r\n  \r\n      var argsList = \"\"; // 'arg0, arg1, arg2, ... , argN'\r\n      for (var i = 0; i < argCount - 1; ++i) {\r\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\r\n        params.push(\"argType\" + i);\r\n        args.push(types[1 + i]);\r\n      }\r\n  \r\n      var functionName = makeLegalFunctionName(\"methodCaller_\" + signatureName);\r\n      var functionBody =\r\n          \"return function \" + functionName + \"(handle, name, destructors, args) {\\n\";\r\n  \r\n      var offset = 0;\r\n      for (var i = 0; i < argCount - 1; ++i) {\r\n          functionBody +=\r\n          \"    var arg\" + i + \" = argType\" + i + \".readValueFromPointer(args\" + (offset ? (\"+\"+offset) : \"\") + \");\\n\";\r\n          offset += types[i + 1]['argPackAdvance'];\r\n      }\r\n      functionBody +=\r\n          \"    var rv = handle[name](\" + argsList + \");\\n\";\r\n      for (var i = 0; i < argCount - 1; ++i) {\r\n          if (types[i + 1]['deleteObject']) {\r\n              functionBody +=\r\n              \"    argType\" + i + \".deleteObject(arg\" + i + \");\\n\";\r\n          }\r\n      }\r\n      if (!retType.isVoid) {\r\n          functionBody +=\r\n          \"    return retType.toWireType(destructors, rv);\\n\";\r\n      }\r\n      functionBody +=\r\n          \"};\\n\";\r\n  \r\n      params.push(functionBody);\r\n      var invokerFunction = new_(Function, params).apply(null, args);\r\n      returnId = __emval_addMethodCaller(invokerFunction);\r\n      emval_registeredMethods[signatureName] = returnId;\r\n      return returnId;\r\n    }\r\n\r\n  function __emval_get_property(handle, key) {\r\n      handle = Emval.toValue(handle);\r\n      key = Emval.toValue(key);\r\n      return Emval.toHandle(handle[key]);\r\n    }\r\n\r\n  function __emval_incref(handle) {\r\n      if (handle > 4) {\r\n        emval_handle_array[handle].refcount += 1;\r\n      }\r\n    }\r\n\r\n  function __emval_new_array() {\r\n      return Emval.toHandle([]);\r\n    }\r\n\r\n  function __emval_new_cstring(v) {\r\n      return Emval.toHandle(getStringOrSymbol(v));\r\n    }\r\n\r\n  function __emval_new_object() {\r\n      return Emval.toHandle({});\r\n    }\r\n\r\n  function __emval_run_destructors(handle) {\r\n      var destructors = Emval.toValue(handle);\r\n      runDestructors(destructors);\r\n      __emval_decref(handle);\r\n    }\r\n\r\n  function __emval_set_property(handle, key, value) {\r\n      handle = Emval.toValue(handle);\r\n      key = Emval.toValue(key);\r\n      value = Emval.toValue(value);\r\n      handle[key] = value;\r\n    }\r\n\r\n  function __emval_take_value(type, argv) {\r\n      type = requireRegisteredType(type, '_emval_take_value');\r\n      var v = type['readValueFromPointer'](argv);\r\n      return Emval.toHandle(v);\r\n    }\r\n\r\n  function _abort() {\r\n      abort('');\r\n    }\r\n\r\n  function _emscripten_memcpy_big(dest, src, num) {\r\n      HEAPU8.copyWithin(dest, src, src + num);\r\n    }\r\n\r\n  function getHeapMax() {\r\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\r\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\r\n      // for any code that deals with heap sizes, which would require special\r\n      // casing all heap size related code to treat 0 specially.\r\n      return 2147483648;\r\n    }\r\n  \r\n  function emscripten_realloc_buffer(size) {\r\n      try {\r\n        // round size grow request up to wasm page size (fixed 64KB per spec)\r\n        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size\r\n        updateGlobalBufferAndViews(wasmMemory.buffer);\r\n        return 1 /*success*/;\r\n      } catch(e) {\r\n      }\r\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\r\n      // anyhow)\r\n    }\r\n  function _emscripten_resize_heap(requestedSize) {\r\n      var oldSize = HEAPU8.length;\r\n      requestedSize = requestedSize >>> 0;\r\n      // With multithreaded builds, races can happen (another thread might increase the size\r\n      // in between), so return a failure, and let the caller retry.\r\n  \r\n      // Memory resize rules:\r\n      // 1.  Always increase heap size to at least the requested size, rounded up\r\n      //     to next page multiple.\r\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\r\n      //     geometrically: increase the heap size according to\r\n      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\r\n      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\r\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\r\n      //     linearly: increase the heap size by at least\r\n      //     MEMORY_GROWTH_LINEAR_STEP bytes.\r\n      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\r\n      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\r\n      // 4.  If we were unable to allocate as much memory, it may be due to\r\n      //     over-eager decision to excessively reserve due to (3) above.\r\n      //     Hence if an allocation fails, cut down on the amount of excess\r\n      //     growth, in an attempt to succeed to perform a smaller allocation.\r\n  \r\n      // A limit is set for how much we can grow. We should not exceed that\r\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\r\n      var maxHeapSize = getHeapMax();\r\n      if (requestedSize > maxHeapSize) {\r\n        return false;\r\n      }\r\n  \r\n      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\r\n  \r\n      // Loop through potential heap size increases. If we attempt a too eager\r\n      // reservation that fails, cut down on the attempted size and reserve a\r\n      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\r\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\r\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\r\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\r\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\r\n  \r\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\r\n  \r\n        var replacement = emscripten_realloc_buffer(newSize);\r\n        if (replacement) {\r\n  \r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n  var ENV = {};\r\n  \r\n  function getExecutableName() {\r\n      return thisProgram || './this.program';\r\n    }\r\n  function getEnvStrings() {\r\n      if (!getEnvStrings.strings) {\r\n        // Default values.\r\n        // Browser language detection #8751\r\n        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';\r\n        var env = {\r\n          'USER': 'web_user',\r\n          'LOGNAME': 'web_user',\r\n          'PATH': '/',\r\n          'PWD': '/',\r\n          'HOME': '/home/web_user',\r\n          'LANG': lang,\r\n          '_': getExecutableName()\r\n        };\r\n        // Apply the user-provided values, if any.\r\n        for (var x in ENV) {\r\n          // x is a key in ENV; if ENV[x] is undefined, that means it was\r\n          // explicitly set to be so. We allow user code to do that to\r\n          // force variables with default values to remain unset.\r\n          if (ENV[x] === undefined) delete env[x];\r\n          else env[x] = ENV[x];\r\n        }\r\n        var strings = [];\r\n        for (var x in env) {\r\n          strings.push(x + '=' + env[x]);\r\n        }\r\n        getEnvStrings.strings = strings;\r\n      }\r\n      return getEnvStrings.strings;\r\n    }\r\n  \r\n  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {\r\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n        return splitPathRe.exec(filename).slice(1);\r\n      },normalizeArray:(parts, allowAboveRoot) => {\r\n        // if the path tries to go above the root, `up` ends up > 0\r\n        var up = 0;\r\n        for (var i = parts.length - 1; i >= 0; i--) {\r\n          var last = parts[i];\r\n          if (last === '.') {\r\n            parts.splice(i, 1);\r\n          } else if (last === '..') {\r\n            parts.splice(i, 1);\r\n            up++;\r\n          } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n          }\r\n        }\r\n        // if the path is allowed to go above the root, restore leading ..s\r\n        if (allowAboveRoot) {\r\n          for (; up; up--) {\r\n            parts.unshift('..');\r\n          }\r\n        }\r\n        return parts;\r\n      },normalize:(path) => {\r\n        var isAbsolute = PATH.isAbs(path),\r\n            trailingSlash = path.substr(-1) === '/';\r\n        // Normalize the path\r\n        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\r\n        if (!path && !isAbsolute) {\r\n          path = '.';\r\n        }\r\n        if (path && trailingSlash) {\r\n          path += '/';\r\n        }\r\n        return (isAbsolute ? '/' : '') + path;\r\n      },dirname:(path) => {\r\n        var result = PATH.splitPath(path),\r\n            root = result[0],\r\n            dir = result[1];\r\n        if (!root && !dir) {\r\n          // No dirname whatsoever\r\n          return '.';\r\n        }\r\n        if (dir) {\r\n          // It has a dirname, strip trailing slash\r\n          dir = dir.substr(0, dir.length - 1);\r\n        }\r\n        return root + dir;\r\n      },basename:(path) => {\r\n        // EMSCRIPTEN return '/'' for '/', not an empty string\r\n        if (path === '/') return '/';\r\n        path = PATH.normalize(path);\r\n        path = path.replace(/\\/$/, \"\");\r\n        var lastSlash = path.lastIndexOf('/');\r\n        if (lastSlash === -1) return path;\r\n        return path.substr(lastSlash+1);\r\n      },join:function() {\r\n        var paths = Array.prototype.slice.call(arguments, 0);\r\n        return PATH.normalize(paths.join('/'));\r\n      },join2:(l, r) => {\r\n        return PATH.normalize(l + '/' + r);\r\n      }};\r\n  \r\n  function getRandomDevice() {\r\n      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\r\n        // for modern web browsers\r\n        var randomBuffer = new Uint8Array(1);\r\n        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };\r\n      } else\r\n      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\r\n      return function() { abort(\"randomDevice\"); };\r\n    }\r\n  \r\n  var PATH_FS = {resolve:function() {\r\n        var resolvedPath = '',\r\n          resolvedAbsolute = false;\r\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n          var path = (i >= 0) ? arguments[i] : FS.cwd();\r\n          // Skip empty and invalid entries\r\n          if (typeof path != 'string') {\r\n            throw new TypeError('Arguments to path.resolve must be strings');\r\n          } else if (!path) {\r\n            return ''; // an invalid portion invalidates the whole thing\r\n          }\r\n          resolvedPath = path + '/' + resolvedPath;\r\n          resolvedAbsolute = PATH.isAbs(path);\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\r\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n      },relative:(from, to) => {\r\n        from = PATH_FS.resolve(from).substr(1);\r\n        to = PATH_FS.resolve(to).substr(1);\r\n        function trim(arr) {\r\n          var start = 0;\r\n          for (; start < arr.length; start++) {\r\n            if (arr[start] !== '') break;\r\n          }\r\n          var end = arr.length - 1;\r\n          for (; end >= 0; end--) {\r\n            if (arr[end] !== '') break;\r\n          }\r\n          if (start > end) return [];\r\n          return arr.slice(start, end - start + 1);\r\n        }\r\n        var fromParts = trim(from.split('/'));\r\n        var toParts = trim(to.split('/'));\r\n        var length = Math.min(fromParts.length, toParts.length);\r\n        var samePartsLength = length;\r\n        for (var i = 0; i < length; i++) {\r\n          if (fromParts[i] !== toParts[i]) {\r\n            samePartsLength = i;\r\n            break;\r\n          }\r\n        }\r\n        var outputParts = [];\r\n        for (var i = samePartsLength; i < fromParts.length; i++) {\r\n          outputParts.push('..');\r\n        }\r\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n        return outputParts.join('/');\r\n      }};\r\n  \r\n  var TTY = {ttys:[],init:function () {\r\n        // https://github.com/emscripten-core/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\r\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\r\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\r\n        //   // with text files until FS.init can be refactored.\r\n        //   process['stdin']['setEncoding']('utf8');\r\n        // }\r\n      },shutdown:function() {\r\n        // https://github.com/emscripten-core/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\r\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\r\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\r\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\r\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\r\n        //   process['stdin']['pause']();\r\n        // }\r\n      },register:function(dev, ops) {\r\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\r\n        FS.registerDevice(dev, TTY.stream_ops);\r\n      },stream_ops:{open:function(stream) {\r\n          var tty = TTY.ttys[stream.node.rdev];\r\n          if (!tty) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          stream.tty = tty;\r\n          stream.seekable = false;\r\n        },close:function(stream) {\r\n          // flush any pending line data\r\n          stream.tty.ops.flush(stream.tty);\r\n        },flush:function(stream) {\r\n          stream.tty.ops.flush(stream.tty);\r\n        },read:function(stream, buffer, offset, length, pos /* ignored */) {\r\n          if (!stream.tty || !stream.tty.ops.get_char) {\r\n            throw new FS.ErrnoError(60);\r\n          }\r\n          var bytesRead = 0;\r\n          for (var i = 0; i < length; i++) {\r\n            var result;\r\n            try {\r\n              result = stream.tty.ops.get_char(stream.tty);\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(29);\r\n            }\r\n            if (result === undefined && bytesRead === 0) {\r\n              throw new FS.ErrnoError(6);\r\n            }\r\n            if (result === null || result === undefined) break;\r\n            bytesRead++;\r\n            buffer[offset+i] = result;\r\n          }\r\n          if (bytesRead) {\r\n            stream.node.timestamp = Date.now();\r\n          }\r\n          return bytesRead;\r\n        },write:function(stream, buffer, offset, length, pos) {\r\n          if (!stream.tty || !stream.tty.ops.put_char) {\r\n            throw new FS.ErrnoError(60);\r\n          }\r\n          try {\r\n            for (var i = 0; i < length; i++) {\r\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\r\n            }\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n          if (length) {\r\n            stream.node.timestamp = Date.now();\r\n          }\r\n          return i;\r\n        }},default_tty_ops:{get_char:function(tty) {\r\n          if (!tty.input.length) {\r\n            var result = null;\r\n            if (typeof window != 'undefined' &&\r\n              typeof window.prompt == 'function') {\r\n              // Browser.\r\n              result = window.prompt('Input: ');  // returns null on cancel\r\n              if (result !== null) {\r\n                result += '\\n';\r\n              }\r\n            } else if (typeof readline == 'function') {\r\n              // Command line.\r\n              result = readline();\r\n              if (result !== null) {\r\n                result += '\\n';\r\n              }\r\n            }\r\n            if (!result) {\r\n              return null;\r\n            }\r\n            tty.input = intArrayFromString(result, true);\r\n          }\r\n          return tty.input.shift();\r\n        },put_char:function(tty, val) {\r\n          if (val === null || val === 10) {\r\n            out(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\r\n          }\r\n        },flush:function(tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            out(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          }\r\n        }},default_tty1_ops:{put_char:function(tty, val) {\r\n          if (val === null || val === 10) {\r\n            err(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val);\r\n          }\r\n        },flush:function(tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            err(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          }\r\n        }}};\r\n  \r\n  function zeroMemory(address, size) {\r\n      HEAPU8.fill(0, address, address + size);\r\n    }\r\n  \r\n  function alignMemory(size, alignment) {\r\n      return Math.ceil(size / alignment) * alignment;\r\n    }\r\n  function mmapAlloc(size) {\r\n      abort();\r\n    }\r\n  var MEMFS = {ops_table:null,mount:function(mount) {\r\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\r\n      },createNode:function(parent, name, mode, dev) {\r\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n          // no supported\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (!MEMFS.ops_table) {\r\n          MEMFS.ops_table = {\r\n            dir: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr,\r\n                lookup: MEMFS.node_ops.lookup,\r\n                mknod: MEMFS.node_ops.mknod,\r\n                rename: MEMFS.node_ops.rename,\r\n                unlink: MEMFS.node_ops.unlink,\r\n                rmdir: MEMFS.node_ops.rmdir,\r\n                readdir: MEMFS.node_ops.readdir,\r\n                symlink: MEMFS.node_ops.symlink\r\n              },\r\n              stream: {\r\n                llseek: MEMFS.stream_ops.llseek\r\n              }\r\n            },\r\n            file: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr\r\n              },\r\n              stream: {\r\n                llseek: MEMFS.stream_ops.llseek,\r\n                read: MEMFS.stream_ops.read,\r\n                write: MEMFS.stream_ops.write,\r\n                allocate: MEMFS.stream_ops.allocate,\r\n                mmap: MEMFS.stream_ops.mmap,\r\n                msync: MEMFS.stream_ops.msync\r\n              }\r\n            },\r\n            link: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr,\r\n                readlink: MEMFS.node_ops.readlink\r\n              },\r\n              stream: {}\r\n            },\r\n            chrdev: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr\r\n              },\r\n              stream: FS.chrdev_stream_ops\r\n            }\r\n          };\r\n        }\r\n        var node = FS.createNode(parent, name, mode, dev);\r\n        if (FS.isDir(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.dir.node;\r\n          node.stream_ops = MEMFS.ops_table.dir.stream;\r\n          node.contents = {};\r\n        } else if (FS.isFile(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.file.node;\r\n          node.stream_ops = MEMFS.ops_table.file.stream;\r\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\r\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\r\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\r\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\r\n          node.contents = null; \r\n        } else if (FS.isLink(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.link.node;\r\n          node.stream_ops = MEMFS.ops_table.link.stream;\r\n        } else if (FS.isChrdev(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.chrdev.node;\r\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n        }\r\n        node.timestamp = Date.now();\r\n        // add the new node to the parent\r\n        if (parent) {\r\n          parent.contents[name] = node;\r\n          parent.timestamp = node.timestamp;\r\n        }\r\n        return node;\r\n      },getFileDataAsTypedArray:function(node) {\r\n        if (!node.contents) return new Uint8Array(0);\r\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\r\n        return new Uint8Array(node.contents);\r\n      },expandFileStorage:function(node, newCapacity) {\r\n        var prevCapacity = node.contents ? node.contents.length : 0;\r\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\r\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\r\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\r\n        // avoid overshooting the allocation cap by a very large margin.\r\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\r\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\r\n        var oldContents = node.contents;\r\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\r\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\r\n      },resizeFileStorage:function(node, newSize) {\r\n        if (node.usedBytes == newSize) return;\r\n        if (newSize == 0) {\r\n          node.contents = null; // Fully decommit when requesting a resize to zero.\r\n          node.usedBytes = 0;\r\n        } else {\r\n          var oldContents = node.contents;\r\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\r\n          if (oldContents) {\r\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\r\n          }\r\n          node.usedBytes = newSize;\r\n        }\r\n      },node_ops:{getattr:function(node) {\r\n          var attr = {};\r\n          // device numbers reuse inode numbers.\r\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n          attr.ino = node.id;\r\n          attr.mode = node.mode;\r\n          attr.nlink = 1;\r\n          attr.uid = 0;\r\n          attr.gid = 0;\r\n          attr.rdev = node.rdev;\r\n          if (FS.isDir(node.mode)) {\r\n            attr.size = 4096;\r\n          } else if (FS.isFile(node.mode)) {\r\n            attr.size = node.usedBytes;\r\n          } else if (FS.isLink(node.mode)) {\r\n            attr.size = node.link.length;\r\n          } else {\r\n            attr.size = 0;\r\n          }\r\n          attr.atime = new Date(node.timestamp);\r\n          attr.mtime = new Date(node.timestamp);\r\n          attr.ctime = new Date(node.timestamp);\r\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\r\n          //       but this is not required by the standard.\r\n          attr.blksize = 4096;\r\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n          return attr;\r\n        },setattr:function(node, attr) {\r\n          if (attr.mode !== undefined) {\r\n            node.mode = attr.mode;\r\n          }\r\n          if (attr.timestamp !== undefined) {\r\n            node.timestamp = attr.timestamp;\r\n          }\r\n          if (attr.size !== undefined) {\r\n            MEMFS.resizeFileStorage(node, attr.size);\r\n          }\r\n        },lookup:function(parent, name) {\r\n          throw FS.genericErrors[44];\r\n        },mknod:function(parent, name, mode, dev) {\r\n          return MEMFS.createNode(parent, name, mode, dev);\r\n        },rename:function(old_node, new_dir, new_name) {\r\n          // if we're overwriting a directory at new_name, make sure it's empty.\r\n          if (FS.isDir(old_node.mode)) {\r\n            var new_node;\r\n            try {\r\n              new_node = FS.lookupNode(new_dir, new_name);\r\n            } catch (e) {\r\n            }\r\n            if (new_node) {\r\n              for (var i in new_node.contents) {\r\n                throw new FS.ErrnoError(55);\r\n              }\r\n            }\r\n          }\r\n          // do the internal rewiring\r\n          delete old_node.parent.contents[old_node.name];\r\n          old_node.parent.timestamp = Date.now()\r\n          old_node.name = new_name;\r\n          new_dir.contents[new_name] = old_node;\r\n          new_dir.timestamp = old_node.parent.timestamp;\r\n          old_node.parent = new_dir;\r\n        },unlink:function(parent, name) {\r\n          delete parent.contents[name];\r\n          parent.timestamp = Date.now();\r\n        },rmdir:function(parent, name) {\r\n          var node = FS.lookupNode(parent, name);\r\n          for (var i in node.contents) {\r\n            throw new FS.ErrnoError(55);\r\n          }\r\n          delete parent.contents[name];\r\n          parent.timestamp = Date.now();\r\n        },readdir:function(node) {\r\n          var entries = ['.', '..'];\r\n          for (var key in node.contents) {\r\n            if (!node.contents.hasOwnProperty(key)) {\r\n              continue;\r\n            }\r\n            entries.push(key);\r\n          }\r\n          return entries;\r\n        },symlink:function(parent, newname, oldpath) {\r\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\r\n          node.link = oldpath;\r\n          return node;\r\n        },readlink:function(node) {\r\n          if (!FS.isLink(node.mode)) {\r\n            throw new FS.ErrnoError(28);\r\n          }\r\n          return node.link;\r\n        }},stream_ops:{read:function(stream, buffer, offset, length, position) {\r\n          var contents = stream.node.contents;\r\n          if (position >= stream.node.usedBytes) return 0;\r\n          var size = Math.min(stream.node.usedBytes - position, length);\r\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\r\n            buffer.set(contents.subarray(position, position + size), offset);\r\n          } else {\r\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\r\n          }\r\n          return size;\r\n        },write:function(stream, buffer, offset, length, position, canOwn) {\r\n          // If the buffer is located in main memory (HEAP), and if\r\n          // memory can grow, we can't hold on to references of the\r\n          // memory buffer, as they may get invalidated. That means we\r\n          // need to do copy its contents.\r\n          if (buffer.buffer === HEAP8.buffer) {\r\n            canOwn = false;\r\n          }\r\n  \r\n          if (!length) return 0;\r\n          var node = stream.node;\r\n          node.timestamp = Date.now();\r\n  \r\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\r\n            if (canOwn) {\r\n              node.contents = buffer.subarray(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\r\n              node.contents = buffer.slice(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\r\n              node.contents.set(buffer.subarray(offset, offset + length), position);\r\n              return length;\r\n            }\r\n          }\r\n  \r\n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\r\n          MEMFS.expandFileStorage(node, position+length);\r\n          if (node.contents.subarray && buffer.subarray) {\r\n            // Use typed array write which is available.\r\n            node.contents.set(buffer.subarray(offset, offset + length), position);\r\n          } else {\r\n            for (var i = 0; i < length; i++) {\r\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\r\n            }\r\n          }\r\n          node.usedBytes = Math.max(node.usedBytes, position + length);\r\n          return length;\r\n        },llseek:function(stream, offset, whence) {\r\n          var position = offset;\r\n          if (whence === 1) {\r\n            position += stream.position;\r\n          } else if (whence === 2) {\r\n            if (FS.isFile(stream.node.mode)) {\r\n              position += stream.node.usedBytes;\r\n            }\r\n          }\r\n          if (position < 0) {\r\n            throw new FS.ErrnoError(28);\r\n          }\r\n          return position;\r\n        },allocate:function(stream, offset, length) {\r\n          MEMFS.expandFileStorage(stream.node, offset + length);\r\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\r\n        },mmap:function(stream, length, position, prot, flags) {\r\n          if (!FS.isFile(stream.node.mode)) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          var ptr;\r\n          var allocated;\r\n          var contents = stream.node.contents;\r\n          // Only make a new copy when MAP_PRIVATE is specified.\r\n          if (!(flags & 2) && contents.buffer === buffer) {\r\n            // We can't emulate MAP_SHARED when the file is not backed by the buffer\r\n            // we're mapping to (e.g. the HEAP buffer).\r\n            allocated = false;\r\n            ptr = contents.byteOffset;\r\n          } else {\r\n            // Try to avoid unnecessary slices.\r\n            if (position > 0 || position + length < contents.length) {\r\n              if (contents.subarray) {\r\n                contents = contents.subarray(position, position + length);\r\n              } else {\r\n                contents = Array.prototype.slice.call(contents, position, position + length);\r\n              }\r\n            }\r\n            allocated = true;\r\n            ptr = mmapAlloc(length);\r\n            if (!ptr) {\r\n              throw new FS.ErrnoError(48);\r\n            }\r\n            HEAP8.set(contents, ptr);\r\n          }\r\n          return { ptr: ptr, allocated: allocated };\r\n        },msync:function(stream, buffer, offset, length, mmapFlags) {\r\n          if (!FS.isFile(stream.node.mode)) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          if (mmapFlags & 2) {\r\n            // MAP_PRIVATE calls need not to be synced back to underlying fs\r\n            return 0;\r\n          }\r\n  \r\n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n          // should we check if bytesWritten and length are the same?\r\n          return 0;\r\n        }}};\r\n  \r\n  /** @param {boolean=} noRunDep */\r\n  function asyncLoad(url, onload, onerror, noRunDep) {\r\n      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';\r\n      readAsync(url, function(arrayBuffer) {\r\n        assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\r\n        onload(new Uint8Array(arrayBuffer));\r\n        if (dep) removeRunDependency(dep);\r\n      }, function(event) {\r\n        if (onerror) {\r\n          onerror();\r\n        } else {\r\n          throw 'Loading data file \"' + url + '\" failed.';\r\n        }\r\n      });\r\n      if (dep) addRunDependency(dep);\r\n    }\r\n  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {\r\n        path = PATH_FS.resolve(FS.cwd(), path);\r\n  \r\n        if (!path) return { path: '', node: null };\r\n  \r\n        var defaults = {\r\n          follow_mount: true,\r\n          recurse_count: 0\r\n        };\r\n        opts = Object.assign(defaults, opts)\r\n  \r\n        if (opts.recurse_count > 8) {  // max recursive lookup of 8\r\n          throw new FS.ErrnoError(32);\r\n        }\r\n  \r\n        // split the path\r\n        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);\r\n  \r\n        // start at the root\r\n        var current = FS.root;\r\n        var current_path = '/';\r\n  \r\n        for (var i = 0; i < parts.length; i++) {\r\n          var islast = (i === parts.length-1);\r\n          if (islast && opts.parent) {\r\n            // stop resolving\r\n            break;\r\n          }\r\n  \r\n          current = FS.lookupNode(current, parts[i]);\r\n          current_path = PATH.join2(current_path, parts[i]);\r\n  \r\n          // jump to the mount's root node if this is a mountpoint\r\n          if (FS.isMountpoint(current)) {\r\n            if (!islast || (islast && opts.follow_mount)) {\r\n              current = current.mounted.root;\r\n            }\r\n          }\r\n  \r\n          // by default, lookupPath will not follow a symlink if it is the final path component.\r\n          // setting opts.follow = true will override this behavior.\r\n          if (!islast || opts.follow) {\r\n            var count = 0;\r\n            while (FS.isLink(current.mode)) {\r\n              var link = FS.readlink(current_path);\r\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\r\n  \r\n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\r\n              current = lookup.node;\r\n  \r\n              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\r\n                throw new FS.ErrnoError(32);\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        return { path: current_path, node: current };\r\n      },getPath:(node) => {\r\n        var path;\r\n        while (true) {\r\n          if (FS.isRoot(node)) {\r\n            var mount = node.mount.mountpoint;\r\n            if (!path) return mount;\r\n            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;\r\n          }\r\n          path = path ? node.name + '/' + path : node.name;\r\n          node = node.parent;\r\n        }\r\n      },hashName:(parentid, name) => {\r\n        var hash = 0;\r\n  \r\n        for (var i = 0; i < name.length; i++) {\r\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\r\n        }\r\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\r\n      },hashAddNode:(node) => {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        node.name_next = FS.nameTable[hash];\r\n        FS.nameTable[hash] = node;\r\n      },hashRemoveNode:(node) => {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        if (FS.nameTable[hash] === node) {\r\n          FS.nameTable[hash] = node.name_next;\r\n        } else {\r\n          var current = FS.nameTable[hash];\r\n          while (current) {\r\n            if (current.name_next === node) {\r\n              current.name_next = node.name_next;\r\n              break;\r\n            }\r\n            current = current.name_next;\r\n          }\r\n        }\r\n      },lookupNode:(parent, name) => {\r\n        var errCode = FS.mayLookup(parent);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode, parent);\r\n        }\r\n        var hash = FS.hashName(parent.id, name);\r\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n          var nodeName = node.name;\r\n          if (node.parent.id === parent.id && nodeName === name) {\r\n            return node;\r\n          }\r\n        }\r\n        // if we failed to find it in the cache, call into the VFS\r\n        return FS.lookup(parent, name);\r\n      },createNode:(parent, name, mode, rdev) => {\r\n        var node = new FS.FSNode(parent, name, mode, rdev);\r\n  \r\n        FS.hashAddNode(node);\r\n  \r\n        return node;\r\n      },destroyNode:(node) => {\r\n        FS.hashRemoveNode(node);\r\n      },isRoot:(node) => {\r\n        return node === node.parent;\r\n      },isMountpoint:(node) => {\r\n        return !!node.mounted;\r\n      },isFile:(mode) => {\r\n        return (mode & 61440) === 32768;\r\n      },isDir:(mode) => {\r\n        return (mode & 61440) === 16384;\r\n      },isLink:(mode) => {\r\n        return (mode & 61440) === 40960;\r\n      },isChrdev:(mode) => {\r\n        return (mode & 61440) === 8192;\r\n      },isBlkdev:(mode) => {\r\n        return (mode & 61440) === 24576;\r\n      },isFIFO:(mode) => {\r\n        return (mode & 61440) === 4096;\r\n      },isSocket:(mode) => {\r\n        return (mode & 49152) === 49152;\r\n      },flagModes:{\"r\":0,\"r+\":2,\"w\":577,\"w+\":578,\"a\":1089,\"a+\":1090},modeStringToFlags:(str) => {\r\n        var flags = FS.flagModes[str];\r\n        if (typeof flags == 'undefined') {\r\n          throw new Error('Unknown file open mode: ' + str);\r\n        }\r\n        return flags;\r\n      },flagsToPermissionString:(flag) => {\r\n        var perms = ['r', 'w', 'rw'][flag & 3];\r\n        if ((flag & 512)) {\r\n          perms += 'w';\r\n        }\r\n        return perms;\r\n      },nodePermissions:(node, perms) => {\r\n        if (FS.ignorePermissions) {\r\n          return 0;\r\n        }\r\n        // return 0 if any user, group or owner bits are set.\r\n        if (perms.includes('r') && !(node.mode & 292)) {\r\n          return 2;\r\n        } else if (perms.includes('w') && !(node.mode & 146)) {\r\n          return 2;\r\n        } else if (perms.includes('x') && !(node.mode & 73)) {\r\n          return 2;\r\n        }\r\n        return 0;\r\n      },mayLookup:(dir) => {\r\n        var errCode = FS.nodePermissions(dir, 'x');\r\n        if (errCode) return errCode;\r\n        if (!dir.node_ops.lookup) return 2;\r\n        return 0;\r\n      },mayCreate:(dir, name) => {\r\n        try {\r\n          var node = FS.lookupNode(dir, name);\r\n          return 20;\r\n        } catch (e) {\r\n        }\r\n        return FS.nodePermissions(dir, 'wx');\r\n      },mayDelete:(dir, name, isdir) => {\r\n        var node;\r\n        try {\r\n          node = FS.lookupNode(dir, name);\r\n        } catch (e) {\r\n          return e.errno;\r\n        }\r\n        var errCode = FS.nodePermissions(dir, 'wx');\r\n        if (errCode) {\r\n          return errCode;\r\n        }\r\n        if (isdir) {\r\n          if (!FS.isDir(node.mode)) {\r\n            return 54;\r\n          }\r\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n            return 10;\r\n          }\r\n        } else {\r\n          if (FS.isDir(node.mode)) {\r\n            return 31;\r\n          }\r\n        }\r\n        return 0;\r\n      },mayOpen:(node, flags) => {\r\n        if (!node) {\r\n          return 44;\r\n        }\r\n        if (FS.isLink(node.mode)) {\r\n          return 32;\r\n        } else if (FS.isDir(node.mode)) {\r\n          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\r\n              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\r\n            return 31;\r\n          }\r\n        }\r\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {\r\n        for (var fd = fd_start; fd <= fd_end; fd++) {\r\n          if (!FS.streams[fd]) {\r\n            return fd;\r\n          }\r\n        }\r\n        throw new FS.ErrnoError(33);\r\n      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {\r\n        if (!FS.FSStream) {\r\n          FS.FSStream = /** @constructor */ function() {\r\n            this.shared = { };\r\n          };\r\n          FS.FSStream.prototype = {\r\n            object: {\r\n              get: function() { return this.node; },\r\n              set: function(val) { this.node = val; }\r\n            },\r\n            isRead: {\r\n              get: function() { return (this.flags & 2097155) !== 1; }\r\n            },\r\n            isWrite: {\r\n              get: function() { return (this.flags & 2097155) !== 0; }\r\n            },\r\n            isAppend: {\r\n              get: function() { return (this.flags & 1024); }\r\n            },\r\n            flags: {\r\n              get: function() { return this.shared.flags; },\r\n              set: function(val) { this.shared.flags = val; },\r\n            },\r\n            position : {\r\n              get function() { return this.shared.position; },\r\n              set: function(val) { this.shared.position = val; },\r\n            },\r\n          };\r\n        }\r\n        // clone it, so we can return an instance of FSStream\r\n        stream = Object.assign(new FS.FSStream(), stream);\r\n        var fd = FS.nextfd(fd_start, fd_end);\r\n        stream.fd = fd;\r\n        FS.streams[fd] = stream;\r\n        return stream;\r\n      },closeStream:(fd) => {\r\n        FS.streams[fd] = null;\r\n      },chrdev_stream_ops:{open:(stream) => {\r\n          var device = FS.getDevice(stream.node.rdev);\r\n          // override node's stream ops with the device's\r\n          stream.stream_ops = device.stream_ops;\r\n          // forward the open call\r\n          if (stream.stream_ops.open) {\r\n            stream.stream_ops.open(stream);\r\n          }\r\n        },llseek:() => {\r\n          throw new FS.ErrnoError(70);\r\n        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {\r\n        FS.devices[dev] = { stream_ops: ops };\r\n      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {\r\n        var mounts = [];\r\n        var check = [mount];\r\n  \r\n        while (check.length) {\r\n          var m = check.pop();\r\n  \r\n          mounts.push(m);\r\n  \r\n          check.push.apply(check, m.mounts);\r\n        }\r\n  \r\n        return mounts;\r\n      },syncfs:(populate, callback) => {\r\n        if (typeof populate == 'function') {\r\n          callback = populate;\r\n          populate = false;\r\n        }\r\n  \r\n        FS.syncFSRequests++;\r\n  \r\n        if (FS.syncFSRequests > 1) {\r\n          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');\r\n        }\r\n  \r\n        var mounts = FS.getMounts(FS.root.mount);\r\n        var completed = 0;\r\n  \r\n        function doCallback(errCode) {\r\n          FS.syncFSRequests--;\r\n          return callback(errCode);\r\n        }\r\n  \r\n        function done(errCode) {\r\n          if (errCode) {\r\n            if (!done.errored) {\r\n              done.errored = true;\r\n              return doCallback(errCode);\r\n            }\r\n            return;\r\n          }\r\n          if (++completed >= mounts.length) {\r\n            doCallback(null);\r\n          }\r\n        };\r\n  \r\n        // sync all mounts\r\n        mounts.forEach((mount) => {\r\n          if (!mount.type.syncfs) {\r\n            return done(null);\r\n          }\r\n          mount.type.syncfs(mount, populate, done);\r\n        });\r\n      },mount:(type, opts, mountpoint) => {\r\n        var root = mountpoint === '/';\r\n        var pseudo = !mountpoint;\r\n        var node;\r\n  \r\n        if (root && FS.root) {\r\n          throw new FS.ErrnoError(10);\r\n        } else if (!root && !pseudo) {\r\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n          mountpoint = lookup.path;  // use the absolute path\r\n          node = lookup.node;\r\n  \r\n          if (FS.isMountpoint(node)) {\r\n            throw new FS.ErrnoError(10);\r\n          }\r\n  \r\n          if (!FS.isDir(node.mode)) {\r\n            throw new FS.ErrnoError(54);\r\n          }\r\n        }\r\n  \r\n        var mount = {\r\n          type: type,\r\n          opts: opts,\r\n          mountpoint: mountpoint,\r\n          mounts: []\r\n        };\r\n  \r\n        // create a root node for the fs\r\n        var mountRoot = type.mount(mount);\r\n        mountRoot.mount = mount;\r\n        mount.root = mountRoot;\r\n  \r\n        if (root) {\r\n          FS.root = mountRoot;\r\n        } else if (node) {\r\n          // set as a mountpoint\r\n          node.mounted = mount;\r\n  \r\n          // add the new mount to the current mount's children\r\n          if (node.mount) {\r\n            node.mount.mounts.push(mount);\r\n          }\r\n        }\r\n  \r\n        return mountRoot;\r\n      },unmount:(mountpoint) => {\r\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n        if (!FS.isMountpoint(lookup.node)) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n  \r\n        // destroy the nodes for this mount, and all its child mounts\r\n        var node = lookup.node;\r\n        var mount = node.mounted;\r\n        var mounts = FS.getMounts(mount);\r\n  \r\n        Object.keys(FS.nameTable).forEach((hash) => {\r\n          var current = FS.nameTable[hash];\r\n  \r\n          while (current) {\r\n            var next = current.name_next;\r\n  \r\n            if (mounts.includes(current.mount)) {\r\n              FS.destroyNode(current);\r\n            }\r\n  \r\n            current = next;\r\n          }\r\n        });\r\n  \r\n        // no longer a mountpoint\r\n        node.mounted = null;\r\n  \r\n        // remove this mount from the child mounts\r\n        var idx = node.mount.mounts.indexOf(mount);\r\n        node.mount.mounts.splice(idx, 1);\r\n      },lookup:(parent, name) => {\r\n        return parent.node_ops.lookup(parent, name);\r\n      },mknod:(path, mode, dev) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        if (!name || name === '.' || name === '..') {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var errCode = FS.mayCreate(parent, name);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.mknod) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return parent.node_ops.mknod(parent, name, mode, dev);\r\n      },create:(path, mode) => {\r\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\r\n        mode &= 4095;\r\n        mode |= 32768;\r\n        return FS.mknod(path, mode, 0);\r\n      },mkdir:(path, mode) => {\r\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\r\n        mode &= 511 | 512;\r\n        mode |= 16384;\r\n        return FS.mknod(path, mode, 0);\r\n      },mkdirTree:(path, mode) => {\r\n        var dirs = path.split('/');\r\n        var d = '';\r\n        for (var i = 0; i < dirs.length; ++i) {\r\n          if (!dirs[i]) continue;\r\n          d += '/' + dirs[i];\r\n          try {\r\n            FS.mkdir(d, mode);\r\n          } catch(e) {\r\n            if (e.errno != 20) throw e;\r\n          }\r\n        }\r\n      },mkdev:(path, mode, dev) => {\r\n        if (typeof dev == 'undefined') {\r\n          dev = mode;\r\n          mode = 438 /* 0666 */;\r\n        }\r\n        mode |= 8192;\r\n        return FS.mknod(path, mode, dev);\r\n      },symlink:(oldpath, newpath) => {\r\n        if (!PATH_FS.resolve(oldpath)) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var lookup = FS.lookupPath(newpath, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var newname = PATH.basename(newpath);\r\n        var errCode = FS.mayCreate(parent, newname);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.symlink) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return parent.node_ops.symlink(parent, newname, oldpath);\r\n      },rename:(old_path, new_path) => {\r\n        var old_dirname = PATH.dirname(old_path);\r\n        var new_dirname = PATH.dirname(new_path);\r\n        var old_name = PATH.basename(old_path);\r\n        var new_name = PATH.basename(new_path);\r\n        // parents must exist\r\n        var lookup, old_dir, new_dir;\r\n  \r\n        // let the errors from non existant directories percolate up\r\n        lookup = FS.lookupPath(old_path, { parent: true });\r\n        old_dir = lookup.node;\r\n        lookup = FS.lookupPath(new_path, { parent: true });\r\n        new_dir = lookup.node;\r\n  \r\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\r\n        // need to be part of the same mount\r\n        if (old_dir.mount !== new_dir.mount) {\r\n          throw new FS.ErrnoError(75);\r\n        }\r\n        // source must exist\r\n        var old_node = FS.lookupNode(old_dir, old_name);\r\n        // old path should not be an ancestor of the new path\r\n        var relative = PATH_FS.relative(old_path, new_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        // new path should not be an ancestor of the old path\r\n        relative = PATH_FS.relative(new_path, old_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(55);\r\n        }\r\n        // see if the new path already exists\r\n        var new_node;\r\n        try {\r\n          new_node = FS.lookupNode(new_dir, new_name);\r\n        } catch (e) {\r\n          // not fatal\r\n        }\r\n        // early out if nothing needs to change\r\n        if (old_node === new_node) {\r\n          return;\r\n        }\r\n        // we'll need to delete the old entry\r\n        var isdir = FS.isDir(old_node.mode);\r\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        // need delete permissions if we'll be overwriting.\r\n        // need create permissions if new doesn't already exist.\r\n        errCode = new_node ?\r\n          FS.mayDelete(new_dir, new_name, isdir) :\r\n          FS.mayCreate(new_dir, new_name);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!old_dir.node_ops.rename) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        // if we are going to change the parent, check write permissions\r\n        if (new_dir !== old_dir) {\r\n          errCode = FS.nodePermissions(old_dir, 'w');\r\n          if (errCode) {\r\n            throw new FS.ErrnoError(errCode);\r\n          }\r\n        }\r\n        // remove the node from the lookup hash\r\n        FS.hashRemoveNode(old_node);\r\n        // do the underlying fs rename\r\n        try {\r\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          // add the node back to the hash (in case node_ops.rename\r\n          // changed its name)\r\n          FS.hashAddNode(old_node);\r\n        }\r\n      },rmdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var errCode = FS.mayDelete(parent, name, true);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.rmdir) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        parent.node_ops.rmdir(parent, name);\r\n        FS.destroyNode(node);\r\n      },readdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        if (!node.node_ops.readdir) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        return node.node_ops.readdir(node);\r\n      },unlink:(path) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var errCode = FS.mayDelete(parent, name, false);\r\n        if (errCode) {\r\n          // According to POSIX, we should map EISDIR to EPERM, but\r\n          // we instead do what Linux does (and we must, as we use\r\n          // the musl linux libc).\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.unlink) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        parent.node_ops.unlink(parent, name);\r\n        FS.destroyNode(node);\r\n      },readlink:(path) => {\r\n        var lookup = FS.lookupPath(path);\r\n        var link = lookup.node;\r\n        if (!link) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!link.node_ops.readlink) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\r\n      },stat:(path, dontFollow) => {\r\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n        var node = lookup.node;\r\n        if (!node) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!node.node_ops.getattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return node.node_ops.getattr(node);\r\n      },lstat:(path) => {\r\n        return FS.stat(path, true);\r\n      },chmod:(path, mode, dontFollow) => {\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          mode: (mode & 4095) | (node.mode & ~4095),\r\n          timestamp: Date.now()\r\n        });\r\n      },lchmod:(path, mode) => {\r\n        FS.chmod(path, mode, true);\r\n      },fchmod:(fd, mode) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        FS.chmod(stream.node, mode);\r\n      },chown:(path, uid, gid, dontFollow) => {\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          timestamp: Date.now()\r\n          // we ignore the uid / gid for now\r\n        });\r\n      },lchown:(path, uid, gid) => {\r\n        FS.chown(path, uid, gid, true);\r\n      },fchown:(fd, uid, gid) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        FS.chown(stream.node, uid, gid);\r\n      },truncate:(path, len) => {\r\n        if (len < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: true });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!FS.isFile(node.mode)) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var errCode = FS.nodePermissions(node, 'w');\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          size: len,\r\n          timestamp: Date.now()\r\n        });\r\n      },ftruncate:(fd, len) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        FS.truncate(stream.node, len);\r\n      },utime:(path, atime, mtime) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        node.node_ops.setattr(node, {\r\n          timestamp: Math.max(atime, mtime)\r\n        });\r\n      },open:(path, flags, mode) => {\r\n        if (path === \"\") {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;\r\n        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\r\n        if ((flags & 64)) {\r\n          mode = (mode & 4095) | 32768;\r\n        } else {\r\n          mode = 0;\r\n        }\r\n        var node;\r\n        if (typeof path == 'object') {\r\n          node = path;\r\n        } else {\r\n          path = PATH.normalize(path);\r\n          try {\r\n            var lookup = FS.lookupPath(path, {\r\n              follow: !(flags & 131072)\r\n            });\r\n            node = lookup.node;\r\n          } catch (e) {\r\n            // ignore\r\n          }\r\n        }\r\n        // perhaps we need to create the node\r\n        var created = false;\r\n        if ((flags & 64)) {\r\n          if (node) {\r\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\r\n            if ((flags & 128)) {\r\n              throw new FS.ErrnoError(20);\r\n            }\r\n          } else {\r\n            // node doesn't exist, try to create it\r\n            node = FS.mknod(path, mode, 0);\r\n            created = true;\r\n          }\r\n        }\r\n        if (!node) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        // can't truncate a device\r\n        if (FS.isChrdev(node.mode)) {\r\n          flags &= ~512;\r\n        }\r\n        // if asked only for a directory, then this must be one\r\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        // check permissions, if this is not a file we just created now (it is ok to\r\n        // create and write to a file with read-only permissions; it is read-only\r\n        // for later use)\r\n        if (!created) {\r\n          var errCode = FS.mayOpen(node, flags);\r\n          if (errCode) {\r\n            throw new FS.ErrnoError(errCode);\r\n          }\r\n        }\r\n        // do truncation if necessary\r\n        if ((flags & 512) && !created) {\r\n          FS.truncate(node, 0);\r\n        }\r\n        // we've already handled these, don't pass down to the underlying vfs\r\n        flags &= ~(128 | 512 | 131072);\r\n  \r\n        // register the stream with the filesystem\r\n        var stream = FS.createStream({\r\n          node: node,\r\n          path: FS.getPath(node),  // we want the absolute path to the node\r\n          flags: flags,\r\n          seekable: true,\r\n          position: 0,\r\n          stream_ops: node.stream_ops,\r\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\r\n          ungotten: [],\r\n          error: false\r\n        });\r\n        // call the new stream's open function\r\n        if (stream.stream_ops.open) {\r\n          stream.stream_ops.open(stream);\r\n        }\r\n        if (Module['logReadFiles'] && !(flags & 1)) {\r\n          if (!FS.readFiles) FS.readFiles = {};\r\n          if (!(path in FS.readFiles)) {\r\n            FS.readFiles[path] = 1;\r\n          }\r\n        }\r\n        return stream;\r\n      },close:(stream) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (stream.getdents) stream.getdents = null; // free readdir state\r\n        try {\r\n          if (stream.stream_ops.close) {\r\n            stream.stream_ops.close(stream);\r\n          }\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          FS.closeStream(stream.fd);\r\n        }\r\n        stream.fd = null;\r\n      },isClosed:(stream) => {\r\n        return stream.fd === null;\r\n      },llseek:(stream, offset, whence) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (!stream.seekable || !stream.stream_ops.llseek) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        if (whence != 0 && whence != 1 && whence != 2) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n        stream.ungotten = [];\r\n        return stream.position;\r\n      },read:(stream, buffer, offset, length, position) => {\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!stream.stream_ops.read) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var seeking = typeof position != 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n        if (!seeking) stream.position += bytesRead;\r\n        return bytesRead;\r\n      },write:(stream, buffer, offset, length, position, canOwn) => {\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!stream.stream_ops.write) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (stream.seekable && stream.flags & 1024) {\r\n          // seek to the end before writing in append mode\r\n          FS.llseek(stream, 0, 2);\r\n        }\r\n        var seeking = typeof position != 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n        if (!seeking) stream.position += bytesWritten;\r\n        return bytesWritten;\r\n      },allocate:(stream, offset, length) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (offset < 0 || length <= 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        if (!stream.stream_ops.allocate) {\r\n          throw new FS.ErrnoError(138);\r\n        }\r\n        stream.stream_ops.allocate(stream, offset, length);\r\n      },mmap:(stream, length, position, prot, flags) => {\r\n        // User requests writing to file (prot & PROT_WRITE != 0).\r\n        // Checking if we have permissions to write to the file unless\r\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\r\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\r\n        // as all modifications will be visible only in the memory of\r\n        // the current process.\r\n        if ((prot & 2) !== 0\r\n            && (flags & 2) === 0\r\n            && (stream.flags & 2097155) !== 2) {\r\n          throw new FS.ErrnoError(2);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(2);\r\n        }\r\n        if (!stream.stream_ops.mmap) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\r\n      },msync:(stream, buffer, offset, length, mmapFlags) => {\r\n        if (!stream || !stream.stream_ops.msync) {\r\n          return 0;\r\n        }\r\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {\r\n        if (!stream.stream_ops.ioctl) {\r\n          throw new FS.ErrnoError(59);\r\n        }\r\n        return stream.stream_ops.ioctl(stream, cmd, arg);\r\n      },readFile:(path, opts = {}) => {\r\n        opts.flags = opts.flags || 0;\r\n        opts.encoding = opts.encoding || 'binary';\r\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\r\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\r\n        }\r\n        var ret;\r\n        var stream = FS.open(path, opts.flags);\r\n        var stat = FS.stat(path);\r\n        var length = stat.size;\r\n        var buf = new Uint8Array(length);\r\n        FS.read(stream, buf, 0, length, 0);\r\n        if (opts.encoding === 'utf8') {\r\n          ret = UTF8ArrayToString(buf, 0);\r\n        } else if (opts.encoding === 'binary') {\r\n          ret = buf;\r\n        }\r\n        FS.close(stream);\r\n        return ret;\r\n      },writeFile:(path, data, opts = {}) => {\r\n        opts.flags = opts.flags || 577;\r\n        var stream = FS.open(path, opts.flags, opts.mode);\r\n        if (typeof data == 'string') {\r\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\r\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n        } else if (ArrayBuffer.isView(data)) {\r\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n        } else {\r\n          throw new Error('Unsupported data type');\r\n        }\r\n        FS.close(stream);\r\n      },cwd:() => FS.currentPath,chdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        if (lookup.node === null) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!FS.isDir(lookup.node.mode)) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        var errCode = FS.nodePermissions(lookup.node, 'x');\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        FS.currentPath = lookup.path;\r\n      },createDefaultDirectories:() => {\r\n        FS.mkdir('/tmp');\r\n        FS.mkdir('/home');\r\n        FS.mkdir('/home/web_user');\r\n      },createDefaultDevices:() => {\r\n        // create /dev\r\n        FS.mkdir('/dev');\r\n        // setup /dev/null\r\n        FS.registerDevice(FS.makedev(1, 3), {\r\n          read: () => 0,\r\n          write: (stream, buffer, offset, length, pos) => length,\r\n        });\r\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\r\n        // setup /dev/tty and /dev/tty1\r\n        // stderr needs to print output using err() rather than out()\r\n        // so we register a second tty just for it.\r\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\r\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\r\n        // setup /dev/[u]random\r\n        var random_device = getRandomDevice();\r\n        FS.createDevice('/dev', 'random', random_device);\r\n        FS.createDevice('/dev', 'urandom', random_device);\r\n        // we're not going to emulate the actual shm device,\r\n        // just create the tmp dirs that reside in it commonly\r\n        FS.mkdir('/dev/shm');\r\n        FS.mkdir('/dev/shm/tmp');\r\n      },createSpecialDirectories:() => {\r\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\r\n        // name of the stream for fd 6 (see test_unistd_ttyname)\r\n        FS.mkdir('/proc');\r\n        var proc_self = FS.mkdir('/proc/self');\r\n        FS.mkdir('/proc/self/fd');\r\n        FS.mount({\r\n          mount: () => {\r\n            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\r\n            node.node_ops = {\r\n              lookup: (parent, name) => {\r\n                var fd = +name;\r\n                var stream = FS.getStream(fd);\r\n                if (!stream) throw new FS.ErrnoError(8);\r\n                var ret = {\r\n                  parent: null,\r\n                  mount: { mountpoint: 'fake' },\r\n                  node_ops: { readlink: () => stream.path },\r\n                };\r\n                ret.parent = ret; // make it look like a simple root node\r\n                return ret;\r\n              }\r\n            };\r\n            return node;\r\n          }\r\n        }, {}, '/proc/self/fd');\r\n      },createStandardStreams:() => {\r\n        // TODO deprecate the old functionality of a single\r\n        // input / output callback and that utilizes FS.createDevice\r\n        // and instead require a unique set of stream ops\r\n  \r\n        // by default, we symlink the standard streams to the\r\n        // default tty devices. however, if the standard streams\r\n        // have been overwritten we create a unique device for\r\n        // them instead.\r\n        if (Module['stdin']) {\r\n          FS.createDevice('/dev', 'stdin', Module['stdin']);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdin');\r\n        }\r\n        if (Module['stdout']) {\r\n          FS.createDevice('/dev', 'stdout', null, Module['stdout']);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdout');\r\n        }\r\n        if (Module['stderr']) {\r\n          FS.createDevice('/dev', 'stderr', null, Module['stderr']);\r\n        } else {\r\n          FS.symlink('/dev/tty1', '/dev/stderr');\r\n        }\r\n  \r\n        // open default streams for the stdin, stdout and stderr devices\r\n        var stdin = FS.open('/dev/stdin', 0);\r\n        var stdout = FS.open('/dev/stdout', 1);\r\n        var stderr = FS.open('/dev/stderr', 1);\r\n      },ensureErrnoError:() => {\r\n        if (FS.ErrnoError) return;\r\n        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {\r\n          this.node = node;\r\n          this.setErrno = /** @this{Object} */ function(errno) {\r\n            this.errno = errno;\r\n          };\r\n          this.setErrno(errno);\r\n          this.message = 'FS error';\r\n  \r\n        };\r\n        FS.ErrnoError.prototype = new Error();\r\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\r\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\r\n        [44].forEach((code) => {\r\n          FS.genericErrors[code] = new FS.ErrnoError(code);\r\n          FS.genericErrors[code].stack = '<generic error, no stack>';\r\n        });\r\n      },staticInit:() => {\r\n        FS.ensureErrnoError();\r\n  \r\n        FS.nameTable = new Array(4096);\r\n  \r\n        FS.mount(MEMFS, {}, '/');\r\n  \r\n        FS.createDefaultDirectories();\r\n        FS.createDefaultDevices();\r\n        FS.createSpecialDirectories();\r\n  \r\n        FS.filesystems = {\r\n          'MEMFS': MEMFS,\r\n        };\r\n      },init:(input, output, error) => {\r\n        FS.init.initialized = true;\r\n  \r\n        FS.ensureErrnoError();\r\n  \r\n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\r\n        Module['stdin'] = input || Module['stdin'];\r\n        Module['stdout'] = output || Module['stdout'];\r\n        Module['stderr'] = error || Module['stderr'];\r\n  \r\n        FS.createStandardStreams();\r\n      },quit:() => {\r\n        FS.init.initialized = false;\r\n        // Call musl-internal function to close all stdio streams, so nothing is\r\n        // left in internal buffers.\r\n        // close all of our streams\r\n        for (var i = 0; i < FS.streams.length; i++) {\r\n          var stream = FS.streams[i];\r\n          if (!stream) {\r\n            continue;\r\n          }\r\n          FS.close(stream);\r\n        }\r\n      },getMode:(canRead, canWrite) => {\r\n        var mode = 0;\r\n        if (canRead) mode |= 292 | 73;\r\n        if (canWrite) mode |= 146;\r\n        return mode;\r\n      },findObject:(path, dontResolveLastLink) => {\r\n        var ret = FS.analyzePath(path, dontResolveLastLink);\r\n        if (ret.exists) {\r\n          return ret.object;\r\n        } else {\r\n          return null;\r\n        }\r\n      },analyzePath:(path, dontResolveLastLink) => {\r\n        // operate from within the context of the symlink's target\r\n        try {\r\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          path = lookup.path;\r\n        } catch (e) {\r\n        }\r\n        var ret = {\r\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\r\n          parentExists: false, parentPath: null, parentObject: null\r\n        };\r\n        try {\r\n          var lookup = FS.lookupPath(path, { parent: true });\r\n          ret.parentExists = true;\r\n          ret.parentPath = lookup.path;\r\n          ret.parentObject = lookup.node;\r\n          ret.name = PATH.basename(path);\r\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          ret.exists = true;\r\n          ret.path = lookup.path;\r\n          ret.object = lookup.node;\r\n          ret.name = lookup.node.name;\r\n          ret.isRoot = lookup.path === '/';\r\n        } catch (e) {\r\n          ret.error = e.errno;\r\n        };\r\n        return ret;\r\n      },createPath:(parent, path, canRead, canWrite) => {\r\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n        var parts = path.split('/').reverse();\r\n        while (parts.length) {\r\n          var part = parts.pop();\r\n          if (!part) continue;\r\n          var current = PATH.join2(parent, part);\r\n          try {\r\n            FS.mkdir(current);\r\n          } catch (e) {\r\n            // ignore EEXIST\r\n          }\r\n          parent = current;\r\n        }\r\n        return current;\r\n      },createFile:(parent, name, properties, canRead, canWrite) => {\r\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS.getMode(canRead, canWrite);\r\n        return FS.create(path, mode);\r\n      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {\r\n        var path = name;\r\n        if (parent) {\r\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n          path = name ? PATH.join2(parent, name) : parent;\r\n        }\r\n        var mode = FS.getMode(canRead, canWrite);\r\n        var node = FS.create(path, mode);\r\n        if (data) {\r\n          if (typeof data == 'string') {\r\n            var arr = new Array(data.length);\r\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n            data = arr;\r\n          }\r\n          // make sure we can write to the file\r\n          FS.chmod(node, mode | 146);\r\n          var stream = FS.open(node, 577);\r\n          FS.write(stream, data, 0, data.length, 0, canOwn);\r\n          FS.close(stream);\r\n          FS.chmod(node, mode);\r\n        }\r\n        return node;\r\n      },createDevice:(parent, name, input, output) => {\r\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS.getMode(!!input, !!output);\r\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\r\n        var dev = FS.makedev(FS.createDevice.major++, 0);\r\n        // Create a fake device that a set of stream ops to emulate\r\n        // the old behavior.\r\n        FS.registerDevice(dev, {\r\n          open: (stream) => {\r\n            stream.seekable = false;\r\n          },\r\n          close: (stream) => {\r\n            // flush any pending line data\r\n            if (output && output.buffer && output.buffer.length) {\r\n              output(10);\r\n            }\r\n          },\r\n          read: (stream, buffer, offset, length, pos /* ignored */) => {\r\n            var bytesRead = 0;\r\n            for (var i = 0; i < length; i++) {\r\n              var result;\r\n              try {\r\n                result = input();\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(29);\r\n              }\r\n              if (result === undefined && bytesRead === 0) {\r\n                throw new FS.ErrnoError(6);\r\n              }\r\n              if (result === null || result === undefined) break;\r\n              bytesRead++;\r\n              buffer[offset+i] = result;\r\n            }\r\n            if (bytesRead) {\r\n              stream.node.timestamp = Date.now();\r\n            }\r\n            return bytesRead;\r\n          },\r\n          write: (stream, buffer, offset, length, pos) => {\r\n            for (var i = 0; i < length; i++) {\r\n              try {\r\n                output(buffer[offset+i]);\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(29);\r\n              }\r\n            }\r\n            if (length) {\r\n              stream.node.timestamp = Date.now();\r\n            }\r\n            return i;\r\n          }\r\n        });\r\n        return FS.mkdev(path, mode, dev);\r\n      },forceLoadFile:(obj) => {\r\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n        if (typeof XMLHttpRequest != 'undefined') {\r\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\r\n        } else if (read_) {\r\n          // Command-line.\r\n          try {\r\n            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\r\n            //          read() will try to parse UTF8.\r\n            obj.contents = intArrayFromString(read_(obj.url), true);\r\n            obj.usedBytes = obj.contents.length;\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n        } else {\r\n          throw new Error('Cannot load without read() or XMLHttpRequest.');\r\n        }\r\n      },createLazyFile:(parent, name, url, canRead, canWrite) => {\r\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\r\n        /** @constructor */\r\n        function LazyUint8Array() {\r\n          this.lengthKnown = false;\r\n          this.chunks = []; // Loaded chunks. Index is the chunk number\r\n        }\r\n        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {\r\n          if (idx > this.length-1 || idx < 0) {\r\n            return undefined;\r\n          }\r\n          var chunkOffset = idx % this.chunkSize;\r\n          var chunkNum = (idx / this.chunkSize)|0;\r\n          return this.getter(chunkNum)[chunkOffset];\r\n        };\r\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\r\n          this.getter = getter;\r\n        };\r\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\r\n          // Find length\r\n          var xhr = new XMLHttpRequest();\r\n          xhr.open('HEAD', url, false);\r\n          xhr.send(null);\r\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n          var header;\r\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n  \r\n          var chunkSize = 1024*1024; // Chunk size in bytes\r\n  \r\n          if (!hasByteServing) chunkSize = datalength;\r\n  \r\n          // Function to get a range from the remote URL.\r\n          var doXHR = (from, to) => {\r\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n            if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n  \r\n            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.open('GET', url, false);\r\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n  \r\n            // Some hints to the browser that we want binary data.\r\n            xhr.responseType = 'arraybuffer';\r\n            if (xhr.overrideMimeType) {\r\n              xhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n            }\r\n  \r\n            xhr.send(null);\r\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n            if (xhr.response !== undefined) {\r\n              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));\r\n            } else {\r\n              return intArrayFromString(xhr.responseText || '', true);\r\n            }\r\n          };\r\n          var lazyArray = this;\r\n          lazyArray.setDataGetter((chunkNum) => {\r\n            var start = chunkNum * chunkSize;\r\n            var end = (chunkNum+1) * chunkSize - 1; // including this byte\r\n            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\r\n            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\r\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\r\n            }\r\n            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');\r\n            return lazyArray.chunks[chunkNum];\r\n          });\r\n  \r\n          if (usesGzip || !datalength) {\r\n            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\r\n            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\r\n            datalength = this.getter(0).length;\r\n            chunkSize = datalength;\r\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\r\n          }\r\n  \r\n          this._length = datalength;\r\n          this._chunkSize = chunkSize;\r\n          this.lengthKnown = true;\r\n        };\r\n        if (typeof XMLHttpRequest != 'undefined') {\r\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\r\n          var lazyArray = new LazyUint8Array();\r\n          Object.defineProperties(lazyArray, {\r\n            length: {\r\n              get: /** @this{Object} */ function() {\r\n                if (!this.lengthKnown) {\r\n                  this.cacheLength();\r\n                }\r\n                return this._length;\r\n              }\r\n            },\r\n            chunkSize: {\r\n              get: /** @this{Object} */ function() {\r\n                if (!this.lengthKnown) {\r\n                  this.cacheLength();\r\n                }\r\n                return this._chunkSize;\r\n              }\r\n            }\r\n          });\r\n  \r\n          var properties = { isDevice: false, contents: lazyArray };\r\n        } else {\r\n          var properties = { isDevice: false, url: url };\r\n        }\r\n  \r\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n        // This is a total hack, but I want to get this lazy file code out of the\r\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\r\n        // be its own thin LAZYFS proxying calls to MEMFS.\r\n        if (properties.contents) {\r\n          node.contents = properties.contents;\r\n        } else if (properties.url) {\r\n          node.contents = null;\r\n          node.url = properties.url;\r\n        }\r\n        // Add a function that defers querying the file size until it is asked the first time.\r\n        Object.defineProperties(node, {\r\n          usedBytes: {\r\n            get: /** @this {FSNode} */ function() { return this.contents.length; }\r\n          }\r\n        });\r\n        // override each stream op with one that tries to force load the lazy file first\r\n        var stream_ops = {};\r\n        var keys = Object.keys(node.stream_ops);\r\n        keys.forEach((key) => {\r\n          var fn = node.stream_ops[key];\r\n          stream_ops[key] = function forceLoadLazyFile() {\r\n            FS.forceLoadFile(node);\r\n            return fn.apply(null, arguments);\r\n          };\r\n        });\r\n        // use a custom read function\r\n        stream_ops.read = (stream, buffer, offset, length, position) => {\r\n          FS.forceLoadFile(node);\r\n          var contents = stream.node.contents;\r\n          if (position >= contents.length)\r\n            return 0;\r\n          var size = Math.min(contents.length - position, length);\r\n          if (contents.slice) { // normal array\r\n            for (var i = 0; i < size; i++) {\r\n              buffer[offset + i] = contents[position + i];\r\n            }\r\n          } else {\r\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\r\n              buffer[offset + i] = contents.get(position + i);\r\n            }\r\n          }\r\n          return size;\r\n        };\r\n        node.stream_ops = stream_ops;\r\n        return node;\r\n      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\r\n        // TODO we should allow people to just pass in a complete filename instead\r\n        // of parent and name being that we just join them anyways\r\n        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\r\n        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname\r\n        function processData(byteArray) {\r\n          function finish(byteArray) {\r\n            if (preFinish) preFinish();\r\n            if (!dontCreateFile) {\r\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n            }\r\n            if (onload) onload();\r\n            removeRunDependency(dep);\r\n          }\r\n          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {\r\n            if (onerror) onerror();\r\n            removeRunDependency(dep);\r\n          })) {\r\n            return;\r\n          }\r\n          finish(byteArray);\r\n        }\r\n        addRunDependency(dep);\r\n        if (typeof url == 'string') {\r\n          asyncLoad(url, (byteArray) => processData(byteArray), onerror);\r\n        } else {\r\n          processData(url);\r\n        }\r\n      },indexedDB:() => {\r\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n      },DB_NAME:() => {\r\n        return 'EM_FS_' + window.location.pathname;\r\n      },DB_VERSION:20,DB_STORE_NAME:\"FILE_DATA\",saveFilesToDB:(paths, onload, onerror) => {\r\n        onload = onload || (() => {});\r\n        onerror = onerror || (() => {});\r\n        var indexedDB = FS.indexedDB();\r\n        try {\r\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n        } catch (e) {\r\n          return onerror(e);\r\n        }\r\n        openRequest.onupgradeneeded = () => {\r\n          out('creating db');\r\n          var db = openRequest.result;\r\n          db.createObjectStore(FS.DB_STORE_NAME);\r\n        };\r\n        openRequest.onsuccess = () => {\r\n          var db = openRequest.result;\r\n          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');\r\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n          var ok = 0, fail = 0, total = paths.length;\r\n          function finish() {\r\n            if (fail == 0) onload(); else onerror();\r\n          }\r\n          paths.forEach((path) => {\r\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\r\n            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };\r\n            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };\r\n          });\r\n          transaction.onerror = onerror;\r\n        };\r\n        openRequest.onerror = onerror;\r\n      },loadFilesFromDB:(paths, onload, onerror) => {\r\n        onload = onload || (() => {});\r\n        onerror = onerror || (() => {});\r\n        var indexedDB = FS.indexedDB();\r\n        try {\r\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n        } catch (e) {\r\n          return onerror(e);\r\n        }\r\n        openRequest.onupgradeneeded = onerror; // no database to load from\r\n        openRequest.onsuccess = () => {\r\n          var db = openRequest.result;\r\n          try {\r\n            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');\r\n          } catch(e) {\r\n            onerror(e);\r\n            return;\r\n          }\r\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n          var ok = 0, fail = 0, total = paths.length;\r\n          function finish() {\r\n            if (fail == 0) onload(); else onerror();\r\n          }\r\n          paths.forEach((path) => {\r\n            var getRequest = files.get(path);\r\n            getRequest.onsuccess = () => {\r\n              if (FS.analyzePath(path).exists) {\r\n                FS.unlink(path);\r\n              }\r\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\r\n              ok++;\r\n              if (ok + fail == total) finish();\r\n            };\r\n            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };\r\n          });\r\n          transaction.onerror = onerror;\r\n        };\r\n        openRequest.onerror = onerror;\r\n      }};\r\n  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {\r\n        if (PATH.isAbs(path)) {\r\n          return path;\r\n        }\r\n        // relative path\r\n        var dir;\r\n        if (dirfd === -100) {\r\n          dir = FS.cwd();\r\n        } else {\r\n          var dirstream = FS.getStream(dirfd);\r\n          if (!dirstream) throw new FS.ErrnoError(8);\r\n          dir = dirstream.path;\r\n        }\r\n        if (path.length == 0) {\r\n          if (!allowEmpty) {\r\n            throw new FS.ErrnoError(44);;\r\n          }\r\n          return dir;\r\n        }\r\n        return PATH.join2(dir, path);\r\n      },doStat:function(func, path, buf) {\r\n        try {\r\n          var stat = func(path);\r\n        } catch (e) {\r\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\r\n            // an error occurred while trying to look up the path; we should just report ENOTDIR\r\n            return -54;\r\n          }\r\n          throw e;\r\n        }\r\n        HEAP32[((buf)>>2)] = stat.dev;\r\n        HEAP32[(((buf)+(4))>>2)] = 0;\r\n        HEAP32[(((buf)+(8))>>2)] = stat.ino;\r\n        HEAP32[(((buf)+(12))>>2)] = stat.mode;\r\n        HEAP32[(((buf)+(16))>>2)] = stat.nlink;\r\n        HEAP32[(((buf)+(20))>>2)] = stat.uid;\r\n        HEAP32[(((buf)+(24))>>2)] = stat.gid;\r\n        HEAP32[(((buf)+(28))>>2)] = stat.rdev;\r\n        HEAP32[(((buf)+(32))>>2)] = 0;\r\n        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);\r\n        HEAP32[(((buf)+(48))>>2)] = 4096;\r\n        HEAP32[(((buf)+(52))>>2)] = stat.blocks;\r\n        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(60))>>2)] = 0;\r\n        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(68))>>2)] = 0;\r\n        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(76))>>2)] = 0;\r\n        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);\r\n        return 0;\r\n      },doMsync:function(addr, stream, len, flags, offset) {\r\n        var buffer = HEAPU8.slice(addr, addr + len);\r\n        FS.msync(stream, buffer, offset, len, flags);\r\n      },varargs:undefined,get:function() {\r\n        SYSCALLS.varargs += 4;\r\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\r\n        return ret;\r\n      },getStr:function(ptr) {\r\n        var ret = UTF8ToString(ptr);\r\n        return ret;\r\n      },getStreamFromFD:function(fd) {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) throw new FS.ErrnoError(8);\r\n        return stream;\r\n      }};\r\n  function _environ_get(__environ, environ_buf) {\r\n      var bufSize = 0;\r\n      getEnvStrings().forEach(function(string, i) {\r\n        var ptr = environ_buf + bufSize;\r\n        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;\r\n        writeAsciiToMemory(string, ptr);\r\n        bufSize += string.length + 1;\r\n      });\r\n      return 0;\r\n    }\r\n\r\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\r\n      var strings = getEnvStrings();\r\n      HEAPU32[((penviron_count)>>2)] = strings.length;\r\n      var bufSize = 0;\r\n      strings.forEach(function(string) {\r\n        bufSize += string.length + 1;\r\n      });\r\n      HEAPU32[((penviron_buf_size)>>2)] = bufSize;\r\n      return 0;\r\n    }\r\n\r\n  function _fd_close(fd) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      FS.close(stream);\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  /** @param {number=} offset */\r\n  function doReadv(stream, iov, iovcnt, offset) {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        var curr = FS.read(stream, HEAP8,ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr;\r\n        if (curr < len) break; // nothing more to read\r\n      }\r\n      return ret;\r\n    }\r\n  function _fd_read(fd, iov, iovcnt, pnum) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      var num = doReadv(stream, iov, iovcnt);\r\n      HEAP32[((pnum)>>2)] = num;\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  function convertI32PairToI53Checked(lo, hi) {\r\n      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\r\n    }\r\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\r\n  try {\r\n  \r\n      var offset = convertI32PairToI53Checked(offset_low, offset_high); if (isNaN(offset)) return 61;\r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      FS.llseek(stream, offset, whence);\r\n      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);\r\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  /** @param {number=} offset */\r\n  function doWritev(stream, iov, iovcnt, offset) {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        var curr = FS.write(stream, HEAP8,ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr;\r\n      }\r\n      return ret;\r\n    }\r\n  function _fd_write(fd, iov, iovcnt, pnum) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      var num = doWritev(stream, iov, iovcnt);\r\n      HEAPU32[((pnum)>>2)] = num;\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  function _setTempRet0(val) {\r\n      setTempRet0(val);\r\n    }\r\n\r\n  function __isLeapYear(year) {\r\n        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);\r\n    }\r\n  \r\n  function __arraySum(array, index) {\r\n      var sum = 0;\r\n      for (var i = 0; i <= index; sum += array[i++]) {\r\n        // no-op\r\n      }\r\n      return sum;\r\n    }\r\n  \r\n  var __MONTH_DAYS_LEAP = [31,29,31,30,31,30,31,31,30,31,30,31];\r\n  \r\n  var __MONTH_DAYS_REGULAR = [31,28,31,30,31,30,31,31,30,31,30,31];\r\n  function __addDays(date, days) {\r\n      var newDate = new Date(date.getTime());\r\n      while (days > 0) {\r\n        var leap = __isLeapYear(newDate.getFullYear());\r\n        var currentMonth = newDate.getMonth();\r\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\r\n  \r\n        if (days > daysInCurrentMonth-newDate.getDate()) {\r\n          // we spill over to next month\r\n          days -= (daysInCurrentMonth-newDate.getDate()+1);\r\n          newDate.setDate(1);\r\n          if (currentMonth < 11) {\r\n            newDate.setMonth(currentMonth+1)\r\n          } else {\r\n            newDate.setMonth(0);\r\n            newDate.setFullYear(newDate.getFullYear()+1);\r\n          }\r\n        } else {\r\n          // we stay in current month\r\n          newDate.setDate(newDate.getDate()+days);\r\n          return newDate;\r\n        }\r\n      }\r\n  \r\n      return newDate;\r\n    }\r\n  function _strftime(s, maxsize, format, tm) {\r\n      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);\r\n      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html\r\n  \r\n      var tm_zone = HEAP32[(((tm)+(40))>>2)];\r\n  \r\n      var date = {\r\n        tm_sec: HEAP32[((tm)>>2)],\r\n        tm_min: HEAP32[(((tm)+(4))>>2)],\r\n        tm_hour: HEAP32[(((tm)+(8))>>2)],\r\n        tm_mday: HEAP32[(((tm)+(12))>>2)],\r\n        tm_mon: HEAP32[(((tm)+(16))>>2)],\r\n        tm_year: HEAP32[(((tm)+(20))>>2)],\r\n        tm_wday: HEAP32[(((tm)+(24))>>2)],\r\n        tm_yday: HEAP32[(((tm)+(28))>>2)],\r\n        tm_isdst: HEAP32[(((tm)+(32))>>2)],\r\n        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],\r\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''\r\n      };\r\n  \r\n      var pattern = UTF8ToString(format);\r\n  \r\n      // expand format\r\n      var EXPANSION_RULES_1 = {\r\n        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013\r\n        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y\r\n        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d\r\n        '%h': '%b',                       // Equivalent to %b\r\n        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation\r\n        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation\r\n        '%T': '%H:%M:%S',                 // Replaced by the time\r\n        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation\r\n        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation\r\n        // Modified Conversion Specifiers\r\n        '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.\r\n        '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.\r\n        '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.\r\n        '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.\r\n        '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.\r\n        '%EY': '%Y',                      // Replaced by the full alternative year representation.\r\n        '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.\r\n        '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.\r\n        '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.\r\n        '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.\r\n        '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.\r\n        '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.\r\n        '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.\r\n        '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).\r\n        '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.\r\n        '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.\r\n        '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.\r\n        '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.\r\n        '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.\r\n      };\r\n      for (var rule in EXPANSION_RULES_1) {\r\n        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);\r\n      }\r\n  \r\n      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\r\n      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\r\n  \r\n      function leadingSomething(value, digits, character) {\r\n        var str = typeof value == 'number' ? value.toString() : (value || '');\r\n        while (str.length < digits) {\r\n          str = character[0]+str;\r\n        }\r\n        return str;\r\n      }\r\n  \r\n      function leadingNulls(value, digits) {\r\n        return leadingSomething(value, digits, '0');\r\n      }\r\n  \r\n      function compareByDay(date1, date2) {\r\n        function sgn(value) {\r\n          return value < 0 ? -1 : (value > 0 ? 1 : 0);\r\n        }\r\n  \r\n        var compare;\r\n        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {\r\n          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {\r\n            compare = sgn(date1.getDate()-date2.getDate());\r\n          }\r\n        }\r\n        return compare;\r\n      }\r\n  \r\n      function getFirstWeekStartDate(janFourth) {\r\n          switch (janFourth.getDay()) {\r\n            case 0: // Sunday\r\n              return new Date(janFourth.getFullYear()-1, 11, 29);\r\n            case 1: // Monday\r\n              return janFourth;\r\n            case 2: // Tuesday\r\n              return new Date(janFourth.getFullYear(), 0, 3);\r\n            case 3: // Wednesday\r\n              return new Date(janFourth.getFullYear(), 0, 2);\r\n            case 4: // Thursday\r\n              return new Date(janFourth.getFullYear(), 0, 1);\r\n            case 5: // Friday\r\n              return new Date(janFourth.getFullYear()-1, 11, 31);\r\n            case 6: // Saturday\r\n              return new Date(janFourth.getFullYear()-1, 11, 30);\r\n          }\r\n      }\r\n  \r\n      function getWeekBasedYear(date) {\r\n          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);\r\n  \r\n          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\r\n          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);\r\n  \r\n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\r\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\r\n  \r\n          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\r\n            // this date is after the start of the first week of this year\r\n            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\r\n              return thisDate.getFullYear()+1;\r\n            } else {\r\n              return thisDate.getFullYear();\r\n            }\r\n          } else {\r\n            return thisDate.getFullYear()-1;\r\n          }\r\n      }\r\n  \r\n      var EXPANSION_RULES_2 = {\r\n        '%a': function(date) {\r\n          return WEEKDAYS[date.tm_wday].substring(0,3);\r\n        },\r\n        '%A': function(date) {\r\n          return WEEKDAYS[date.tm_wday];\r\n        },\r\n        '%b': function(date) {\r\n          return MONTHS[date.tm_mon].substring(0,3);\r\n        },\r\n        '%B': function(date) {\r\n          return MONTHS[date.tm_mon];\r\n        },\r\n        '%C': function(date) {\r\n          var year = date.tm_year+1900;\r\n          return leadingNulls((year/100)|0,2);\r\n        },\r\n        '%d': function(date) {\r\n          return leadingNulls(date.tm_mday, 2);\r\n        },\r\n        '%e': function(date) {\r\n          return leadingSomething(date.tm_mday, 2, ' ');\r\n        },\r\n        '%g': function(date) {\r\n          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.\r\n          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes\r\n          // January 4th, which is also the week that includes the first Thursday of the year, and\r\n          // is also the first week that contains at least four days in the year.\r\n          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of\r\n          // the last week of the preceding year; thus, for Saturday 2nd January 1999,\r\n          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,\r\n          // or 31st is a Monday, it and any following days are part of week 1 of the following year.\r\n          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.\r\n  \r\n          return getWeekBasedYear(date).toString().substring(2);\r\n        },\r\n        '%G': function(date) {\r\n          return getWeekBasedYear(date);\r\n        },\r\n        '%H': function(date) {\r\n          return leadingNulls(date.tm_hour, 2);\r\n        },\r\n        '%I': function(date) {\r\n          var twelveHour = date.tm_hour;\r\n          if (twelveHour == 0) twelveHour = 12;\r\n          else if (twelveHour > 12) twelveHour -= 12;\r\n          return leadingNulls(twelveHour, 2);\r\n        },\r\n        '%j': function(date) {\r\n          // Day of the year (001-366)\r\n          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);\r\n        },\r\n        '%m': function(date) {\r\n          return leadingNulls(date.tm_mon+1, 2);\r\n        },\r\n        '%M': function(date) {\r\n          return leadingNulls(date.tm_min, 2);\r\n        },\r\n        '%n': function() {\r\n          return '\\n';\r\n        },\r\n        '%p': function(date) {\r\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\r\n            return 'AM';\r\n          } else {\r\n            return 'PM';\r\n          }\r\n        },\r\n        '%S': function(date) {\r\n          return leadingNulls(date.tm_sec, 2);\r\n        },\r\n        '%t': function() {\r\n          return '\\t';\r\n        },\r\n        '%u': function(date) {\r\n          return date.tm_wday || 7;\r\n        },\r\n        '%U': function(date) {\r\n          var days = date.tm_yday + 7 - date.tm_wday;\r\n          return leadingNulls(Math.floor(days / 7), 2);\r\n        },\r\n        '%V': function(date) {\r\n          // Replaced by the week number of the year (Monday as the first day of the week)\r\n          // as a decimal number [01,53]. If the week containing 1 January has four\r\n          // or more days in the new year, then it is considered week 1.\r\n          // Otherwise, it is the last week of the previous year, and the next week is week 1.\r\n          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]\r\n          var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7 ) / 7);\r\n          // If 1 Jan is just 1-3 days past Monday, the previous week\r\n          // is also in this year.\r\n          if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\r\n            val++;\r\n          }\r\n          if (!val) {\r\n            val = 52;\r\n            // If 31 December of prev year a Thursday, or Friday of a\r\n            // leap year, then the prev year has 53 weeks.\r\n            var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\r\n            if (dec31 == 4 || (dec31 == 5 && __isLeapYear(date.tm_year%400-1))) {\r\n              val++;\r\n            }\r\n          } else if (val == 53) {\r\n            // If 1 January is not a Thursday, and not a Wednesday of a\r\n            // leap year, then this year has only 52 weeks.\r\n            var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\r\n            if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year)))\r\n              val = 1;\r\n          }\r\n          return leadingNulls(val, 2);\r\n        },\r\n        '%w': function(date) {\r\n          return date.tm_wday;\r\n        },\r\n        '%W': function(date) {\r\n          var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\r\n          return leadingNulls(Math.floor(days / 7), 2);\r\n        },\r\n        '%y': function(date) {\r\n          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]\r\n          return (date.tm_year+1900).toString().substring(2);\r\n        },\r\n        '%Y': function(date) {\r\n          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]\r\n          return date.tm_year+1900;\r\n        },\r\n        '%z': function(date) {\r\n          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).\r\n          // For example, \"-0430\" means 4 hours 30 minutes behind UTC (west of Greenwich).\r\n          var off = date.tm_gmtoff;\r\n          var ahead = off >= 0;\r\n          off = Math.abs(off) / 60;\r\n          // convert from minutes into hhmm format (which means 60 minutes = 100 units)\r\n          off = (off / 60)*100 + (off % 60);\r\n          return (ahead ? '+' : '-') + String(\"0000\" + off).slice(-4);\r\n        },\r\n        '%Z': function(date) {\r\n          return date.tm_zone;\r\n        },\r\n        '%%': function() {\r\n          return '%';\r\n        }\r\n      };\r\n  \r\n      // Replace %% with a pair of NULLs (which cannot occur in a C string), then\r\n      // re-inject them after processing.\r\n      pattern = pattern.replace(/%%/g, '\\0\\0')\r\n      for (var rule in EXPANSION_RULES_2) {\r\n        if (pattern.includes(rule)) {\r\n          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));\r\n        }\r\n      }\r\n      pattern = pattern.replace(/\\0\\0/g, '%')\r\n  \r\n      var bytes = intArrayFromString(pattern, false);\r\n      if (bytes.length > maxsize) {\r\n        return 0;\r\n      }\r\n  \r\n      writeArrayToMemory(bytes, s);\r\n      return bytes.length-1;\r\n    }\r\n  function _strftime_l(s, maxsize, format, tm) {\r\n      return _strftime(s, maxsize, format, tm); // no locale support yet\r\n    }\r\nInternalError = Module['InternalError'] = extendError(Error, 'InternalError');;\r\nembind_init_charCodes();\r\nBindingError = Module['BindingError'] = extendError(Error, 'BindingError');;\r\ninit_ClassHandle();\r\ninit_embind();;\r\ninit_RegisteredPointer();\r\nUnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;\r\ninit_emval();;\r\n\r\n  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {\r\n    if (!parent) {\r\n      parent = this;  // root node sets parent to itself\r\n    }\r\n    this.parent = parent;\r\n    this.mount = parent.mount;\r\n    this.mounted = null;\r\n    this.id = FS.nextInode++;\r\n    this.name = name;\r\n    this.mode = mode;\r\n    this.node_ops = {};\r\n    this.stream_ops = {};\r\n    this.rdev = rdev;\r\n  };\r\n  var readMode = 292/*292*/ | 73/*73*/;\r\n  var writeMode = 146/*146*/;\r\n  Object.defineProperties(FSNode.prototype, {\r\n   read: {\r\n    get: /** @this{FSNode} */function() {\r\n     return (this.mode & readMode) === readMode;\r\n    },\r\n    set: /** @this{FSNode} */function(val) {\r\n     val ? this.mode |= readMode : this.mode &= ~readMode;\r\n    }\r\n   },\r\n   write: {\r\n    get: /** @this{FSNode} */function() {\r\n     return (this.mode & writeMode) === writeMode;\r\n    },\r\n    set: /** @this{FSNode} */function(val) {\r\n     val ? this.mode |= writeMode : this.mode &= ~writeMode;\r\n    }\r\n   },\r\n   isFolder: {\r\n    get: /** @this{FSNode} */function() {\r\n     return FS.isDir(this.mode);\r\n    }\r\n   },\r\n   isDevice: {\r\n    get: /** @this{FSNode} */function() {\r\n     return FS.isChrdev(this.mode);\r\n    }\r\n   }\r\n  });\r\n  FS.FSNode = FSNode;\r\n  FS.staticInit();;\r\nvar ASSERTIONS = false;\r\n\r\n\r\n\r\n/** @type {function(string, boolean=, number=)} */\r\nfunction intArrayFromString(stringy, dontAddNull, length) {\r\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\r\n  var u8array = new Array(len);\r\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n  if (dontAddNull) u8array.length = numBytesWritten;\r\n  return u8array;\r\n}\r\n\r\nfunction intArrayToString(array) {\r\n  var ret = [];\r\n  for (var i = 0; i < array.length; i++) {\r\n    var chr = array[i];\r\n    if (chr > 0xFF) {\r\n      if (ASSERTIONS) {\r\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\r\n      }\r\n      chr &= 0xFF;\r\n    }\r\n    ret.push(String.fromCharCode(chr));\r\n  }\r\n  return ret.join('');\r\n}\r\n\r\n\r\nvar asmLibraryArg = {\r\n  \"__assert_fail\": ___assert_fail,\r\n  \"__cxa_allocate_exception\": ___cxa_allocate_exception,\r\n  \"__cxa_throw\": ___cxa_throw,\r\n  \"_embind_finalize_value_object\": __embind_finalize_value_object,\r\n  \"_embind_register_bigint\": __embind_register_bigint,\r\n  \"_embind_register_bool\": __embind_register_bool,\r\n  \"_embind_register_class\": __embind_register_class,\r\n  \"_embind_register_class_constructor\": __embind_register_class_constructor,\r\n  \"_embind_register_class_function\": __embind_register_class_function,\r\n  \"_embind_register_emval\": __embind_register_emval,\r\n  \"_embind_register_float\": __embind_register_float,\r\n  \"_embind_register_function\": __embind_register_function,\r\n  \"_embind_register_integer\": __embind_register_integer,\r\n  \"_embind_register_memory_view\": __embind_register_memory_view,\r\n  \"_embind_register_std_string\": __embind_register_std_string,\r\n  \"_embind_register_std_wstring\": __embind_register_std_wstring,\r\n  \"_embind_register_value_object\": __embind_register_value_object,\r\n  \"_embind_register_value_object_field\": __embind_register_value_object_field,\r\n  \"_embind_register_void\": __embind_register_void,\r\n  \"_emval_as\": __emval_as,\r\n  \"_emval_call_method\": __emval_call_method,\r\n  \"_emval_call_void_method\": __emval_call_void_method,\r\n  \"_emval_decref\": __emval_decref,\r\n  \"_emval_get_global\": __emval_get_global,\r\n  \"_emval_get_method_caller\": __emval_get_method_caller,\r\n  \"_emval_get_property\": __emval_get_property,\r\n  \"_emval_incref\": __emval_incref,\r\n  \"_emval_new_array\": __emval_new_array,\r\n  \"_emval_new_cstring\": __emval_new_cstring,\r\n  \"_emval_new_object\": __emval_new_object,\r\n  \"_emval_run_destructors\": __emval_run_destructors,\r\n  \"_emval_set_property\": __emval_set_property,\r\n  \"_emval_take_value\": __emval_take_value,\r\n  \"abort\": _abort,\r\n  \"emscripten_memcpy_big\": _emscripten_memcpy_big,\r\n  \"emscripten_resize_heap\": _emscripten_resize_heap,\r\n  \"environ_get\": _environ_get,\r\n  \"environ_sizes_get\": _environ_sizes_get,\r\n  \"fd_close\": _fd_close,\r\n  \"fd_read\": _fd_read,\r\n  \"fd_seek\": _fd_seek,\r\n  \"fd_write\": _fd_write,\r\n  \"setTempRet0\": _setTempRet0,\r\n  \"strftime_l\": _strftime_l\r\n};\r\nvar asm = createWasm();\r\n/** @type {function(...*):?} */\r\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\r\n  return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"__wasm_call_ctors\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _malloc = Module[\"_malloc\"] = function() {\r\n  return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"malloc\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___getTypeName = Module[\"___getTypeName\"] = function() {\r\n  return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"__getTypeName\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function() {\r\n  return (___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = Module[\"asm\"][\"__embind_register_native_and_builtin_types\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___errno_location = Module[\"___errno_location\"] = function() {\r\n  return (___errno_location = Module[\"___errno_location\"] = Module[\"asm\"][\"__errno_location\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _free = Module[\"_free\"] = function() {\r\n  return (_free = Module[\"_free\"] = Module[\"asm\"][\"free\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar stackSave = Module[\"stackSave\"] = function() {\r\n  return (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"stackSave\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar stackRestore = Module[\"stackRestore\"] = function() {\r\n  return (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"stackRestore\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\r\n  return (stackAlloc = Module[\"stackAlloc\"] = Module[\"asm\"][\"stackAlloc\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = function() {\r\n  return (___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = Module[\"asm\"][\"__cxa_is_pointer_type\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_viijii = Module[\"dynCall_viijii\"] = function() {\r\n  return (dynCall_viijii = Module[\"dynCall_viijii\"] = Module[\"asm\"][\"dynCall_viijii\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\r\n  return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"dynCall_jiji\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = function() {\r\n  return (dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = Module[\"asm\"][\"dynCall_iiiiij\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = function() {\r\n  return (dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = Module[\"asm\"][\"dynCall_iiiiijj\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = function() {\r\n  return (dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = Module[\"asm\"][\"dynCall_iiiiiijj\"]).apply(null, arguments);\r\n};\r\n\r\n\r\n\r\n\r\n\r\n// === Auto-generated postamble setup entry stuff ===\r\n\r\n\r\n\r\nvar calledRun;\r\n\r\n/**\r\n * @constructor\r\n * @this {ExitStatus}\r\n */\r\nfunction ExitStatus(status) {\r\n  this.name = \"ExitStatus\";\r\n  this.message = \"Program terminated with exit(\" + status + \")\";\r\n  this.status = status;\r\n}\r\n\r\nvar calledMain = false;\r\n\r\ndependenciesFulfilled = function runCaller() {\r\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\r\n  if (!calledRun) run();\r\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\r\n};\r\n\r\n/** @type {function(Array=)} */\r\nfunction run(args) {\r\n  args = args || arguments_;\r\n\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n  preRun();\r\n\r\n  // a preRun added a dependency, run will be called later\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n  function doRun() {\r\n    // run may have just been called through dependencies being fulfilled just in this very frame,\r\n    // or while the async setStatus time below was happening\r\n    if (calledRun) return;\r\n    calledRun = true;\r\n    Module['calledRun'] = true;\r\n\r\n    if (ABORT) return;\r\n\r\n    initRuntime();\r\n\r\n    readyPromiseResolve(Module);\r\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\r\n\r\n    postRun();\r\n  }\r\n\r\n  if (Module['setStatus']) {\r\n    Module['setStatus']('Running...');\r\n    setTimeout(function() {\r\n      setTimeout(function() {\r\n        Module['setStatus']('');\r\n      }, 1);\r\n      doRun();\r\n    }, 1);\r\n  } else\r\n  {\r\n    doRun();\r\n  }\r\n}\r\nModule['run'] = run;\r\n\r\n/** @param {boolean|number=} implicit */\r\nfunction exit(status, implicit) {\r\n  EXITSTATUS = status;\r\n\r\n  procExit(status);\r\n}\r\n\r\nfunction procExit(code) {\r\n  EXITSTATUS = code;\r\n  if (!keepRuntimeAlive()) {\r\n    if (Module['onExit']) Module['onExit'](code);\r\n    ABORT = true;\r\n  }\r\n  quit_(code, new ExitStatus(code));\r\n}\r\n\r\nif (Module['preInit']) {\r\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\r\n  while (Module['preInit'].length > 0) {\r\n    Module['preInit'].pop()();\r\n  }\r\n}\r\n\r\nrun();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  return Module.ready\r\n}\r\n);\r\n})();\r\nexport default Module;","module.exports = require(\"child_process\");","module.exports = require(\"electron\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"util\");"],"names":[],"sourceRoot":""}